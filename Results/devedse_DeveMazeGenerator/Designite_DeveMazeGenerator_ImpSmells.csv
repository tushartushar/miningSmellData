Implementation smell,Namespace,Class,File,Method,Description
Long Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The method has 109 lines of code.
Long Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The method has 151 lines of code.
Long Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The method has 162 lines of code.
Long Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The method has 172 lines of code.
Long Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The method has 150 lines of code.
Long Method,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The method has 173 lines of code.
Long Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The method has 169 lines of code.
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Maze,Cyclomatic complexity of the method is 17
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,GenerateListOfMazeWalls,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,Cyclomatic complexity of the method is 10
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,Cyclomatic complexity of the method is 13
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,Cyclomatic complexity of the method is 10
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,Cyclomatic complexity of the method is 15
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,Cyclomatic complexity of the method is 16
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,Cyclomatic complexity of the method is 20
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,Cyclomatic complexity of the method is 16
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxe,Cyclomatic complexity of the method is 8
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeWithDynamicallyGeneratedPath,Cyclomatic complexity of the method is 8
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,Cyclomatic complexity of the method is 8
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,Cyclomatic complexity of the method is 8
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,Cyclomatic complexity of the method is 14
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,Cyclomatic complexity of the method is 8
Complex Method,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,Cyclomatic complexity of the method is 18
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,Cyclomatic complexity of the method is 12
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,Cyclomatic complexity of the method is 12
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,Cyclomatic complexity of the method is 16
Complex Method,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,Cyclomatic complexity of the method is 35
Complex Method,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,Cyclomatic complexity of the method is 14
Complex Method,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,Cyclomatic complexity of the method is 11
Complex Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,Cyclomatic complexity of the method is 44
Complex Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,Cyclomatic complexity of the method is 20
Complex Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,Cyclomatic complexity of the method is 15
Complex Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,Cyclomatic complexity of the method is 14
Complex Method,DeveMazeGenerator.PathFinders,PathFinderDepthFirst,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirst.cs,GoFind,Cyclomatic complexity of the method is 12
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,AddToWallList,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMaxPathRowsThatWouldFitInMemoryFromHere,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxe,The method has 6 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxe,The method has 6 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeWithDynamicallyGeneratedPath,The method has 8 parameters.
Long Parameter List,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,Algorithm,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Algorithm.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,Generate,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.InnerMaps,HybridInnerMapPart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,HybridInnerMapPart,The method has 5 parameters.
Long Parameter List,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternalWithCount,The method has 5 parameters.
Long Statement,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The length of the statement  "		return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound)); " is 141.
Long Statement,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The length of the statement  "	return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range); " is 128.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The length of the statement  "			debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3))); " is 301.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "	debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2))); " is 190.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "	//    debugMessageCallback(string.Format("We can't work with the default tilesize of '{0}' so we have to scale it back to RowsPerCycle: '{1}'"' tiffTileSize' rowsPerPathDeterminingCycle)); " is 188.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000. " is 262.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm... " is 192.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger. " is 204.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was " is 280.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize. " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here. " is 191.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree); " is 147.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing. " is 162.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount)); " is 285.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The length of the statement  "		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3))); " is 666.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "	debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2))); " is 190.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		debugMessageCallback (string.Format ("We can't work with the default tilesize of '{0}' so we have to scale it back to RowsPerCycle: '{1}'"' tiffTileSize' rowsPerPathDeterminingCycle)); " is 184.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000. " is 262.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm... " is 192.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger. " is 204.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was " is 280.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize. " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here. " is 191.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree); " is 147.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing. " is 162.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "				debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount)); " is 285.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3))); " is 666.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000. " is 262.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm... " is 192.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger. " is 204.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was " is 280.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize. " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here. " is 191.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree); " is 148.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing. " is 164.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount)); " is 289.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The length of the statement  "			debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' "")); " is 407.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The length of the statement  "			debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle)); " is 181.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The length of the statement  "			debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle)); " is 146.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The length of the statement  "			debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle)); " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The length of the statement  "	debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2))); " is 171.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeWithDynamicallyGeneratedPath,The length of the statement  "			SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis (fileName' dynamicallyGeneratedPath' lineSavingProgress' debugMessageCallback); " is 144.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeWithDynamicallyGeneratedPath,The length of the statement  "			SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis (fileName' dynamicallyGeneratedPath' lineSavingProgress' debugMessageCallback); " is 145.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeWithDynamicallyGeneratedPath,The length of the statement  "			SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages (Path.GetFileNameWithoutExtension (fileName)' dynamicallyGeneratedPath' lineSavingProgress' debugMessageCallback); " is 194.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The length of the statement  "		System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat); " is 145.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath32Bit,The length of the statement  "		objGraphics.FillRegion (new SolidBrush (brushColor)' new Region (new Rectangle (n.X * cursize' n.Y * cursize' cursize' cursize))); " is 130.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The length of the statement  "		System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat); " is 145.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,CreatePngWriter,The length of the statement  "	var stream = new FileStream (fileName' FileMode.Create' FileAccess.Write' FileShare.Read' 4096' FileOptions.WriteThrough); " is 122.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "	debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2))); " is 190.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		debugMessageCallback (string.Format ("We can't work with the default tilesize of '{0}' so we have to scale it back to RowsPerCycle: '{1}'"' tiffTileSize' rowsPerPathDeterminingCycle)); " is 184.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000. " is 262.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm... " is 192.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger. " is 204.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was " is 280.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize. " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here. " is 191.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree); " is 150.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing. " is 162.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount)); " is 285.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The length of the statement  "		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3))); " is 812.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The length of the statement  "			debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle)); " is 181.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The length of the statement  "			debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle)); " is 146.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The length of the statement  "			debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle)); " is 169.
Long Statement,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The length of the statement  "	debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2))); " is 171.
Long Statement,DeveMazeGenerator.InnerMaps,HybridInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,LoadNewMapPart,The length of the statement  "		if (mapToCheck != null && mapToCheck.StartX == x * GridSize && mapToCheck.StartY == y * GridSize && mapToCheck.EndX == (x + 1) * GridSize && mapToCheck.EndY == (y + 1) * GridSize) { " is 181.
Long Statement,DeveMazeGenerator.InnerMaps,HybridInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,LoadNewMapPart,The length of the statement  "			long posToStoreAt = sizeinbytes * (long)(Width / GridSize) * (long)(oldone.StartY / GridSize) + (long)sizeinbytes * (long)(oldone.StartX / GridSize); " is 149.
Long Statement,DeveMazeGenerator.InnerMaps,HybridInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,LoadNewMapPart,The length of the statement  "		currentMapPart = new HybridInnerMapPart (x * GridSize' y * GridSize' (x + 1) * GridSize' (y + 1) * GridSize' completeHDArray); " is 126.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The length of the statement  "		//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction) " is 180.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The length of the statement  "		//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions " is 168.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The length of the statement  "		//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet) " is 165.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The length of the statement  "		if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) { " is 150.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The length of the statement  "	return DeterminePathFromDirections (directions' new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map); " is 122.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The length of the statement  "	//By first determining max and then returning a yield IEnumerable based on this max we only have to calculate the max value once instead of every time you look through the IEnumerable " is 183.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The length of the statement  "	//This is because a yield return is only executed when a foreach is ran. But the parameters are already precalculated in it. " is 124.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The length of the statement  "	//One additional note is calling this method to obtain the IEnumerable will instantly execute this max count instead of having this also done later. (This means that when you want to " is 182.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The length of the statement  "	//loop through the path once it will still do it one extra time to determine the max count). This shouldn't matter that much though :). " is 135.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The length of the statement  "		//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white " is 173.
Long Statement,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The length of the statement  "		//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white " is 173.
Complex Conditional,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,isValid,The conditional expression  "x > 0 && x < maze.Width - 1 && y > 0 && y < maze.Height - 1"  is complex.
Complex Conditional,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The conditional expression  "(x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1"  is complex.
Complex Conditional,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,isValid,The conditional expression  "x > 0 && x < maze.Width - 1 && y > 0 && y < maze.Height - 1"  is complex.
Complex Conditional,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The conditional expression  "x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2"  is complex.
Complex Conditional,DeveMazeGenerator.InnerMaps,HybridInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,LoadNewMapPart,The conditional expression  "mapToCheck != null && mapToCheck.StartX == x * GridSize && mapToCheck.StartY == y * GridSize && mapToCheck.EndX == (x + 1) * GridSize && mapToCheck.EndY == (y + 1) * GridSize"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The conditional expression  "(prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The conditional expression  "(prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The conditional expression  "(possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The conditional expression  "(prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The conditional expression  "(prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The conditional expression  "(prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The conditional expression  "(prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The conditional expression  "(prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The conditional expression  "(prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The conditional expression  "(prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The conditional expression  "(prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The conditional expression  "(prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]"  is complex.
Complex Conditional,DeveMazeGenerator.PathFinders,PathFinderDepthFirst,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirst.cs,GoFind,The conditional expression  "x == 0 || y == 0 || x == width || y == height"  is complex.
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0) {  	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).  	// We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	  	return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0) {  	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).  	// We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	  	return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound;) {  	// Generate 4 bytes.   	// Increased performance is achieved by generating 4 random bytes per loop.  	// Also note that no mask needs to be applied to zero out the higher order bytes before  	// casting because the cast ignores thos bytes. Thanks to Stefan Troschütz for pointing this out.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	buffer [i++] = (byte)(w >> 8);  	buffer [i++] = (byte)(w >> 16);  	buffer [i++] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: t = (x ^ (x << 11));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i++] = (byte)(w >> 8);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i++] = (byte)(w >> 16);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i++] = (byte)(w >> 24);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	// Generate 4 bytes.  	t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	buffer [i++] = (byte)w;  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 8);  		if (i < buffer.Length) {  			buffer [i++] = (byte)(w >> 16);  			if (i < buffer.Length) {  				buffer [i] = (byte)(w >> 24);  			}  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: t = (x ^ (x << 11));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i++] = (byte)(w >> 8);  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 16);  		if (i < buffer.Length) {  			buffer [i] = (byte)(w >> 24);  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i++] = (byte)(w >> 8);  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 16);  		if (i < buffer.Length) {  			buffer [i] = (byte)(w >> 24);  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i++] = (byte)(w >> 8);  	if (i < buffer.Length) {  		buffer [i++] = (byte)(w >> 16);  		if (i < buffer.Length) {  			buffer [i] = (byte)(w >> 24);  		}  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i++] = (byte)(w >> 8);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i++] = (byte)(w >> 16);  	if (i < buffer.Length) {  		buffer [i] = (byte)(w >> 24);  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i++] = (byte)(w >> 16);  	if (i < buffer.Length) {  		buffer [i] = (byte)(w >> 24);  	}  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i++] = (byte)(w >> 16);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length) {  	buffer [i] = (byte)(w >> 24);  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBytes,The following statement contains a magic number: buffer [i] = (byte)(w >> 24);  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1) {  	// Generate 32 more bits.  	uint t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	// Reset the bitMask that tells us which bit to read next.  	bitMask = 0x80000000;  	return (bitBuffer & bitMask) == 0;  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1) {  	// Generate 32 more bits.  	uint t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	// Reset the bitMask that tells us which bit to read next.  	bitMask = 0x80000000;  	return (bitBuffer & bitMask) == 0;  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1) {  	// Generate 32 more bits.  	uint t = (x ^ (x << 11));  	x = y;  	y = z;  	z = w;  	bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  	// Reset the bitMask that tells us which bit to read next.  	bitMask = 0x80000000;  	return (bitBuffer & bitMask) == 0;  }  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBool,The following statement contains a magic number: bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,FastRandom,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\FastRandom.cs,NextBool,The following statement contains a magic number: bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,GetColorMaps,The following statement contains a magic number: for (int i = 0; i < colorMapSize - 2; i++) {  	colorMapRed [i] = (ushort)(i * colorMapSize);  	colorMapGreen [i] = (ushort)((colorMapSizeMinusTwo - i) * colorMapSize);  	colorMapBlue [i] = 0;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,GetColorMaps,The following statement contains a magic number: colorMapRed [colorMapSize - 2] = 0;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,GetColorMaps,The following statement contains a magic number: colorMapGreen [colorMapSize - 2] = 0;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,GetColorMaps,The following statement contains a magic number: colorMapBlue [colorMapSize - 2] = 0;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[(this.Width - 1) * 3];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			color_ptr [x * 3 + 0] = r;  			color_ptr [x * 3 + 1] = g;  			color_ptr [x * 3 + 2] = b;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		color_ptr [x * 3 + 0] = r;  		color_ptr [x * 3 + 1] = g;  		color_ptr [x * 3 + 2] = b;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	color_ptr [x * 3 + 0] = r;  	color_ptr [x * 3 + 1] = g;  	color_ptr [x * 3 + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: color_ptr [x * 3 + 0] = r;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: color_ptr [x * 3 + 1] = g;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: color_ptr [x * 3 + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: color_ptr [x * 3 + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiff,The following statement contains a magic number: lineSavingProgress (y' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileSize);  	tif.SetField (TiffTag.TILELENGTH' tileSize);  	int curpos = 0;  	byte[] color_ptr = new byte[tileSize * tileSize * 3];  	int tileNumber = 0;  	for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tileSize);  			for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPosjes.Count) {  							curPathPos = pathPosjes [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startY = 0; startY < this.Height - 1; startY += tileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tileSize);  		for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPosjes.Count) {  						curPathPos = pathPosjes [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tileSize);  	for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPosjes.Count) {  					curPathPos = pathPosjes [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tileSize * tileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: color_ptr [startPos + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithChunks,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 1);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.PALETTE);  	tif.SetField (TiffTag.COLORMAP' GetColorMaps ());  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[this.Width - 1];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte ding = 254;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  					ding = (byte)((byte)reinterpreted);  					curpos++;  				} else if (this.innerMap [x' y]) {  					ding = 255;  				}  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  			color_ptr [x] = ding;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 1);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.PALETTE);  	tif.SetField (TiffTag.COLORMAP' GetColorMaps ());  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[this.Width - 1];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte ding = 254;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  					ding = (byte)((byte)reinterpreted);  					curpos++;  				} else if (this.innerMap [x' y]) {  					ding = 255;  				}  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  			color_ptr [x] = ding;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 1);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.PALETTE);  	tif.SetField (TiffTag.COLORMAP' GetColorMaps ());  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[this.Width - 1];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte ding = 254;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  					ding = (byte)((byte)reinterpreted);  					curpos++;  				} else if (this.innerMap [x' y]) {  					ding = 255;  				}  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  			color_ptr [x] = ding;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 1);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.PALETTE);  	tif.SetField (TiffTag.COLORMAP' GetColorMaps ());  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[this.Width - 1];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte ding = 254;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  					ding = (byte)((byte)reinterpreted);  					curpos++;  				} else if (this.innerMap [x' y]) {  					ding = 255;  				}  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  			color_ptr [x] = ding;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 1);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.PALETTE);  	tif.SetField (TiffTag.COLORMAP' GetColorMaps ());  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	tif.SetField (TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	int curpos = 0;  	byte[] color_ptr = new byte[this.Width - 1];  	for (int y = 0; y < this.Height - 1; y++) {  		for (int x = 0; x < this.Width - 1; x++) {  			byte ding = 254;  			MazePointPos curPathPos;  			if (curpos < pathPosjes.Count) {  				curPathPos = pathPosjes [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  					ding = (byte)((byte)reinterpreted);  					curpos++;  				} else if (this.innerMap [x' y]) {  					ding = 255;  				}  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  			color_ptr [x] = ding;  		}  		tif.WriteScanline (color_ptr' y);  		lineSavingProgress (y' this.Height - 2);  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte ding = 254;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  				ding = (byte)((byte)reinterpreted);  				curpos++;  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  		color_ptr [x] = ding;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte ding = 254;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  				ding = (byte)((byte)reinterpreted);  				curpos++;  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  		color_ptr [x] = ding;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte ding = 254;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  				ding = (byte)((byte)reinterpreted);  				curpos++;  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  		color_ptr [x] = ding;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	for (int x = 0; x < this.Width - 1; x++) {  		byte ding = 254;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  				ding = (byte)((byte)reinterpreted);  				curpos++;  			} else if (this.innerMap [x' y]) {  				ding = 255;  			}  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  		color_ptr [x] = ding;  	}  	tif.WriteScanline (color_ptr' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte ding = 254;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  			ding = (byte)((byte)reinterpreted);  			curpos++;  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  	} else if (this.innerMap [x' y]) {  		ding = 255;  	}  	color_ptr [x] = ding;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte ding = 254;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  			ding = (byte)((byte)reinterpreted);  			curpos++;  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  	} else if (this.innerMap [x' y]) {  		ding = 255;  	}  	color_ptr [x] = ding;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	byte ding = 254;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  			ding = (byte)((byte)reinterpreted);  			curpos++;  		} else if (this.innerMap [x' y]) {  			ding = 255;  		}  	} else if (this.innerMap [x' y]) {  		ding = 255;  	}  	color_ptr [x] = ding;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  		ding = (byte)((byte)reinterpreted);  		curpos++;  	} else if (this.innerMap [x' y]) {  		ding = 255;  	}  } else if (this.innerMap [x' y]) {  	ding = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  		ding = (byte)((byte)reinterpreted);  		curpos++;  	} else if (this.innerMap [x' y]) {  		ding = 255;  	}  } else if (this.innerMap [x' y]) {  	ding = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	float reinterpreted = ((float)curPathPos.RelativePos) / 255.0f * 253.0f;  	ding = (byte)((byte)reinterpreted);  	curpos++;  } else if (this.innerMap [x' y]) {  	ding = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: if (this.innerMap [x' y]) {  	ding = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: ding = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: if (this.innerMap [x' y]) {  	ding = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: ding = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithColorMap,The following statement contains a magic number: lineSavingProgress (y' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	int stepsPerLoop = tiffTileSize * Maze.LineChunkCount;  	int tileNumber = 0;  	int partNumber = 0;  	for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  		var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  		var w = Stopwatch.StartNew ();  		var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		int curpos = 0;  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += stepsPerLoop) {  	var yChunkEnd = Math.Min (yChunkStart + stepsPerLoop' this.Height - 1);  	var w = Stopwatch.StartNew ();  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	int curpos = 0;  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Count: {3}' Time to generate this part: {4} sec' Size: {5}mb"' partNumber' yChunkStart' yChunkEnd' pathPointsHere.Count' Math.Round (w.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: color_ptr [startPos + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPath,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: memoryFree = (ulong)(memoryFree * 0.6);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: tiffTileSize = 256;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var fileNamePart;  			var completeFileName = Path.Combine (folderName' fileNamePart);  			SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  			//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var fileNamePart;  		var completeFileName = Path.Combine (folderName' fileNamePart);  		SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var fileNamePart;  	var completeFileName = Path.Combine (folderName' fileNamePart);  	SaveTiffImage (completeFileName' color_ptr' tiffTileSize' tiffTileSize);  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: color_ptr [startPos + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysisAndSplitImages,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' tileWidth);  	tif.SetField (TiffTag.IMAGELENGTH' tileHeight);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileWidth);  	tif.SetField (TiffTag.TILELENGTH' tileHeight);  	tif.WriteEncodedTile (0' color_ptr' tileWidth * tileHeight * 3);  	tif.FlushData ();  	tif.Close ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' tileWidth);  	tif.SetField (TiffTag.IMAGELENGTH' tileHeight);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileWidth);  	tif.SetField (TiffTag.TILELENGTH' tileHeight);  	tif.WriteEncodedTile (0' color_ptr' tileWidth * tileHeight * 3);  	tif.FlushData ();  	tif.Close ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' tileWidth);  	tif.SetField (TiffTag.IMAGELENGTH' tileHeight);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tileWidth);  	tif.SetField (TiffTag.TILELENGTH' tileHeight);  	tif.WriteEncodedTile (0' color_ptr' tileWidth * tileHeight * 3);  	tif.FlushData ();  	tif.Close ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveTiffImage,The following statement contains a magic number: tif.WriteEncodedTile (0' color_ptr' tileWidth * tileHeight * 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: memoryFree = (ulong)(memoryFree * 0.6);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' this.Width - 1);  	tif.SetField (TiffTag.IMAGELENGTH' this.Height - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < this.Height - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  		stepsThisLoop = yChunkEnd - yChunkStart;  		var wObtainPathPart = Stopwatch.StartNew ();  		//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  		var pathPointsHere = new List<MazePointPos> (expectedPathCount);  		int currentPathPosPoint = 0;  		foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  			pathPointsHere.Add (pathPos);  			currentPathPosPoint++;  		}  		wObtainPathPart.Stop ();  		if (pathPointsHere.Count != expectedPathCount) {  			debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		}  		var wSort = Stopwatch.StartNew ();  		pathPointsHere.Sort ((first' second) => {  			int firstXTile = first.X / tiffTileSize;  			int firstYTile = first.Y / tiffTileSize;  			int secondXTile = second.X / tiffTileSize;  			int secondYTile = second.Y / tiffTileSize;  			if (firstYTile != secondYTile) {  				return firstYTile - secondYTile;  			}  			if (firstXTile != secondXTile) {  				return firstXTile - secondXTile;  			}  			int firstXInTile = first.X % tiffTileSize;  			int firstYInTile = first.Y % tiffTileSize;  			int secondXInTile = second.X % tiffTileSize;  			int secondYInTile = second.Y % tiffTileSize;  			if (firstYInTile == secondYInTile) {  				return firstXInTile - secondXInTile;  			}  			return firstYInTile - secondYInTile;  		});  		wSort.Stop ();  		int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  				int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  				int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							MazePointPos curPathPos;  							if (curpos < pathPointsHere.Count) {  								curPathPos = pathPointsHere [curpos];  								if (curPathPos.X == x && curPathPos.Y == y) {  									r = curPathPos.RelativePos;  									g = (byte)(255 - curPathPos.RelativePos);  									b = 0;  									curpos++;  								} else if (this.innerMap [x' y]) {  									r = 255;  									g = 255;  									b = 255;  								}  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  		partNumber++;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		pathPointsHere = null;  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		int firstXTile = first.X / tiffTileSize;  		int firstYTile = first.Y / tiffTileSize;  		int secondXTile = second.X / tiffTileSize;  		int secondYTile = second.Y / tiffTileSize;  		if (firstYTile != secondYTile) {  			return firstYTile - secondYTile;  		}  		if (firstXTile != secondXTile) {  			return firstXTile - secondXTile;  		}  		int firstXInTile = first.X % tiffTileSize;  		int firstYInTile = first.Y % tiffTileSize;  		int secondXInTile = second.X % tiffTileSize;  		int secondYInTile = second.Y % tiffTileSize;  		if (firstYInTile == secondYInTile) {  			return firstXInTile - secondXInTile;  		}  		return firstYInTile - secondYInTile;  	});  	wSort.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  			int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						MazePointPos curPathPos;  						if (curpos < pathPointsHere.Count) {  							curPathPos = pathPointsHere [curpos];  							if (curPathPos.X == x && curPathPos.Y == y) {  								r = curPathPos.RelativePos;  								g = (byte)(255 - curPathPos.RelativePos);  								b = 0;  								curpos++;  							} else if (this.innerMap [x' y]) {  								r = 255;  								g = 255;  								b = 255;  							}  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  		int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					MazePointPos curPathPos;  					if (curpos < pathPointsHere.Count) {  						curPathPos = pathPointsHere [curpos];  						if (curPathPos.X == x && curPathPos.Y == y) {  							r = curPathPos.RelativePos;  							g = (byte)(255 - curPathPos.RelativePos);  							b = 0;  							curpos++;  						} else if (this.innerMap [x' y]) {  							r = 255;  							g = 255;  							b = 255;  						}  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  	int xMax = Math.Min (this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				MazePointPos curPathPos;  				if (curpos < pathPointsHere.Count) {  					curPathPos = pathPointsHere [curpos];  					if (curPathPos.X == x && curPathPos.Y == y) {  						r = curPathPos.RelativePos;  						g = (byte)(255 - curPathPos.RelativePos);  						b = 0;  						curpos++;  					} else if (this.innerMap [x' y]) {  						r = 255;  						g = 255;  						b = 255;  					}  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: color_ptr [startPos + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxeTiffWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: using (var tif = Tiff.Open (fileName' "w")) {  	if (tif == null) {  		throw new InvalidOperationException ("Tif file could not be opened. It is probably in use: " + fileName);  	}  	tif.SetField (TiffTag.IMAGEWIDTH' size - 1);  	tif.SetField (TiffTag.IMAGELENGTH' size - 1);  	tif.SetField (TiffTag.BITSPERSAMPLE' 8);  	tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  	tif.SetField (TiffTag.PHOTOMETRIC' Photometric.RGB);  	tif.SetField (TiffTag.PLANARCONFIG' PlanarConfig.CONTIG);  	//tif.SetField(TiffTag.ROWSPERSTRIP' 1);  	tif.SetField (TiffTag.COMPRESSION' Compression.LZW);  	tif.SetField (TiffTag.TILEWIDTH' tiffTileSize);  	tif.SetField (TiffTag.TILELENGTH' tiffTileSize);  	byte[] color_ptr = new byte[tiffTileSize * tiffTileSize * 3];  	//int stepsPerLoop = rowsPerPathDeterminingCycle;  	int tileNumber = 0;  	int partNumber = 0;  	int yChunkStart = 0;  	while (yChunkStart < size - 1) {  		//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  		//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  		//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  		//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  		//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  		//  		//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  		//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  		var stepsThisLoop = 8192;  		var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  		//stepsThisLoop = yChunkEnd - yChunkStart;  		//var wObtainPathPart = Stopwatch.StartNew();  		////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  		//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  		//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  		//int currentPathPosPoint = 0;  		//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  		//{  		//    pathPointsHere.Add(pathPos);  		//    currentPathPosPoint++;  		//}  		//wObtainPathPart.Stop();  		//if (pathPointsHere.Count != expectedPathCount)  		//{  		//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  		//}  		//var wSort = Stopwatch.StartNew();  		//pathPointsHere.Sort((first' second) =>  		//{  		//    int firstXTile = first.X / tiffTileSize;  		//    int firstYTile = first.Y / tiffTileSize;  		//    int secondXTile = second.X / tiffTileSize;  		//    int secondYTile = second.Y / tiffTileSize;  		//    if (firstYTile != secondYTile)  		//    {  		//        return firstYTile - secondYTile;  		//    }  		//    if (firstXTile != secondXTile)  		//    {  		//        return firstXTile - secondXTile;  		//    }  		//    int firstXInTile = first.X % tiffTileSize;  		//    int firstYInTile = first.Y % tiffTileSize;  		//    int secondXInTile = second.X % tiffTileSize;  		//    int secondYInTile = second.Y % tiffTileSize;  		//    if (firstYInTile == secondYInTile)  		//    {  		//        return firstXInTile - secondXInTile;  		//    }  		//    return firstYInTile - secondYInTile;  		//});  		//wSort.Stop();  		//int curpos = 0;  		var wSaveAsImage = Stopwatch.StartNew ();  		for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  			for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  				int xMax = Math.Min (size - 1 - startX' tiffTileSize);  				int yMax = Math.Min (size - 1 - startY' tiffTileSize);  				for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  					for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  						byte r = 0;  						byte g = 0;  						byte b = 0;  						if (otherx >= xMax || othery >= yMax) {  							//Not sure if needed but I'd like to ensure that any additional bytes  							//written to the image are 0.  						} else {  							if (useComplexImage) {  								//This is way harder to compress  								r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  								if (y % 256 == 0 || x % 256 == 0) {  									g = 255;  								}  								b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  							} else {  								//Quite easy to compress  								if (x % 100 == 0 || y % 100 == 0) {  									r = 255;  								}  								if (x % 256 == 0 || y % 256 == 0) {  									g = 255;  								}  								if (x % 256 == y % 256) {  									b = 255;  								}  							}  							//some random stuff:  							//MazePointPos curPathPos;  							//if (curpos < pathPointsHere.Count)  							//{  							//    curPathPos = pathPointsHere[curpos];  							//    if (curPathPos.X == x && curPathPos.Y == y)  							//    {  							//        r = curPathPos.RelativePos;  							//        g = (byte)(255 - curPathPos.RelativePos);  							//        b = 0;  							//        curpos++;  							//    }  							//    else if (this.innerMap[x' y])  							//    {  							//        r = 255;  							//        g = 255;  							//        b = 255;  							//    }  							//}  							//else if (this.innerMap[x' y])  							//{  							//    r = 255;  							//    g = 255;  							//    b = 255;  							//}  						}  						int startPos = othery * tiffTileSize * 3 + otherx * 3;  						color_ptr [startPos + 0] = r;  						color_ptr [startPos + 1] = g;  						color_ptr [startPos + 2] = b;  					}  				}  				var wblah = Stopwatch.StartNew ();  				var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  				wblah.Stop ();  				lastTime += wblah.Elapsed.TotalSeconds;  				//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  				//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  				//Result should not be -1  				lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  				tileNumber++;  			}  		}  		wSaveAsImage.Stop ();  		debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  		partNumber++;  		lastTime = 0;  		yChunkStart += stepsThisLoop;  		//Do some forced garbage collection since we're finished with this loop  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  	}  	tif.FlushData ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: tif.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: tif.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: while (yChunkStart < size - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	//int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHere(debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var stepsThisLoop = 8192;  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' size - 1);  	//stepsThisLoop = yChunkEnd - yChunkStart;  	//var wObtainPathPart = Stopwatch.StartNew();  	////We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	//var expectedPathCount = pathPointsPerRow.Skip(yChunkStart).Take(yChunkEnd - yChunkStart).Sum();  	//var pathPointsHere = new List<MazePointPos>(expectedPathCount);  	//int currentPathPosPoint = 0;  	//foreach (var pathPos in pathPosjes.Where(t => t.Y >= yChunkStart && t.Y < yChunkEnd))  	//{  	//    pathPointsHere.Add(pathPos);  	//    currentPathPosPoint++;  	//}  	//wObtainPathPart.Stop();  	//if (pathPointsHere.Count != expectedPathCount)  	//{  	//    debugMessageCallback(string.Format("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	//}  	//var wSort = Stopwatch.StartNew();  	//pathPointsHere.Sort((first' second) =>  	//{  	//    int firstXTile = first.X / tiffTileSize;  	//    int firstYTile = first.Y / tiffTileSize;  	//    int secondXTile = second.X / tiffTileSize;  	//    int secondYTile = second.Y / tiffTileSize;  	//    if (firstYTile != secondYTile)  	//    {  	//        return firstYTile - secondYTile;  	//    }  	//    if (firstXTile != secondXTile)  	//    {  	//        return firstXTile - secondXTile;  	//    }  	//    int firstXInTile = first.X % tiffTileSize;  	//    int firstYInTile = first.Y % tiffTileSize;  	//    int secondXInTile = second.X % tiffTileSize;  	//    int secondYInTile = second.Y % tiffTileSize;  	//    if (firstYInTile == secondYInTile)  	//    {  	//        return firstXInTile - secondXInTile;  	//    }  	//    return firstYInTile - secondYInTile;  	//});  	//wSort.Stop();  	//int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  			int xMax = Math.Min (size - 1 - startX' tiffTileSize);  			int yMax = Math.Min (size - 1 - startY' tiffTileSize);  			for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					byte r = 0;  					byte g = 0;  					byte b = 0;  					if (otherx >= xMax || othery >= yMax) {  						//Not sure if needed but I'd like to ensure that any additional bytes  						//written to the image are 0.  					} else {  						if (useComplexImage) {  							//This is way harder to compress  							r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  							if (y % 256 == 0 || x % 256 == 0) {  								g = 255;  							}  							b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  						} else {  							//Quite easy to compress  							if (x % 100 == 0 || y % 100 == 0) {  								r = 255;  							}  							if (x % 256 == 0 || y % 256 == 0) {  								g = 255;  							}  							if (x % 256 == y % 256) {  								b = 255;  							}  						}  						//some random stuff:  						//MazePointPos curPathPos;  						//if (curpos < pathPointsHere.Count)  						//{  						//    curPathPos = pathPointsHere[curpos];  						//    if (curPathPos.X == x && curPathPos.Y == y)  						//    {  						//        r = curPathPos.RelativePos;  						//        g = (byte)(255 - curPathPos.RelativePos);  						//        b = 0;  						//        curpos++;  						//    }  						//    else if (this.innerMap[x' y])  						//    {  						//        r = 255;  						//        g = 255;  						//        b = 255;  						//    }  						//}  						//else if (this.innerMap[x' y])  						//{  						//    r = 255;  						//    g = 255;  						//    b = 255;  						//}  					}  					int startPos = othery * tiffTileSize * 3 + otherx * 3;  					color_ptr [startPos + 0] = r;  					color_ptr [startPos + 1] = g;  					color_ptr [startPos + 2] = b;  				}  			}  			var wblah = Stopwatch.StartNew ();  			var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  			wblah.Stop ();  			lastTime += wblah.Elapsed.TotalSeconds;  			//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  			//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  			//Result should not be -1  			lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  			tileNumber++;  		}  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  	partNumber++;  	lastTime = 0;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  	for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  		int xMax = Math.Min (size - 1 - startX' tiffTileSize);  		int yMax = Math.Min (size - 1 - startY' tiffTileSize);  		for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  			for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  				byte r = 0;  				byte g = 0;  				byte b = 0;  				if (otherx >= xMax || othery >= yMax) {  					//Not sure if needed but I'd like to ensure that any additional bytes  					//written to the image are 0.  				} else {  					if (useComplexImage) {  						//This is way harder to compress  						r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  						if (y % 256 == 0 || x % 256 == 0) {  							g = 255;  						}  						b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  					} else {  						//Quite easy to compress  						if (x % 100 == 0 || y % 100 == 0) {  							r = 255;  						}  						if (x % 256 == 0 || y % 256 == 0) {  							g = 255;  						}  						if (x % 256 == y % 256) {  							b = 255;  						}  					}  					//some random stuff:  					//MazePointPos curPathPos;  					//if (curpos < pathPointsHere.Count)  					//{  					//    curPathPos = pathPointsHere[curpos];  					//    if (curPathPos.X == x && curPathPos.Y == y)  					//    {  					//        r = curPathPos.RelativePos;  					//        g = (byte)(255 - curPathPos.RelativePos);  					//        b = 0;  					//        curpos++;  					//    }  					//    else if (this.innerMap[x' y])  					//    {  					//        r = 255;  					//        g = 255;  					//        b = 255;  					//    }  					//}  					//else if (this.innerMap[x' y])  					//{  					//    r = 255;  					//    g = 255;  					//    b = 255;  					//}  				}  				int startPos = othery * tiffTileSize * 3 + otherx * 3;  				color_ptr [startPos + 0] = r;  				color_ptr [startPos + 1] = g;  				color_ptr [startPos + 2] = b;  			}  		}  		var wblah = Stopwatch.StartNew ();  		var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		wblah.Stop ();  		lastTime += wblah.Elapsed.TotalSeconds;  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  		tileNumber++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int startX = 0; startX < size - 1; startX += tiffTileSize) {  	int xMax = Math.Min (size - 1 - startX' tiffTileSize);  	int yMax = Math.Min (size - 1 - startY' tiffTileSize);  	for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  		for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			if (otherx >= xMax || othery >= yMax) {  				//Not sure if needed but I'd like to ensure that any additional bytes  				//written to the image are 0.  			} else {  				if (useComplexImage) {  					//This is way harder to compress  					r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  					if (y % 256 == 0 || x % 256 == 0) {  						g = 255;  					}  					b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  				} else {  					//Quite easy to compress  					if (x % 100 == 0 || y % 100 == 0) {  						r = 255;  					}  					if (x % 256 == 0 || y % 256 == 0) {  						g = 255;  					}  					if (x % 256 == y % 256) {  						b = 255;  					}  				}  				//some random stuff:  				//MazePointPos curPathPos;  				//if (curpos < pathPointsHere.Count)  				//{  				//    curPathPos = pathPointsHere[curpos];  				//    if (curPathPos.X == x && curPathPos.Y == y)  				//    {  				//        r = curPathPos.RelativePos;  				//        g = (byte)(255 - curPathPos.RelativePos);  				//        b = 0;  				//        curpos++;  				//    }  				//    else if (this.innerMap[x' y])  				//    {  				//        r = 255;  				//        g = 255;  				//        b = 255;  				//    }  				//}  				//else if (this.innerMap[x' y])  				//{  				//    r = 255;  				//    g = 255;  				//    b = 255;  				//}  			}  			int startPos = othery * tiffTileSize * 3 + otherx * 3;  			color_ptr [startPos + 0] = r;  			color_ptr [startPos + 1] = g;  			color_ptr [startPos + 2] = b;  		}  	}  	var wblah = Stopwatch.StartNew ();  	var result = tif.WriteEncodedTile (tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	wblah.Stop ();  	lastTime += wblah.Elapsed.TotalSeconds;  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  	tileNumber++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int y = startY' othery = 0; othery < tiffTileSize; y++' othery++) {  	for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		if (otherx >= xMax || othery >= yMax) {  			//Not sure if needed but I'd like to ensure that any additional bytes  			//written to the image are 0.  		} else {  			if (useComplexImage) {  				//This is way harder to compress  				r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  				if (y % 256 == 0 || x % 256 == 0) {  					g = 255;  				}  				b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  			} else {  				//Quite easy to compress  				if (x % 100 == 0 || y % 100 == 0) {  					r = 255;  				}  				if (x % 256 == 0 || y % 256 == 0) {  					g = 255;  				}  				if (x % 256 == y % 256) {  					b = 255;  				}  			}  			//some random stuff:  			//MazePointPos curPathPos;  			//if (curpos < pathPointsHere.Count)  			//{  			//    curPathPos = pathPointsHere[curpos];  			//    if (curPathPos.X == x && curPathPos.Y == y)  			//    {  			//        r = curPathPos.RelativePos;  			//        g = (byte)(255 - curPathPos.RelativePos);  			//        b = 0;  			//        curpos++;  			//    }  			//    else if (this.innerMap[x' y])  			//    {  			//        r = 255;  			//        g = 255;  			//        b = 255;  			//    }  			//}  			//else if (this.innerMap[x' y])  			//{  			//    r = 255;  			//    g = 255;  			//    b = 255;  			//}  		}  		int startPos = othery * tiffTileSize * 3 + otherx * 3;  		color_ptr [startPos + 0] = r;  		color_ptr [startPos + 1] = g;  		color_ptr [startPos + 2] = b;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	if (otherx >= xMax || othery >= yMax) {  		//Not sure if needed but I'd like to ensure that any additional bytes  		//written to the image are 0.  	} else {  		if (useComplexImage) {  			//This is way harder to compress  			r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  			if (y % 256 == 0 || x % 256 == 0) {  				g = 255;  			}  			b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  		} else {  			//Quite easy to compress  			if (x % 100 == 0 || y % 100 == 0) {  				r = 255;  			}  			if (x % 256 == 0 || y % 256 == 0) {  				g = 255;  			}  			if (x % 256 == y % 256) {  				b = 255;  			}  		}  		//some random stuff:  		//MazePointPos curPathPos;  		//if (curpos < pathPointsHere.Count)  		//{  		//    curPathPos = pathPointsHere[curpos];  		//    if (curPathPos.X == x && curPathPos.Y == y)  		//    {  		//        r = curPathPos.RelativePos;  		//        g = (byte)(255 - curPathPos.RelativePos);  		//        b = 0;  		//        curpos++;  		//    }  		//    else if (this.innerMap[x' y])  		//    {  		//        r = 255;  		//        g = 255;  		//        b = 255;  		//    }  		//}  		//else if (this.innerMap[x' y])  		//{  		//    r = 255;  		//    g = 255;  		//    b = 255;  		//}  	}  	int startPos = othery * tiffTileSize * 3 + otherx * 3;  	color_ptr [startPos + 0] = r;  	color_ptr [startPos + 1] = g;  	color_ptr [startPos + 2] = b;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (otherx >= xMax || othery >= yMax) {  	//Not sure if needed but I'd like to ensure that any additional bytes  	//written to the image are 0.  } else {  	if (useComplexImage) {  		//This is way harder to compress  		r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  		if (y % 256 == 0 || x % 256 == 0) {  			g = 255;  		}  		b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  	} else {  		//Quite easy to compress  		if (x % 100 == 0 || y % 100 == 0) {  			r = 255;  		}  		if (x % 256 == 0 || y % 256 == 0) {  			g = 255;  		}  		if (x % 256 == y % 256) {  			b = 255;  		}  	}  	//some random stuff:  	//MazePointPos curPathPos;  	//if (curpos < pathPointsHere.Count)  	//{  	//    curPathPos = pathPointsHere[curpos];  	//    if (curPathPos.X == x && curPathPos.Y == y)  	//    {  	//        r = curPathPos.RelativePos;  	//        g = (byte)(255 - curPathPos.RelativePos);  	//        b = 0;  	//        curpos++;  	//    }  	//    else if (this.innerMap[x' y])  	//    {  	//        r = 255;  	//        g = 255;  	//        b = 255;  	//    }  	//}  	//else if (this.innerMap[x' y])  	//{  	//    r = 255;  	//    g = 255;  	//    b = 255;  	//}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (useComplexImage) {  	//This is way harder to compress  	r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  	if (y % 256 == 0 || x % 256 == 0) {  		g = 255;  	}  	b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  } else {  	//Quite easy to compress  	if (x % 100 == 0 || y % 100 == 0) {  		r = 255;  	}  	if (x % 256 == 0 || y % 256 == 0) {  		g = 255;  	}  	if (x % 256 == y % 256) {  		b = 255;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: r = (byte)(Math.Abs (((x * 2 % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (y % 256 == 0 || x % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (y % 256 == 0 || x % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (y % 256 == 0 || x % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: b = (byte)(Math.Abs (((y % 512) - 256)) % 256);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 100 == 0 || y % 100 == 0) {  	r = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 100 == 0 || y % 100 == 0) {  	r = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 100 == 0 || y % 100 == 0) {  	r = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == 0 || y % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == 0 || y % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == 0 || y % 256 == 0) {  	g = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == y % 256) {  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == y % 256) {  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: if (x % 256 == y % 256) {  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: color_ptr [startPos + 2] = b;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: lineSavingProgress ((int)Math.Min ((tileNumber + 1L) * tiffTileSize / tilesInWidth' size - 2)' size - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,Testje,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to save this part in the image: {7} sec' Combined time: {8} sec' Size: {9}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' ""' ""' Math.Round (lastTime' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' ""' ""));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMaxPathRowsThatWouldFitInMemoryFromHere,The following statement contains a magic number: while (true) {  	var newTestSize = maxRowsToCheck + stepsToIncreaseWithSize;  	long curSize = 0;  	var endRow = Math.Min (this.Height' startRow + newTestSize);  	for (int y = startRow; y < endRow; y++) {  		curSize += pathPointsPerRow [y];  	}  	if (curSize > GlobalVars.MaxArraySize) {  		break;  	}  	var expectedMemoryUsage = curSize * 9;  	//9 bytes per path pos  	if ((ulong)expectedMemoryUsage > memoryFree) {  		break;  	}  	maxRowsToCheck = newTestSize;  	if (maxRowsToCheck >= (this.Height - startRow)) {  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: while (true) {  	int newTestSize = rowsPerPathDeterminingCycle * 2;  	long maxSizeCur = 0;  	for (int i = 0; i < this.Height; i += newTestSize) {  		long curSize = 0;  		var endRow = Math.Min (this.Height' i + newTestSize);  		for (int y = i; y < endRow; y++) {  			curSize += pathPointsPerRow [y];  		}  		maxSizeCur = Math.Max (curSize' maxSizeCur);  	}  	if (maxSizeCur > GlobalVars.MaxArraySize) {  		debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	var expectedMemoryUsage = maxSizeCur * 9;  	//9 bytes per path pos  	if ((ulong)expectedMemoryUsage > memoryFree) {  		debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	rowsPerPathDeterminingCycle = newTestSize;  	max = maxSizeCur;  	if (rowsPerPathDeterminingCycle >= this.Height) {  		debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle));  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: while (true) {  	int newTestSize = rowsPerPathDeterminingCycle * 2;  	long maxSizeCur = 0;  	for (int i = 0; i < this.Height; i += newTestSize) {  		long curSize = 0;  		var endRow = Math.Min (this.Height' i + newTestSize);  		for (int y = i; y < endRow; y++) {  			curSize += pathPointsPerRow [y];  		}  		maxSizeCur = Math.Max (curSize' maxSizeCur);  	}  	if (maxSizeCur > GlobalVars.MaxArraySize) {  		debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	var expectedMemoryUsage = maxSizeCur * 9;  	//9 bytes per path pos  	if ((ulong)expectedMemoryUsage > memoryFree) {  		debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	rowsPerPathDeterminingCycle = newTestSize;  	max = maxSizeCur;  	if (rowsPerPathDeterminingCycle >= this.Height) {  		debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle));  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWrite,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxe,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	var curPathNode = path [i];  	byte formulathing = (byte)((double)i / (double)path.Count * 255.0);  	var pathPos = new MazePointPos (curPathNode.X' curPathNode.Y' formulathing);  	pathPosjes.Add (pathPos);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format1bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 7; j >= 0; j--) {  				if (x < innerMap.Width) {  					bitar [j] = innerMap [x' y];  					x++;  				}  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format1bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 7; j >= 0; j--) {  				if (x < innerMap.Width) {  					bitar [j] = innerMap [x' y];  					x++;  				}  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 7; j >= 0; j--) {  			if (x < innerMap.Width) {  				bitar [j] = innerMap [x' y];  				x++;  			}  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 7; j >= 0; j--) {  			if (x < innerMap.Width) {  				bitar [j] = innerMap [x' y];  				x++;  			}  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 7; j >= 0; j--) {  		if (x < innerMap.Width) {  			bitar [j] = innerMap [x' y];  			x++;  		}  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 7; j >= 0; j--) {  		if (x < innerMap.Width) {  			bitar [j] = innerMap [x' y];  			x++;  		}  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImage,The following statement contains a magic number: for (int j = 7; j >= 0; j--) {  	if (x < innerMap.Width) {  		bitar [j] = innerMap [x' y];  		x++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath32Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	MazePoint n = path [i];  	int formulathing = (int)((double)i / (double)path.Count * 255.0);  	//rgb  	Color brushColor = Color.FromArgb (formulathing' 255 - formulathing' 0);  	objGraphics.FillRegion (new SolidBrush (brushColor)' new Region (new Rectangle (n.X * cursize' n.Y * cursize' cursize' cursize)));  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath32Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	MazePoint n = path [i];  	int formulathing = (int)((double)i / (double)path.Count * 255.0);  	//rgb  	Color brushColor = Color.FromArgb (formulathing' 255 - formulathing' 0);  	objGraphics.FillRegion (new SolidBrush (brushColor)' new Region (new Rectangle (n.X * cursize' n.Y * cursize' cursize' cursize)));  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: using (Bitmap objBmpImage = new Bitmap (innerMap.Width - 1' innerMap.Height - 1' PixelFormat.Format4bppIndexed)) {  	Rectangle rect = new Rectangle (0' 0' objBmpImage.Width' objBmpImage.Height);  	System.Drawing.Imaging.BitmapData bmpData = objBmpImage.LockBits (rect' System.Drawing.Imaging.ImageLockMode.ReadWrite' objBmpImage.PixelFormat);  	IntPtr ptr = bmpData.Scan0;  	int bytes = Math.Abs (bmpData.Stride) * objBmpImage.Height;  	byte[] rgbValues = new byte[bytes];  	System.Runtime.InteropServices.Marshal.Copy (ptr' rgbValues' 0' bytes);  	//BitArreintjeFast[] pathding = new BitArreintjeFast[width];  	//for (int x = 0; x < width; x++)  	//{  	//    pathding[x] = new BitArreintjeFast(height);  	//    for (int y = 0; y < height; y++)  	//    {  	//        pathding[x][y] = false;  	//    }  	//}  	//foreach (MazePoint p in path)  	//{  	//    pathding[p.X][p.Y] = true;  	//}  	for (int y = 0; y < innerMap.Height - 1; y++) {  		int counterdeluxe = bmpData.Stride * y;  		int x = 0;  		for (int i = 0; i < bmpData.Stride; i++) {  			if (x > objBmpImage.Width) {  				break;  			}  			BitArray bitar = new BitArray (8);  			for (int j = 4; j >= 0; j = j - 4) {  				if (innerMap [x' y]) {  					bitar [j + 3] = true;  					bitar [j + 2] = true;  					bitar [j + 1] = true;  					bitar [j + 0] = true;  				} else {  					bitar [j + 3] = false;  					bitar [j + 2] = false;  					bitar [j + 1] = false;  					bitar [j + 0] = false;  				}  				x++;  			}  			rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  			counterdeluxe++;  		}  	}  	for (int i = 0; i < path.Count; i++) {  		long percent = 100L * (long)(i + 1) / (long)path.Count;  		MazePoint point = path [i];  		int xrest = point.X % 2;  		int pos = bmpData.Stride * point.Y + point.X / 2;  		//Console.WriteLine(pos);  		BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  		int xtra = 4;  		if (xrest >= 1) {  			xtra = 0;  		}  		if (percent < 20) {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 40) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = false;  		} else if (percent < 60) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = true;  			bitar [xtra + 0] = true;  		} else if (percent < 80) {  			bitar [xtra + 3] = false;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		} else {  			bitar [xtra + 3] = true;  			bitar [xtra + 2] = false;  			bitar [xtra + 1] = false;  			bitar [xtra + 0] = true;  		}  		rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  	}  	System.Runtime.InteropServices.Marshal.Copy (rgbValues' 0' ptr' bytes);  	objBmpImage.UnlockBits (bmpData);  	objBmpImage.Save (fileName' imageFormat);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int y = 0; y < innerMap.Height - 1; y++) {  	int counterdeluxe = bmpData.Stride * y;  	int x = 0;  	for (int i = 0; i < bmpData.Stride; i++) {  		if (x > objBmpImage.Width) {  			break;  		}  		BitArray bitar = new BitArray (8);  		for (int j = 4; j >= 0; j = j - 4) {  			if (innerMap [x' y]) {  				bitar [j + 3] = true;  				bitar [j + 2] = true;  				bitar [j + 1] = true;  				bitar [j + 0] = true;  			} else {  				bitar [j + 3] = false;  				bitar [j + 2] = false;  				bitar [j + 1] = false;  				bitar [j + 0] = false;  			}  			x++;  		}  		rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  		counterdeluxe++;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < bmpData.Stride; i++) {  	if (x > objBmpImage.Width) {  		break;  	}  	BitArray bitar = new BitArray (8);  	for (int j = 4; j >= 0; j = j - 4) {  		if (innerMap [x' y]) {  			bitar [j + 3] = true;  			bitar [j + 2] = true;  			bitar [j + 1] = true;  			bitar [j + 0] = true;  		} else {  			bitar [j + 3] = false;  			bitar [j + 2] = false;  			bitar [j + 1] = false;  			bitar [j + 0] = false;  		}  		x++;  	}  	rgbValues [counterdeluxe] = (byte)GetIntFromBitArray (bitar);  	counterdeluxe++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int j = 4; j >= 0; j = j - 4) {  	if (innerMap [x' y]) {  		bitar [j + 3] = true;  		bitar [j + 2] = true;  		bitar [j + 1] = true;  		bitar [j + 0] = true;  	} else {  		bitar [j + 3] = false;  		bitar [j + 2] = false;  		bitar [j + 1] = false;  		bitar [j + 0] = false;  	}  	x++;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: j = j - 4
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (innerMap [x' y]) {  	bitar [j + 3] = true;  	bitar [j + 2] = true;  	bitar [j + 1] = true;  	bitar [j + 0] = true;  } else {  	bitar [j + 3] = false;  	bitar [j + 2] = false;  	bitar [j + 1] = false;  	bitar [j + 0] = false;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (innerMap [x' y]) {  	bitar [j + 3] = true;  	bitar [j + 2] = true;  	bitar [j + 1] = true;  	bitar [j + 0] = true;  } else {  	bitar [j + 3] = false;  	bitar [j + 2] = false;  	bitar [j + 1] = false;  	bitar [j + 0] = false;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (innerMap [x' y]) {  	bitar [j + 3] = true;  	bitar [j + 2] = true;  	bitar [j + 1] = true;  	bitar [j + 0] = true;  } else {  	bitar [j + 3] = false;  	bitar [j + 2] = false;  	bitar [j + 1] = false;  	bitar [j + 0] = false;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (innerMap [x' y]) {  	bitar [j + 3] = true;  	bitar [j + 2] = true;  	bitar [j + 1] = true;  	bitar [j + 0] = true;  } else {  	bitar [j + 3] = false;  	bitar [j + 2] = false;  	bitar [j + 1] = false;  	bitar [j + 0] = false;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [j + 3] = true;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [j + 2] = true;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [j + 3] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [j + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: for (int i = 0; i < path.Count; i++) {  	long percent = 100L * (long)(i + 1) / (long)path.Count;  	MazePoint point = path [i];  	int xrest = point.X % 2;  	int pos = bmpData.Stride * point.Y + point.X / 2;  	//Console.WriteLine(pos);  	BitArray bitar = GetBitArrayFromByte (rgbValues [pos]);  	int xtra = 4;  	if (xrest >= 1) {  		xtra = 0;  	}  	if (percent < 20) {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 40) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = false;  	} else if (percent < 60) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = true;  		bitar [xtra + 0] = true;  	} else if (percent < 80) {  		bitar [xtra + 3] = false;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	} else {  		bitar [xtra + 3] = true;  		bitar [xtra + 2] = false;  		bitar [xtra + 1] = false;  		bitar [xtra + 0] = true;  	}  	rgbValues [pos] = (byte)GetIntFromBitArray (bitar);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 20) {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 3] = true;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 40) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = false;  } else if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 3] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 60) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = true;  	bitar [xtra + 0] = true;  } else if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 3] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: if (percent < 80) {  	bitar [xtra + 3] = false;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  } else {  	bitar [xtra + 3] = true;  	bitar [xtra + 2] = false;  	bitar [xtra + 1] = false;  	bitar [xtra + 0] = true;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 3] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 3] = true;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImagePath4Bit,The following statement contains a magic number: bitar [xtra + 2] = false;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: png.GetMetadata ().SetDpi (100.0);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: png.CompLevel = 4;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int y = 0; y < this.Height - 1; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPosjes.Count) {  			curPathPos = pathPosjes [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPosjes.Count) {  		curPathPos = pathPosjes [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curpos < pathPosjes.Count) {  	curPathPos = pathPosjes [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: g = 255 - curPathPos.RelativePos;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePng,The following statement contains a magic number: lineSavingProgress (y' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: png.GetMetadata ().SetDpi (100.0);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: png.CompLevel = 4;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int yChunkStart = 0; yChunkStart < this.Height - 1; yChunkStart += Maze.LineChunks) {  	var yChunkEnd = Math.Min (yChunkStart + Maze.LineChunks' this.Height - 1);  	var pathPointsHere = pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd).ToList ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	int curpos = 0;  	for (int y = yChunkStart; y < yChunkEnd; y++) {  		ImageLine iline = new ImageLine (imi);  		for (int x = 0; x < this.Width - 1; x++) {  			int r = 0;  			int g = 0;  			int b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == y) {  					r = curPathPos.RelativePos;  					g = 255 - curPathPos.RelativePos;  					b = 0;  					curpos++;  				} else if (this.innerMap [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		png.WriteRow (iline' y);  		lineSavingProgress (y' this.Height - 2);  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int y = yChunkStart; y < yChunkEnd; y++) {  	ImageLine iline = new ImageLine (imi);  	for (int x = 0; x < this.Width - 1; x++) {  		int r = 0;  		int g = 0;  		int b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == y) {  				r = curPathPos.RelativePos;  				g = 255 - curPathPos.RelativePos;  				b = 0;  				curpos++;  			} else if (this.innerMap [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	png.WriteRow (iline' y);  	lineSavingProgress (y' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: for (int x = 0; x < this.Width - 1; x++) {  	int r = 0;  	int g = 0;  	int b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == y) {  			r = curPathPos.RelativePos;  			g = 255 - curPathPos.RelativePos;  			b = 0;  			curpos++;  		} else if (this.innerMap [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == y) {  		r = curPathPos.RelativePos;  		g = 255 - curPathPos.RelativePos;  		b = 0;  		curpos++;  	} else if (this.innerMap [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == y) {  	r = curPathPos.RelativePos;  	g = 255 - curPathPos.RelativePos;  	b = 0;  	curpos++;  } else if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: g = 255 - curPathPos.RelativePos;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: if (this.innerMap [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPath,The following statement contains a magic number: lineSavingProgress (y' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Path analysis completed. Total path length: {0}' this would take up {1}mb."' totalPathLength' Math.Round (totalPathLength * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Memory free: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: memoryFree = (ulong)(memoryFree * 0.6);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("Setting max usage to 60% of this: {0}mb"' memoryFree / 1024 / 1024));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: png.GetMetadata ().SetDpi (100.0);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: png.CompLevel = 4;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: while (yChunkStart < this.Height - 1) {  	//We must use rowsperpathdeterminingcycle here instead of tifftilesize because else you might get into a scenario where the first 4 values and the second 4 values are beneath 1000. But if we would take value 2 to 6 which are also 4 values we would go above 1000.  	//And yes I thought about this pretty well' it needs to be like this because you get forced into reading 500 lines of path from for example 1000 to 1500 where the other thing is 2000' hmmmm...  	//Or not I really need to think about this a bit more. Because if the chunk size is 1000 then you can never end up reading something smaller then that which works because the rowsperpath is always bigger.  	//So yeah' because rows per path is always a multiple or equal to tifftilesize you can never go out of sync becuase no matter what happens' e.g. tifftile = 500 and perpath = 2000. When you're at 2500 you just need to read 500. And you are never forced in reading anything that was  	//not measured. Because you can't end up in having to read somewhere from 1250 to 1750 because of the multiple thingy. Ok I'm quite sure now it needs to be tiffTileSize.  	//  	//Additional note' it always needs to be a multiple of tiffTileSize because we write tiles at a time (we can't write half tiles). So that's why we don't want some stupidly small numbers here.  	int stepsThisLoop = FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng (debugMessageCallback' pathPointsPerRow' yChunkStart' tiffTileSize' memoryFree);  	var yChunkEnd = Math.Min (yChunkStart + stepsThisLoop' this.Height - 1);  	stepsThisLoop = yChunkEnd - yChunkStart;  	var wObtainPathPart = Stopwatch.StartNew ();  	//We don't use a ToList here because we do actually know the expected list size beforehand. This way we make sure we don't have to do any internal Array Resizing.  	var expectedPathCount = pathPointsPerRow.Skip (yChunkStart).Take (yChunkEnd - yChunkStart).Sum ();  	var pathPointsHere = new List<MazePointPos> (expectedPathCount);  	int currentPathPosPoint = 0;  	foreach (var pathPos in pathPosjes.Where (t => t.Y >= yChunkStart && t.Y < yChunkEnd)) {  		pathPointsHere.Add (pathPos);  		currentPathPosPoint++;  	}  	wObtainPathPart.Stop ();  	if (pathPointsHere.Count != expectedPathCount) {  		debugMessageCallback (string.Format ("Warning: Something strange is happening where the actual path point count '{0}' is not equal to the expected path point count '{1}' (Maze will still save correctly but it uses more memory then expected)"' pathPointsHere.Count' expectedPathCount));  	}  	var wSort = Stopwatch.StartNew ();  	pathPointsHere.Sort ((first' second) => {  		if (first.Y == second.Y) {  			return first.X - second.X;  		}  		return first.Y - second.Y;  	});  	wSort.Stop ();  	var wGmemorifiedPieceOpMap = Stopwatch.StartNew ();  	var innerMapTemporaryInMemoryCopy = new BitArreintjeFastInnerMap (this.Width' stepsThisLoop);  	for (int startY = yChunkStart; startY < yChunkEnd; startY += tiffTileSize) {  		for (int startX = 0; startX < this.Width - 1; startX += tiffTileSize) {  			int yStart = startY - yChunkStart;  			int yEnd = yStart + tiffTileSize;  			for (int y = startY' othery = yStart; othery < yEnd; y++' othery++) {  				for (int x = startX' otherx = 0; otherx < tiffTileSize; x++' otherx++) {  					innerMapTemporaryInMemoryCopy [x' othery] = innerMap [x' y];  				}  			}  		}  	}  	wGmemorifiedPieceOpMap.Stop ();  	int curpos = 0;  	var wSaveAsImage = Stopwatch.StartNew ();  	var yChunkMaxRealEnzo = Math.Min (yChunkEnd' this.Height - 1);  	for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  		ImageLine iline = new ImageLine (imi);  		//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  		int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  		for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  			byte r = 0;  			byte g = 0;  			byte b = 0;  			MazePointPos curPathPos;  			if (curpos < pathPointsHere.Count) {  				curPathPos = pathPointsHere [curpos];  				if (curPathPos.X == x && curPathPos.Y == startY) {  					r = curPathPos.RelativePos;  					g = (byte)(255 - curPathPos.RelativePos);  					b = 0;  					curpos++;  				} else if (innerMapTemporaryInMemoryCopy [x' y]) {  					r = 255;  					g = 255;  					b = 255;  				}  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  			ImageLineHelper.SetPixel (iline' x' r' g' b);  		}  		//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  		//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  		//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  		//Result should not be -1  		//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  		png.WriteRow (iline' y + yChunkStart);  		lineSavingProgress (y + yChunkStart' this.Height - 2);  	}  	wSaveAsImage.Stop ();  	debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  	partNumber++;  	yChunkStart += stepsThisLoop;  	//Do some forced garbage collection since we're finished with this loop  	pathPointsHere = null;  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int startY = yChunkStart' y = 0; startY < yChunkMaxRealEnzo; startY += 1' y++) {  	ImageLine iline = new ImageLine (imi);  	//int xMax = Math.Min(this.Width - 1 - startX' tiffTileSize);  	int yMax = Math.Min (this.Height - 1 - startY' tiffTileSize);  	for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  		byte r = 0;  		byte g = 0;  		byte b = 0;  		MazePointPos curPathPos;  		if (curpos < pathPointsHere.Count) {  			curPathPos = pathPointsHere [curpos];  			if (curPathPos.X == x && curPathPos.Y == startY) {  				r = curPathPos.RelativePos;  				g = (byte)(255 - curPathPos.RelativePos);  				b = 0;  				curpos++;  			} else if (innerMapTemporaryInMemoryCopy [x' y]) {  				r = 255;  				g = 255;  				b = 255;  			}  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  		ImageLineHelper.SetPixel (iline' x' r' g' b);  	}  	//var result = tif.WriteEncodedTile(tileNumber' color_ptr' tiffTileSize * tiffTileSize * 3);  	//var result = tif.WriteTile(color_ptr' startX / tileSize' startY / tileSize' 0' 0);  	//var result = tif.WriteRawTile(tileNumber' color_ptr' tileSize * tileSize * 3);  	//Result should not be -1  	//lineSavingProgress((int)Math.Min((tileNumber + 1L) * tiffTileSize / tilesInWidth' this.Height - 2)' this.Height - 2);  	png.WriteRow (iline' y + yChunkStart);  	lineSavingProgress (y + yChunkStart' this.Height - 2);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: for (int x = 0' otherx = 0; otherx < this.Width - 1; x++' otherx++) {  	byte r = 0;  	byte g = 0;  	byte b = 0;  	MazePointPos curPathPos;  	if (curpos < pathPointsHere.Count) {  		curPathPos = pathPointsHere [curpos];  		if (curPathPos.X == x && curPathPos.Y == startY) {  			r = curPathPos.RelativePos;  			g = (byte)(255 - curPathPos.RelativePos);  			b = 0;  			curpos++;  		} else if (innerMapTemporaryInMemoryCopy [x' y]) {  			r = 255;  			g = 255;  			b = 255;  		}  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  	ImageLineHelper.SetPixel (iline' x' r' g' b);  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curpos < pathPointsHere.Count) {  	curPathPos = pathPointsHere [curpos];  	if (curPathPos.X == x && curPathPos.Y == startY) {  		r = curPathPos.RelativePos;  		g = (byte)(255 - curPathPos.RelativePos);  		b = 0;  		curpos++;  	} else if (innerMapTemporaryInMemoryCopy [x' y]) {  		r = 255;  		g = 255;  		b = 255;  	}  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == startY) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == startY) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == startY) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (curPathPos.X == x && curPathPos.Y == startY) {  	r = curPathPos.RelativePos;  	g = (byte)(255 - curPathPos.RelativePos);  	b = 0;  	curpos++;  } else if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = (byte)(255 - curPathPos.RelativePos);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: if (innerMapTemporaryInMemoryCopy [x' y]) {  	r = 255;  	g = 255;  	b = 255;  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: r = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: g = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: b = 255;  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: lineSavingProgress (y + yChunkStart' this.Height - 2);  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,SaveMazeAsImageDeluxePngWithDynamicallyGeneratedPathWithAnalysis,The following statement contains a magic number: debugMessageCallback (string.Format ("{0}: YChunkStart: {1}' YChunkEnd: {2}' Rows written: {3}' Count: {4}' Time to generate this part: {5} sec' Time to sort this part: {6} sec' Time to put this part in memory: {7}' Time to save this part in the image: {8} sec' Combined time: {9} sec' Size: {10}mb"' partNumber' yChunkStart' yChunkEnd' stepsThisLoop' pathPointsHere.Count' Math.Round (wObtainPathPart.Elapsed.TotalSeconds' 2)' Math.Round (wSort.Elapsed.TotalSeconds' 2)' Math.Round (wGmemorifiedPieceOpMap.Elapsed.TotalSeconds' 2)' Math.Round (wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (wObtainPathPart.Elapsed.TotalSeconds + wSort.Elapsed.TotalSeconds + wGmemorifiedPieceOpMap.Elapsed.TotalSeconds + wSaveAsImage.Elapsed.TotalSeconds' 2)' Math.Round (pathPointsHere.Count * 9.0 / 1024.0 / 1024.0' 3)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: while (true) {  	int newTestSize = rowsPerPathDeterminingCycle * 2;  	long maxSizeCur = 0;  	for (int i = 0; i < this.Height; i += newTestSize) {  		long curSize = 0;  		var endRow = Math.Min (this.Height' i + newTestSize);  		for (int y = i; y < endRow; y++) {  			curSize += pathPointsPerRow [y];  		}  		maxSizeCur = Math.Max (curSize' maxSizeCur);  	}  	if (maxSizeCur > GlobalVars.MaxArraySize) {  		debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	var expectedMemoryUsageForPath = maxSizeCur * 9;  	//9 bytes per path pos  	int chunksInWidth = this.Height / newTestSize;  	var expectedMemoryUsageForChunks = (newTestSize * newTestSize / 8) * chunksInWidth;  	var totalMemoryUsage = expectedMemoryUsageForChunks + expectedMemoryUsageForPath;  	if ((ulong)totalMemoryUsage > memoryFree) {  		debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	rowsPerPathDeterminingCycle = newTestSize;  	max = maxSizeCur;  	if (rowsPerPathDeterminingCycle >= this.Height) {  		debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle));  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: while (true) {  	int newTestSize = rowsPerPathDeterminingCycle * 2;  	long maxSizeCur = 0;  	for (int i = 0; i < this.Height; i += newTestSize) {  		long curSize = 0;  		var endRow = Math.Min (this.Height' i + newTestSize);  		for (int y = i; y < endRow; y++) {  			curSize += pathPointsPerRow [y];  		}  		maxSizeCur = Math.Max (curSize' maxSizeCur);  	}  	if (maxSizeCur > GlobalVars.MaxArraySize) {  		debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	var expectedMemoryUsageForPath = maxSizeCur * 9;  	//9 bytes per path pos  	int chunksInWidth = this.Height / newTestSize;  	var expectedMemoryUsageForChunks = (newTestSize * newTestSize / 8) * chunksInWidth;  	var totalMemoryUsage = expectedMemoryUsageForChunks + expectedMemoryUsageForPath;  	if ((ulong)totalMemoryUsage > memoryFree) {  		debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	rowsPerPathDeterminingCycle = newTestSize;  	max = maxSizeCur;  	if (rowsPerPathDeterminingCycle >= this.Height) {  		debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle));  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: while (true) {  	int newTestSize = rowsPerPathDeterminingCycle * 2;  	long maxSizeCur = 0;  	for (int i = 0; i < this.Height; i += newTestSize) {  		long curSize = 0;  		var endRow = Math.Min (this.Height' i + newTestSize);  		for (int y = i; y < endRow; y++) {  			curSize += pathPointsPerRow [y];  		}  		maxSizeCur = Math.Max (curSize' maxSizeCur);  	}  	if (maxSizeCur > GlobalVars.MaxArraySize) {  		debugMessageCallback (string.Format ("We would have to create a list bigger then int.MaxValue with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	var expectedMemoryUsageForPath = maxSizeCur * 9;  	//9 bytes per path pos  	int chunksInWidth = this.Height / newTestSize;  	var expectedMemoryUsageForChunks = (newTestSize * newTestSize / 8) * chunksInWidth;  	var totalMemoryUsage = expectedMemoryUsageForChunks + expectedMemoryUsageForPath;  	if ((ulong)totalMemoryUsage > memoryFree) {  		debugMessageCallback (string.Format ("Memory would be full with RowsPerCycle '{0}'' so we take '{1}'"' newTestSize' rowsPerPathDeterminingCycle));  		break;  	}  	rowsPerPathDeterminingCycle = newTestSize;  	max = maxSizeCur;  	if (rowsPerPathDeterminingCycle >= this.Height) {  		debugMessageCallback (string.Format ("This RowsPerCycle is chosen because it fits in memory and we can do the complete maze in it: '{0}'"' rowsPerPathDeterminingCycle));  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMinimalRowsToWriteForPng,The following statement contains a magic number: debugMessageCallback (string.Format ("Max size of the minimal rows to write would be: {0}' taking up {1}mb of memory."' max' Math.Round (max * 9.0 / 1024.0 / 1024.0' 2)));  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng,The following statement contains a magic number: while (true) {  	var newTestSize = maxRowsToCheck + stepsToIncreaseWithSize;  	long curSize = 0;  	var endRow = Math.Min (this.Height' startRow + newTestSize);  	for (int y = startRow; y < endRow; y++) {  		curSize += pathPointsPerRow [y];  	}  	if (curSize > GlobalVars.MaxArraySize) {  		break;  	}  	var expectedMemoryUsageForPath = curSize * 9;  	//9 bytes per path pos  	int chunksInWidth = this.Height / newTestSize;  	var expectedMemoryUsageForChunks = (newTestSize * newTestSize / 8) * chunksInWidth;  	var totalMemoryUsage = expectedMemoryUsageForChunks + expectedMemoryUsageForPath;  	if ((ulong)totalMemoryUsage > memoryFree) {  		break;  	}  	maxRowsToCheck = newTestSize;  	if (maxRowsToCheck >= (this.Height - startRow)) {  		break;  	}  }  
Magic Number,DeveMazeGenerator,Maze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Maze.cs,FindTheMaxPathRowsThatWouldFitInMemoryFromHerePng,The following statement contains a magic number: while (true) {  	var newTestSize = maxRowsToCheck + stepsToIncreaseWithSize;  	long curSize = 0;  	var endRow = Math.Min (this.Height' startRow + newTestSize);  	for (int y = startRow; y < endRow; y++) {  		curSize += pathPointsPerRow [y];  	}  	if (curSize > GlobalVars.MaxArraySize) {  		break;  	}  	var expectedMemoryUsageForPath = curSize * 9;  	//9 bytes per path pos  	int chunksInWidth = this.Height / newTestSize;  	var expectedMemoryUsageForChunks = (newTestSize * newTestSize / 8) * chunksInWidth;  	var totalMemoryUsage = expectedMemoryUsageForChunks + expectedMemoryUsageForPath;  	if ((ulong)totalMemoryUsage > memoryFree) {  		break;  	}  	maxRowsToCheck = newTestSize;  	if (maxRowsToCheck >= (this.Height - startRow)) {  		break;  	}  }  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,QuatroList,The following statement contains a magic number: innerData = new int[128];  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IncreaseSize,The following statement contains a magic number: v |= v >> 2;  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IncreaseSize,The following statement contains a magic number: v |= v >> 4;  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IncreaseSize,The following statement contains a magic number: v |= v >> 8;  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IncreaseSize,The following statement contains a magic number: v |= v >> 16;  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,BitStringToInt,The following statement contains a magic number: return Convert.ToInt32 (bits' 2);  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IntToBitString,The following statement contains a magic number: while (build.Length < 32) {  	build.Insert (0' "0");  }  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IntToBitString,The following statement contains a magic number: build.Insert (8' " ");  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IntToBitString,The following statement contains a magic number: build.Insert (17' " ");  
Magic Number,DeveMazeGenerator,QuatroList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\QuatroList.cs,IntToBitString,The following statement contains a magic number: build.Insert (26' " ");  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutAction,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutAction.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2] [y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2] [y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x] [y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x] [y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X] [target.Y] = true;  		if (target.X < x) {  			map [x - 1] [y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1] [y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x] [y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x] [y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2] [y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2] [y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2] [y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2] [y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2] [y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2] [y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x] [y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x] [y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x] [y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x] [y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x] [y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x] [y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray3.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [y * width + x - 2]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [y * width + x + 2]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [(y - 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.Y * width + target.X] = true;  		if (target.X < x) {  			map [y * width + (x - 1)] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [y * width + (x + 1)] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [(y - 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [(y + 1) * width + x] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [y * width + x - 2]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [y * width + x - 2]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [y * width + x - 2]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [y * width + x + 2]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [y * width + x + 2]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [y * width + x + 2]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [(y - 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [(y - 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [(y - 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [(y + 2) * width + x]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray2.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (pointertje == stackjex.Count) {  			stackjex.Add (target.X);  			stackjey.Add (target.Y);  		} else {  			stackjex [pointertje] = target.X;  			stackjey [pointertje] = target.Y;  		}  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackList.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: while (pointertje > 0) {  	x = stackjex [pointertje - 1];  	y = stackjey [pointertje - 1];  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackjex [pointertje] = target.X;  		stackjey [pointertje] = target.Y;  		pointertje++;  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		pointertje--;  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMazeAndFastRandomFastStackArray.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		if (target.X < x) {  			map [x - 1' y] = true;  			//pixelChangedCallback.Invoke(x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			//pixelChangedCallback.Invoke(x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			//pixelChangedCallback.Invoke(x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			//pixelChangedCallback.Invoke(x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		//pixelChangedCallback.Invoke(target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackFastWithoutActionAndMaze,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackFastWithoutActionAndMaze.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < maze.Width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < maze.Height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators.Tests,AlgorithmBacktrackTest,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\Tests\AlgorithmBacktrackTest.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int x = 0; x < map.Width; x++) {  	theMap [x] = new KruskalCell[map.Height];  	for (int y = 0; y < map.Height; y++) {  		KruskalCell c = new KruskalCell (x' y);  		theMap [x] [y] = c;  		if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  			currentStep++;  			pixelChangedCallback (x' y' currentStep' totSteps);  			c.kruskalTileType = KruskalTileType.Passable;  			c.cellset.Add (c);  		} else {  			c.kruskalTileType = KruskalTileType.Solid;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int x = 0; x < map.Width; x++) {  	theMap [x] = new KruskalCell[map.Height];  	for (int y = 0; y < map.Height; y++) {  		KruskalCell c = new KruskalCell (x' y);  		theMap [x] [y] = c;  		if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  			currentStep++;  			pixelChangedCallback (x' y' currentStep' totSteps);  			c.kruskalTileType = KruskalTileType.Passable;  			c.cellset.Add (c);  		} else {  			c.kruskalTileType = KruskalTileType.Solid;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 0; y < map.Height; y++) {  	KruskalCell c = new KruskalCell (x' y);  	theMap [x] [y] = c;  	if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  		currentStep++;  		pixelChangedCallback (x' y' currentStep' totSteps);  		c.kruskalTileType = KruskalTileType.Passable;  		c.cellset.Add (c);  	} else {  		c.kruskalTileType = KruskalTileType.Solid;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 0; y < map.Height; y++) {  	KruskalCell c = new KruskalCell (x' y);  	theMap [x] [y] = c;  	if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  		currentStep++;  		pixelChangedCallback (x' y' currentStep' totSteps);  		c.kruskalTileType = KruskalTileType.Passable;  		c.cellset.Add (c);  	} else {  		c.kruskalTileType = KruskalTileType.Solid;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  	currentStep++;  	pixelChangedCallback (x' y' currentStep' totSteps);  	c.kruskalTileType = KruskalTileType.Passable;  	c.cellset.Add (c);  } else {  	c.kruskalTileType = KruskalTileType.Solid;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: if ((x + 1) % 2 == 0 && (y + 1) % 2 == 0 && x != map.Width - 1 && y != map.Height - 1) {  	currentStep++;  	pixelChangedCallback (x' y' currentStep' totSteps);  	c.kruskalTileType = KruskalTileType.Passable;  	c.cellset.Add (c);  } else {  	c.kruskalTileType = KruskalTileType.Solid;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 1; y < map.Height - 2; y++) {  	Boolean horizontalwall = false;  	int startje = 1;  	if (y % 2 == 1) {  		horizontalwall = true;  		startje = 2;  	}  	for (int x = startje; x < map.Width - 2; x = x + 2) {  		KruskalCell ccc = theMap [x] [y];  		ccc.kruskalTileType = KruskalTileType.Solid;  		walls.Add (ccc);  		ccc.cellset.Clear ();  		if (horizontalwall) {  			//form.pixelDraw(x' y' Brushes.Blue);  			ccc.cellset.Add (theMap [x - 1] [y]);  			ccc.cellset.Add (theMap [x + 1] [y]);  		} else {  			//form.pixelDraw(x' y' Brushes.Yellow);  			ccc.cellset.Add (theMap [x] [y - 1]);  			ccc.cellset.Add (theMap [x] [y + 1]);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 1; y < map.Height - 2; y++) {  	Boolean horizontalwall = false;  	int startje = 1;  	if (y % 2 == 1) {  		horizontalwall = true;  		startje = 2;  	}  	for (int x = startje; x < map.Width - 2; x = x + 2) {  		KruskalCell ccc = theMap [x] [y];  		ccc.kruskalTileType = KruskalTileType.Solid;  		walls.Add (ccc);  		ccc.cellset.Clear ();  		if (horizontalwall) {  			//form.pixelDraw(x' y' Brushes.Blue);  			ccc.cellset.Add (theMap [x - 1] [y]);  			ccc.cellset.Add (theMap [x + 1] [y]);  		} else {  			//form.pixelDraw(x' y' Brushes.Yellow);  			ccc.cellset.Add (theMap [x] [y - 1]);  			ccc.cellset.Add (theMap [x] [y + 1]);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 1; y < map.Height - 2; y++) {  	Boolean horizontalwall = false;  	int startje = 1;  	if (y % 2 == 1) {  		horizontalwall = true;  		startje = 2;  	}  	for (int x = startje; x < map.Width - 2; x = x + 2) {  		KruskalCell ccc = theMap [x] [y];  		ccc.kruskalTileType = KruskalTileType.Solid;  		walls.Add (ccc);  		ccc.cellset.Clear ();  		if (horizontalwall) {  			//form.pixelDraw(x' y' Brushes.Blue);  			ccc.cellset.Add (theMap [x - 1] [y]);  			ccc.cellset.Add (theMap [x + 1] [y]);  		} else {  			//form.pixelDraw(x' y' Brushes.Yellow);  			ccc.cellset.Add (theMap [x] [y - 1]);  			ccc.cellset.Add (theMap [x] [y + 1]);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 1; y < map.Height - 2; y++) {  	Boolean horizontalwall = false;  	int startje = 1;  	if (y % 2 == 1) {  		horizontalwall = true;  		startje = 2;  	}  	for (int x = startje; x < map.Width - 2; x = x + 2) {  		KruskalCell ccc = theMap [x] [y];  		ccc.kruskalTileType = KruskalTileType.Solid;  		walls.Add (ccc);  		ccc.cellset.Clear ();  		if (horizontalwall) {  			//form.pixelDraw(x' y' Brushes.Blue);  			ccc.cellset.Add (theMap [x - 1] [y]);  			ccc.cellset.Add (theMap [x + 1] [y]);  		} else {  			//form.pixelDraw(x' y' Brushes.Yellow);  			ccc.cellset.Add (theMap [x] [y - 1]);  			ccc.cellset.Add (theMap [x] [y + 1]);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int y = 1; y < map.Height - 2; y++) {  	Boolean horizontalwall = false;  	int startje = 1;  	if (y % 2 == 1) {  		horizontalwall = true;  		startje = 2;  	}  	for (int x = startje; x < map.Width - 2; x = x + 2) {  		KruskalCell ccc = theMap [x] [y];  		ccc.kruskalTileType = KruskalTileType.Solid;  		walls.Add (ccc);  		ccc.cellset.Clear ();  		if (horizontalwall) {  			//form.pixelDraw(x' y' Brushes.Blue);  			ccc.cellset.Add (theMap [x - 1] [y]);  			ccc.cellset.Add (theMap [x + 1] [y]);  		} else {  			//form.pixelDraw(x' y' Brushes.Yellow);  			ccc.cellset.Add (theMap [x] [y - 1]);  			ccc.cellset.Add (theMap [x] [y + 1]);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: if (y % 2 == 1) {  	horizontalwall = true;  	startje = 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: if (y % 2 == 1) {  	horizontalwall = true;  	startje = 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: startje = 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int x = startje; x < map.Width - 2; x = x + 2) {  	KruskalCell ccc = theMap [x] [y];  	ccc.kruskalTileType = KruskalTileType.Solid;  	walls.Add (ccc);  	ccc.cellset.Clear ();  	if (horizontalwall) {  		//form.pixelDraw(x' y' Brushes.Blue);  		ccc.cellset.Add (theMap [x - 1] [y]);  		ccc.cellset.Add (theMap [x + 1] [y]);  	} else {  		//form.pixelDraw(x' y' Brushes.Yellow);  		ccc.cellset.Add (theMap [x] [y - 1]);  		ccc.cellset.Add (theMap [x] [y + 1]);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: for (int x = startje; x < map.Width - 2; x = x + 2) {  	KruskalCell ccc = theMap [x] [y];  	ccc.kruskalTileType = KruskalTileType.Solid;  	walls.Add (ccc);  	ccc.cellset.Clear ();  	if (horizontalwall) {  		//form.pixelDraw(x' y' Brushes.Blue);  		ccc.cellset.Add (theMap [x - 1] [y]);  		ccc.cellset.Add (theMap [x + 1] [y]);  	} else {  		//form.pixelDraw(x' y' Brushes.Yellow);  		ccc.cellset.Add (theMap [x] [y - 1]);  		ccc.cellset.Add (theMap [x] [y + 1]);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmKruskal,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmKruskal.cs,GoGenerate,The following statement contains a magic number: x = x + 2
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: while (true) {  	//Console.WriteLine(quatro.Count + "' X: " + x + " Y: " + y);  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		if (backtracking) {  			backtracking = false;  			targetCount = 0;  			if (map [x - 1' y])//Wall open at the left  			 {  				targets [targetCount].X = x - 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x + 1' y])//Wall open at the right  			 {  				targets [targetCount].X = x + 2;  				targets [targetCount].Y = y;  				targetCount++;  			}  			if (map [x' y - 1])//Wall open at the top  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y - 2;  				targetCount++;  			}  			if (map [x' y + 1])//Wall open at the bottom  			 {  				targets [targetCount].X = x;  				targets [targetCount].Y = y + 2;  				targetCount++;  			}  			if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  			 {  				for (int i = 0; i < targetCount; i++) {  					var curMazePoint = targets [i];  					if (curMazePoint.X != prex || curMazePoint.Y != prey) {  						if (curMazePoint.Y < y) {  							quatro.Push (0);  							//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X > x) {  							quatro.Push (1);  							//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.Y > y) {  							quatro.Push (2);  							//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  						} else if (curMazePoint.X < x) {  							quatro.Push (3);  							//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  						}  						break;  					}  				}  			}  		}  		//stackje.Push(target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  		}  		x = target.X;  		y = target.Y;  		prex = -1;  		prey = -1;  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  	} else {  		backtracking = true;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount > 2)//Junction  		 {  			prex = x;  			prey = y;  			int whereToGo = quatro.Pop ();  			if (whereToGo == 0) {  				y -= 2;  			} else if (whereToGo == 1) {  				x += 2;  			} else if (whereToGo == 2) {  				y += 2;  			} else if (whereToGo == 3) {  				x -= 2;  			}  		} else {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					prex = x;  					prey = y;  					x = curMazePoint.X;  					y = curMazePoint.Y;  					break;  				}  			}  		}  		pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  	}  	if (x == 1 && y == 1) {  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 0) {  	var target = targets [r.Next (targetCount)];  	if (backtracking) {  		backtracking = false;  		targetCount = 0;  		if (map [x - 1' y])//Wall open at the left  		 {  			targets [targetCount].X = x - 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x + 1' y])//Wall open at the right  		 {  			targets [targetCount].X = x + 2;  			targets [targetCount].Y = y;  			targetCount++;  		}  		if (map [x' y - 1])//Wall open at the top  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y - 2;  			targetCount++;  		}  		if (map [x' y + 1])//Wall open at the bottom  		 {  			targets [targetCount].X = x;  			targets [targetCount].Y = y + 2;  			targetCount++;  		}  		if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  		 {  			for (int i = 0; i < targetCount; i++) {  				var curMazePoint = targets [i];  				if (curMazePoint.X != prex || curMazePoint.Y != prey) {  					if (curMazePoint.Y < y) {  						quatro.Push (0);  						//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X > x) {  						quatro.Push (1);  						//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.Y > y) {  						quatro.Push (2);  						//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  					} else if (curMazePoint.X < x) {  						quatro.Push (3);  						//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  					}  					break;  				}  			}  		}  	}  	//stackje.Push(target);  	map [target.X' target.Y] = true;  	currentStep++;  	if (target.X < x) {  		map [x - 1' y] = true;  		pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  	} else if (target.X > x) {  		map [x + 1' y] = true;  		pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  	} else if (target.Y < y) {  		map [x' y - 1] = true;  		pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  	} else if (target.Y > y) {  		map [x' y + 1] = true;  		pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  	}  	x = target.X;  	y = target.Y;  	prex = -1;  	prey = -1;  	pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  } else {  	backtracking = true;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount > 2)//Junction  	 {  		prex = x;  		prey = y;  		int whereToGo = quatro.Pop ();  		if (whereToGo == 0) {  			y -= 2;  		} else if (whereToGo == 1) {  			x += 2;  		} else if (whereToGo == 2) {  			y += 2;  		} else if (whereToGo == 3) {  			x -= 2;  		}  	} else {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				prex = x;  				prey = y;  				x = curMazePoint.X;  				y = curMazePoint.Y;  				break;  			}  		}  	}  	pixelChangedCallback.Invoke (x' y' currentStep' totSteps);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (backtracking) {  	backtracking = false;  	targetCount = 0;  	if (map [x - 1' y])//Wall open at the left  	 {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x + 1' y])//Wall open at the right  	 {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (map [x' y - 1])//Wall open at the top  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (map [x' y + 1])//Wall open at the bottom  	 {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	if (targetCount <= 2)//If currently only 2 exist at this tile' create junction  	 {  		for (int i = 0; i < targetCount; i++) {  			var curMazePoint = targets [i];  			if (curMazePoint.X != prex || curMazePoint.Y != prey) {  				if (curMazePoint.Y < y) {  					quatro.Push (0);  					//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X > x) {  					quatro.Push (1);  					//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.Y > y) {  					quatro.Push (2);  					//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  				} else if (curMazePoint.X < x) {  					quatro.Push (3);  					//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  				}  				break;  			}  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x - 1' y])//Wall open at the left   {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x + 1' y])//Wall open at the right   {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x' y - 1])//Wall open at the top   {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x' y + 1])//Wall open at the bottom   {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount <= 2)//If currently only 2 exist at this tile' create junction   {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			if (curMazePoint.Y < y) {  				quatro.Push (0);  				//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X > x) {  				quatro.Push (1);  				//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.Y > y) {  				quatro.Push (2);  				//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X < x) {  				quatro.Push (3);  				//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  			}  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount <= 2)//If currently only 2 exist at this tile' create junction   {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			if (curMazePoint.Y < y) {  				quatro.Push (0);  				//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X > x) {  				quatro.Push (1);  				//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.Y > y) {  				quatro.Push (2);  				//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X < x) {  				quatro.Push (3);  				//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  			}  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount <= 2)//If currently only 2 exist at this tile' create junction   {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			if (curMazePoint.Y < y) {  				quatro.Push (0);  				//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X > x) {  				quatro.Push (1);  				//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.Y > y) {  				quatro.Push (2);  				//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  			} else if (curMazePoint.X < x) {  				quatro.Push (3);  				//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  			}  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: for (int i = 0; i < targetCount; i++) {  	var curMazePoint = targets [i];  	if (curMazePoint.X != prex || curMazePoint.Y != prey) {  		if (curMazePoint.Y < y) {  			quatro.Push (0);  			//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.X > x) {  			quatro.Push (1);  			//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.Y > y) {  			quatro.Push (2);  			//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.X < x) {  			quatro.Push (3);  			//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  		}  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: for (int i = 0; i < targetCount; i++) {  	var curMazePoint = targets [i];  	if (curMazePoint.X != prex || curMazePoint.Y != prey) {  		if (curMazePoint.Y < y) {  			quatro.Push (0);  			//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.X > x) {  			quatro.Push (1);  			//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.Y > y) {  			quatro.Push (2);  			//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  		} else if (curMazePoint.X < x) {  			quatro.Push (3);  			//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  		}  		break;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.X != prex || curMazePoint.Y != prey) {  	if (curMazePoint.Y < y) {  		quatro.Push (0);  		//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.X > x) {  		quatro.Push (1);  		//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.Y > y) {  		quatro.Push (2);  		//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.X < x) {  		quatro.Push (3);  		//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  	}  	break;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.X != prex || curMazePoint.Y != prey) {  	if (curMazePoint.Y < y) {  		quatro.Push (0);  		//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.X > x) {  		quatro.Push (1);  		//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.Y > y) {  		quatro.Push (2);  		//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  	} else if (curMazePoint.X < x) {  		quatro.Push (3);  		//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  	}  	break;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.Y < y) {  	quatro.Push (0);  	//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X > x) {  	quatro.Push (1);  	//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  } else if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.Y < y) {  	quatro.Push (0);  	//g.FillRectangle(Brushes.Green' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X > x) {  	quatro.Push (1);  	//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  } else if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.X > x) {  	quatro.Push (1);  	//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  } else if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.X > x) {  	quatro.Push (1);  	//g.FillRectangle(Brushes.Violet' x * 5' y * 5' 5' 5);  } else if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.Y > y) {  	quatro.Push (2);  	//g.FillRectangle(Brushes.Blue' x * 5' y * 5' 5' 5);  } else if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: quatro.Push (2);  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (curMazePoint.X < x) {  	quatro.Push (3);  	//g.FillRectangle(Brushes.Brown' x * 5' y * 5' 5' 5);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: quatro.Push (3);  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x - 1' y])//Wall open at the left   {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x + 1' y])//Wall open at the right   {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x' y - 1])//Wall open at the top   {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (map [x' y + 1])//Wall open at the bottom   {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (targetCount > 2)//Junction   {  	prex = x;  	prey = y;  	int whereToGo = quatro.Pop ();  	if (whereToGo == 0) {  		y -= 2;  	} else if (whereToGo == 1) {  		x += 2;  	} else if (whereToGo == 2) {  		y += 2;  	} else if (whereToGo == 3) {  		x -= 2;  	}  } else {  	for (int i = 0; i < targetCount; i++) {  		var curMazePoint = targets [i];  		if (curMazePoint.X != prex || curMazePoint.Y != prey) {  			prex = x;  			prey = y;  			x = curMazePoint.X;  			y = curMazePoint.Y;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 0) {  	y -= 2;  } else if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: y -= 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 1) {  	x += 2;  } else if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: x += 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 2) {  	y += 2;  } else if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: y += 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: if (whereToGo == 3) {  	x -= 2;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The following statement contains a magic number: x -= 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: for (int x = 0; x < maze.Width; x++) {  	for (int y = 0; y < maze.Height; y++) {  		if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  			map [x' y] = false;  		} else {  			map [x' y] = true;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: for (int x = 0; x < maze.Width; x++) {  	for (int y = 0; y < maze.Height; y++) {  		if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  			map [x' y] = false;  		} else {  			map [x' y] = true;  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: for (int y = 0; y < maze.Height; y++) {  	if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  		map [x' y] = false;  	} else {  		map [x' y] = true;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: for (int y = 0; y < maze.Height; y++) {  	if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  		map [x' y] = false;  	} else {  		map [x' y] = true;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  	map [x' y] = false;  } else {  	map [x' y] = true;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (x == 0 || x == maze.Width - 1 || x == maze.Width - 2 || y == 0 || y == maze.Height - 1 || y == maze.Height - 2) {  	map [x' y] = false;  } else {  	map [x' y] = true;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: while (rectangles.Count != 0) {  	curRect = rectangles.Pop ();  	if (curRect.Width > 3 && curRect.Height > 3) {  		Boolean horizontalSplit = true;  		if (curRect.Width > curRect.Height) {  			horizontalSplit = false;  		} else if (curRect.Width < curRect.Height) {  			horizontalSplit = true;  		} else {  			if (r.Next (2) == 0) {  				horizontalSplit = false;  			}  		}  		if (horizontalSplit) {  			int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  			Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  			for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  				if (i - curRect.X != opening) {  					map [i' curRect.Y + splitnumber] = false;  				}  			}  			//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  			//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		} else {  			int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  			int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  			Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  			Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  			for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  				if (i - curRect.Y != opening) {  					map [curRect.X + splitnumber' i] = false;  				}  			}  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  			//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  			rectangles.Push (rect1);  			rectangles.Push (rect2);  		}  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > 3 && curRect.Height > 3) {  	Boolean horizontalSplit = true;  	if (curRect.Width > curRect.Height) {  		horizontalSplit = false;  	} else if (curRect.Width < curRect.Height) {  		horizontalSplit = true;  	} else {  		if (r.Next (2) == 0) {  			horizontalSplit = false;  		}  	}  	if (horizontalSplit) {  		int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  		Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  		for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  			if (i - curRect.X != opening) {  				map [i' curRect.Y + splitnumber] = false;  			}  		}  		//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  		//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	} else {  		int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  		int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  		Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  		Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  		for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  			if (i - curRect.Y != opening) {  				map [curRect.X + splitnumber' i] = false;  			}  		}  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  		//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  		rectangles.Push (rect1);  		rectangles.Push (rect2);  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width > curRect.Height) {  	horizontalSplit = false;  } else if (curRect.Width < curRect.Height) {  	horizontalSplit = true;  } else {  	if (r.Next (2) == 0) {  		horizontalSplit = false;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (curRect.Width < curRect.Height) {  	horizontalSplit = true;  } else {  	if (r.Next (2) == 0) {  		horizontalSplit = false;  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (r.Next (2) == 0) {  	horizontalSplit = false;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmDivision,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmDivision.cs,GoGenerate,The following statement contains a magic number: if (horizontalSplit) {  	int splitnumber = 2 + r.Next ((curRect.Height - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Width) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' curRect.Width' splitnumber + 1);  	Rectangle rect2 = new Rectangle (curRect.X' curRect.Y + splitnumber' curRect.Width' curRect.Height - splitnumber);  	for (int i = curRect.X; i < curRect.X + curRect.Width; i++) {  		if (i - curRect.X != opening) {  			map [i' curRect.Y + splitnumber] = false;  		}  	}  	//form.drawRectangle(curRect.X' curRect.Y + splitnumber' opening' 1' brushBlack);  	//form.drawRectangle(curRect.X + opening + 1' curRect.Y + splitnumber' curRect.Width - opening - 1' 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  } else {  	int splitnumber = 2 + r.Next ((curRect.Width - 2) / 2) * 2;  	int opening = 1 + r.Next ((curRect.Height) / 2) * 2;  	Rectangle rect1 = new Rectangle (curRect.X' curRect.Y' splitnumber + 1' curRect.Height);  	Rectangle rect2 = new Rectangle (curRect.X + splitnumber' curRect.Y' curRect.Width - splitnumber' curRect.Height);  	for (int i = curRect.Y; i < curRect.Y + curRect.Height; i++) {  		if (i - curRect.Y != opening) {  			map [curRect.X + splitnumber' i] = false;  		}  	}  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y' 1' opening' brushBlack);  	//form.drawRectangle(curRect.X + splitnumber' curRect.Y + opening + 1' 1' curRect.Height - opening - 1' brushBlack);  	rectangles.Push (rect1);  	rectangles.Push (rect2);  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: while (stackje.Count != 0) {  	MazePoint cur = stackje.Peek ();  	x = cur.X;  	y = cur.Y;  	int targetCount = 0;  	if (x - 2 > 0 && !map [x - 2' y]) {  		targets [targetCount].X = x - 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (x + 2 < width - 1 && !map [x + 2' y]) {  		targets [targetCount].X = x + 2;  		targets [targetCount].Y = y;  		targetCount++;  	}  	if (y - 2 > 0 && !map [x' y - 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y - 2;  		targetCount++;  	}  	if (y + 2 < height - 1 && !map [x' y + 2]) {  		targets [targetCount].X = x;  		targets [targetCount].Y = y + 2;  		targetCount++;  	}  	//Thread.Sleep(1000);  	if (targetCount > 0) {  		var target = targets [r.Next (targetCount)];  		stackje.Push (target);  		map [target.X' target.Y] = true;  		currentStep++;  		if (target.X < x) {  			map [x - 1' y] = true;  			pixelChangedCallback.Invoke (x - 1' y' currentStep' totSteps);  			//form.drawPixel(x - 1' y' brushThisUses);  		} else if (target.X > x) {  			map [x + 1' y] = true;  			pixelChangedCallback.Invoke (x + 1' y' currentStep' totSteps);  			//form.drawPixel(x + 1' y' brushThisUses);  		} else if (target.Y < y) {  			map [x' y - 1] = true;  			pixelChangedCallback.Invoke (x' y - 1' currentStep' totSteps);  			//form.drawPixel(x' y - 1' brushThisUses);  		} else if (target.Y > y) {  			map [x' y + 1] = true;  			pixelChangedCallback.Invoke (x' y + 1' currentStep' totSteps);  			//form.drawPixel(x' y + 1' brushThisUses);  		}  		pixelChangedCallback.Invoke (target.X' target.Y' currentStep' totSteps);  		//form.drawPixel(target.X' target.Y' brushThisUses);  	} else {  		stackje.Pop ();  	}  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x - 2 > 0 && !map [x - 2' y]) {  	targets [targetCount].X = x - 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (x + 2 < width - 1 && !map [x + 2' y]) {  	targets [targetCount].X = x + 2;  	targets [targetCount].Y = y;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].X = x + 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y - 2 > 0 && !map [x' y - 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y - 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y - 2;  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: if (y + 2 < height - 1 && !map [x' y + 2]) {  	targets [targetCount].X = x;  	targets [targetCount].Y = y + 2;  	targetCount++;  }  
Magic Number,DeveMazeGenerator.Generators,AlgorithmBacktrack,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrack.cs,GoGenerate,The following statement contains a magic number: targets [targetCount].Y = y + 2;  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,BitArrayMappedOnHardDiskInnerMap,The following statement contains a magic number: inthdarray = new IntHDArray (totalLength / 8 + 1);  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,SetRealPos,The following statement contains a magic number: if (value) {  	int a = 1 << thePositionForBitShift;  	inthdarray [pos / 32] |= a;  } else {  	int a = ~(1 << thePositionForBitShift);  	inthdarray [pos / 32] &= a;  }  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,SetRealPos,The following statement contains a magic number: if (value) {  	int a = 1 << thePositionForBitShift;  	inthdarray [pos / 32] |= a;  } else {  	int a = ~(1 << thePositionForBitShift);  	inthdarray [pos / 32] &= a;  }  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,SetRealPos,The following statement contains a magic number: inthdarray [pos / 32] |= a;  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,SetRealPos,The following statement contains a magic number: inthdarray [pos / 32] &= a;  
Magic Number,DeveMazeGenerator.InnerMaps,BitArrayMappedOnHardDiskInnerMap,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArrayMappedOnHardDiskInnerMap.cs,GetRealPos,The following statement contains a magic number: return (inthdarray [pos / 32] & (1 << thePositionForBitShift)) != 0;  
Magic Number,DeveMazeGenerator.InnerMaps,BitArreintjeFastInnerMapArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\BitArreintjeFastInnerMapArray.cs,BitArreintjeFastInnerMapArray,The following statement contains a magic number: innerData = new int[height / 32 + 1];  
Magic Number,DeveMazeGenerator.InnerMaps,HybridInnerMapPart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\HybridInnerMap.cs,Load,The following statement contains a magic number: innerMapInPart.innerData = hdArray.ReadIntArray (pos' (width * height) / 8);  
Magic Number,DeveMazeGenerator.InnerMaps.InnerMapHelpers,CompleteHDArray,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\InnerMaps\InnerMapHelpers\CompleteHDArray.cs,CompleteHDArray,The following statement contains a magic number: fileStream = new FileStream (innerFileName' FileMode.Create' FileAccess.ReadWrite' FileShare.Read' 4096' GlobalVars.FileFlagNoBuffering | FileOptions.WriteThrough);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: while (true) {  	//cur = stackje[stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	if (!backtracking) {  		callBack (x' y' PathFinderAction.Step);  	} else {  		callBack (x' y' PathFinderAction.Backtrack);  	}  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (maxTimesAtStart == -1) {  		//Only the first time when we are actually at start  		maxTimesAtStart = possibleDirectionsCount;  	} else if (cur.X == start.X && cur.Y == start.Y) {  		maxTimesAtStart--;  		if (maxTimesAtStart == 0) {  			Console.WriteLine ("No path found...");  			break;  		}  	}  	//If we have more then 2 directions we got a junction (only if we're not backtracking) (This is actually 3 directions but we only count 2 because we don't count previous direction)  	//If we are however at the start (which is actually the end because we swap them around) we don't create a direction because you're at the end and don't need directions  	//If we are however at the end (which is the start) we will create a direction if we have more then 2 directions (This is 2 because we don't have a previous one yet)  	if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  		//Create junction  		callBack (x' y' PathFinderAction.Junction);  		int directionWeCameFrom = -1;  		if (prev.X > cur.X) {  			directionWeCameFrom = 1;  			//Previous x was bigger so we came from the right  		} else if (prev.Y > cur.Y) {  			directionWeCameFrom = 2;  		} else if (prev.X < cur.X) {  			directionWeCameFrom = 3;  		} else if (prev.Y < cur.Y) {  			directionWeCameFrom = 0;  		}  		quatro.Push (directionWeCameFrom);  	}  	if (x == end.X && y == end.Y) {  		//path found  		return quatro;  	}  	if (possibleDirectionsCount > 0) {  		if (backtracking && cur.X == start.X && cur.Y == start.Y) {  			//This is because we don't have a junction at the start point but we want to stop backtracking anyway  			backtracking = false;  		}  		if (backtracking) {  			if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  			 {  				callBack (x' y' PathFinderAction.RefoundJunction);  				//Set the direction we backtracked from  				var lastBackTrackDir = -1;  				if (prev.X < cur.X) {  					lastBackTrackDir = 0;  				} else if (prev.Y < cur.Y) {  					lastBackTrackDir = 1;  				} else if (prev.X > cur.X) {  					lastBackTrackDir = 2;  				} else if (prev.Y > cur.Y) {  					lastBackTrackDir = 3;  				}  				var foundJunction = quatro.Peek ();  				int previousDirectionX = 0;  				int previousDirectionY = 0;  				switch (foundJunction) {  				case 0:  					previousDirectionY = -1;  					break;  				case 1:  					previousDirectionX = 1;  					break;  				case 2:  					previousDirectionY = 1;  					break;  				case 3:  					previousDirectionX = -1;  					break;  				}  				Boolean foundSomething = false;  				for (int i = 0; i < possibleDirectionsCount; i++) {  					var probDir = possibleDirections [i];  					if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  						var directionOfThisDir = -1;  						if (probDir.X < cur.X) {  							directionOfThisDir = 0;  						} else if (probDir.Y < cur.Y) {  							directionOfThisDir = 1;  						} else if (probDir.X > cur.X) {  							directionOfThisDir = 2;  						} else if (probDir.Y > cur.Y) {  							directionOfThisDir = 3;  						}  						if (directionOfThisDir > lastBackTrackDir) {  							prev = cur;  							cur = probDir;  							foundSomething = true;  							backtracking = false;  							break;  						}  					}  				}  				if (!foundSomething) {  					callBack (x' y' PathFinderAction.RemovingJunction);  					quatro.Pop ();  					prev = cur;  					cur.X += previousDirectionX;  					cur.Y += previousDirectionY;  				}  			} else {  				prev = cur;  				cur = possibleDirections [0];  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		MazePoint curtemp = cur;  		cur = prev;  		prev = curtemp;  		backtracking = true;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  	//Create junction  	callBack (x' y' PathFinderAction.Junction);  	int directionWeCameFrom = -1;  	if (prev.X > cur.X) {  		directionWeCameFrom = 1;  		//Previous x was bigger so we came from the right  	} else if (prev.Y > cur.Y) {  		directionWeCameFrom = 2;  	} else if (prev.X < cur.X) {  		directionWeCameFrom = 3;  	} else if (prev.Y < cur.Y) {  		directionWeCameFrom = 0;  	}  	quatro.Push (directionWeCameFrom);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  	//Create junction  	callBack (x' y' PathFinderAction.Junction);  	int directionWeCameFrom = -1;  	if (prev.X > cur.X) {  		directionWeCameFrom = 1;  		//Previous x was bigger so we came from the right  	} else if (prev.Y > cur.Y) {  		directionWeCameFrom = 2;  	} else if (prev.X < cur.X) {  		directionWeCameFrom = 3;  	} else if (prev.Y < cur.Y) {  		directionWeCameFrom = 0;  	}  	quatro.Push (directionWeCameFrom);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if ((possibleDirectionsCount >= 2 && !backtracking && (x != start.X || y != start.Y)) || (possibleDirectionsCount >= 1 && x == end.X && y == end.Y)) {  	//Create junction  	callBack (x' y' PathFinderAction.Junction);  	int directionWeCameFrom = -1;  	if (prev.X > cur.X) {  		directionWeCameFrom = 1;  		//Previous x was bigger so we came from the right  	} else if (prev.Y > cur.Y) {  		directionWeCameFrom = 2;  	} else if (prev.X < cur.X) {  		directionWeCameFrom = 3;  	} else if (prev.Y < cur.Y) {  		directionWeCameFrom = 0;  	}  	quatro.Push (directionWeCameFrom);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X > cur.X) {  	directionWeCameFrom = 1;  	//Previous x was bigger so we came from the right  } else if (prev.Y > cur.Y) {  	directionWeCameFrom = 2;  } else if (prev.X < cur.X) {  	directionWeCameFrom = 3;  } else if (prev.Y < cur.Y) {  	directionWeCameFrom = 0;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X > cur.X) {  	directionWeCameFrom = 1;  	//Previous x was bigger so we came from the right  } else if (prev.Y > cur.Y) {  	directionWeCameFrom = 2;  } else if (prev.X < cur.X) {  	directionWeCameFrom = 3;  } else if (prev.Y < cur.Y) {  	directionWeCameFrom = 0;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.Y > cur.Y) {  	directionWeCameFrom = 2;  } else if (prev.X < cur.X) {  	directionWeCameFrom = 3;  } else if (prev.Y < cur.Y) {  	directionWeCameFrom = 0;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.Y > cur.Y) {  	directionWeCameFrom = 2;  } else if (prev.X < cur.X) {  	directionWeCameFrom = 3;  } else if (prev.Y < cur.Y) {  	directionWeCameFrom = 0;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: directionWeCameFrom = 2;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X < cur.X) {  	directionWeCameFrom = 3;  } else if (prev.Y < cur.Y) {  	directionWeCameFrom = 0;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: directionWeCameFrom = 3;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount > 0) {  	if (backtracking && cur.X == start.X && cur.Y == start.Y) {  		//This is because we don't have a junction at the start point but we want to stop backtracking anyway  		backtracking = false;  	}  	if (backtracking) {  		if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  		 {  			callBack (x' y' PathFinderAction.RefoundJunction);  			//Set the direction we backtracked from  			var lastBackTrackDir = -1;  			if (prev.X < cur.X) {  				lastBackTrackDir = 0;  			} else if (prev.Y < cur.Y) {  				lastBackTrackDir = 1;  			} else if (prev.X > cur.X) {  				lastBackTrackDir = 2;  			} else if (prev.Y > cur.Y) {  				lastBackTrackDir = 3;  			}  			var foundJunction = quatro.Peek ();  			int previousDirectionX = 0;  			int previousDirectionY = 0;  			switch (foundJunction) {  			case 0:  				previousDirectionY = -1;  				break;  			case 1:  				previousDirectionX = 1;  				break;  			case 2:  				previousDirectionY = 1;  				break;  			case 3:  				previousDirectionX = -1;  				break;  			}  			Boolean foundSomething = false;  			for (int i = 0; i < possibleDirectionsCount; i++) {  				var probDir = possibleDirections [i];  				if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  					var directionOfThisDir = -1;  					if (probDir.X < cur.X) {  						directionOfThisDir = 0;  					} else if (probDir.Y < cur.Y) {  						directionOfThisDir = 1;  					} else if (probDir.X > cur.X) {  						directionOfThisDir = 2;  					} else if (probDir.Y > cur.Y) {  						directionOfThisDir = 3;  					}  					if (directionOfThisDir > lastBackTrackDir) {  						prev = cur;  						cur = probDir;  						foundSomething = true;  						backtracking = false;  						break;  					}  				}  			}  			if (!foundSomething) {  				callBack (x' y' PathFinderAction.RemovingJunction);  				quatro.Pop ();  				prev = cur;  				cur.X += previousDirectionX;  				cur.Y += previousDirectionY;  			}  		} else {  			prev = cur;  			cur = possibleDirections [0];  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	MazePoint curtemp = cur;  	cur = prev;  	prev = curtemp;  	backtracking = true;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (backtracking) {  	if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from  	 {  		callBack (x' y' PathFinderAction.RefoundJunction);  		//Set the direction we backtracked from  		var lastBackTrackDir = -1;  		if (prev.X < cur.X) {  			lastBackTrackDir = 0;  		} else if (prev.Y < cur.Y) {  			lastBackTrackDir = 1;  		} else if (prev.X > cur.X) {  			lastBackTrackDir = 2;  		} else if (prev.Y > cur.Y) {  			lastBackTrackDir = 3;  		}  		var foundJunction = quatro.Peek ();  		int previousDirectionX = 0;  		int previousDirectionY = 0;  		switch (foundJunction) {  		case 0:  			previousDirectionY = -1;  			break;  		case 1:  			previousDirectionX = 1;  			break;  		case 2:  			previousDirectionY = 1;  			break;  		case 3:  			previousDirectionX = -1;  			break;  		}  		Boolean foundSomething = false;  		for (int i = 0; i < possibleDirectionsCount; i++) {  			var probDir = possibleDirections [i];  			if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  				var directionOfThisDir = -1;  				if (probDir.X < cur.X) {  					directionOfThisDir = 0;  				} else if (probDir.Y < cur.Y) {  					directionOfThisDir = 1;  				} else if (probDir.X > cur.X) {  					directionOfThisDir = 2;  				} else if (probDir.Y > cur.Y) {  					directionOfThisDir = 3;  				}  				if (directionOfThisDir > lastBackTrackDir) {  					prev = cur;  					cur = probDir;  					foundSomething = true;  					backtracking = false;  					break;  				}  			}  		}  		if (!foundSomething) {  			callBack (x' y' PathFinderAction.RemovingJunction);  			quatro.Pop ();  			prev = cur;  			cur.X += previousDirectionX;  			cur.Y += previousDirectionY;  		}  	} else {  		prev = cur;  		cur = possibleDirections [0];  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (possibleDirectionsCount >= 2)//Make sure we don't start searching again in the direction we originally came from   {  	callBack (x' y' PathFinderAction.RefoundJunction);  	//Set the direction we backtracked from  	var lastBackTrackDir = -1;  	if (prev.X < cur.X) {  		lastBackTrackDir = 0;  	} else if (prev.Y < cur.Y) {  		lastBackTrackDir = 1;  	} else if (prev.X > cur.X) {  		lastBackTrackDir = 2;  	} else if (prev.Y > cur.Y) {  		lastBackTrackDir = 3;  	}  	var foundJunction = quatro.Peek ();  	int previousDirectionX = 0;  	int previousDirectionY = 0;  	switch (foundJunction) {  	case 0:  		previousDirectionY = -1;  		break;  	case 1:  		previousDirectionX = 1;  		break;  	case 2:  		previousDirectionY = 1;  		break;  	case 3:  		previousDirectionX = -1;  		break;  	}  	Boolean foundSomething = false;  	for (int i = 0; i < possibleDirectionsCount; i++) {  		var probDir = possibleDirections [i];  		if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  			var directionOfThisDir = -1;  			if (probDir.X < cur.X) {  				directionOfThisDir = 0;  			} else if (probDir.Y < cur.Y) {  				directionOfThisDir = 1;  			} else if (probDir.X > cur.X) {  				directionOfThisDir = 2;  			} else if (probDir.Y > cur.Y) {  				directionOfThisDir = 3;  			}  			if (directionOfThisDir > lastBackTrackDir) {  				prev = cur;  				cur = probDir;  				foundSomething = true;  				backtracking = false;  				break;  			}  		}  	}  	if (!foundSomething) {  		callBack (x' y' PathFinderAction.RemovingJunction);  		quatro.Pop ();  		prev = cur;  		cur.X += previousDirectionX;  		cur.Y += previousDirectionY;  	}  } else {  	prev = cur;  	cur = possibleDirections [0];  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X < cur.X) {  	lastBackTrackDir = 0;  } else if (prev.Y < cur.Y) {  	lastBackTrackDir = 1;  } else if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X < cur.X) {  	lastBackTrackDir = 0;  } else if (prev.Y < cur.Y) {  	lastBackTrackDir = 1;  } else if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.Y < cur.Y) {  	lastBackTrackDir = 1;  } else if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.Y < cur.Y) {  	lastBackTrackDir = 1;  } else if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.X > cur.X) {  	lastBackTrackDir = 2;  } else if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 2;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (prev.Y > cur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 3;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: switch (foundJunction) {  case 0:  	previousDirectionY = -1;  	break;  case 1:  	previousDirectionX = 1;  	break;  case 2:  	previousDirectionY = 1;  	break;  case 3:  	previousDirectionX = -1;  	break;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: switch (foundJunction) {  case 0:  	previousDirectionY = -1;  	break;  case 1:  	previousDirectionX = 1;  	break;  case 2:  	previousDirectionY = 1;  	break;  case 3:  	previousDirectionX = -1;  	break;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: for (int i = 0; i < possibleDirectionsCount; i++) {  	var probDir = possibleDirections [i];  	if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  		var directionOfThisDir = -1;  		if (probDir.X < cur.X) {  			directionOfThisDir = 0;  		} else if (probDir.Y < cur.Y) {  			directionOfThisDir = 1;  		} else if (probDir.X > cur.X) {  			directionOfThisDir = 2;  		} else if (probDir.Y > cur.Y) {  			directionOfThisDir = 3;  		}  		if (directionOfThisDir > lastBackTrackDir) {  			prev = cur;  			cur = probDir;  			foundSomething = true;  			backtracking = false;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: for (int i = 0; i < possibleDirectionsCount; i++) {  	var probDir = possibleDirections [i];  	if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  		var directionOfThisDir = -1;  		if (probDir.X < cur.X) {  			directionOfThisDir = 0;  		} else if (probDir.Y < cur.Y) {  			directionOfThisDir = 1;  		} else if (probDir.X > cur.X) {  			directionOfThisDir = 2;  		} else if (probDir.Y > cur.Y) {  			directionOfThisDir = 3;  		}  		if (directionOfThisDir > lastBackTrackDir) {  			prev = cur;  			cur = probDir;  			foundSomething = true;  			backtracking = false;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  	var directionOfThisDir = -1;  	if (probDir.X < cur.X) {  		directionOfThisDir = 0;  	} else if (probDir.Y < cur.Y) {  		directionOfThisDir = 1;  	} else if (probDir.X > cur.X) {  		directionOfThisDir = 2;  	} else if (probDir.Y > cur.Y) {  		directionOfThisDir = 3;  	}  	if (directionOfThisDir > lastBackTrackDir) {  		prev = cur;  		cur = probDir;  		foundSomething = true;  		backtracking = false;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X != x + previousDirectionX || probDir.Y != y + previousDirectionY) {  	var directionOfThisDir = -1;  	if (probDir.X < cur.X) {  		directionOfThisDir = 0;  	} else if (probDir.Y < cur.Y) {  		directionOfThisDir = 1;  	} else if (probDir.X > cur.X) {  		directionOfThisDir = 2;  	} else if (probDir.Y > cur.Y) {  		directionOfThisDir = 3;  	}  	if (directionOfThisDir > lastBackTrackDir) {  		prev = cur;  		cur = probDir;  		foundSomething = true;  		backtracking = false;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X < cur.X) {  	directionOfThisDir = 0;  } else if (probDir.Y < cur.Y) {  	directionOfThisDir = 1;  } else if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X < cur.X) {  	directionOfThisDir = 0;  } else if (probDir.Y < cur.Y) {  	directionOfThisDir = 1;  } else if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.Y < cur.Y) {  	directionOfThisDir = 1;  } else if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.Y < cur.Y) {  	directionOfThisDir = 1;  } else if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.X > cur.X) {  	directionOfThisDir = 2;  } else if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: directionOfThisDir = 2;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: if (probDir.Y > cur.Y) {  	directionOfThisDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following statement contains a magic number: directionOfThisDir = 3;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The following statement contains a magic number: return DeterminePathFromDirections (directions' new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirections,The following statement contains a magic number: return DeterminePathFromDirections (directions' new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternalWithCount,The following statement contains a magic number: foreach (var point in DeterminePathFromDirectionsInternal (directions' start' end' map)) {  	byte formulathing = (byte)((double)current / (double)maxCount * 255.0);  	current++;  	yield return new MazePointPos (point.X' point.Y' formulathing);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: while (true) {  	yield return cur;  	if (cur.X == end.X && cur.Y == end.Y) {  		//We found the path  		break;  	}  	int x = cur.X;  	int y = cur.Y;  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (possibleDirectionsCount == 1) {  		prev = cur;  		cur = possibleDirections [0];  	} else if (possibleDirectionsCount > 1) {  		int directionToGo = directions.InnerList [currentDirectionPos];  		currentDirectionPos--;  		prev = cur;  		switch (directionToGo) {  		case 0:  			cur.Y -= 1;  			break;  		case 1:  			cur.X += 1;  			break;  		case 2:  			cur.Y += 1;  			break;  		case 3:  			cur.X -= 1;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: while (true) {  	yield return cur;  	if (cur.X == end.X && cur.Y == end.Y) {  		//We found the path  		break;  	}  	int x = cur.X;  	int y = cur.Y;  	possibleDirectionsCount = 0;  	if ((prev.X != x - 1 || prev.Y != y) && x - 1 > 0 && map [x - 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x - 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y - 1) && y - 1 > 0 && map [x' y - 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y - 1;  		possibleDirectionsCount++;  	}  	if ((prev.X != x + 1 || prev.Y != y) && x + 1 < width - 1 && map [x + 1' y]) {  		possibleDirections [possibleDirectionsCount].X = x + 1;  		possibleDirections [possibleDirectionsCount].Y = y;  		possibleDirectionsCount++;  	}  	if ((prev.X != x || prev.Y != y + 1) && y + 1 < height - 1 && map [x' y + 1]) {  		possibleDirections [possibleDirectionsCount].X = x;  		possibleDirections [possibleDirectionsCount].Y = y + 1;  		possibleDirectionsCount++;  	}  	if (possibleDirectionsCount == 1) {  		prev = cur;  		cur = possibleDirections [0];  	} else if (possibleDirectionsCount > 1) {  		int directionToGo = directions.InnerList [currentDirectionPos];  		currentDirectionPos--;  		prev = cur;  		switch (directionToGo) {  		case 0:  			cur.Y -= 1;  			break;  		case 1:  			cur.X += 1;  			break;  		case 2:  			cur.Y += 1;  			break;  		case 3:  			cur.X -= 1;  			break;  		}  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: if (possibleDirectionsCount == 1) {  	prev = cur;  	cur = possibleDirections [0];  } else if (possibleDirectionsCount > 1) {  	int directionToGo = directions.InnerList [currentDirectionPos];  	currentDirectionPos--;  	prev = cur;  	switch (directionToGo) {  	case 0:  		cur.Y -= 1;  		break;  	case 1:  		cur.X += 1;  		break;  	case 2:  		cur.Y += 1;  		break;  	case 3:  		cur.X -= 1;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: if (possibleDirectionsCount == 1) {  	prev = cur;  	cur = possibleDirections [0];  } else if (possibleDirectionsCount > 1) {  	int directionToGo = directions.InnerList [currentDirectionPos];  	currentDirectionPos--;  	prev = cur;  	switch (directionToGo) {  	case 0:  		cur.Y -= 1;  		break;  	case 1:  		cur.X += 1;  		break;  	case 2:  		cur.Y += 1;  		break;  	case 3:  		cur.X -= 1;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: if (possibleDirectionsCount > 1) {  	int directionToGo = directions.InnerList [currentDirectionPos];  	currentDirectionPos--;  	prev = cur;  	switch (directionToGo) {  	case 0:  		cur.Y -= 1;  		break;  	case 1:  		cur.X += 1;  		break;  	case 2:  		cur.Y += 1;  		break;  	case 3:  		cur.X -= 1;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: if (possibleDirectionsCount > 1) {  	int directionToGo = directions.InnerList [currentDirectionPos];  	currentDirectionPos--;  	prev = cur;  	switch (directionToGo) {  	case 0:  		cur.Y -= 1;  		break;  	case 1:  		cur.X += 1;  		break;  	case 2:  		cur.Y += 1;  		break;  	case 3:  		cur.X -= 1;  		break;  	}  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: switch (directionToGo) {  case 0:  	cur.Y -= 1;  	break;  case 1:  	cur.X += 1;  	break;  case 2:  	cur.Y += 1;  	break;  case 3:  	cur.X -= 1;  	break;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following statement contains a magic number: switch (directionToGo) {  case 0:  	cur.Y -= 1;  	break;  case 1:  	cur.X += 1;  	break;  case 2:  	cur.Y += 1;  	break;  case 3:  	cur.X -= 1;  	break;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePointPos target = new MazePointPos (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePointPos (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePointPos (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePointPos (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePointPos (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePointPos (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePointPos target = new MazePointPos (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePointPos (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePointPos (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePointPos (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePointPos (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePointPos (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePointPos target = new MazePointPos (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePointPos (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePointPos (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePointPos (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePointPos (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePointPos (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePointPos target = new MazePointPos (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePointPos (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePointPos (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePointPos (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePointPos (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePointPos (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePointPos target = new MazePointPos (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePointPos (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePointPos (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePointPos (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePointPos (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePointPos (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePointPos (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePointPos (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePointPos (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePointPos (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePointPos (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePointPos (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePointPos (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePointPos (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePointPos (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (stackje.Count == 1) {  	prev = new MazePointPos (-1' -1);  } else {  	prev = stackje.ElementAt (stackje.Count - 2);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: prev = stackje.ElementAt (stackje.Count - 2);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.X > newcur.X) {  	lastBackTrackDir = 0;  } else if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.X > newcur.X) {  	lastBackTrackDir = 0;  } else if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 2;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 3;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartWithPos,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartWithPos.cs,GoFind,The following statement contains a magic number: for (int i = 0; i < stackje.Count; i++) {  	byte formulathing = (byte)((double)i / (double)stackje.Count * 255.0);  	var currentStackjeThing = stackje [i];  	stackje [i] = new MazePointPos (currentStackjeThing.X' currentStackjeThing.Y' formulathing);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePoint target = new MazePoint (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePoint (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePoint (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePoint (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePoint (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePoint (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePoint target = new MazePoint (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePoint (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePoint (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePoint (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePoint (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePoint (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePoint target = new MazePoint (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePoint (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePoint (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePoint (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePoint (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePoint (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePoint target = new MazePoint (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePoint (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePoint (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePoint (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePoint (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePoint (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: while (stackje.Count != 0) {  	cur = stackje [stackje.Count - 1];  	var x = cur.X;  	var y = cur.Y;  	MazePoint target = new MazePoint (-1' -1);  	//Make sure the point was not the previous point' also make sure that if we backtracked we don't go to a direction we already went to' also make sure that the point is white  	if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  		target = new MazePoint (x + 1' y);  	} else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  		target = new MazePoint (x' y + 1);  	} else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  		target = new MazePoint (x - 1' y);  	} else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  		target = new MazePoint (x' y - 1);  	} else {  		var prepoppy = stackje [stackje.Count - 1];  		stackje.RemoveAt (stackje.Count - 1);  		if (stackje.Count == 0) {  			//No path found  			break;  		}  		var newcur = stackje [stackje.Count - 1];  		//Set the new previous point  		if (stackje.Count == 1) {  			prev = new MazePoint (-1' -1);  		} else {  			prev = stackje.ElementAt (stackje.Count - 2);  		}  		//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  		//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  		callBack.Invoke (prepoppy.X' prepoppy.Y' false);  		//Set the direction we backtracked from  		if (prepoppy.X > newcur.X) {  			lastBackTrackDir = 0;  		} else if (prepoppy.Y > newcur.Y) {  			lastBackTrackDir = 1;  		} else if (prepoppy.X < newcur.X) {  			lastBackTrackDir = 2;  		} else if (prepoppy.Y < newcur.Y) {  			lastBackTrackDir = 3;  		}  		//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  		continue;  	}  	lastBackTrackDir = -1;  	//Console.WriteLine("Going to X: " + target.X + " Y: " + target.Y);  	callBack.Invoke (x' y' true);  	stackje.Add (target);  	if (target.X == end.X && target.Y == end.Y) {  		//Path found  		break;  	}  	prev = cur;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePoint (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePoint (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePoint (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePoint (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x + 1 || prev.Y != y) && lastBackTrackDir < 0 && x + 1 < width - 1 && map [x + 1' y]) {  	target = new MazePoint (x + 1' y);  } else if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y + 1) && lastBackTrackDir < 1 && y + 1 < height - 1 && map [x' y + 1]) {  	target = new MazePoint (x' y + 1);  } else if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x - 1 || prev.Y != y) && lastBackTrackDir < 2 && x - 1 > 0 && map [x - 1' y]) {  	target = new MazePoint (x - 1' y);  } else if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if ((prev.X != x || prev.Y != y - 1) && lastBackTrackDir < 3 && y - 1 > 0 && map [x' y - 1]) {  	target = new MazePoint (x' y - 1);  } else {  	var prepoppy = stackje [stackje.Count - 1];  	stackje.RemoveAt (stackje.Count - 1);  	if (stackje.Count == 0) {  		//No path found  		break;  	}  	var newcur = stackje [stackje.Count - 1];  	//Set the new previous point  	if (stackje.Count == 1) {  		prev = new MazePoint (-1' -1);  	} else {  		prev = stackje.ElementAt (stackje.Count - 2);  	}  	//Console.WriteLine("Backtracking to X: " + newcur.X + " Y: " + newcur.Y);  	//Console.WriteLine("Setting new prev: " + prev.X + " Y: " + prev.Y);  	callBack.Invoke (prepoppy.X' prepoppy.Y' false);  	//Set the direction we backtracked from  	if (prepoppy.X > newcur.X) {  		lastBackTrackDir = 0;  	} else if (prepoppy.Y > newcur.Y) {  		lastBackTrackDir = 1;  	} else if (prepoppy.X < newcur.X) {  		lastBackTrackDir = 2;  	} else if (prepoppy.Y < newcur.Y) {  		lastBackTrackDir = 3;  	}  	//Console.WriteLine("Lastbacktrackdir: " + lastBackTrackDir);  	continue;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (stackje.Count == 1) {  	prev = new MazePoint (-1' -1);  } else {  	prev = stackje.ElementAt (stackje.Count - 2);  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: prev = stackje.ElementAt (stackje.Count - 2);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.X > newcur.X) {  	lastBackTrackDir = 0;  } else if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.X > newcur.X) {  	lastBackTrackDir = 0;  } else if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y > newcur.Y) {  	lastBackTrackDir = 1;  } else if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.X < newcur.X) {  	lastBackTrackDir = 2;  } else if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 2;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: if (prepoppy.Y < newcur.Y) {  	lastBackTrackDir = 3;  }  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmart,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmart.cs,GoFind,The following statement contains a magic number: lastBackTrackDir = 3;  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirst,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirst.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Magic Number,DeveMazeGenerator.PathFinders,PathFinderDepthFirst,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirst.cs,GoFind,The following statement contains a magic number: return GoFind (new MazePoint (1' 1)' new MazePoint (map.Width - 3' map.Height - 3)' map' callBack);  
Duplicate Code,DeveMazeGenerator.Generators,AlgorithmBacktrackSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\Generators\AlgorithmBacktrackSmartMemory.cs,GoGenerate,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 70)' (117' 140))
Missing Default,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,GoFind,The following switch statement is missing a default case: switch (foundJunction) {  case 0:  	previousDirectionY = -1;  	break;  case 1:  	previousDirectionX = 1;  	break;  case 2:  	previousDirectionY = 1;  	break;  case 3:  	previousDirectionX = -1;  	break;  }  
Missing Default,DeveMazeGenerator.PathFinders,PathFinderDepthFirstSmartAndSmartMemory,F:\newReposMay17\devedse_DeveMazeGenerator\DeveMazeGenerator\PathFinders\PathFinderDepthFirstSmartAndSmartMemory.cs,DeterminePathFromDirectionsInternal,The following switch statement is missing a default case: switch (directionToGo) {  case 0:  	cur.Y -= 1;  	break;  case 1:  	cur.X += 1;  	break;  case 2:  	cur.Y += 1;  	break;  case 3:  	cur.X -= 1;  	break;  }  
