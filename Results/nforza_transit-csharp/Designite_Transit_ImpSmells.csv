Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Beerendonk.Transit.Impl,IEmitter,C:\repos\nforza_transit-csharp\src\Transit\Impl\IEmitter.cs,EmitString,The method has 5 parameters. Parameters: prefix' tag' s' asDictionaryKey' cache
Long Parameter List,Beerendonk.Transit.Impl,JsonVerboseEmitter,C:\repos\nforza_transit-csharp\src\Transit\Impl\JsonVerboseEmitter.cs,EmitString,The method has 5 parameters. Parameters: prefix' tag' s' asDictionaryKey' cache
Long Parameter List,Beerendonk.Transit.Impl,JsonEmitter,C:\repos\nforza_transit-csharp\src\Transit\Impl\JsonEmitter.cs,EmitString,The method has 5 parameters. Parameters: prefix' tag' s' asDictionaryKey' cache
Long Parameter List,Beerendonk.Transit.Impl,AbstractEmitter,C:\repos\nforza_transit-csharp\src\Transit\Impl\AbstractEmitter.cs,EmitEncoded,The method has 5 parameters. Parameters: t' handler' obj' asDictionaryKey' cache
Long Parameter List,Beerendonk.Transit.Impl,AbstractEmitter,C:\repos\nforza_transit-csharp\src\Transit\Impl\AbstractEmitter.cs,EmitString,The method has 5 parameters. Parameters: prefix' tag' s' asDictionaryKey' cache
Long Parameter List,Beerendonk.Transit.Impl,JsonParser,C:\repos\nforza_transit-csharp\src\Transit\Impl\JsonParser.cs,JsonParser,The method has 5 parameters. Parameters: jsonTextReader' handlers' defaultHandler' dictionaryBuilder' listBuilder
Long Parameter List,Beerendonk.Transit.Impl,Link,C:\repos\nforza_transit-csharp\src\Transit\Impl\Link.cs,Link,The method has 5 parameters. Parameters: href' rel' name' render' prompt
Long Parameter List,Beerendonk.Transit,TransitFactory,C:\repos\nforza_transit-csharp\src\Transit\TransitFactory.cs,Link,The method has 5 parameters. Parameters: href' rel' name' prompt' render
Long Parameter List,Beerendonk.Transit,TransitFactory,C:\repos\nforza_transit-csharp\src\Transit\TransitFactory.cs,Link,The method has 5 parameters. Parameters: href' rel' name' prompt' render
Long Parameter List,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The method has 5 parameters. Parameters: dbl' sign' exp' man' isFinite
Long Statement,Beerendonk.Transit.Impl,JsonParser,C:\repos\nforza_transit-csharp\src\Transit\Impl\JsonParser.cs,ParseLong,The length of the statement  "            // TODO Use BigInteger just in case (write test' see for example TestReadBooleanDictionary where short numbers are used): " is 121.
Complex Conditional,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The conditional expression  "bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16)"  is complex.
Magic Number,Beerendonk.Transit.Impl,Keyword,C:\repos\nforza_transit-csharp\src\Transit\Impl\Keyword.cs,GetHashCode,The following statement contains a magic number: return 17 * Value.GetHashCode();
Magic Number,Beerendonk.Transit.Impl,Symbol,C:\repos\nforza_transit-csharp\src\Transit\Impl\Symbol.cs,GetHashCode,The following statement contains a magic number: return 19 * Value.GetHashCode();
Magic Number,Beerendonk.Transit.Impl,AbstractParser,C:\repos\nforza_transit-csharp\src\Transit\Impl\AbstractParser.cs,ParseString,The following statement contains a magic number: if (obj is string)              {                  string s = (string)obj;                  if (s.Length > 1)                  {                      switch (s[0])                      {                          case Constants.Esc:                              switch (s[1])                              {                                  case Constants.Esc:                                  case Constants.Sub:                                  case Constants.Reserved:                                      return s.Substring(1);                                  case Constants.Tag:                                      return new Tag(s.Substring(2));                                  default:                                      {                                          string tag = s.Substring(1' 1);                                          string representation = s.Length > 2 ? s.Substring(2) : string.Empty;                                          return Decode(tag' representation);                                      }                              }                          case Constants.Sub:                              if (s[1] == ' ')                              {                                  return Constants.DirectoryAsList;                              }                              break;                      }                  }              }
Magic Number,Beerendonk.Transit.Impl,AbstractParser,C:\repos\nforza_transit-csharp\src\Transit\Impl\AbstractParser.cs,ParseString,The following statement contains a magic number: if (obj is string)              {                  string s = (string)obj;                  if (s.Length > 1)                  {                      switch (s[0])                      {                          case Constants.Esc:                              switch (s[1])                              {                                  case Constants.Esc:                                  case Constants.Sub:                                  case Constants.Reserved:                                      return s.Substring(1);                                  case Constants.Tag:                                      return new Tag(s.Substring(2));                                  default:                                      {                                          string tag = s.Substring(1' 1);                                          string representation = s.Length > 2 ? s.Substring(2) : string.Empty;                                          return Decode(tag' representation);                                      }                              }                          case Constants.Sub:                              if (s[1] == ' ')                              {                                  return Constants.DirectoryAsList;                              }                              break;                      }                  }              }
Magic Number,Beerendonk.Transit.Impl,AbstractParser,C:\repos\nforza_transit-csharp\src\Transit\Impl\AbstractParser.cs,ParseString,The following statement contains a magic number: if (obj is string)              {                  string s = (string)obj;                  if (s.Length > 1)                  {                      switch (s[0])                      {                          case Constants.Esc:                              switch (s[1])                              {                                  case Constants.Esc:                                  case Constants.Sub:                                  case Constants.Reserved:                                      return s.Substring(1);                                  case Constants.Tag:                                      return new Tag(s.Substring(2));                                  default:                                      {                                          string tag = s.Substring(1' 1);                                          string representation = s.Length > 2 ? s.Substring(2) : string.Empty;                                          return Decode(tag' representation);                                      }                              }                          case Constants.Sub:                              if (s[1] == ' ')                              {                                  return Constants.DirectoryAsList;                              }                              break;                      }                  }              }
Magic Number,Beerendonk.Transit.Impl,ReadCache,C:\repos\nforza_transit-csharp\src\Transit\Impl\ReadCache.cs,CodeToIndex,The following statement contains a magic number: if (sz == 2)              {                  return ((int)s[1] - WriteCache.BaseCharIdx);              }              else              {                  return (((int)s[1] - WriteCache.BaseCharIdx) * WriteCache.CacheCodeDigits) +                          ((int)s[2] - WriteCache.BaseCharIdx);              }
Magic Number,Beerendonk.Transit.Impl,ReadCache,C:\repos\nforza_transit-csharp\src\Transit\Impl\ReadCache.cs,CodeToIndex,The following statement contains a magic number: if (sz == 2)              {                  return ((int)s[1] - WriteCache.BaseCharIdx);              }              else              {                  return (((int)s[1] - WriteCache.BaseCharIdx) * WriteCache.CacheCodeDigits) +                          ((int)s[2] - WriteCache.BaseCharIdx);              }
Magic Number,Beerendonk.Transit.Impl,TaggedValue,C:\repos\nforza_transit-csharp\src\Transit\Impl\TaggedValue.cs,GetHashCode,The following statement contains a magic number: int result = 17;
Magic Number,Beerendonk.Transit.Impl,TaggedValue,C:\repos\nforza_transit-csharp\src\Transit\Impl\TaggedValue.cs,GetHashCode,The following statement contains a magic number: result = 31 * result * tag.GetHashCode();
Magic Number,Beerendonk.Transit.Impl,TaggedValue,C:\repos\nforza_transit-csharp\src\Transit\Impl\TaggedValue.cs,GetHashCode,The following statement contains a magic number: result = 31 * result * representation.GetHashCode();
Magic Number,Beerendonk.Transit.Impl.WriteHandlers,RatioWriteHandler,C:\repos\nforza_transit-csharp\src\Transit\Impl\WriteHandlers\RatioWriteHandler.cs,Representation,The following statement contains a magic number: BigInteger[] l = new BigInteger[2];
Magic Number,Beerendonk.Transit.Impl.WriteHandlers,GuidWriteHandler,C:\repos\nforza_transit-csharp\src\Transit\Impl\WriteHandlers\GuidWriteHandler.cs,Representation,The following statement contains a magic number: long[] l = new long[2];
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_denominator = 1 << 52;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16))              {                  throw new ArgumentException("invalid Decimal"' "value");              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16))              {                  throw new ArgumentException("invalid Decimal"' "value");              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16))              {                  throw new ArgumentException("invalid Decimal"' "value");              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16))              {                  throw new ArgumentException("invalid Decimal"' "value");              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: if (bits == null || bits.Length != 4 || (bits[3] & ~(DecimalSignMask | DecimalScaleMask)) != 0 || (bits[3] & DecimalScaleMask) > (28 << 16))              {                  throw new ArgumentException("invalid Decimal"' "value");              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: ulong ul = (((ulong)(uint)bits[2]) << 32) | ((ulong)(uint)bits[1]);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: ulong ul = (((ulong)(uint)bits[2]) << 32) | ((ulong)(uint)bits[1]);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_numerator = (new BigInteger(ul) << 32) | (uint)bits[0];
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: bool isNegative = (bits[3] & DecimalSignMask) != 0;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: int scale = (bits[3] & DecimalScaleMask) >> 16;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: int scale = (bits[3] & DecimalScaleMask) >> 16;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,BigRational,The following statement contains a magic number: m_denominator = BigInteger.Pow(10' scale);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: exp = (int)(du.uu >> 52) & 0x7FF;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  isFinite = true;                  if (man != 0)                      exp = -1074;              }              else if (exp == 0x7FF)              {                  // NaN or Infinite.                  isFinite = false;                  exp = Int32.MaxValue;              }              else              {                  isFinite = true;                  man |= 0x0010000000000000; // mask in the implied leading 53rd significand bit                  exp -= 1075;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,SplitDoubleIntoParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  isFinite = true;                  if (man != 0)                      exp = -1074;              }              else if (exp == 0x7FF)              {                  // NaN or Infinite.                  isFinite = false;                  exp = Int32.MaxValue;              }              else              {                  isFinite = true;                  man |= 0x0010000000000000; // mask in the implied leading 53rd significand bit                  exp -= 1075;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023)                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized                      exp--;                      if (exp < -52)                      {                          // Underflow to zero                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023)                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized                      exp--;                      if (exp < -52)                      {                          // Underflow to zero                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023)                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized                      exp--;                      if (exp < -52)                      {                          // Underflow to zero                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023)                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized                      exp--;                      if (exp < -52)                      {                          // Underflow to zero                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((uu & 0xFFFFFFFF00000000) == 0)                  return 32 + CbitHighZero((uint)uu);
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero((uint)(uu >> 32));
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if (u == 0)                  return 32;
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,Beerendonk.Transit.Numerics,BigRational,C:\repos\nforza_transit-csharp\src\Transit\Numerics\BigRational.cs,TryParse,The following statement contains a magic number: if (DigitDotDigit.IsMatch(parse))              {                  int toSubtract;                  bool isNegative = false;                  string[] parts = parse.TrimStart('+').Split('.');                  parts[1] = parts[1].TrimEnd('0');                  if (parts[0].StartsWith("-"))                  {                      isNegative = true;                      parts[0] = parts[0].Substring(1);                  }                    BigRational whole = new BigRational(BigInteger.Parse(parts[0])' BigInteger.Zero' BigInteger.One);                  BigRational decimalPart = new BigRational(BigInteger.Parse(parts[1])' BigInteger.Zero' BigInteger.One);                  toSubtract = parts[1].Length;                  while (toSubtract != 0)                  {                      decimalPart /= 10;                      toSubtract = toSubtract - 1;                  }                    result = whole + decimalPart;                  if (isNegative)                  {                      result = -result;                  }                    return true;              }              else if (DotDigit.IsMatch(parse))              {                  return TryParse("0" + parse' out result);              }              else if (PlainDigit.IsMatch(parse))              {                  parse = parse.TrimStart('+');                  if (parse.StartsWith("-"))                  {                      result = new BigRational(-BigInteger.Parse(parse)' BigInteger.Zero' BigInteger.One);                      return true;                  }                    result = new BigRational(BigInteger.Parse(parse)' BigInteger.Zero' BigInteger.One);                  return true;              }              else if (DigitSlashDigit.IsMatch(parse))              {                  string[] parts = parse.TrimStart('+').Split('/');                  if (parts[0].StartsWith("-"))                  {                      parts[0] = parts[0].Substring(1);                      result = -(new BigRational(BigInteger.Parse(parts[0])' BigInteger.Parse(parts[1])));                      return true;                  }                    result = new BigRational(BigInteger.Parse(parts[0])' BigInteger.Parse(parts[1]));                  return true;              }
