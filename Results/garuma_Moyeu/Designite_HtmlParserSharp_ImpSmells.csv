Implementation smell,Namespace,Class,File,Method,Description
Long Method,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,IsNCNameStart,The method has 161 lines of code.
Long Method,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,IsNCNameTrail,The method has 250 lines of code.
Long Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method has 5351 lines of code.
Long Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,HandleNcrValue,The method has 104 lines of code.
Long Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The method has 604 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The method has 249 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The method has 413 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Eof,The method has 183 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The method has 1636 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,ExtractCharsetFromContent,The method has 174 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The method has 886 lines of code.
Long Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,AdoptionAgencyEndTag,The method has 184 lines of code.
Complex Method,HtmlParserSharp,Parser,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Parser.cs,Tokenize,Cyclomatic complexity of the method is 11
Complex Method,HtmlParserSharp,SimpleHtmlParser,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\SimpleHtmlParser.cs,Tokenize,Cyclomatic complexity of the method is 11
Complex Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,EndTagExpectationToArray,Cyclomatic complexity of the method is 11
Complex Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,AddAttributeWithoutValue,Cyclomatic complexity of the method is 8
Complex Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,HandleNcrValue,Cyclomatic complexity of the method is 15
Complex Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,Cyclomatic complexity of the method is 45
Complex Method,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,LoadState,Cyclomatic complexity of the method is 9
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,Cyclomatic complexity of the method is 30
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,Cyclomatic complexity of the method is 48
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Eof,Cyclomatic complexity of the method is 27
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,Cyclomatic complexity of the method is 211
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,ExtractCharsetFromContent,Cyclomatic complexity of the method is 30
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,Cyclomatic complexity of the method is 149
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,IsQuirky,Cyclomatic complexity of the method is 11
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,ResetTheInsertionMode,Cyclomatic complexity of the method is 18
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,AdoptionAgencyEndTag,Cyclomatic complexity of the method is 21
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,ReconstructTheActiveFormattingElements,Cyclomatic complexity of the method is 9
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,Cyclomatic complexity of the method is 11
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,SnapshotMatches,Cyclomatic complexity of the method is 8
Complex Method,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,LoadState,Cyclomatic complexity of the method is 10
Long Parameter List,HtmlParserSharp.Core,StackNode<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\StackNode.cs,StackNode,The method has 7 parameters. Parameters: flags' ns' name' node' popName' attributes' locator
Long Parameter List,HtmlParserSharp.Core,StackNode<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\StackNode.cs,StackNode,The method has 5 parameters. Parameters: elementName' node' popName' markAsIntegrationPoint' locator
Long Parameter List,HtmlParserSharp.Core,StateSnapshot<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\StateSnapshot.cs,StateSnapshot,The method has 10 parameters. Parameters: stack' listOfActiveFormattingElements' formPointer' headPointer' deepTreeSurrogateParent' mode' originalMode' framesetOk' needToDropLF' quirks
Long Parameter List,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method has 7 parameters. Parameters: state' c' pos' buf' reconsume' returnState' endPos
Long Identifier,HtmlParserSharp,XmlTreeBuilder,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\TreeBuilders\XmlTreeBuilder.cs,ReceiveDocumentMode,The length of the parameter html4SpecificAdditionalErrorChecks is 34.
Long Identifier,HtmlParserSharp.Common,DocumentModeEventArgs,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Common\DocumentModeEventArgs.cs,DocumentModeEventArgs,The length of the parameter html4SpecificAdditionalErrorChecks is 34.
Long Identifier,HtmlParserSharp.Core,StateSnapshot<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\StateSnapshot.cs,StateSnapshot,The length of the parameter listOfActiveFormattingElements is 30.
Long Identifier,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,,The length of the parameter html4ModeCompatibleWithXhtml1Schemata is 37.
Long Identifier,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,DocumentModeInternal,The length of the parameter html4SpecificAdditionalErrorChecks is 34.
Long Identifier,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,ReceiveDocumentMode,The length of the parameter html4SpecificAdditionalErrorChecks is 34.
Long Identifier,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,,The length of the parameter listOfActiveFormattingElements is 30.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "									Err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 140.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "									Err("Almost standards mode doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 155.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 218.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "										Err("The doctype was not the HTML 4.01 Strict doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 174.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "									Err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 152.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 230.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "										Err("The doctype was not a non-quirky HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 201.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "									Err("The doctype was not the HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 192.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 230.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The length of the statement  "											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 218.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The length of the statement  "												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 183.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The length of the statement  "												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 195.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Eof,The length of the statement  "								Err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 173.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Eof,The length of the statement  "								Err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 185.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "										Err("Saw a \u201Cform\u201D start tag' but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");" is 147.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "								case DispatchGroup.ADDRESS_OR_ARTICLE_OR_ASIDE_OR_DETAILS_OR_DIR_OR_FIGCAPTION_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_HGROUP_OR_NAV_OR_SECTION_OR_SUMMARY:" is 148.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "										Err("Saw a \u201Cform\u201D start tag' but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");" is 147.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "								Err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 171.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "								Err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 183.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The length of the statement  "                    Err("Self-closing syntax (\u201C/>\u201D) used on a non-void HTML element. Ignoring the slash and treating as a start tag."); " is 125.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The length of the statement  "							case DispatchGroup.ADDRESS_OR_ARTICLE_OR_ASIDE_OR_DETAILS_OR_DIR_OR_FIGCAPTION_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_HGROUP_OR_NAV_OR_SECTION_OR_SUMMARY:" is 148.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The length of the statement  "								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");" is 169.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The length of the statement  "								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");" is 181.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,The length of the statement  "									Warn("Attribute \u201Cxmlns:xlink\u201D with a value other than \u201Chttp://www.w3.org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");" is 175.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,The length of the statement  "									Fatal("Attribute \u201Cxmlns:xlink\u201D with a value other than \u201Chttp://www.w3.org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");" is 176.
Long Statement,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,NewSnapshot,The length of the statement  "			return new StateSnapshot<T>(stackCopy' listCopy' formPointer' headPointer' deepTreeSurrogateParent' mode' originalMode' framesetOk' needToDropLF' quirks);" is 154.
Complex Conditional,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,AddAttributeWithValue,The conditional expression  "!endTag && html4 && html4ModeCompatibleWithXhtml1Schemata 						&& attributeName.IsCaseFolded"  is complex.
Complex Conditional,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The conditional expression  "ch == '=' || (ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')"  is complex.
Complex Conditional,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,HandleNcrValue,The conditional expression  "(value <= 0x0008) || (value == 0x000B) 						  || (value >= 0x000E && value <= 0x001F)"  is complex.
Complex Conditional,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The conditional expression  "(ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTokenization,The conditional expression  ""style" == contextName || "xmp" == contextName 					  || "iframe" == contextName || "noembed" == contextName 					  || "noframes" == contextName 					  || (IsScriptingEnabled && "noscript" == contextName)"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The conditional expression  "("-//W3C//DTD HTML 4.0//EN" == publicIdentifier && 										(systemIdentifier == null || "http://www.w3.org/TR/REC-html40/strict.dtd" == systemIdentifier)) 											|| ("-//W3C//DTD HTML 4.01//EN" == publicIdentifier && 												(systemIdentifier == null || "http://www.w3.org/TR/html4/strict.dtd" == systemIdentifier)) 											|| ("-//W3C//DTD XHTML 1.0 Strict//EN" == publicIdentifier && 													"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" == systemIdentifier) 											|| ("-//W3C//DTD XHTML 1.1//EN" == publicIdentifier && 													"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" == systemIdentifier)"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The conditional expression  "!(currentNode.IsHtmlIntegrationPoint || (currNs == "http://www.w3.org/1998/Math/MathML" && 						((currentNode.Group == DispatchGroup.MI_MO_MN_MS_MTEXT && group != DispatchGroup.MGLYPH_OR_MALIGNMARK) || 						(currentNode.Group == DispatchGroup.ANNOTATION_XML && group == DispatchGroup.SVG))))"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The conditional expression  "node.IsScoping 											  || (node.IsSpecial 													  && node.name != "p" 													  && node.name != "address" && node.name != "div")"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,FlushCharacters,The conditional expression  "(mode == InsertionMode.IN_TABLE || mode == InsertionMode.IN_TABLE_BODY || mode == InsertionMode.IN_ROW) 						&& CharBufferContainsNonWhitespace()"  is complex.
Complex Conditional,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,SnapshotMatches,The conditional expression  "stackLen != currentPtr + 1 					|| listLen != listPtr + 1 					|| formPointer != snapshot.FormPointer 					|| headPointer != snapshot.HeadPointer 					|| deepTreeSurrogateParent != snapshot.DeepTreeSurrogateParent 					|| mode != snapshot.Mode 					|| originalMode != snapshot.OriginalMode 					|| framesetOk != snapshot.IsFramesetOk 					|| needToDropLF != snapshot.IsNeedToDropLF 					|| quirks != snapshot.IsQuirks"  is complex.
Magic Number,HtmlParserSharp,Parser,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Parser.cs,Tokenize,The following statement contains a magic number: char[] buffer = new char[2048];
Magic Number,HtmlParserSharp,SimpleHtmlParser,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\SimpleHtmlParser.cs,Tokenize,The following statement contains a magic number: char[] buffer = new char[2048];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,COMPUTE_QNAME,The following statement contains a magic number: string[] arr = new string[4];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SVG_DIFFERENT,The following statement contains a magic number: string[] arr = new string[4];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SVG_DIFFERENT,The following statement contains a magic number: arr[2] = camel;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SVG_DIFFERENT,The following statement contains a magic number: arr[3] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,MATH_DIFFERENT,The following statement contains a magic number: string[] arr = new string[4];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,MATH_DIFFERENT,The following statement contains a magic number: arr[2] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,MATH_DIFFERENT,The following statement contains a magic number: arr[3] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,COLONIFIED_LOCAL,The following statement contains a magic number: string[] arr = new string[4];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,COLONIFIED_LOCAL,The following statement contains a magic number: arr[2] = suffix;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,COLONIFIED_LOCAL,The following statement contains a magic number: arr[3] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SAME_LOCAL,The following statement contains a magic number: string[] arr = new string[4];
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SAME_LOCAL,The following statement contains a magic number: arr[2] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,SAME_LOCAL,The following statement contains a magic number: arr[3] = name;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,BufToHash,The following statement contains a magic number: hash <<= 5;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,BufToHash,The following statement contains a magic number: hash <<= 5;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,BufToHash,The following statement contains a magic number: hash2 <<= 6;
Magic Number,HtmlParserSharp.Core,AttributeName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\AttributeName.cs,BufToHash,The following statement contains a magic number: i < 4 && j > 0
Magic Number,HtmlParserSharp.Core,ElementName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\ElementName.cs,BufToHash,The following statement contains a magic number: hash <<= 5;
Magic Number,HtmlParserSharp.Core,ElementName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\ElementName.cs,BufToHash,The following statement contains a magic number: hash <<= 5;
Magic Number,HtmlParserSharp.Core,ElementName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\ElementName.cs,BufToHash,The following statement contains a magic number: i < 4 && j > 0
Magic Number,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,HtmlAttributes,The following statement contains a magic number: this.names = new AttributeName[5];
Magic Number,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,HtmlAttributes,The following statement contains a magic number: this.values = new string[5];
Magic Number,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,AddAttribute,The following statement contains a magic number: int newLen = xmlnsLength == 0 ? 2 : xmlnsLength << 1;
Magic Number,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,CloneAttributes,The following statement contains a magic number: Debug.Assert((length == 0 && xmlnsLength == 0) || mode == 0 || mode == 3);
Magic Number,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,Equals,The following statement contains a magic number: Debug.Assert(mode == 0 || mode == 3' "Trying to compare attributes in foreign content.");
Magic Number,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,AppendUHexTo,The following statement contains a magic number: sb.Append(HEX_TABLE[(c & 0xF00000) >> 20]);
Magic Number,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,AppendUHexTo,The following statement contains a magic number: c <<= 4;
Magic Number,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,AppendUHexTo,The following statement contains a magic number: i < 6
Magic Number,HtmlParserSharp.Core,NCName,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\NCName.cs,EscapeName,The following statement contains a magic number: AppendUHexTo(sb' (c << 10) + next + SURROGATE_OFFSET);
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Tokenizer,The following statement contains a magic number: this.astralChar = new char[2];
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Tokenizer,The following statement contains a magic number: this.astralChar = new char[2];
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,Eof,The following statement contains a magic number: switch (state) 				{ 					case TokenizerState.SCRIPT_DATA_LESS_THAN_SIGN: 					case TokenizerState.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: 						/* 						 * Otherwise' emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_OPEN: 						/* 						 * The behavior of this state depends on the content model 						 * flag. 						 */ 						/* 						 * Anything else Parse error. 						 */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the data 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.RAWTEXT_RCDATA_LESS_THAN_SIGN: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token 						 */ 						TokenHandler.Characters(LT_GT' 0' 1); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.NON_DATA_END_TAG_NAME: 						/* 						 * Emit a U+003C LESS-THAN SIGN character token' a U+002F 						 * SOLIDUS character token' 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * a character token for each of the characters in the 						 * temporary buffer (in the order they were added to the 						 * buffer)' 						 */ 						EmitStrBuf(); 						/* 						 * and reconsume the current input character in the RCDATA 						 * state. 						 */ 						goto breakEofloop; 					case TokenizerState.CLOSE_TAG_OPEN: 						/* EOF Parse error. */ 						ErrEofAfterLt(); 						/* 						 * Emit a U+003C LESS-THAN SIGN character token and a U+002F 						 * SOLIDUS character token. 						 */ 						TokenHandler.Characters(LT_SOLIDUS' 0' 2); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.TAG_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInTagName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BEFORE_ATTRIBUTE_NAME: 					case TokenizerState.AFTER_ATTRIBUTE_VALUE_QUOTED: 					case TokenizerState.SELF_CLOSING_START_TAG: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_NAME: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInAttributeName(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_ATTRIBUTE_NAME: 					case TokenizerState.BEFORE_ATTRIBUTE_VALUE: 						/* EOF Parse error. */ 						ErrEofWithoutGt(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.ATTRIBUTE_VALUE_DOUBLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_SINGLE_QUOTED: 					case TokenizerState.ATTRIBUTE_VALUE_UNQUOTED: 						/* EOF Parse error. */ 						ErrEofInAttributeValue(); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT: 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.BOGUS_COMMENT_HYPHEN: 						// [NOCPP[ 						MaybeAppendSpaceToBogusComment(); 						// ]NOCPP] 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OPEN: 						ErrBogusComment(); 						ClearLongStrBuf(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_HYPHEN: 						ErrBogusComment(); 						EmitComment(0' 0); 						goto breakEofloop; 					case TokenizerState.MARKUP_DECLARATION_OCTYPE: 						if (index < 6) 						{ 							ErrBogusComment(); 							EmitComment(0' 0); 						} 						else 						{ 							/* EOF Parse error. */ 							ErrEofInDoctype(); 							/* 							 * Create a new DOCTYPE token. Set its force-quirks flag 							 * to on. 							 */ 							doctypeName = ""; 							if (systemIdentifier != null) 							{ 								systemIdentifier = null; 							} 							if (publicIdentifier != null) 							{ 								publicIdentifier = null; 							} 							forceQuirks = true; 							/* 							 * Emit the token. 							 */ 							EmitDoctypeToken(0); 							/* 							 * Reconsume the EOF character in the data state. 							 */ 							goto breakEofloop; 						} 						goto breakEofloop; 					case TokenizerState.COMMENT_START: 					case TokenizerState.COMMENT: 						/* 						 * EOF Parse error. 						 */ 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(0' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(2' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_DASH: 					case TokenizerState.COMMENT_START_DASH: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(1' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.COMMENT_END_BANG: 						ErrEofInComment(); 						/* Emit the comment token. */ 						EmitComment(3' 0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE: 					case TokenizerState.BEFORE_DOCTYPE_NAME: 						ErrEofInDoctype(); 						/* 						 * Create a new DOCTYPE token. Set its force-quirks flag to 						 * on. 						 */ 						forceQuirks = true; 						/* 						 * Emit the token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_NAME: 						ErrEofInDoctype(); 						StrBufToDoctypeName(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_UBLIC: 					case TokenizerState.DOCTYPE_YSTEM: 					case TokenizerState.AFTER_DOCTYPE_NAME: 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_KEYWORD: 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_KEYWORD: 					case TokenizerState.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInPublicId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						publicIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: 					case TokenizerState.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: 					case TokenizerState.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: 					case TokenizerState.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: 						/* EOF Parse error. */ 						ErrEofInSystemId(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						systemIdentifier = LongStrBufToString(); 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: 						ErrEofInDoctype(); 						/* 						 * Set the DOCTYPE token's force-quirks flag to on. 						 */ 						forceQuirks = true; 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.BOGUS_DOCTYPE: 						/* 						 * Emit that DOCTYPE token. 						 */ 						EmitDoctypeToken(0); 						/* 						 * Reconsume the EOF character in the data state. 						 */ 						goto breakEofloop; 					case TokenizerState.CONSUME_CHARACTER_REFERENCE: 						/* 						 * Unlike the definition is the spec' this state does not 						 * return a value and never requires the caller to 						 * backtrack. This state takes care of emitting characters 						 * or appending to the current attribute value. It also 						 * takes care of that in the case TokenizerState.when consuming the entity 						 * fails. 						 */ 						/* 						 * This section defines how to consume an entity. This 						 * definition is used when parsing entities in text and in 						 * attributes. 						 *  						 * The behavior depends on the identity of the next 						 * character (the one immediately after the U+0026 AMPERSAND 						 * character): 						 */  						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_HILO_LOOKUP: 						ErrNoNamedCharacterMatch(); 						EmitOrAppendStrBuf(returnState); 						state = returnState; 						continue; 					case TokenizerState.CHARACTER_REFERENCE_TAIL: 						/*outer:*/ 						for (; ; ) 						{ 							char c = '\u0000'; 							entCol++; 							/* 							 * Consume the maximum number of characters possible' 							 * with the consumed characters matching one of the 							 * identifiers in the first column of the named 							 * character references table (in a case-sensitive 							 * manner). 							 */ 							/*hiloop:*/ 							for (; ; ) 							{ 								if (hi == -1) 								{ 									goto breakHiloop; 								} 								if (entCol == NamedCharacters.NAMES[hi].Length) 								{ 									goto breakHiloop; 								} 								if (entCol > NamedCharacters.NAMES[hi].Length) 								{ 									goto breakOuter; 								} 								else if (c < NamedCharacters.NAMES[hi][entCol]) 								{ 									hi--; 								} 								else 								{ 									goto breakHiloop; 								} 							}  						breakHiloop:  							/*loloop:*/ 							for (; ; ) 							{ 								if (hi < lo) 								{ 									goto breakOuter; 								} 								if (entCol == NamedCharacters.NAMES[lo].Length) 								{ 									candidate = lo; 									strBufMark = strBufLen; 									lo++; 								} 								else if (entCol > NamedCharacters.NAMES[lo].Length) 								{ 									goto breakOuter; 								} 								else if (c > NamedCharacters.NAMES[lo][entCol]) 								{ 									lo++; 								} 								else 								{ 									goto breakLoloop; 								} 							}  						breakLoloop:  							if (hi < lo) 							{ 								goto breakOuter; 							} 							continue; 						}  					breakOuter:  						if (candidate == -1) 						{ 							/* 							 * If no match can be made' then this is a parse error. 							 */ 							ErrNoNamedCharacterMatch(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							goto continueEofloop; 						} 						else 						{ 							string candidateName = NamedCharacters.NAMES[candidate]; 							if (candidateName.Length == 0 									|| candidateName[candidateName.Length - 1] != ';') 							{ 								/* 								 * If the last character matched is not a U+003B 								 * SEMICOLON (;)' there is a parse error. 								 */ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									/* 									 * If the entity is being consumed as part of an 									 * attribute' and the last character matched is 									 * not a U+003B SEMICOLON (;)' 									 */ 									char ch; 									if (strBufMark == strBufLen) 									{ 										ch = '\u0000'; 									} 									else 									{ 										ch = strBuf[strBufMark]; 									} 									if ((ch >= '0' && ch <= '9') 											|| (ch >= 'A' && ch <= 'Z') 											|| (ch >= 'a' && ch <= 'z')) 									{ 										/* 										 * and the next character is in the range 										 * U+0030 DIGIT ZERO to U+0039 DIGIT NINE' 										 * U+0041 LATIN CAPITAL LETTER A to U+005A 										 * LATIN CAPITAL LETTER Z' or U+0061 LATIN 										 * SMALL LETTER A to U+007A LATIN SMALL 										 * LETTER Z' then' for historical reasons' 										 * all the characters that were matched 										 * after the U+0026 AMPERSAND (&) must be 										 * unconsumed' and nothing is returned. 										 */ 										ErrNoNamedCharacterMatch(); 										AppendStrBufToLongStrBuf(); 										state = returnState; 										goto continueEofloop; 									} 								} 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									ErrUnescapedAmpersandInterpretedAsCharacterReference(); 								} 								else 								{ 									ErrNotSemicolonTerminated(); 								} 							}  							/* 							 * Otherwise' return a character token for the character 							 * corresponding to the entity name (as given by the 							 * second column of the named character references 							 * table). 							 */ 							char[] val = NamedCharacters.VALUES[candidate]; 							if ( 								// [NOCPP[ 							val.Length == 1 								// ]NOCPP] 								// CPPONLY: val[1] == 0 							) 							{ 								EmitOrAppendOne(val' returnState); 							} 							else 							{ 								EmitOrAppendTwo(val' returnState); 							} 							// this is so complicated! 							if (strBufMark < strBufLen) 							{ 								//if ((returnState & DATA_AND_RCDATA_MASK) != 0)                                  if (((byte)returnState & DATA_AND_RCDATA_MASK) == 0) 								{ 									for (int i = strBufMark; i < strBufLen; i++) 									{ 										AppendLongStrBuf(strBuf[i]); 									} 								} 								else 								{ 									TokenHandler.Characters(strBuf' strBufMark' 											strBufLen - strBufMark); 								} 							} 							state = returnState; 							goto continueEofloop; 							/* 							 * If the markup contains I'm &notit; I tell you' the 							 * entity is parsed as "not"' as in' I'm Â¬it; I tell 							 * you. But if the markup was I'm &notin; I tell you' 							 * the entity would be parsed as "notin;"' resulting in 							 * I'm âˆ‰ I tell you. 							 */ 						} 					case TokenizerState.CONSUME_NCR: 					case TokenizerState.DECIMAL_NRC_LOOP: 					case TokenizerState.HEX_NCR_LOOP: 						/* 						 * If no characters match the range' then don't consume any 						 * characters (and unconsume the U+0023 NUMBER SIGN 						 * character and' if appropriate' the X character). This is 						 * a parse error; nothing is returned. 						 *  						 * Otherwise' if the next character is a U+003B SEMICOLON' 						 * consume that too. If it isn't' there is a parse error. 						 */ 						if (!seenDigits) 						{ 							ErrNoDigitsInNCR(); 							EmitOrAppendStrBuf(returnState); 							state = returnState; 							continue; 						} 						else 						{ 							ErrCharRefLacksSemicolon(); 						} 						// WARNING previous state sets reconsume 						HandleNcrValue(returnState); 						state = returnState; 						continue; 					case TokenizerState.CDATA_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 1); 						goto breakEofloop; 					case TokenizerState.CDATA_RSQB_RSQB: 						TokenHandler.Characters(RSQB_RSQB' 0' 2); 						goto breakEofloop; 					case TokenizerState.DATA: 					default: 						goto breakEofloop; 				}
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,InitializeWithoutStarting,The following statement contains a magic number: strBuf = new char[64];
Magic Number,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,InitializeWithoutStarting,The following statement contains a magic number: longStrBuf = new char[1024];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTokenization,The following statement contains a magic number: stack = new StackNode<T>[64];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTokenization,The following statement contains a magic number: listOfActiveFormattingElements = new StackNode<T>[64];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The following statement contains a magic number: switch (mode) 				{ 					case InsertionMode.IN_ROW: 						switch (group) 						{ 							case DispatchGroup.TR: 								eltPos = FindLastOrRoot(DispatchGroup.TR); 								if (eltPos == 0) 								{ 									Debug.Assert(fragment); 									Err("No table row to close."); 									goto breakEndtagloop; 								} 								ClearStackBackTo(eltPos); 								Pop(); 								mode = InsertionMode.IN_TABLE_BODY; 								goto breakEndtagloop; 							case DispatchGroup.TABLE: 								eltPos = FindLastOrRoot(DispatchGroup.TR); 								if (eltPos == 0) 								{ 									Debug.Assert(fragment); 									Err("No table row to close."); 									goto breakEndtagloop; 								} 								ClearStackBackTo(eltPos); 								Pop(); 								mode = InsertionMode.IN_TABLE_BODY; 								continue; 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 								if (FindLastInTableScope(name) == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								eltPos = FindLastOrRoot(DispatchGroup.TR); 								if (eltPos == 0) 								{ 									Debug.Assert(fragment); 									Err("No table row to close."); 									goto breakEndtagloop; 								} 								ClearStackBackTo(eltPos); 								Pop(); 								mode = InsertionMode.IN_TABLE_BODY; 								continue; 							case DispatchGroup.BODY: 							case DispatchGroup.CAPTION: 							case DispatchGroup.COL: 							case DispatchGroup.COLGROUP: 							case DispatchGroup.HTML: 							case DispatchGroup.TD_OR_TH: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								// fall through to IN_TABLE (TODO: IN_TABLE_BODY?) 								break; 						}  						goto case InsertionMode.IN_TABLE_BODY; 					case InsertionMode.IN_TABLE_BODY: 						switch (group) 						{ 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 								eltPos = FindLastOrRoot(name); 								if (eltPos == 0) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								ClearStackBackTo(eltPos); 								Pop(); 								mode = InsertionMode.IN_TABLE; 								goto breakEndtagloop; 							case DispatchGroup.TABLE: 								eltPos = FindLastInTableScopeOrRootTbodyTheadTfoot(); 								if (eltPos == 0) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								ClearStackBackTo(eltPos); 								Pop(); 								mode = InsertionMode.IN_TABLE; 								continue; 							case DispatchGroup.BODY: 							case DispatchGroup.CAPTION: 							case DispatchGroup.COL: 							case DispatchGroup.COLGROUP: 							case DispatchGroup.HTML: 							case DispatchGroup.TD_OR_TH: 							case DispatchGroup.TR: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								// fall through to IN_TABLE 								break; 						} 						goto case InsertionMode.IN_TABLE; 					case InsertionMode.IN_TABLE: 						switch (group) 						{ 							case DispatchGroup.TABLE: 								eltPos = FindLast("table"); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								ResetTheInsertionMode(); 								goto breakEndtagloop; 							case DispatchGroup.BODY: 							case DispatchGroup.CAPTION: 							case DispatchGroup.COL: 							case DispatchGroup.COLGROUP: 							case DispatchGroup.HTML: 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 							case DispatchGroup.TD_OR_TH: 							case DispatchGroup.TR: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								ErrStrayEndTag(name); 								// fall through to IN_BODY (TODO: IN_CAPTION?) 								break; 						} 						goto case InsertionMode.IN_CAPTION; 					case InsertionMode.IN_CAPTION: 						switch (group) 						{ 							case DispatchGroup.CAPTION: 								eltPos = FindLastInTableScope("caption"); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									goto breakEndtagloop; 								} 								GenerateImpliedEndTags(); 								if (ErrorEvent != null && currentPtr != eltPos) 								{ 									ErrUnclosedElements(eltPos' name); 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								ClearTheListOfActiveFormattingElementsUpToTheLastMarker(); 								mode = InsertionMode.IN_TABLE; 								goto breakEndtagloop; 							case DispatchGroup.TABLE: 								Err("\u201Ctable\u201D closed but \u201Ccaption\u201D was still open."); 								eltPos = FindLastInTableScope("caption"); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									goto breakEndtagloop; 								} 								GenerateImpliedEndTags(); 								if (ErrorEvent != null && currentPtr != eltPos) 								{ 									ErrUnclosedElements(eltPos' name); 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								ClearTheListOfActiveFormattingElementsUpToTheLastMarker(); 								mode = InsertionMode.IN_TABLE; 								continue; 							case DispatchGroup.BODY: 							case DispatchGroup.COL: 							case DispatchGroup.COLGROUP: 							case DispatchGroup.HTML: 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 							case DispatchGroup.TD_OR_TH: 							case DispatchGroup.TR: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								// fall through to IN_BODY (TODO: IN_CELL?) 								break; 						} 						goto case InsertionMode.IN_CELL; 					case InsertionMode.IN_CELL: 						switch (group) 						{ 							case DispatchGroup.TD_OR_TH: 								eltPos = FindLastInTableScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								GenerateImpliedEndTags(); 								if (ErrorEvent != null && !IsCurrent(name)) 								{ 									ErrUnclosedElements(eltPos' name); 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								ClearTheListOfActiveFormattingElementsUpToTheLastMarker(); 								mode = InsertionMode.IN_ROW; 								goto breakEndtagloop; 							case DispatchGroup.TABLE: 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 							case DispatchGroup.TR: 								if (FindLastInTableScope(name) == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								CloseTheCell(FindLastInTableScopeTdTh()); 								continue; 							case DispatchGroup.BODY: 							case DispatchGroup.CAPTION: 							case DispatchGroup.COL: 							case DispatchGroup.COLGROUP: 							case DispatchGroup.HTML: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								// fall through to IN_BODY 								break; 						} 						goto case InsertionMode.IN_BODY; 					case InsertionMode.FRAMESET_OK: 					case InsertionMode.IN_BODY: 						switch (group) 						{ 							case DispatchGroup.BODY: 								if (!IsSecondOnStackBody()) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								Debug.Assert(currentPtr >= 1); 								if (ErrorEvent != null) 								{ 									/*uncloseloop1:*/ 									for (int i = 2; i <= currentPtr; i++) 									{ 										switch (stack[i].Group) 										{ 											case DispatchGroup.DD_OR_DT: 											case DispatchGroup.LI: 											case DispatchGroup.OPTGROUP: 											case DispatchGroup.OPTION: // is this possible? 											case DispatchGroup.P: 											case DispatchGroup.RT_OR_RP: 											case DispatchGroup.TD_OR_TH: 											case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 												break; 											default: 												ErrEndWithUnclosedElements("End tag for \u201Cbody\u201D seen but there were unclosed elements."); 												goto breakUncloseloop1; 										} 									} 								} 							breakUncloseloop1: 								mode = InsertionMode.AFTER_BODY; 								goto breakEndtagloop; 							case DispatchGroup.HTML: 								if (!IsSecondOnStackBody()) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								if (ErrorEvent != null) 								{ 									/*uncloseloop2:*/ 									for (int i = 0; i <= currentPtr; i++) 									{ 										switch (stack[i].Group) 										{ 											case DispatchGroup.DD_OR_DT: 											case DispatchGroup.LI: 											case DispatchGroup.P: 											case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 											case DispatchGroup.TD_OR_TH: 											case DispatchGroup.BODY: 											case DispatchGroup.HTML: 												break; 											default: 												ErrEndWithUnclosedElements("End tag for \u201Chtml\u201D seen but there were unclosed elements."); 												goto breakUncloseloop2; 										} 									} 								}  							breakUncloseloop2: 								mode = InsertionMode.AFTER_BODY; 								continue; 							case DispatchGroup.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU: 							case DispatchGroup.UL_OR_OL_OR_DL: 							case DispatchGroup.PRE_OR_LISTING: 							case DispatchGroup.FIELDSET: 							case DispatchGroup.BUTTON: 							case DispatchGroup.ADDRESS_OR_ARTICLE_OR_ASIDE_OR_DETAILS_OR_DIR_OR_FIGCAPTION_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_HGROUP_OR_NAV_OR_SECTION_OR_SUMMARY: 								eltPos = FindLastInScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 								} 								else 								{ 									GenerateImpliedEndTags(); 									if (ErrorEvent != null && !IsCurrent(name)) 									{ 										ErrUnclosedElements(eltPos' name); 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 								} 								goto breakEndtagloop; 							case DispatchGroup.FORM: 								if (formPointer == null) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								formPointer = null; 								eltPos = FindLastInScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								GenerateImpliedEndTags(); 								if (ErrorEvent != null && !IsCurrent(name)) 								{ 									ErrUnclosedElements(eltPos' name); 								} 								RemoveFromStack(eltPos); 								goto breakEndtagloop; 							case DispatchGroup.P: 								eltPos = FindLastInButtonScope("p"); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									Err("No \u201Cp\u201D element in scope but a \u201Cp\u201D end tag seen."); 									// XXX Can the 'in foreign' case happen anymore? 									if (IsInForeign) 									{ 										Err("HTML start tag \u201C" 												+ name 												+ "\u201D in a foreign namespace context."); 										while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") 										{ 											Pop(); 										} 									} 									AppendVoidElementToCurrentMayFoster( 											elementName' 											HtmlAttributes.EMPTY_ATTRIBUTES); 									goto breakEndtagloop; 								} 								GenerateImpliedEndTagsExceptFor("p"); 								Debug.Assert(eltPos != TreeBuilderConstants.NOT_FOUND_ON_STACK); 								if (ErrorEvent != null && eltPos != currentPtr) 								{ 									ErrUnclosedElements(eltPos' name); 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								goto breakEndtagloop; 							case DispatchGroup.LI: 								eltPos = FindLastInListScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									Err("No \u201Cli\u201D element in list scope but a \u201Cli\u201D end tag seen."); 								} 								else 								{ 									GenerateImpliedEndTagsExceptFor(name); 									if (ErrorEvent != null && eltPos != currentPtr) 									{ 										ErrUnclosedElements(eltPos' name); 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 								} 								goto breakEndtagloop; 							case DispatchGroup.DD_OR_DT: 								eltPos = FindLastInScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									Err("No \u201C" 											+ name 											+ "\u201D element in scope but a \u201C" 											+ name + "\u201D end tag seen."); 								} 								else 								{ 									GenerateImpliedEndTagsExceptFor(name); 									if (ErrorEvent != null 											&& eltPos != currentPtr) 									{ 										ErrUnclosedElements(eltPos' name); 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 								} 								goto breakEndtagloop; 							case DispatchGroup.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6: 								eltPos = FindLastInScopeHn(); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 								} 								else 								{ 									GenerateImpliedEndTags(); 									if (ErrorEvent != null && !IsCurrent(name)) 									{ 										ErrUnclosedElements(eltPos' name); 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 								} 								goto breakEndtagloop; 							case DispatchGroup.OBJECT: 							case DispatchGroup.MARQUEE_OR_APPLET: 								eltPos = FindLastInScope(name); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									ErrStrayEndTag(name); 								} 								else 								{ 									GenerateImpliedEndTags(); 									if (ErrorEvent != null && !IsCurrent(name)) 									{ 										ErrUnclosedElements(eltPos' name); 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 									ClearTheListOfActiveFormattingElementsUpToTheLastMarker(); 								} 								goto breakEndtagloop; 							case DispatchGroup.BR: 								Err("End tag \u201Cbr\u201D."); 								if (IsInForeign) 								{ 									Err("HTML start tag \u201C" 											+ name 											+ "\u201D in a foreign namespace context."); 									while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") 									{ 										Pop(); 									} 								} 								ReconstructTheActiveFormattingElements(); 								AppendVoidElementToCurrentMayFoster( 										elementName' 										HtmlAttributes.EMPTY_ATTRIBUTES); 								goto breakEndtagloop; 							case DispatchGroup.AREA_OR_WBR: 							case DispatchGroup.PARAM_OR_SOURCE_OR_TRACK: 							case DispatchGroup.EMBED_OR_IMG: 							case DispatchGroup.IMAGE: 							case DispatchGroup.INPUT: 							case DispatchGroup.KEYGEN: // XXX?? 							case DispatchGroup.HR: 							case DispatchGroup.ISINDEX: 							case DispatchGroup.IFRAME: 							case DispatchGroup.NOEMBED: // XXX??? 							case DispatchGroup.NOFRAMES: // XXX?? 							case DispatchGroup.SELECT: 							case DispatchGroup.TABLE: 							case DispatchGroup.TEXTAREA: // XXX?? 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							case DispatchGroup.NOSCRIPT: 								if (IsScriptingEnabled) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								else 								{ 									// fall through 									goto case DispatchGroup.A; 								} 							case DispatchGroup.A: 							case DispatchGroup.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U: 							case DispatchGroup.FONT: 							case DispatchGroup.NOBR: 								if (AdoptionAgencyEndTag(name)) 								{ 									goto breakEndtagloop; 								} 								else 								{ 									// else handle like any other tag 									goto default; 								} 							default: 								if (IsCurrent(name)) 								{ 									Pop(); 									goto breakEndtagloop; 								}  								eltPos = currentPtr; 								for (; ; ) 								{ 									StackNode<T> node = stack[eltPos]; 									if (node.name == name) 									{ 										GenerateImpliedEndTags(); 										if (ErrorEvent != null 												&& !IsCurrent(name)) 										{ 											ErrUnclosedElements(eltPos' name); 										} 										while (currentPtr >= eltPos) 										{ 											Pop(); 										} 										goto breakEndtagloop; 									} 									else if (node.IsSpecial) 									{ 										ErrStrayEndTag(name); 										goto breakEndtagloop; 									} 									eltPos--; 								} 						} 					case InsertionMode.IN_COLUMN_GROUP: 						switch (group) 						{ 							case DispatchGroup.COLGROUP: 								if (currentPtr == 0) 								{ 									Debug.Assert(fragment); 									Err("Garbage in \u201Ccolgroup\u201D fragment."); 									goto breakEndtagloop; 								} 								Pop(); 								mode = InsertionMode.IN_TABLE; 								goto breakEndtagloop; 							case DispatchGroup.COL: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 							default: 								if (currentPtr == 0) 								{ 									Debug.Assert(fragment); 									Err("Garbage in \u201Ccolgroup\u201D fragment."); 									goto breakEndtagloop; 								} 								Pop(); 								mode = InsertionMode.IN_TABLE; 								continue; 						} 					case InsertionMode.IN_SELECT_IN_TABLE: 						switch (group) 						{ 							case DispatchGroup.CAPTION: 							case DispatchGroup.TABLE: 							case DispatchGroup.TBODY_OR_THEAD_OR_TFOOT: 							case DispatchGroup.TR: 							case DispatchGroup.TD_OR_TH: 								Err("\u201C" 										+ name 										+ "\u201D end tag with \u201Cselect\u201D open."); 								if (FindLastInTableScope(name) != TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									eltPos = FindLastInTableScope("select"); 									if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 									{ 										Debug.Assert(fragment); 										goto breakEndtagloop; // http://www.w3.org/Bugs/Public/show_bug.cgi?id=8375 									} 									while (currentPtr >= eltPos) 									{ 										Pop(); 									} 									ResetTheInsertionMode(); 									continue; 								} 								else 								{ 									goto breakEndtagloop; 								} 							default: 								break; 							// fall through to IN_SELECT 						} 						goto case InsertionMode.IN_SELECT; 					case InsertionMode.IN_SELECT: 						switch (group) 						{ 							case DispatchGroup.OPTION: 								if (IsCurrent("option")) 								{ 									Pop(); 									goto breakEndtagloop; 								} 								else 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 							case DispatchGroup.OPTGROUP: 								if (IsCurrent("option") 										&& "optgroup" == stack[currentPtr - 1].name) 								{ 									Pop(); 								} 								if (IsCurrent("optgroup")) 								{ 									Pop(); 								} 								else 								{ 									ErrStrayEndTag(name); 								} 								goto breakEndtagloop; 							case DispatchGroup.SELECT: 								eltPos = FindLastInTableScope("select"); 								if (eltPos == TreeBuilderConstants.NOT_FOUND_ON_STACK) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								while (currentPtr >= eltPos) 								{ 									Pop(); 								} 								ResetTheInsertionMode(); 								goto breakEndtagloop; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.AFTER_BODY: 						switch (group) 						{ 							case DispatchGroup.HTML: 								if (fragment) 								{ 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								else 								{ 									mode = InsertionMode.AFTER_AFTER_BODY; 									goto breakEndtagloop; 								} 							default: 								Err("Saw an end tag after \u201Cbody\u201D had been closed."); 								mode = framesetOk ? InsertionMode.FRAMESET_OK : InsertionMode.IN_BODY; 								continue; 						} 					case InsertionMode.IN_FRAMESET: 						switch (group) 						{ 							case DispatchGroup.FRAMESET: 								if (currentPtr == 0) 								{ 									Debug.Assert(fragment); 									ErrStrayEndTag(name); 									goto breakEndtagloop; 								} 								Pop(); 								if ((!fragment) && !IsCurrent("frameset")) 								{ 									mode = InsertionMode.AFTER_FRAMESET; 								} 								goto breakEndtagloop; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.AFTER_FRAMESET: 						switch (group) 						{ 							case DispatchGroup.HTML: 								mode = InsertionMode.AFTER_AFTER_FRAMESET; 								goto breakEndtagloop; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.INITIAL: 						/* 						 * Parse error. 						 */ 						// [NOCPP[ 						switch (DoctypeExpectation) 						{ 							case DoctypeExpectation.Auto: 								Err("End tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html401Strict: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 								break; 							case DoctypeExpectation.Html401Transitional: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 								break; 							case DoctypeExpectation.NoDoctypeErrors: 								break; 						} 						// ]NOCPP] 						/* 						 * 						 * Set the document to quirks mode. 						 */ 						DocumentModeInternal(DocumentMode.QuirksMode' null' null' 								false); 						/* 						 * Then' switch to the root element mode of the tree 						 * construction stage 						 */ 						mode = InsertionMode.BEFORE_HTML; 						/* 						 * and reprocess the current token. 						 */ 						continue; 					case InsertionMode.BEFORE_HTML: 						switch (group) 						{ 							case DispatchGroup.HEAD: 							case DispatchGroup.BR: 							case DispatchGroup.HTML: 							case DispatchGroup.BODY: 								/* 								 * Create an HTMLElement node with the tag name 								 * html' in the HTML namespace. Append it to the 								 * Document object. 								 */ 								AppendHtmlElementToDocumentAndPush(); 								/* Switch to the main mode */ 								mode = InsertionMode.BEFORE_HEAD; 								/* 								 * reprocess the current token. 								 */ 								continue; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.BEFORE_HEAD: 						switch (group) 						{ 							case DispatchGroup.HEAD: 							case DispatchGroup.BR: 							case DispatchGroup.HTML: 							case DispatchGroup.BODY: 								AppendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES); 								mode = InsertionMode.IN_HEAD; 								continue; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.IN_HEAD: 						switch (group) 						{ 							case DispatchGroup.HEAD: 								Pop(); 								mode = InsertionMode.AFTER_HEAD; 								goto breakEndtagloop; 							case DispatchGroup.BR: 							case DispatchGroup.HTML: 							case DispatchGroup.BODY: 								Pop(); 								mode = InsertionMode.AFTER_HEAD; 								continue; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.IN_HEAD_NOSCRIPT: 						switch (group) 						{ 							case DispatchGroup.NOSCRIPT: 								Pop(); 								mode = InsertionMode.IN_HEAD; 								goto breakEndtagloop; 							case DispatchGroup.BR: 								ErrStrayEndTag(name); 								Pop(); 								mode = InsertionMode.IN_HEAD; 								continue; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.AFTER_HEAD: 						switch (group) 						{ 							case DispatchGroup.HTML: 							case DispatchGroup.BODY: 							case DispatchGroup.BR: 								AppendToCurrentNodeAndPushBodyElement(); 								mode = InsertionMode.FRAMESET_OK; 								continue; 							default: 								ErrStrayEndTag(name); 								goto breakEndtagloop; 						} 					case InsertionMode.AFTER_AFTER_BODY: 						ErrStrayEndTag(name); 						mode = framesetOk ? InsertionMode.FRAMESET_OK : InsertionMode.IN_BODY; 						continue; 					case InsertionMode.AFTER_AFTER_FRAMESET: 						ErrStrayEndTag(name); 						mode = InsertionMode.IN_FRAMESET; 						continue; 					case InsertionMode.TEXT: 						// XXX need to manage insertion point here 						Pop(); 						if (originalMode == InsertionMode.AFTER_HEAD) 						{ 							SilentPop(); 						} 						mode = originalMode; 						goto breakEndtagloop; 				}
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Push,The following statement contains a magic number: StackNode<T>[] newStack = new StackNode<T>[stack.Length + 64];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,SilentPush,The following statement contains a magic number: StackNode<T>[] newStack = new StackNode<T>[stack.Length + 64];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Append,The following statement contains a magic number: StackNode<T>[] newList = new StackNode<T>[listOfActiveFormattingElements.Length + 64];
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,AdoptionAgencyEndTag,The following statement contains a magic number: j < 3
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,AdoptionAgencyEndTag,The following statement contains a magic number: i < 8
Magic Number,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,MaybeForgetEarlierDuplicateFormattingElement,The following statement contains a magic number: count >= 3
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((376' 396)' (923' 943))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((388' 407)' (3979' 3998))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((455' 483)' (1107' 1135))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((2373' 2410)' (2497' 2534))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3201' 3220)' (3368' 3387))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3306' 3328)' (3565' 3587))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3659' 3683)' (3726' 3750))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3967' 3987)' (4265' 4285)' (4961' 4981))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4140' 4164)' (4378' 4402)' (5075' 5099))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4331' 4372)' (4427' 4468))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4339' 4372)' (5036' 5069)' (4435' 4468))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4343' 4362)' (4439' 4458)' (5040' 5059)' (5136' 5155))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4343' 4372)' (5136' 5165)' (4439' 4468)' (5040' 5069))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4500' 4535)' (5258' 5293))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4510' 4530)' (4772' 4792)' (5202' 5222)' (5268' 5288))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4772' 4802)' (5202' 5232))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4618' 4641)' (4708' 4731))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4647' 4671)' (4809' 4833))
Duplicate Code,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,StateLoop,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4762' 4790)' (5192' 5220))
Missing Default,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,AddAttribute,The following switch statement is missing a default case: switch (xmlnsPolicy) 				{ 					case XmlViolationPolicy.Fatal: 						// this is ugly (TODO) 						throw new Exception("Saw an xmlns attribute."); 					case XmlViolationPolicy.AlterInfoset: 						return; 					case XmlViolationPolicy.Allow: 						break; // fall through 				}
Missing Default,HtmlParserSharp.Core,HtmlAttributes,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\HtmlAttributes.cs,ProcessNonNcNames,The following switch statement is missing a default case: switch (namePolicy) 					{ 						case XmlViolationPolicy.AlterInfoset: 							names[i] = AttributeName.Create(NCName.EscapeName(name)); 							goto case XmlViolationPolicy.Allow; // fall through 						case XmlViolationPolicy.Allow: 							if (attName != AttributeName.XML_LANG) 							{ 								treeBuilder.Warn("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0."); 							} 							break; 						case XmlViolationPolicy.Fatal: 							treeBuilder.Fatal("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0."); 							break; 					}
Missing Default,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,AppendSecondHyphenToBogusComment,The following switch statement is missing a default case: switch (commentPolicy) 			{ 				case XmlViolationPolicy.AlterInfoset: 					// detachLongStrBuf(); 					AppendLongStrBuf(' '); 					// FALLTHROUGH 					goto case XmlViolationPolicy.Allow; 				case XmlViolationPolicy.Allow: 					Warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment."); 					// ]NOCPP] 					AppendLongStrBuf('-'); 					// [NOCPP[ 					break; 				case XmlViolationPolicy.Fatal: 					Fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment."); 					break; 			}
Missing Default,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,MaybeAppendSpaceToBogusComment,The following switch statement is missing a default case: switch (commentPolicy) 			{ 				case XmlViolationPolicy.AlterInfoset: 					// detachLongStrBuf(); 					AppendLongStrBuf(' '); 					// FALLTHROUGH 					goto case XmlViolationPolicy.Allow; 				case XmlViolationPolicy.Allow: 					Warn("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment."); 					break; 				case XmlViolationPolicy.Fatal: 					Fatal("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment."); 					break; 			}
Missing Default,HtmlParserSharp.Core,Tokenizer,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\Tokenizer.cs,AdjustDoubleHyphenAndAppendToLongStrBufAndErr,The following switch statement is missing a default case: switch (commentPolicy) 			{ 				case XmlViolationPolicy.AlterInfoset: 					// detachLongStrBuf(); 					longStrBufLen--; 					AppendLongStrBuf(' '); 					AppendLongStrBuf('-'); 					// FALLTHROUGH 					goto case XmlViolationPolicy.Allow; 				case XmlViolationPolicy.Allow: 					Warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment."); 					// ]NOCPP] 					AppendLongStrBuf(c); 					// [NOCPP[ 					break; 				case XmlViolationPolicy.Fatal: 					Fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment."); 					break; 			}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Doctype,The following switch statement is missing a default case: switch (DoctypeExpectation) 						{ 							case DoctypeExpectation.Html: 								// ]NOCPP] 								if (IsQuirky(name' publicIdentifier' 										systemIdentifier' forceQuirks)) 								{ 									Err("Quirky doctype. Expected \u201C<!DOCTYPE html>\u201D."); 									DocumentModeInternal(DocumentMode.QuirksMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								else if (IsAlmostStandards(publicIdentifier' 									  systemIdentifier)) 								{ 									Err("Almost standards mode doctype. Expected \u201C<!DOCTYPE html>\u201D."); 									DocumentModeInternal( 											DocumentMode.AlmostStandardsMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								else 								{ 									// [NOCPP[ 									if (("-//W3C//DTD HTML 4.0//EN" == publicIdentifier && 										(systemIdentifier == null || "http://www.w3.org/TR/REC-html40/strict.dtd" == systemIdentifier)) 											|| ("-//W3C//DTD HTML 4.01//EN" == publicIdentifier && 												(systemIdentifier == null || "http://www.w3.org/TR/html4/strict.dtd" == systemIdentifier)) 											|| ("-//W3C//DTD XHTML 1.0 Strict//EN" == publicIdentifier && 													"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" == systemIdentifier) 											|| ("-//W3C//DTD XHTML 1.1//EN" == publicIdentifier && 													"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" == systemIdentifier)  									) 									{ 										Warn("Obsolete doctype. Expected \u201C<!DOCTYPE html>\u201D."); 									} 									else if (!((systemIdentifier == null || "about:legacy-compat" == systemIdentifier) && 										publicIdentifier == null)) 									{ 										Err("Legacy doctype. Expected \u201C<!DOCTYPE html>\u201D."); 									} 									// ]NOCPP] 									DocumentModeInternal( 											DocumentMode.StandardsMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								// [NOCPP[ 								break; 							case DoctypeExpectation.Html401Strict: 								html4 = true; 								tokenizer.TurnOnAdditionalHtml4Errors(); 								if (IsQuirky(name' publicIdentifier' 										systemIdentifier' forceQuirks)) 								{ 									Err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 									DocumentModeInternal(DocumentMode.QuirksMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								else if (IsAlmostStandards(publicIdentifier' 									  systemIdentifier)) 								{ 									Err("Almost standards mode doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 									DocumentModeInternal( 											DocumentMode.AlmostStandardsMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								else 								{ 									if ("-//W3C//DTD HTML 4.01//EN" == publicIdentifier) 									{ 										if ("http://www.w3.org/TR/html4/strict.dtd" != systemIdentifier) 										{ 											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 										} 									} 									else 									{ 										Err("The doctype was not the HTML 4.01 Strict doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 									} 									DocumentModeInternal( 											DocumentMode.StandardsMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								break; 							case DoctypeExpectation.Html401Transitional: 								html4 = true; 								tokenizer.TurnOnAdditionalHtml4Errors(); 								if (IsQuirky(name' publicIdentifier' 										systemIdentifier' forceQuirks)) 								{ 									Err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 									DocumentModeInternal(DocumentMode.QuirksMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								else if (IsAlmostStandards(publicIdentifier' 									  systemIdentifier)) 								{ 									if ("-//W3C//DTD HTML 4.01 Transitional//EN" == publicIdentifier 											&& systemIdentifier != null) 									{ 										if ("http://www.w3.org/TR/html4/loose.dtd" != systemIdentifier) 										{ 											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 										} 									} 									else 									{ 										Err("The doctype was not a non-quirky HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 									} 									DocumentModeInternal( 											DocumentMode.AlmostStandardsMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								else 								{ 									Err("The doctype was not the HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 									DocumentModeInternal( 											DocumentMode.StandardsMode' 											publicIdentifier' systemIdentifier' 											true); 								} 								break; 							case DoctypeExpectation.Auto: 								html4 = IsHtml4Doctype(publicIdentifier); 								if (html4) 								{ 									tokenizer.TurnOnAdditionalHtml4Errors(); 								} 								if (IsQuirky(name' publicIdentifier' 										systemIdentifier' forceQuirks)) 								{ 									Err("Quirky doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 									DocumentModeInternal(DocumentMode.QuirksMode' 											publicIdentifier' systemIdentifier' 											html4); 								} 								else if (IsAlmostStandards(publicIdentifier' 									  systemIdentifier)) 								{ 									if ("-//W3C//DTD HTML 4.01 Transitional//EN" == publicIdentifier) 									{ 										if ("http://www.w3.org/TR/html4/loose.dtd" != systemIdentifier) 										{ 											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 										} 									} 									else 									{ 										Err("Almost standards mode doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 									} 									DocumentModeInternal( 											DocumentMode.AlmostStandardsMode' 											publicIdentifier' systemIdentifier' 											html4); 								} 								else 								{ 									if ("-//W3C//DTD HTML 4.01//EN" == publicIdentifier) 									{ 										if ("http://www.w3.org/TR/html4/strict.dtd" != systemIdentifier) 										{ 											Warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 										} 									} 									else 									{ 										if (!(publicIdentifier == null && systemIdentifier == null)) 										{ 											Err("Legacy doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 										} 									} 									DocumentModeInternal( 											DocumentMode.StandardsMode' 											publicIdentifier' systemIdentifier' 											html4); 								} 								break; 							case DoctypeExpectation.NoDoctypeErrors: 								if (IsQuirky(name' publicIdentifier' 										systemIdentifier' forceQuirks)) 								{ 									DocumentModeInternal(DocumentMode.QuirksMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								else if (IsAlmostStandards(publicIdentifier' 									  systemIdentifier)) 								{ 									DocumentModeInternal( 											DocumentMode.AlmostStandardsMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								else 								{ 									DocumentModeInternal( 											DocumentMode.StandardsMode' 											publicIdentifier' systemIdentifier' 											false); 								} 								break; 						}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The following switch statement is missing a default case: switch (mode) 								{ 									case InsertionMode.INITIAL: 									case InsertionMode.BEFORE_HTML: 									case InsertionMode.BEFORE_HEAD: 										/* 										 * Ignore the token. 										 */ 										start = i + 1; 										continue; 									case InsertionMode.IN_HEAD: 									case InsertionMode.IN_HEAD_NOSCRIPT: 									case InsertionMode.AFTER_HEAD: 									case InsertionMode.IN_COLUMN_GROUP: 									case InsertionMode.IN_FRAMESET: 									case InsertionMode.AFTER_FRAMESET: 										/* 										 * Append the character to the current node. 										 */ 										continue; 									case InsertionMode.FRAMESET_OK: 									case InsertionMode.IN_BODY: 									case InsertionMode.IN_CELL: 									case InsertionMode.IN_CAPTION: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										}  										/* 										 * Reconstruct the active formatting 										 * elements' if any. 										 */                                          if (!IsInForeignButNotHtmlOrMathTextIntegrationPoint) 										{ 											FlushCharacters(); 											ReconstructTheActiveFormattingElements(); 										} 										/* 										 * Append the token's character to the 										 * current node. 										 */ 										goto continueCharactersloop; 									case InsertionMode.IN_SELECT: 									case InsertionMode.IN_SELECT_IN_TABLE: 										goto continueCharactersloop; 									case InsertionMode.IN_TABLE: 									case InsertionMode.IN_TABLE_BODY: 									case InsertionMode.IN_ROW: 										AccumulateCharactersForced(buf' i' 1); 										start = i + 1; 										continue; 									case InsertionMode.AFTER_BODY: 									case InsertionMode.AFTER_AFTER_BODY: 									case InsertionMode.AFTER_AFTER_FRAMESET: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Reconstruct the active formatting 										 * elements' if any. 										 */ 										FlushCharacters(); 										ReconstructTheActiveFormattingElements(); 										/* 										 * Append the token's character to the 										 * current node. 										 */ 										continue; 								}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The following switch statement is missing a default case: switch (mode) 								{ 									case InsertionMode.INITIAL: 										/* 										 * Parse error. 										 */ 										// [NOCPP[ 										switch (DoctypeExpectation) 										{ 											case DoctypeExpectation.Auto: 												Err("Non-space characters found without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 												break; 											case DoctypeExpectation.Html: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 												break; 											case DoctypeExpectation.Html401Strict: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 												break; 											case DoctypeExpectation.Html401Transitional: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 												break; 											case DoctypeExpectation.NoDoctypeErrors: 												break; 										} 										// ]NOCPP] 										/* 										 * 										 * Set the document to quirks mode. 										 */ 										DocumentModeInternal( 												DocumentMode.QuirksMode' null' 												null' false); 										/* 										 * Then' switch to the root element mode of 										 * the tree construction stage 										 */ 										mode = InsertionMode.BEFORE_HTML; 										/* 										 * and reprocess the current token. 										 */ 										i--; 										continue; 									case InsertionMode.BEFORE_HTML: 										/* 										 * Create an HTMLElement node with the tag 										 * name html' in the HTML namespace. Append 										 * it to the Document object. 										 */ 										// No need to flush characters here' 										// because there's nothing to flush. 										AppendHtmlElementToDocumentAndPush(); 										/* Switch to the main mode */ 										mode = InsertionMode.BEFORE_HEAD; 										/* 										 * reprocess the current token. 										 */ 										i--; 										continue; 									case InsertionMode.BEFORE_HEAD: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * /Act as if a start tag token with the tag 										 * name "head" and no attributes had been 										 * seen' 										 */ 										FlushCharacters(); 										AppendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES); 										mode = InsertionMode.IN_HEAD; 										/* 										 * then reprocess the current token. 										 * 										 * This will result in an empty head element 										 * being generated' with the current token 										 * being reprocessed in the "after head" 										 * insertion mode. 										 */ 										i--; 										continue; 									case InsertionMode.IN_HEAD: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Act as if an end tag token with the tag 										 * name "head" had been seen' 										 */ 										FlushCharacters(); 										Pop(); 										mode = InsertionMode.AFTER_HEAD; 										/* 										 * and reprocess the current token. 										 */ 										i--; 										continue; 									case InsertionMode.IN_HEAD_NOSCRIPT: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Parse error. Act as if an end tag with 										 * the tag name "noscript" had been seen 										 */ 										Err("Non-space character inside \u201Cnoscript\u201D inside \u201Chead\u201D."); 										FlushCharacters(); 										Pop(); 										mode = InsertionMode.IN_HEAD; 										/* 										 * and reprocess the current token. 										 */ 										i--; 										continue; 									case InsertionMode.AFTER_HEAD: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Act as if a start tag token with the tag 										 * name "body" and no attributes had been 										 * seen' 										 */ 										FlushCharacters(); 										AppendToCurrentNodeAndPushBodyElement(); 										mode = InsertionMode.FRAMESET_OK; 										/* 										 * and then reprocess the current token. 										 */ 										i--; 										continue; 									case InsertionMode.FRAMESET_OK: 										framesetOk = false; 										mode = InsertionMode.IN_BODY; 										i--; 										continue; 									case InsertionMode.IN_BODY: 									case InsertionMode.IN_CELL: 									case InsertionMode.IN_CAPTION: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Reconstruct the active formatting 										 * elements' if any. 										 */                                          if (!IsInForeignButNotHtmlOrMathTextIntegrationPoint) 										{ 											FlushCharacters(); 											ReconstructTheActiveFormattingElements(); 										} 										/* 										 * Append the token's character to the 										 * current node. 										 */ 										goto continueCharactersloop; 									case InsertionMode.IN_TABLE: 									case InsertionMode.IN_TABLE_BODY: 									case InsertionMode.IN_ROW: 										AccumulateCharactersForced(buf' i' 1); 										start = i + 1; 										continue; 									case InsertionMode.IN_COLUMN_GROUP: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Act as if an end tag with the tag name 										 * "colgroup" had been seen' and then' if 										 * that token wasn't ignored' reprocess the 										 * current token. 										 */ 										if (currentPtr == 0) 										{ 											Err("Non-space in \u201Ccolgroup\u201D when parsing fragment."); 											start = i + 1; 											continue; 										} 										FlushCharacters(); 										Pop(); 										mode = InsertionMode.IN_TABLE; 										i--; 										continue; 									case InsertionMode.IN_SELECT: 									case InsertionMode.IN_SELECT_IN_TABLE: 										goto continueCharactersloop; 									case InsertionMode.AFTER_BODY: 										Err("Non-space character after body."); 										Fatal(); 										mode = framesetOk ? InsertionMode.FRAMESET_OK : InsertionMode.IN_BODY; 										i--; 										continue; 									case InsertionMode.IN_FRAMESET: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Parse error. 										 */ 										Err("Non-space in \u201Cframeset\u201D."); 										/* 										 * Ignore the token. 										 */ 										start = i + 1; 										continue; 									case InsertionMode.AFTER_FRAMESET: 										if (start < i) 										{ 											AccumulateCharacters(buf' start' i 													- start); 											start = i; 										} 										/* 										 * Parse error. 										 */ 										Err("Non-space after \u201Cframeset\u201D."); 										/* 										 * Ignore the token. 										 */ 										start = i + 1; 										continue; 									case InsertionMode.AFTER_AFTER_BODY: 										/* 										 * Parse error. 										 */ 										Err("Non-space character in page trailer."); 										/* 										 * Switch back to the main mode and 										 * reprocess the token. 										 */ 										mode = framesetOk ? InsertionMode.FRAMESET_OK : InsertionMode.IN_BODY; 										i--; 										continue; 									case InsertionMode.AFTER_AFTER_FRAMESET: 										/* 										 * Parse error. 										 */ 										Err("Non-space character in page trailer."); 										/* 										 * Switch back to the main mode and 										 * reprocess the token. 										 */ 										mode = InsertionMode.IN_FRAMESET; 										i--; 										continue; 								}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Characters,The following switch statement is missing a default case: switch (DoctypeExpectation) 										{ 											case DoctypeExpectation.Auto: 												Err("Non-space characters found without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 												break; 											case DoctypeExpectation.Html: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 												break; 											case DoctypeExpectation.Html401Strict: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 												break; 											case DoctypeExpectation.Html401Transitional: 												Err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 												break; 											case DoctypeExpectation.NoDoctypeErrors: 												break; 										}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,Eof,The following switch statement is missing a default case: switch (DoctypeExpectation) 						{ 							case DoctypeExpectation.Auto: 								Err("End of file seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html: 								Err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html401Strict: 								Err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 								break; 							case DoctypeExpectation.Html401Transitional: 								Err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 								break; 							case DoctypeExpectation.NoDoctypeErrors: 								break; 						}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,StartTag,The following switch statement is missing a default case: switch (DoctypeExpectation) 						{ 							case DoctypeExpectation.Auto: 								Err("Start tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html: 								Err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html401Strict: 								Err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 								break; 							case DoctypeExpectation.Html401Transitional: 								Err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 								break; 							case DoctypeExpectation.NoDoctypeErrors: 								break; 						}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,EndTag,The following switch statement is missing a default case: switch (DoctypeExpectation) 						{ 							case DoctypeExpectation.Auto: 								Err("End tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D."); 								break; 							case DoctypeExpectation.Html401Strict: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D."); 								break; 							case DoctypeExpectation.Html401Transitional: 								Err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D."); 								break; 							case DoctypeExpectation.NoDoctypeErrors: 								break; 						}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,The following switch statement is missing a default case: switch (NamePolicy) 								{ 									case XmlViolationPolicy.AlterInfoset: 									// fall through 									case XmlViolationPolicy.Allow: 										Warn("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0."); 										break; 									case XmlViolationPolicy.Fatal: 										Fatal("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0."); 										break; 								}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,The following switch statement is missing a default case: switch (NamePolicy) 							{ 								case XmlViolationPolicy.AlterInfoset: 								// fall through 								case XmlViolationPolicy.Allow: 									Warn("Attribute \u201Cxmlns:xlink\u201D with a value other than \u201Chttp://www.w3.org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics."); 									break; 								case XmlViolationPolicy.Fatal: 									Fatal("Attribute \u201Cxmlns:xlink\u201D with a value other than \u201Chttp://www.w3.org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics."); 									break; 							}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckAttributes,The following switch statement is missing a default case: switch (NamePolicy) 						{ 							case XmlViolationPolicy.AlterInfoset: 							// fall through 							case XmlViolationPolicy.Allow: 								Warn("Attribute with the local name \u201C" 										+ attributes.GetXmlnsLocalName(i) 										+ "\u201D is not serializable as XML 1.0."); 								break; 							case XmlViolationPolicy.Fatal: 								Fatal("Attribute with the local name \u201C" 										+ attributes.GetXmlnsLocalName(i) 										+ "\u201D is not serializable as XML 1.0."); 								break; 						}
Missing Default,HtmlParserSharp.Core,TreeBuilder<T>,D:\research\architectureSmells\repos\garuma_Moyeu\HtmlParserSharp\Core\TreeBuilder.cs,CheckPopName,The following switch statement is missing a default case: switch (NamePolicy) 				{ 					case XmlViolationPolicy.Allow: 						Warn("Element name \u201C" + name 								+ "\u201D cannot be represented as XML 1.0."); 						return name; 					case XmlViolationPolicy.AlterInfoset: 						Warn("Element name \u201C" + name 								+ "\u201D cannot be represented as XML 1.0."); 						return NCName.EscapeName(name); 					case XmlViolationPolicy.Fatal: 						Fatal("Element name \u201C" + name 								+ "\u201D cannot be represented as XML 1.0."); 						break; 				}
