Implementation smell,Namespace,Class,File,Method,Description
Long Method,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The method has 246 lines of code.
Complex Method,Avalonia,DependencyObject,C:\repos\grokys_Avalonia\Avalonia\DependencyObject.cs,OnPropertyChanged,Cyclomatic complexity of the method is 11
Complex Method,Avalonia.Controls,Image,C:\repos\grokys_Avalonia\Avalonia\Controls\Image.cs,MeasureOverride,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,Cyclomatic complexity of the method is 18
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,ArrangeOverride,Cyclomatic complexity of the method is 12
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,AllocateDesiredSize,Cyclomatic complexity of the method is 10
Complex Method,Avalonia.Controls,ItemContainerGenerator,C:\repos\grokys_Avalonia\Avalonia\Controls\ItemContainerGenerator.cs,GenerateNext,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Shapes,Shape,C:\repos\grokys_Avalonia\Avalonia\Shapes\Shape.cs,MeasureOverride,Cyclomatic complexity of the method is 9
Long Parameter List,Avalonia,FrameworkPropertyMetadata,C:\repos\grokys_Avalonia\Avalonia\FrameworkPropertyMetadata.cs,FrameworkPropertyMetadata,The method has 5 parameters. Parameters: defaultValue' flags' propertyChangedCallback' coerceValueCallback' isAnimationProhibited
Long Parameter List,Avalonia,FrameworkPropertyMetadata,C:\repos\grokys_Avalonia\Avalonia\FrameworkPropertyMetadata.cs,FrameworkPropertyMetadata,The method has 6 parameters. Parameters: defaultValue' flags' propertyChangedCallback' coerceValueCallback' isAnimationProhibited' defaultUpdateSourceTrigger
Long Parameter List,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,DependencyProperty,The method has 6 parameters. Parameters: isAttached' name' propertyType' ownerType' defaultMetadata' validateValueCallback
Long Parameter List,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,Register,The method has 5 parameters. Parameters: name' propertyType' ownerType' typeMetadata' validateValueCallback
Long Parameter List,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,RegisterAttached,The method has 5 parameters. Parameters: name' propertyType' ownerType' defaultMetadata' validateValueCallback
Long Parameter List,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,RegisterAttachedReadOnly,The method has 5 parameters. Parameters: name' propertyType' ownerType' defaultMetadata' validateValueCallback
Long Parameter List,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,RegisterReadOnly,The method has 5 parameters. Parameters: name' propertyType' ownerType' typeMetadata' validateValueCallback
Long Parameter List,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,AssignSize,The method has 6 parameters. Parameters: matrix' start' end' size' type' desiredSize
Long Parameter List,Avalonia.Media,StreamGeometryContext,C:\repos\grokys_Avalonia\Avalonia\Media\StreamGeometryContext.cs,BezierTo,The method has 5 parameters. Parameters: point1' point2' point3' isStroked' isSmoothJoin
Long Parameter List,Avalonia.Media,DrawingContext,C:\repos\grokys_Avalonia\Avalonia\Media\DrawingContext.cs,DrawRoundedRectangle,The method has 5 parameters. Parameters: brush' pen' rectangle' radiusX' radiusY
Long Parameter List,Avalonia.Media,FormattedText,C:\repos\grokys_Avalonia\Avalonia\Media\FormattedText.cs,FormattedText,The method has 6 parameters. Parameters: textToFormat' culture' flowDirection' typeface' emSize' foreground
Long Parameter List,Avalonia.Media,Matrix,C:\repos\grokys_Avalonia\Avalonia\Media\Matrix.cs,Matrix,The method has 6 parameters. Parameters: m11' m12' m21' m22' offsetX' offsetY
Long Parameter List,Avalonia.Media.Imaging,RenderTargetBitmap,C:\repos\grokys_Avalonia\Avalonia\Media\Imaging\RenderTargetBitmap.cs,RenderTargetBitmap,The method has 5 parameters. Parameters: pixelWidth' pixelHeight' dpiX' dpiY' pixelFormat
Long Parameter List,Avalonia.Platform,PlatformInterface,C:\repos\grokys_Avalonia\Avalonia\Platform\PlatformInterface.cs,CreateRenderTargetBitmap,The method has 5 parameters. Parameters: pixelWidth' pixelHeight' dpiX' dpiY' pixelFormat
Long Parameter List,Avalonia.Threading,Dispatcher,C:\repos\grokys_Avalonia\Avalonia\Threading\Dispatcher.cs,Invoke,The method has 5 parameters. Parameters: priority' timeout' method' arg' args
Long Parameter List,Avalonia.Threading,DispatcherOperation,C:\repos\grokys_Avalonia\Avalonia\Threading\DispatcherOperation.cs,DispatcherOperation,The method has 5 parameters. Parameters: dis' prio' d' arg' args
Long Identifier,Avalonia.Controls,Control,C:\repos\grokys_Avalonia\Avalonia\Controls\Control.cs,,The length of the parameter HorizontalContentAlignmentProperty is 34.
Long Identifier,Avalonia.Controls,Control,C:\repos\grokys_Avalonia\Avalonia\Controls\Control.cs,,The length of the parameter VerticalContentAlignmentProperty is 32.
Long Identifier,Avalonia.Controls.Primitives,Selector,C:\repos\grokys_Avalonia\Avalonia\Controls\Primitives\Selector.cs,,The length of the parameter IsSynchronizedWithCurrentItemProperty is 37.
Long Statement,Avalonia,DependencyPropertyConverter,C:\repos\grokys_Avalonia\Avalonia\DependencyPropertyConverter.cs,Resolve,The length of the statement  "            IXamlSchemaContextProvider schema = (IXamlSchemaContextProvider)serviceProvider.GetService(typeof(IXamlSchemaContextProvider)); " is 127.
Long Statement,Avalonia,Setter,C:\repos\grokys_Avalonia\Avalonia\Setter.cs,EndInit,The length of the statement  "                    IXamlSchemaContextProvider schema = (IXamlSchemaContextProvider)this.serviceProvider.GetService(typeof(IXamlSchemaContextProvider)); " is 132.
Long Statement,Avalonia,Setter,C:\repos\grokys_Avalonia\Avalonia\Setter.cs,EndInit,The length of the statement  "                    TemplateContent templateContent = (TemplateContent)ambient.GetFirstAmbientValue(new[] { frameworkTemplateType }' templateProperty).Value; " is 137.
Long Statement,Avalonia,TemplateContentLoader,C:\repos\grokys_Avalonia\Avalonia\TemplateContentLoader.cs,Load,The length of the statement  "            IXamlSchemaContextProvider schema = (IXamlSchemaContextProvider)serviceProvider.GetService(typeof(IXamlSchemaContextProvider)); " is 127.
Long Statement,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,RegisterAttachedReadOnly,The length of the statement  "            throw new NotImplementedException("RegisterAttachedReadOnly(string name' Type propertyType' Type ownerType' PropertyMetadata defaultMetadata)"); " is 144.
Long Statement,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,RegisterAttachedReadOnly,The length of the statement  "            throw new NotImplementedException("RegisterAttachedReadOnly(string name' Type propertyType' Type ownerType' PropertyMetadata defaultMetadata' ValidateValueCallback validateValueCallback)"); " is 189.
Long Statement,Avalonia,DependencyProperty,C:\repos\grokys_Avalonia\Avalonia\DependencyProperty.cs,OverrideMetadata,The length of the statement  "                throw new InvalidOperationException(string.Format("Cannot override metadata on readonly property '{0}' without using a DependencyPropertyKey"' this.Name)); " is 155.
Long Statement,Avalonia.Controls,ItemContainerGenerator,C:\repos\grokys_Avalonia\Avalonia\Controls\ItemContainerGenerator.cs,OnOwnerItemsItemsChanged,The length of the statement  "                    Console.WriteLine("*** Critical error in ItemContainerGenerator.OnOwnerItemsItemsChanged. NotifyCollectionChangedAction.{0} is not supported"' e.Action); " is 153.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The conditional expression  "autoRow && autoCol && !starRow && !starCol"  is complex.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The conditional expression  "(autoRow || autoCol) && !(starRow || starCol)"  is complex.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,CreateMatrices,The conditional expression  "this.rowMatrix == null || this.colMatrix == null ||                  this.rowMatrix.GetUpperBound(0) != rowCount - 1 ||                  this.colMatrix.GetUpperBound(0) != colCount - 1"  is complex.
Complex Conditional,Avalonia.Media,PathMarkupParser,C:\repos\grokys_Avalonia\Avalonia\Media\PathMarkupParser.cs,ReadCommand,The conditional expression  "(char.IsDigit(c) || c == '.' || c == '+' || c == '-') &&                           (lastCommand != Command.None)"  is complex.
Complex Conditional,Avalonia.Media,PathMarkupParser,C:\repos\grokys_Avalonia\Avalonia\Media\PathMarkupParser.cs,ReadDouble,The conditional expression  "((c == '+' || c == '-') && !readSign) ||                      (c == '.' && !readPoint) ||                      (c == 'E' && !readExponent) ||                      char.IsDigit(c)"  is complex.
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnGotKeyboardFocus".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnLostKeyboardFocus".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnMouseEnter".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnMouseLeave".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnMouseLeftButtonDown".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnMouseLeftButtonUp".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnMouseMove".
Virtual Method Call from Constructor,Avalonia,UIElement,C:\repos\grokys_Avalonia\Avalonia\UIElement.cs,UIElement,The constructor "UIElement" calls a virtual method "OnTextInput".
Virtual Method Call from Constructor,Avalonia,Window,C:\repos\grokys_Avalonia\Avalonia\Window.cs,Window,The constructor "Window" calls a virtual method "CreatePresentationSource".
Virtual Method Call from Constructor,Avalonia,Window,C:\repos\grokys_Avalonia\Avalonia\Window.cs,Window,The constructor "Window" calls a virtual method "OnClosed".
Virtual Method Call from Constructor,Avalonia.Controls,Control,C:\repos\grokys_Avalonia\Avalonia\Controls\Control.cs,Control,The constructor "Control" calls a virtual method "OnKeyDown".
Virtual Method Call from Constructor,Avalonia.Controls.Primitives,PopupRoot,C:\repos\grokys_Avalonia\Avalonia\Controls\Primitives\PopupRoot.cs,PopupRoot,The constructor "PopupRoot" calls a virtual method "CreatePopupPresentationSource".
Virtual Method Call from Constructor,Avalonia.Controls.Primitives,PopupRoot,C:\repos\grokys_Avalonia\Avalonia\Controls\Primitives\PopupRoot.cs,PopupRoot,The constructor "PopupRoot" calls a virtual method "Show".
Virtual Method Call from Constructor,Avalonia.Media,StreamGeometry,C:\repos\grokys_Avalonia\Avalonia\Media\StreamGeometry.cs,StreamGeometry,The constructor "StreamGeometry" calls a virtual method "CreateStreamGeometry".
Virtual Method Call from Constructor,Avalonia.Media,FormattedText,C:\repos\grokys_Avalonia\Avalonia\Media\FormattedText.cs,FormattedText,The constructor "FormattedText" calls a virtual method "CreateFormattedText".
Virtual Method Call from Constructor,Avalonia.Media.Imaging,PngBitmapEncoder,C:\repos\grokys_Avalonia\Avalonia\Media\Imaging\PngBitmapEncoder.cs,PngBitmapEncoder,The constructor "PngBitmapEncoder" calls a virtual method "CreateBitmapEncoder".
Virtual Method Call from Constructor,Avalonia.Media.Imaging,RenderTargetBitmap,C:\repos\grokys_Avalonia\Avalonia\Media\Imaging\RenderTargetBitmap.cs,RenderTargetBitmap,The constructor "RenderTargetBitmap" calls a virtual method "CreateRenderTargetBitmap".
Empty Catch Block,Avalonia.Input,InputManager,C:\repos\grokys_Avalonia\Avalonia\Input\InputManager.cs,ProcessStack,The method has an empty catch block.
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,GridLengthConverter,C:\repos\grokys_Avalonia\Avalonia\GridLengthConverter.cs,ConvertFrom,The following statement contains a magic number: if (s == "Auto")              {                  type = GridUnitType.Auto;              }              else if (s.EndsWith("*"))              {                  type = GridUnitType.Star;                  s = s.Substring(0' s.Length - 1);                  canBeEmptyString = true;              }              else if (s.EndsWith("px"))              {                  s = s.Substring(0' s.Length - 2);              }              else if (s.EndsWith("in"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96;              }              else if (s.EndsWith("cm"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 2.54;              }              else if (s.EndsWith("pt"))              {                  s = s.Substring(0' s.Length - 2);                  scale = 96.0 / 72.0;              }
Magic Number,Avalonia,ThicknessConverter,C:\repos\grokys_Avalonia\Avalonia\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new Thickness(double.Parse(components[0]));              }              else              {                  if (components.Length == 2)                  {                      return new Thickness(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[0])'                          double.Parse(components[1]));                  }                  else                  {                      if (components.Length == 4)                      {                          return new Thickness(                              double.Parse(components[0])'                              double.Parse(components[1])'                              double.Parse(components[2])'                              double.Parse(components[3]));                      }                      else                      {                          throw new NotSupportedException("Value is not valid: must contain one' two or four delineated lengths.");                      }                  }              }
Magic Number,Avalonia,ThicknessConverter,C:\repos\grokys_Avalonia\Avalonia\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new Thickness(double.Parse(components[0]));              }              else              {                  if (components.Length == 2)                  {                      return new Thickness(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[0])'                          double.Parse(components[1]));                  }                  else                  {                      if (components.Length == 4)                      {                          return new Thickness(                              double.Parse(components[0])'                              double.Parse(components[1])'                              double.Parse(components[2])'                              double.Parse(components[3]));                      }                      else                      {                          throw new NotSupportedException("Value is not valid: must contain one' two or four delineated lengths.");                      }                  }              }
Magic Number,Avalonia,ThicknessConverter,C:\repos\grokys_Avalonia\Avalonia\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new Thickness(double.Parse(components[0]));              }              else              {                  if (components.Length == 2)                  {                      return new Thickness(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[0])'                          double.Parse(components[1]));                  }                  else                  {                      if (components.Length == 4)                      {                          return new Thickness(                              double.Parse(components[0])'                              double.Parse(components[1])'                              double.Parse(components[2])'                              double.Parse(components[3]));                      }                      else                      {                          throw new NotSupportedException("Value is not valid: must contain one' two or four delineated lengths.");                      }                  }              }
Magic Number,Avalonia,ThicknessConverter,C:\repos\grokys_Avalonia\Avalonia\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new Thickness(double.Parse(components[0]));              }              else              {                  if (components.Length == 2)                  {                      return new Thickness(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[0])'                          double.Parse(components[1]));                  }                  else                  {                      if (components.Length == 4)                      {                          return new Thickness(                              double.Parse(components[0])'                              double.Parse(components[1])'                              double.Parse(components[2])'                              double.Parse(components[3]));                      }                      else                      {                          throw new NotSupportedException("Value is not valid: must contain one' two or four delineated lengths.");                      }                  }              }
Magic Number,Avalonia,CornerRadiusConverter,C:\repos\grokys_Avalonia\Avalonia\CornerRadiusConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new CornerRadius(double.Parse(components[0]));              }              else              {                  if (components.Length == 4)                  {                      return new CornerRadius(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[2])'                          double.Parse(components[3]));                  }                  else                  {                      throw new NotSupportedException("Value is not valid: must contain one or four delineated lengths.");                  }              }
Magic Number,Avalonia,CornerRadiusConverter,C:\repos\grokys_Avalonia\Avalonia\CornerRadiusConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new CornerRadius(double.Parse(components[0]));              }              else              {                  if (components.Length == 4)                  {                      return new CornerRadius(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[2])'                          double.Parse(components[3]));                  }                  else                  {                      throw new NotSupportedException("Value is not valid: must contain one or four delineated lengths.");                  }              }
Magic Number,Avalonia,CornerRadiusConverter,C:\repos\grokys_Avalonia\Avalonia\CornerRadiusConverter.cs,ConvertFrom,The following statement contains a magic number: if (components.Length == 1)              {                  return new CornerRadius(double.Parse(components[0]));              }              else              {                  if (components.Length == 4)                  {                      return new CornerRadius(                          double.Parse(components[0])'                          double.Parse(components[1])'                          double.Parse(components[2])'                          double.Parse(components[3]));                  }                  else                  {                      throw new NotSupportedException("Value is not valid: must contain one or four delineated lengths.");                  }              }
Magic Number,Avalonia,FrameworkElement,C:\repos\grokys_Avalonia\Avalonia\FrameworkElement.cs,ArrangeCore,The following statement contains a magic number: switch (this.HorizontalAlignment)              {                  case HorizontalAlignment.Center:                      origin.X += (finalRect.Width - size.Width) / 2;                      break;                  case HorizontalAlignment.Right:                      origin.X += finalRect.Width - size.Width;                      break;              }
Magic Number,Avalonia,FrameworkElement,C:\repos\grokys_Avalonia\Avalonia\FrameworkElement.cs,ArrangeCore,The following statement contains a magic number: switch (this.VerticalAlignment)              {                  case VerticalAlignment.Center:                      origin.Y += (finalRect.Height - size.Height) / 2;                      break;                  case VerticalAlignment.Bottom:                      origin.Y += finalRect.Height - size.Height;                      break;              }
Magic Number,Avalonia,Point,C:\repos\grokys_Avalonia\Avalonia\Point.cs,Parse,The following statement contains a magic number: if (points.Length < 2)              {                  throw new InvalidOperationException("source does not contain two numbers");              }
Magic Number,Avalonia,Point,C:\repos\grokys_Avalonia\Avalonia\Point.cs,Parse,The following statement contains a magic number: if (points.Length > 2)              {                  throw new InvalidOperationException("source contains too many delimiters");              }
Magic Number,Avalonia,Rect,C:\repos\grokys_Avalonia\Avalonia\Rect.cs,Inflate,The following statement contains a magic number: if (width < rect.Width * -2)              {                  return Rect.Empty;              }
Magic Number,Avalonia,Rect,C:\repos\grokys_Avalonia\Avalonia\Rect.cs,Inflate,The following statement contains a magic number: if (height < rect.Height * -2)              {                  return Rect.Empty;              }
Magic Number,Avalonia,Rect,C:\repos\grokys_Avalonia\Avalonia\Rect.cs,Inflate,The following statement contains a magic number: this.width += 2 * width;
Magic Number,Avalonia,Rect,C:\repos\grokys_Avalonia\Avalonia\Rect.cs,Inflate,The following statement contains a magic number: this.height += 2 * height;
Magic Number,Avalonia,Thickness,C:\repos\grokys_Avalonia\Avalonia\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = (hash * 23) + this.Left.GetHashCode();                  hash = (hash * 23) + this.Top.GetHashCode();                  hash = (hash * 23) + this.Right.GetHashCode();                  hash = (hash * 23) + this.Bottom.GetHashCode();                  return hash;              }
Magic Number,Avalonia,Thickness,C:\repos\grokys_Avalonia\Avalonia\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = (hash * 23) + this.Left.GetHashCode();                  hash = (hash * 23) + this.Top.GetHashCode();                  hash = (hash * 23) + this.Right.GetHashCode();                  hash = (hash * 23) + this.Bottom.GetHashCode();                  return hash;              }
Magic Number,Avalonia,Thickness,C:\repos\grokys_Avalonia\Avalonia\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = (hash * 23) + this.Left.GetHashCode();                  hash = (hash * 23) + this.Top.GetHashCode();                  hash = (hash * 23) + this.Right.GetHashCode();                  hash = (hash * 23) + this.Bottom.GetHashCode();                  return hash;              }
Magic Number,Avalonia,Thickness,C:\repos\grokys_Avalonia\Avalonia\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = (hash * 23) + this.Left.GetHashCode();                  hash = (hash * 23) + this.Top.GetHashCode();                  hash = (hash * 23) + this.Right.GetHashCode();                  hash = (hash * 23) + this.Bottom.GetHashCode();                  return hash;              }
Magic Number,Avalonia,Thickness,C:\repos\grokys_Avalonia\Avalonia\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = (hash * 23) + this.Left.GetHashCode();                  hash = (hash * 23) + this.Top.GetHashCode();                  hash = (hash * 23) + this.Right.GetHashCode();                  hash = (hash * 23) + this.Bottom.GetHashCode();                  return hash;              }
Magic Number,Avalonia,Vector,C:\repos\grokys_Avalonia\Avalonia\Vector.cs,AngleBetween,The following statement contains a magic number: return Math.Acos(cos_theta) / Math.PI * 180;
Magic Number,Avalonia.Controls,Image,C:\repos\grokys_Avalonia\Avalonia\Controls\Image.cs,OnRender,The following statement contains a magic number: if (source != null)              {                  Rect sourceRect = new Rect(0' 0' source.PixelWidth' source.PixelHeight);                  Rect destRect = new Rect(this.RenderSize);                    switch (this.Stretch)                  {                      case Stretch.None:                          sourceRect = new Rect(                              0'                              0'                              Math.Min(this.ActualWidth' source.PixelWidth)'                              Math.Min(this.ActualHeight' source.PixelHeight));                          break;                        case Stretch.Uniform:                      {                          double scale = Math.Min(                              this.DesiredSize.Width / source.PixelWidth'                               this.DesiredSize.Height / source.PixelHeight);                          double scaledWidth = source.PixelWidth * scale;                          double scaledHeight = source.PixelHeight * scale;                          destRect = new Rect(                              (this.ActualWidth - scaledWidth) / 2'                              (this.ActualHeight - scaledHeight) / 2'                              scaledWidth'                              scaledHeight);                          break;                      }                        case Stretch.UniformToFill:                      {                          double scale = Math.Max(                              this.DesiredSize.Width / source.PixelWidth'                              this.DesiredSize.Height / source.PixelHeight);                          sourceRect = new Rect(                              0'                              0'                              this.ActualWidth / scale'                              this.ActualHeight / scale);                          break;                      }                  }                    drawingContext.DrawImage(source' 1' sourceRect' destRect);              }
Magic Number,Avalonia.Controls,Image,C:\repos\grokys_Avalonia\Avalonia\Controls\Image.cs,OnRender,The following statement contains a magic number: if (source != null)              {                  Rect sourceRect = new Rect(0' 0' source.PixelWidth' source.PixelHeight);                  Rect destRect = new Rect(this.RenderSize);                    switch (this.Stretch)                  {                      case Stretch.None:                          sourceRect = new Rect(                              0'                              0'                              Math.Min(this.ActualWidth' source.PixelWidth)'                              Math.Min(this.ActualHeight' source.PixelHeight));                          break;                        case Stretch.Uniform:                      {                          double scale = Math.Min(                              this.DesiredSize.Width / source.PixelWidth'                               this.DesiredSize.Height / source.PixelHeight);                          double scaledWidth = source.PixelWidth * scale;                          double scaledHeight = source.PixelHeight * scale;                          destRect = new Rect(                              (this.ActualWidth - scaledWidth) / 2'                              (this.ActualHeight - scaledHeight) / 2'                              scaledWidth'                              scaledHeight);                          break;                      }                        case Stretch.UniformToFill:                      {                          double scale = Math.Max(                              this.DesiredSize.Width / source.PixelWidth'                              this.DesiredSize.Height / source.PixelHeight);                          sourceRect = new Rect(                              0'                              0'                              this.ActualWidth / scale'                              this.ActualHeight / scale);                          break;                      }                  }                    drawingContext.DrawImage(source' 1' sourceRect' destRect);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      this.ExpandStarCols(totalSize);                      this.ExpandStarRows(totalSize);                  }                    foreach (UIElement child in VisualTreeHelper.GetChildren(this))                  {                      int col' row;                      int colspan' rowspan;                      Size childSize = new Size(0' 0);                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= this.rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= this.rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= this.colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= this.colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                         // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSize.Width = double.PositiveInfinity;                          childSize.Height = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSize.Height = double.PositiveInfinity;                          }                            childSize.Width = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSize.Height = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSize.Height = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSize.Width = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSize.Height += this.rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSize.Width += this.colMatrix[c' c].OfferedSize;                      }                        child.Measure(childSize);                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(this.rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(this.colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      this.AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      this.ExpandStarCols(totalSize);                      this.ExpandStarRows(totalSize);                  }                    foreach (UIElement child in VisualTreeHelper.GetChildren(this))                  {                      int col' row;                      int colspan' rowspan;                      Size childSize = new Size(0' 0);                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= this.rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= this.rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= this.colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= this.colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                         // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSize.Width = double.PositiveInfinity;                          childSize.Height = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSize.Height = double.PositiveInfinity;                          }                            childSize.Width = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSize.Height = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSize.Height = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSize.Width = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSize.Height += this.rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSize.Width += this.colMatrix[c' c].OfferedSize;                      }                        child.Measure(childSize);                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(this.rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(this.colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      this.AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      this.ExpandStarCols(totalSize);                      this.ExpandStarRows(totalSize);                  }                    foreach (UIElement child in VisualTreeHelper.GetChildren(this))                  {                      int col' row;                      int colspan' rowspan;                      Size childSize = new Size(0' 0);                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= this.rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= this.rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= this.colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= this.colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                         // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSize.Width = double.PositiveInfinity;                          childSize.Height = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSize.Height = double.PositiveInfinity;                          }                            childSize.Width = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSize.Height = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSize.Height = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSize.Width = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSize.Height += this.rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSize.Width += this.colMatrix[c' c].OfferedSize;                      }                        child.Measure(childSize);                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(this.rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(this.colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      this.AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      this.ExpandStarCols(totalSize);                      this.ExpandStarRows(totalSize);                  }                    foreach (UIElement child in VisualTreeHelper.GetChildren(this))                  {                      int col' row;                      int colspan' rowspan;                      Size childSize = new Size(0' 0);                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= this.rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= this.rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= this.colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= this.colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                         // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSize.Width = double.PositiveInfinity;                          childSize.Height = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSize.Height = double.PositiveInfinity;                          }                            childSize.Width = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSize.Height = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSize.Height = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSize.Width = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSize.Height += this.rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSize.Width += this.colMatrix[c' c].OfferedSize;                      }                        child.Measure(childSize);                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(this.rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(this.colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      this.AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      this.ExpandStarCols(totalSize);                      this.ExpandStarRows(totalSize);                  }                    foreach (UIElement child in VisualTreeHelper.GetChildren(this))                  {                      int col' row;                      int colspan' rowspan;                      Size childSize = new Size(0' 0);                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= this.rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= this.rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= this.colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= this.colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                         // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSize.Width = double.PositiveInfinity;                          childSize.Height = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSize.Height = double.PositiveInfinity;                          }                            childSize.Width = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSize.Height = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSize.Height = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSize.Width = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSize.Height += this.rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSize.Width += this.colMatrix[c' c].OfferedSize;                      }                        child.Measure(childSize);                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(this.rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(this.colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      this.AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Avalonia\Avalonia\Controls\Grid.cs,AllocateDesiredSize,The following statement contains a magic number: for (int i = 0; i < 2; i++)               {                  Segment['] matrix = i == 0 ? this.rowMatrix : this.colMatrix;                  int count = i == 0 ? rowCount : colCount;                    for (int row = count - 1; row >= 0; row--)                   {                      for (int col = row; col >= 0; col--)                       {                          bool spansStar = false;                          for (int j = row; j >= col; j--)                          {                              spansStar |= matrix[j' j].Type == GridUnitType.Star;                          }                            // This is the amount of pixels which must be available between the grid rows                          // at index 'col' and 'row'. i.e. if 'row' == 0 and 'col' == 2' there must                          // be at least 'matrix [row][col].size' pixels of height allocated between                          // all the rows in the range col -> row.                          double current = matrix[row' col].DesiredSize;                            // Count how many pixels have already been allocated between the grid rows                          // in the range col -> row. The amount of pixels allocated to each grid row/column                          // is found on the diagonal of the matrix.                          double totalAllocated = 0;                                                    for (int k = row; k >= col; k--)                          {                              totalAllocated += matrix[k' k].DesiredSize;                          }                            // If the size requirement has not been met' allocate the additional required                          // size between 'pixel' rows' then 'star' rows' finally 'auto' rows' until all                          // height has been assigned.                          if (totalAllocated < current)                           {                              double additional = current - totalAllocated;                                if (spansStar)                               {                                  this.AssignSize(matrix' col' row' ref additional' GridUnitType.Star' true);                              }                               else                               {                                  this.AssignSize(matrix' col' row' ref additional' GridUnitType.Pixel' true);                                  this.AssignSize(matrix' col' row' ref additional' GridUnitType.Auto' true);                              }                          }                      }                  }              }
Magic Number,Avalonia.Controls,RangeCollection,C:\repos\grokys_Avalonia\Avalonia\Controls\RangeCollection.cs,FindRangeIndexForValue,The following statement contains a magic number: while (min <= max)              {                  int mid = min + ((max - min) / 2);                  Range range = this.ranges[mid];                  if (value >= range.Start && value <= range.End)                  {                      return mid;    // In Range                  }                  else                  {                      if (value < range.Start)                      {                          max = mid - 1; // Below Range                      }                      else                      {                          min = mid + 1; // Above Range                      }                  }              }
Magic Number,Avalonia.Controls,RangeCollection,C:\repos\grokys_Avalonia\Avalonia\Controls\RangeCollection.cs,FindInsertionPosition,The following statement contains a magic number: while (min <= max)              {                  int mid = min + ((max - min) / 2);                  int cmp = CompareRanges(this.ranges[mid]' range);                    if (cmp == 0)                  {                      return mid;                  }                  else                  {                      if (cmp > 0)                      {                          if (mid > 0 && CompareRanges(this.ranges[mid - 1]' range) < 0)                          {                              return mid;                          }                            max = mid - 1;                      }                      else                      {                          min = mid + 1;                      }                  }              }
Magic Number,Avalonia.Controls,Border,C:\repos\grokys_Avalonia\Avalonia\Controls\Border.cs,OnRender,The following statement contains a magic number: if (this.BorderBrush != null && !this.BorderThickness.IsEmpty)              {                  pen = new Pen(this.BorderBrush' this.BorderThickness.Left);                    double penOffset = -(pen.Thickness / 2);                  brushRect.Inflate(-pen.Thickness' -pen.Thickness);                  penRect.Inflate(penOffset' penOffset);              }
Magic Number,Avalonia.Media,PathMarkupParser,C:\repos\grokys_Avalonia\Avalonia\Media\PathMarkupParser.cs,ReadCommand,The following statement contains a magic number: if (i == -1)              {                  return Command.Eof;              }              else              {                  char c = (char)i;                  Command command = Command.None;                  bool canMove = lastCommand == Command.None || lastCommand == Command.FillRule;                    if (!Commands.TryGetValue(c' out command))                  {                      if ((char.IsDigit(c) || c == '.' || c == '+' || c == '-') &&                           (lastCommand != Command.None))                      {                          return lastCommand;                      }                      else                      {                          throw new InvalidDataException("Unexpected path command '" + c + "'.");                      }                  }                    if (!canMove && command <= Command.MoveRelative)                  {                      command += 2;                  }                    reader.Read();                  return command;              }
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgr101010 = new PixelFormat("Bgr101010"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgr24 = new PixelFormat("Bgr24"' 24);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgr32 = new PixelFormat("Bgr32"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgr555 = new PixelFormat("Bgr555"' 16);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgr565 = new PixelFormat("Bgr565"' 16);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Bgra32 = new PixelFormat("Bgra32"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Cmyk32 = new PixelFormat("Cmyk32"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Gray16 = new PixelFormat("Gray16"' 16);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Gray2 = new PixelFormat("Gray2"' 2);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Gray32Float = new PixelFormat("Gray32Float"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Gray4 = new PixelFormat("Gray4"' 4);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Gray8 = new PixelFormat("Gray8"' 8);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Indexed2 = new PixelFormat("Indexed2"' 2);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Indexed4 = new PixelFormat("Indexed4"' 4);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Indexed8 = new PixelFormat("Indexed8"' 8);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Pbgra32 = new PixelFormat("Pbgra32"' 32);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Prgba128Float = new PixelFormat("Prgba128Float"' 128);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Prgba64 = new PixelFormat("Prgba64"' 64);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Rgb128Float = new PixelFormat("Rgb128Float"' 128);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Rgb24 = new PixelFormat("Rgb24"' 24);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Rgb48 = new PixelFormat("Rgb48"' 48);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Rgba128Float = new PixelFormat("Rgba128Float"' 128);
Magic Number,Avalonia.Media,PixelFormats,C:\repos\grokys_Avalonia\Avalonia\Media\PixelFormats.cs,PixelFormats,The following statement contains a magic number: Rgba64 = new PixelFormat("Rgba64"' 64);
Magic Number,Avalonia.Media,BrushConverter,C:\repos\grokys_Avalonia\Avalonia\Media\BrushConverter.cs,ConvertFrom,The following statement contains a magic number: if (s.StartsWith("#"))              {                  s = s.Substring(1);                    if (s.Length == 6)                  {                      s = "ff" + s;                  }                    if (s.Length != 8)                  {                      throw new NotSupportedException("Invalid color string.");                  }                    return new SolidColorBrush(Color.FromUInt32(uint.Parse(s' NumberStyles.HexNumber)));              }              else              {                  PropertyInfo p = typeof(Colors).GetProperty(s' BindingFlags.Public | BindingFlags.Static);                    if (p != null)                  {                      return new SolidColorBrush((Color)p.GetValue(null));                  }                  else                  {                      throw new NotSupportedException();                  }              }
Magic Number,Avalonia.Media,BrushConverter,C:\repos\grokys_Avalonia\Avalonia\Media\BrushConverter.cs,ConvertFrom,The following statement contains a magic number: if (s.StartsWith("#"))              {                  s = s.Substring(1);                    if (s.Length == 6)                  {                      s = "ff" + s;                  }                    if (s.Length != 8)                  {                      throw new NotSupportedException("Invalid color string.");                  }                    return new SolidColorBrush(Color.FromUInt32(uint.Parse(s' NumberStyles.HexNumber)));              }              else              {                  PropertyInfo p = typeof(Colors).GetProperty(s' BindingFlags.Public | BindingFlags.Static);                    if (p != null)                  {                      return new SolidColorBrush((Color)p.GetValue(null));                  }                  else                  {                      throw new NotSupportedException();                  }              }
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,FromUInt32,The following statement contains a magic number: return new Color              {                  A = (byte)((value >> 24) & 0xff)'                  R = (byte)((value >> 16) & 0xff)'                  G = (byte)((value >> 8) & 0xff)'                  B = (byte)(value & 0xff)'              };
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,FromUInt32,The following statement contains a magic number: return new Color              {                  A = (byte)((value >> 24) & 0xff)'                  R = (byte)((value >> 16) & 0xff)'                  G = (byte)((value >> 8) & 0xff)'                  B = (byte)(value & 0xff)'              };
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,FromUInt32,The following statement contains a magic number: return new Color              {                  A = (byte)((value >> 24) & 0xff)'                  R = (byte)((value >> 16) & 0xff)'                  G = (byte)((value >> 8) & 0xff)'                  B = (byte)(value & 0xff)'              };
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToString,The following statement contains a magic number: uint rgb = ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToString,The following statement contains a magic number: uint rgb = ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToString,The following statement contains a magic number: uint rgb = ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToUint32,The following statement contains a magic number: return ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToUint32,The following statement contains a magic number: return ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Color,C:\repos\grokys_Avalonia\Avalonia\Media\Color.cs,ToUint32,The following statement contains a magic number: return ((uint)this.A << 24) | ((uint)this.R << 16) | ((uint)this.G << 8) | (uint)this.B;
Magic Number,Avalonia.Media,Matrix,C:\repos\grokys_Avalonia\Avalonia\Media\Matrix.cs,Rotate,The following statement contains a magic number: double theta = angle * Math.PI / 180;
Magic Number,Avalonia.Media,Matrix,C:\repos\grokys_Avalonia\Avalonia\Media\Matrix.cs,Skew,The following statement contains a magic number: Matrix skew_m = new Matrix(                  1'                  Math.Tan(skewY * Math.PI / 180)'                  Math.Tan(skewX * Math.PI / 180)'                  1'                  0'                  0);
Magic Number,Avalonia.Media,Matrix,C:\repos\grokys_Avalonia\Avalonia\Media\Matrix.cs,Skew,The following statement contains a magic number: Matrix skew_m = new Matrix(                  1'                  Math.Tan(skewY * Math.PI / 180)'                  Math.Tan(skewX * Math.PI / 180)'                  1'                  0'                  0);
Magic Number,Avalonia.Shapes,Shape,C:\repos\grokys_Avalonia\Avalonia\Shapes\Shape.cs,OnRender,The following statement contains a magic number: if (this.Stretch != Stretch.None)              {                  double scaleX = this.ActualWidth / shapeBounds.Width;                  double scaleY = this.ActualHeight / shapeBounds.Height;                    switch (this.Stretch)                  {                      case Stretch.Uniform:                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                        case Stretch.UniformToFill:                          // Hmm' in WPF appears to be the same as Uniform. This can't be right...                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                  }                    matrix.Translate(-shapeBounds.X' -shapeBounds.Y);                  matrix.Scale(scaleX' scaleY);                  matrix.Translate(                      (this.ActualWidth - (shapeBounds.Width * scaleX)) / 2'                      (this.ActualHeight - (shapeBounds.Height * scaleY)) / 2);              }
Magic Number,Avalonia.Shapes,Shape,C:\repos\grokys_Avalonia\Avalonia\Shapes\Shape.cs,OnRender,The following statement contains a magic number: if (this.Stretch != Stretch.None)              {                  double scaleX = this.ActualWidth / shapeBounds.Width;                  double scaleY = this.ActualHeight / shapeBounds.Height;                    switch (this.Stretch)                  {                      case Stretch.Uniform:                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                        case Stretch.UniformToFill:                          // Hmm' in WPF appears to be the same as Uniform. This can't be right...                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                  }                    matrix.Translate(-shapeBounds.X' -shapeBounds.Y);                  matrix.Scale(scaleX' scaleY);                  matrix.Translate(                      (this.ActualWidth - (shapeBounds.Width * scaleX)) / 2'                      (this.ActualHeight - (shapeBounds.Height * scaleY)) / 2);              }
Magic Number,Avalonia.Threading,PokableQueue,C:\repos\grokys_Avalonia\Avalonia\Threading\Dispatcher.cs,Grow,The following statement contains a magic number: int newc = this.array.Length * 2;
Missing Default,Avalonia,TemplateContentLoader,C:\repos\grokys_Avalonia\Avalonia\TemplateContentLoader.cs,Load,The following switch statement is missing a default case: switch (xamlReader.NodeType)                      {                          case XamlNodeType.StartObject:                              currentType = xamlReader.Type.UnderlyingType;                              break;                            case XamlNodeType.StartMember:                              // HACK: This matches any Name property. Should probably just match                              // FrameworkElement and x:Name but this'll do for now...                              if (xamlReader.Member.Name == "Name")                              {                                  nextValueIsName = true;                              }                                break;                            case XamlNodeType.Value:                              if (nextValueIsName)                              {                                  typesByName.Add((string)xamlReader.Value' currentType);                                  nextValueIsName = false;                              }                                                            break;                      }
Missing Default,Avalonia,FrameworkElement,C:\repos\grokys_Avalonia\Avalonia\FrameworkElement.cs,ArrangeCore,The following switch statement is missing a default case: switch (this.HorizontalAlignment)              {                  case HorizontalAlignment.Center:                      origin.X += (finalRect.Width - size.Width) / 2;                      break;                  case HorizontalAlignment.Right:                      origin.X += finalRect.Width - size.Width;                      break;              }
Missing Default,Avalonia,FrameworkElement,C:\repos\grokys_Avalonia\Avalonia\FrameworkElement.cs,ArrangeCore,The following switch statement is missing a default case: switch (this.VerticalAlignment)              {                  case VerticalAlignment.Center:                      origin.Y += (finalRect.Height - size.Height) / 2;                      break;                  case VerticalAlignment.Bottom:                      origin.Y += finalRect.Height - size.Height;                      break;              }
Missing Default,Avalonia.Controls,Image,C:\repos\grokys_Avalonia\Avalonia\Controls\Image.cs,OnRender,The following switch statement is missing a default case: switch (this.Stretch)                  {                      case Stretch.None:                          sourceRect = new Rect(                              0'                              0'                              Math.Min(this.ActualWidth' source.PixelWidth)'                              Math.Min(this.ActualHeight' source.PixelHeight));                          break;                        case Stretch.Uniform:                      {                          double scale = Math.Min(                              this.DesiredSize.Width / source.PixelWidth'                               this.DesiredSize.Height / source.PixelHeight);                          double scaledWidth = source.PixelWidth * scale;                          double scaledHeight = source.PixelHeight * scale;                          destRect = new Rect(                              (this.ActualWidth - scaledWidth) / 2'                              (this.ActualHeight - scaledHeight) / 2'                              scaledWidth'                              scaledHeight);                          break;                      }                        case Stretch.UniformToFill:                      {                          double scale = Math.Max(                              this.DesiredSize.Width / source.PixelWidth'                              this.DesiredSize.Height / source.PixelHeight);                          sourceRect = new Rect(                              0'                              0'                              this.ActualWidth / scale'                              this.ActualHeight / scale);                          break;                      }                  }
Missing Default,Avalonia.Controls,Image,C:\repos\grokys_Avalonia\Avalonia\Controls\Image.cs,MeasureOverride,The following switch statement is missing a default case: switch (this.Stretch)              {                  case Stretch.Uniform:                      sx = sy = Math.Min(sx' sy);                      break;                  case Stretch.UniformToFill:                      sx = sy = Math.Max(sx' sy);                      break;                  case Stretch.Fill:                      if (double.IsInfinity(constraint.Width))                      {                          sx = sy;                      }                        if (double.IsInfinity(constraint.Height))                      {                          sy = sx;                      }                        break;                  case Stretch.None:                      sx = sy = 1;                      break;              }
Missing Default,Avalonia.Controls,ItemsControl,C:\repos\grokys_Avalonia\Avalonia\Controls\ItemsControl.cs,InvokeItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      this.SetLogicalParent(this' e.NewItems);                      break;                  case NotifyCollectionChangedAction.Remove:                      this.SetLogicalParent(null' e.OldItems);                      break;                  case NotifyCollectionChangedAction.Replace:                      this.SetLogicalParent(null' e.OldItems);                      this.SetLogicalParent(this' e.NewItems);                      break;              }
Missing Default,Avalonia.Controls,ItemsControl,C:\repos\grokys_Avalonia\Avalonia\Controls\ItemsControl.cs,OnItemContainerGeneratorChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Reset:                      // the list has gone away' so clear the children of the panel                      if (panel.InternalChildren.Count > 0)                      {                          this.RemoveItemsFromPresenter(new GeneratorPosition(0' 0)' panel.InternalChildren.Count);                      }                        break;                  case NotifyCollectionChangedAction.Add:                      this.AddItemsToPresenter(e.Position' e.ItemCount);                      break;                  case NotifyCollectionChangedAction.Remove:                      this.RemoveItemsFromPresenter(e.Position' e.ItemCount);                      break;                  case NotifyCollectionChangedAction.Replace:                      this.RemoveItemsFromPresenter(e.Position' e.ItemCount);                      this.AddItemsToPresenter(e.Position' e.ItemCount);                      break;              }
Missing Default,Avalonia.Controls,TextBox,C:\repos\grokys_Avalonia\Avalonia\Controls\TextBox.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Left:                      --this.CaretIndex;                      break;                                    case Key.Right:                      ++this.CaretIndex;                      break;                    case Key.Back:                      if (this.caretIndex > 0)                      {                                                  this.Text = text.Substring(0' this.caretIndex - 1) + text.Substring(this.caretIndex);                          --this.CaretIndex;                      }                        break;                    case Key.Delete:                      if (this.caretIndex < text.Length)                      {                          this.Text = text.Substring(0' this.caretIndex) + text.Substring(this.caretIndex + 1);                      }                        break;              }
Missing Default,Avalonia.Controls,UIElementCollection,C:\repos\grokys_Avalonia\Avalonia\Controls\UIElementCollection.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      foreach (UIElement element in e.NewItems)                      {                          this.SetLogicalParent(element);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (UIElement element in e.OldItems)                      {                          this.ClearLogicalParent(element);                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (UIElement element in e.OldItems)                      {                          this.ClearLogicalParent(element);                      }                        foreach (UIElement element in e.NewItems)                      {                          this.SetLogicalParent(element);                      }                        break;              }
Missing Default,Avalonia.Data,BindingExpression,C:\repos\grokys_Avalonia\Avalonia\Data\BindingExpression.cs,RewritePath,The following switch statement is missing a default case: switch (this.ParentBinding.RelativeSource.Mode)                      {                          case RelativeSourceMode.TemplatedParent:                              if (fe != null)                              {                                  prefix = "TemplatedParent";                              }                                break;                      }
Missing Default,Avalonia.Shapes,Shape,C:\repos\grokys_Avalonia\Avalonia\Shapes\Shape.cs,OnRender,The following switch statement is missing a default case: switch (this.Stretch)                  {                      case Stretch.Uniform:                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                        case Stretch.UniformToFill:                          // Hmm' in WPF appears to be the same as Uniform. This can't be right...                          scaleX = scaleY = Math.Min(scaleX' scaleY);                          break;                  }
Missing Default,Avalonia.Input,KeyboardDevice,C:\repos\grokys_Avalonia\Avalonia\Input\KeyboardDevice.cs,PreProcessKeyboardInput,The following switch statement is missing a default case: switch (rawKeyEvent.Type)                      {                          case RawKeyEventType.KeyDown:                              KeyEventArgs ek = new KeyEventArgs(                                  (KeyboardDevice)rawKeyEvent.Device'                                  Mouse.PrimaryDevice.ActiveSource'                                  rawKeyEvent.Timestamp'                                  rawKeyEvent.Key);                              ek.RoutedEvent = Keyboard.KeyDownEvent;                              InputManager.Current.ProcessInput(ek);                              e.Cancel();                              break;                      }
Missing Default,Avalonia.Input,MouseDevice,C:\repos\grokys_Avalonia\Avalonia\Input\MouseDevice.cs,ProcessRawMouseEvent,The following switch statement is missing a default case: switch (input.Type)              {                  case RawMouseEventType.Move:                      e = new MouseEventArgs(this' input.Timestamp);                      e.RoutedEvent = UIElement.MouseMoveEvent;                      break;                    case RawMouseEventType.LeftButtonDown:                      e = new MouseButtonEventArgs(this' input.Timestamp);                      e.RoutedEvent = UIElement.MouseLeftButtonDownEvent;                      break;                    case RawMouseEventType.LeftButtonUp:                      e = new MouseButtonEventArgs(this' input.Timestamp);                      e.RoutedEvent = UIElement.MouseLeftButtonUpEvent;                      break;              }
