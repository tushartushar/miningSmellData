Implementation smell,Namespace,Class,File,Method,Description
Long Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The method has 110 lines of code.
Complex Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeLocalVariables,Cyclomatic complexity of the method is 12
Complex Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,Cyclomatic complexity of the method is 13
Complex Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,MakeSubstitution,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,ReduceAddition,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,ReducePowers,Cyclomatic complexity of the method is 9
Complex Method,MathExpressionsNET,ValueNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\ValueNode.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,FromDecimal,Cyclomatic complexity of the method is 13
Complex Method,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,Equals,Cyclomatic complexity of the method is 8
Long Parameter List,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,MathFunc,The method has 5 parameters. Parameters: root' variable' parameters' calculateConstants' simplify
Long Parameter List,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,MathFunc,The method has 6 parameters. Parameters: left' right' variable' parameters' simplify' calculateConstants
Long Parameter List,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,FromDecimal,The method has 6 parameters. Parameters: value' result' decimalPlaces' trimZeroes' minPeriodRepeat' digitsForReal
Long Statement,MathExpressionsNET,MathFuncAssemblyCecil,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncAssemblyCecil.cs,Init,The length of the statement  "			var methodAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName; " is 140.
Long Statement,MathExpressionsNET,MathFuncAssemblyCecil,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncAssemblyCecil.cs,Init,The length of the statement  "			method.Body.Instructions.Add(Instruction.Create(OpCodes.Call' Assembly.MainModule.Import(typeof(object).GetConstructor(new Type[0])))); " is 135.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,Compile,The length of the statement  "				MethodAttributes.Public | MethodAttributes.HideBySig | (Static ? MethodAttributes.Static : 0)' mathFuncAssembly.DoubleType); " is 124.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,AddFuncArgs,The length of the statement  "				method.Parameters.Add(new ParameterDefinition(param.Value.Name' ParameterAttributes.None' MathFuncAssembly.DoubleType)); " is 120.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitMultFunc,The length of the statement  "				return !(func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Childs[1].LessThenZero()); " is 128.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitMultFunc,The length of the statement  "				if (func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Childs[1].LessThenZero()) " is 122.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitMultFunc,The length of the statement  "					if (IlInstructions[IlInstructions.Count - 1].OpCode == OpCodes.Ldc_R8 && (double)IlInstructions[IlInstructions.Count - 1].Arg == 1.0) " is 133.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The length of the statement  "					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType])); " is 120.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitKnownFunc,The length of the statement  "			if (funcNode.FunctionType != null && MathFuncAssembly.TypesReferences.TryGetValue((KnownFuncType)funcNode.FunctionType' out value)) " is 131.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,Precompile,The length of the statement  "				if (node.Childs.Count > 0 && node.Childs.All(child => child.Type == MathNodeType.Value || child.Type == MathNodeType.Calculated)) " is 129.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,Simplify,The length of the statement  "						else if (funcNode.Childs[0].Type == MathNodeType.Function && ((FuncNode)funcNode.Childs[0]).FunctionType == KnownFuncType.Neg) " is 126.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,Simplify,The length of the statement  "									(MathFuncNode)(new ValueNode(-((ValueNode)powerNode).Value)) : new FuncNode(KnownFuncType.Neg' powerNode)) : powerNode); " is 120.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,MultValues,The length of the statement  "				.Where(child => child.Type != MathNodeType.Value && !(child.Type == MathNodeType.Function && ((FuncNode)child).FunctionType == KnownFuncType.Neg)) " is 146.
Long Statement,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,ExpValue,The length of the statement  "						return new FuncNode(KnownFuncType.Neg' new FuncNode(KnownFuncType.Pow' funcNode.Childs[0].Childs[0]' new ValueNode(bValue.Value))); " is 131.
Long Statement,MathExpressionsNET,MathFuncGenerator,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,The length of the statement  "					return new ValueNode(Rational<long>.Approximate((decimal)(MinValue + _rand.NextDouble() * (MaxValue - MinValue))' 0.001m)); " is 123.
Long Statement,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,BuildTryParser,The length of the statement  "				throw new InvalidOperationException("Underlying Rational type T must support TryParse in order to try-parse Rational<T>."); " is 123.
Long Statement,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,ToDouble,The length of the statement  "			double denominator = provider != null ? this.denominator.ToDouble(provider) : this.denominator.ToDouble(CultureInfo.InvariantCulture); " is 134.
Long Statement,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,ToDouble,The length of the statement  "			return provider != null ? numerator.ToDouble(provider) : numerator.ToDouble(CultureInfo.InvariantCulture) / denominator; " is 120.
Complex Conditional,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitMultFunc,The conditional expression  "func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Childs[1].LessThenZero()"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The conditional expression  "(funcNode.Childs[1].Type == MathNodeType.Value && ((ValueNode)funcNode.Childs[1]).Value.IsInteger) ||  				(funcNode.Childs[1].Type == MathNodeType.Calculated && ((CalculatedNode)funcNode.Childs[1]).Value % 1 == 0)"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The conditional expression  "(child1.Type == MathNodeType.Value && ((ValueNode)child1).Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1.Type == MathNodeType.Calculated && Math.Abs(((CalculatedNode)child1).Value) == 0.5)"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The conditional expression  "!negExpAbs && ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value < 0) ||  							(child1.Type == MathNodeType.Calculated && ((CalculatedNode)child1).Value < 0))"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,BuildMultichildTree,The conditional expression  "neg && (beginNode.FunctionType == KnownFuncType.Add ||  					(beginNode.FunctionType == KnownFuncType.Mult && child == funcNode.Childs.First()))"  is complex.
Complex Conditional,MathExpressionsNET,ValueNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\ValueNode.cs,ToString,The conditional expression  "parent.FunctionType == KnownFuncType.Mult || parent.FunctionType == KnownFuncType.Div ||  				parent.FunctionType == KnownFuncType.Pow || parent.FunctionType == KnownFuncType.Neg"  is complex.
Empty Catch Block,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The method has an empty catch block.
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The following statement contains a magic number: if ((funcNode.Childs[1].Type == MathNodeType.Value && ((ValueNode)funcNode.Childs[1]).Value.IsInteger) ||  				(funcNode.Childs[1].Type == MathNodeType.Calculated && ((CalculatedNode)funcNode.Childs[1]).Value % 1 == 0))  			{  				int powerValue = (int)funcNode.Childs[1].DoubleValue;  				int power = Math.Abs(powerValue);  				if (negExpAbs)  					powerValue = power;    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));    				EmitNode(funcNode.Childs[0]);    				if (power == 1)  				{  				}  				else  					if (power <= 3)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						for (int i = 1; i < power; i++)  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						}  					}  					else if (power == 4)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  					}  					else  					{  						// result: funcNode.Number  						// x: funcNode.Number + 1    						//int result = x;  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));    						power--;  						do  						{  							if ((power & 1) == 1)  							{  								IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  								IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							}    							if (power <= 1)  								break;    							//x = x * x;  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));    							power = power >> 1;  						}  						while (power != 0);  					}    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Div));  			}  			else  			{  				var child1 = funcNode.Childs[1];  				if ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1.Type == MathNodeType.Calculated && Math.Abs(((CalculatedNode)child1).Value) == 0.5))  				{  					if (!negExpAbs && ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value < 0) ||  							(child1.Type == MathNodeType.Calculated && ((CalculatedNode)child1).Value < 0)))  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  						IlInstructions.Add(new OpCodeArg(OpCodes.Div));  					}  					else  					{  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  					}  				}  				else  				{  					EmitNode(funcNode.Childs[0]);  					if (negExpAbs)  						EmitNode(funcNode.Childs[1].Abs());  					else  						EmitNode(funcNode.Childs[1]);    					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType]));  				}  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The following statement contains a magic number: if ((funcNode.Childs[1].Type == MathNodeType.Value && ((ValueNode)funcNode.Childs[1]).Value.IsInteger) ||  				(funcNode.Childs[1].Type == MathNodeType.Calculated && ((CalculatedNode)funcNode.Childs[1]).Value % 1 == 0))  			{  				int powerValue = (int)funcNode.Childs[1].DoubleValue;  				int power = Math.Abs(powerValue);  				if (negExpAbs)  					powerValue = power;    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));    				EmitNode(funcNode.Childs[0]);    				if (power == 1)  				{  				}  				else  					if (power <= 3)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						for (int i = 1; i < power; i++)  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						}  					}  					else if (power == 4)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  					}  					else  					{  						// result: funcNode.Number  						// x: funcNode.Number + 1    						//int result = x;  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));    						power--;  						do  						{  							if ((power & 1) == 1)  							{  								IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  								IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							}    							if (power <= 1)  								break;    							//x = x * x;  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));    							power = power >> 1;  						}  						while (power != 0);  					}    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Div));  			}  			else  			{  				var child1 = funcNode.Childs[1];  				if ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1.Type == MathNodeType.Calculated && Math.Abs(((CalculatedNode)child1).Value) == 0.5))  				{  					if (!negExpAbs && ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value < 0) ||  							(child1.Type == MathNodeType.Calculated && ((CalculatedNode)child1).Value < 0)))  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  						IlInstructions.Add(new OpCodeArg(OpCodes.Div));  					}  					else  					{  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  					}  				}  				else  				{  					EmitNode(funcNode.Childs[0]);  					if (negExpAbs)  						EmitNode(funcNode.Childs[1].Abs());  					else  						EmitNode(funcNode.Childs[1]);    					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType]));  				}  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The following statement contains a magic number: if ((funcNode.Childs[1].Type == MathNodeType.Value && ((ValueNode)funcNode.Childs[1]).Value.IsInteger) ||  				(funcNode.Childs[1].Type == MathNodeType.Calculated && ((CalculatedNode)funcNode.Childs[1]).Value % 1 == 0))  			{  				int powerValue = (int)funcNode.Childs[1].DoubleValue;  				int power = Math.Abs(powerValue);  				if (negExpAbs)  					powerValue = power;    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));    				EmitNode(funcNode.Childs[0]);    				if (power == 1)  				{  				}  				else  					if (power <= 3)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						for (int i = 1; i < power; i++)  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						}  					}  					else if (power == 4)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  					}  					else  					{  						// result: funcNode.Number  						// x: funcNode.Number + 1    						//int result = x;  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));    						power--;  						do  						{  							if ((power & 1) == 1)  							{  								IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  								IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							}    							if (power <= 1)  								break;    							//x = x * x;  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));    							power = power >> 1;  						}  						while (power != 0);  					}    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Div));  			}  			else  			{  				var child1 = funcNode.Childs[1];  				if ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1.Type == MathNodeType.Calculated && Math.Abs(((CalculatedNode)child1).Value) == 0.5))  				{  					if (!negExpAbs && ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value < 0) ||  							(child1.Type == MathNodeType.Calculated && ((CalculatedNode)child1).Value < 0)))  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  						IlInstructions.Add(new OpCodeArg(OpCodes.Div));  					}  					else  					{  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  					}  				}  				else  				{  					EmitNode(funcNode.Childs[0]);  					if (negExpAbs)  						EmitNode(funcNode.Childs[1].Abs());  					else  						EmitNode(funcNode.Childs[1]);    					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType]));  				}  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitExpFunc,The following statement contains a magic number: if ((funcNode.Childs[1].Type == MathNodeType.Value && ((ValueNode)funcNode.Childs[1]).Value.IsInteger) ||  				(funcNode.Childs[1].Type == MathNodeType.Calculated && ((CalculatedNode)funcNode.Childs[1]).Value % 1 == 0))  			{  				int powerValue = (int)funcNode.Childs[1].DoubleValue;  				int power = Math.Abs(powerValue);  				if (negExpAbs)  					powerValue = power;    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));    				EmitNode(funcNode.Childs[0]);    				if (power == 1)  				{  				}  				else  					if (power <= 3)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						for (int i = 1; i < power; i++)  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						}  					}  					else if (power == 4)  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  					}  					else  					{  						// result: funcNode.Number  						// x: funcNode.Number + 1    						//int result = x;  						IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));    						power--;  						do  						{  							if ((power & 1) == 1)  							{  								IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  								IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							}    							if (power <= 1)  								break;    							//x = x * x;  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number + 1));  							IlInstructions.Add(new OpCodeArg(OpCodes.Mul));  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number + 1));    							power = power >> 1;  						}  						while (power != 0);  					}    				if (powerValue < 0)  					IlInstructions.Add(new OpCodeArg(OpCodes.Div));  			}  			else  			{  				var child1 = funcNode.Childs[1];  				if ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1.Type == MathNodeType.Calculated && Math.Abs(((CalculatedNode)child1).Value) == 0.5))  				{  					if (!negExpAbs && ((child1.Type == MathNodeType.Value && ((ValueNode)child1).Value < 0) ||  							(child1.Type == MathNodeType.Calculated && ((CalculatedNode)child1).Value < 0)))  					{  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8' 1.0));  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  						IlInstructions.Add(new OpCodeArg(OpCodes.Div));  					}  					else  					{  						EmitNode(funcNode.Childs[0]);  						IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[KnownFuncType.Sqrt]));  					}  				}  				else  				{  					EmitNode(funcNode.Childs[0]);  					if (negExpAbs)  						EmitNode(funcNode.Childs[1].Abs());  					else  						EmitNode(funcNode.Childs[1]);    					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType]));  				}  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,OptimizeInstructions,The following statement contains a magic number: while (i < IlInstructions.Count)  			{  				if (i < IlInstructions.Count - 1)  				{  					var firstOpCode = IlInstructions[i].OpCode;    					if ((firstOpCode == OpCodes.Ldarg || firstOpCode == OpCodes.Ldc_R8) && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						var locNumber = (int)IlInstructions[i + 1].Arg;    						for (int j = i + 2; j < IlInstructions.Count; j++)  						{  							if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber)  								break;    							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  								IlInstructions[j] = new OpCodeArg(firstOpCode' IlInstructions[i].Arg);  						}    						IlInstructions.RemoveRange(i' 2);  						continue;  					}    					if (firstOpCode == OpCodes.Ldloc && IlInstructions[i + 1].OpCode == OpCodes.Stloc)  					{  						if ((int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  						else  						{  							var locNumber1 = (int)IlInstructions[i].Arg;  							var locNumber2 = (int)IlInstructions[i + 1].Arg;    							bool arg2IsUsed = false;  							for (int j = i + 2; j < IlInstructions.Count; j++)  							{  								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber1)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Stloc) && (int)IlInstructions[j].Arg == locNumber2)  									break;    								if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber2)  								{  									IlInstructions[j] = new OpCodeArg(OpCodes.Ldloc' locNumber1);  									arg2IsUsed = true;  								}  							}    							if (arg2IsUsed)  							{  								IlInstructions.RemoveRange(i' 2);  								continue;  							}  						}  					}    					if (firstOpCode == OpCodes.Stloc && IlInstructions[i + 1].OpCode == OpCodes.Ldloc &&  						(int)IlInstructions[i].Arg == (int)IlInstructions[i + 1].Arg)  					{  						var locNumber = (int)IlInstructions[i].Arg;    						bool remove = true;  						for (int j = i + 2; j < IlInstructions.Count; j++)  							if ((IlInstructions[j].OpCode == OpCodes.Ldloc) && (int)IlInstructions[j].Arg == locNumber)  							{  								remove = false;  								break;  							}    						if (remove)  						{  							IlInstructions.RemoveRange(i' 2);  							continue;  						}  					}  				}    				i++;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,PrecompileMultFunc,The following statement contains a magic number: for (int i = 0; i < funcNode2.Childs.Count; i++)  			{  				if (funcNode2.Childs[i] == firstItem)  					continue;    				FuncNode funcChildNode = funcNode2.Childs[i] as FuncNode;  				if (funcChildNode != null && funcChildNode.FunctionType == KnownFuncType.Pow && funcChildNode.Childs[1].LessThenZero())  				{  					if (!funcChildNode.Childs[1].IsValueOrCalculated || funcChildNode.Childs[1].DoubleValue != -1.0)  					{  						FuncNode second;  						if (!funcChildNode.Childs[1].IsValueOrCalculated)  							second = new FuncNode(KnownFuncType.Pow' funcChildNode.Childs[0]' funcChildNode.Childs[1].Abs());  						else  							second = Math.Abs(funcChildNode.Childs[1].DoubleValue) != 0.5 ?  								new FuncNode(KnownFuncType.Pow' funcChildNode.Childs[0]' funcChildNode.Childs[1].Abs()) :  								new FuncNode(KnownFuncType.Sqrt' funcChildNode.Childs[0]);  						result = new FuncNode(KnownFuncType.Div' result' second);  					}  					else  						result = new FuncNode(KnownFuncType.Div' result' funcChildNode.Childs[0]);  				}  				else  					result = new FuncNode(KnownFuncType.Mult' result' funcNode2.Childs[i]);  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,PrecompileExpFunc,The following statement contains a magic number: if ((parent == null ||  				((FuncNode)parent).FunctionType != KnownFuncType.Mult) &&  				funcNode.Childs[1].LessThenZero())  			{  				if (!funcNode.Childs[1].IsValueOrCalculated || funcNode.Childs[1].DoubleValue != -1.0)  				{  					FuncNode second;  					if (!funcNode.Childs[1].IsValueOrCalculated)  						second = new FuncNode(KnownFuncType.Pow' funcNode.Childs[0]' funcNode.Childs[1].Abs());  					else  						second = Math.Abs(funcNode.Childs[1].DoubleValue) != 0.5 ?  							new FuncNode(KnownFuncType.Pow' funcNode.Childs[0]' funcNode.Childs[1].Abs()) :  							new FuncNode(KnownFuncType.Sqrt' funcNode.Childs[0]);  					return new FuncNode(KnownFuncType.Div' new CalculatedNode(1.0)' second);  				}  				else  					return new FuncNode(KnownFuncType.Div' new CalculatedNode(1.0)' funcNode.Childs[0]);  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,PrecompileExpFunc,The following statement contains a magic number: if (funcNode.Childs[1].IsValueOrCalculated && funcNode.Childs[1].DoubleValue == 0.5)  				return new FuncNode(KnownFuncType.Sqrt' funcNode.Childs[0]);
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,CalculateValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result += args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Sub:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Mult:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Div:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Pow:  					if (args[1].DoubleValue == 0.5)  						return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));  					else  						return new CalculatedNode(Math.Pow(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Neg:  					return new CalculatedNode(-args[0].DoubleValue);    				case KnownFuncType.Sgn:  					return new CalculatedNode((double)Math.Sign(args[0].DoubleValue));    				case KnownFuncType.Trunc:  					return new CalculatedNode(Math.Truncate(args[0].DoubleValue));    				case KnownFuncType.Round:  					return new CalculatedNode(Math.Round(args[0].DoubleValue));    				case KnownFuncType.Diff:  					return new CalculatedNode(0.0);    				case KnownFuncType.Sqrt:  					return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));    				case KnownFuncType.Sin:  					return new CalculatedNode(Math.Sin(args[0].DoubleValue));    				case KnownFuncType.Cos:  					return new CalculatedNode(Math.Cos(args[0].DoubleValue));    				case KnownFuncType.Tan:  					return new CalculatedNode(Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Cot:  					return new CalculatedNode(1 / Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Arcsin:  					return new CalculatedNode(Math.Asin(args[0].DoubleValue));    				case KnownFuncType.Arccos:  					return new CalculatedNode(Math.Acos(args[0].DoubleValue));    				case KnownFuncType.Arctan:  					return new CalculatedNode(Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Arccot:  					return new CalculatedNode(Math.PI / 2 - Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Sinh:  					return new CalculatedNode(Math.Sinh(args[0].DoubleValue));    				case KnownFuncType.Cosh:  					return new CalculatedNode(Math.Cosh(args[0].DoubleValue));    				case KnownFuncType.Arcsinh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1)));    				case KnownFuncType.Arcosh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1)));    				case KnownFuncType.Ln:  					return new CalculatedNode(Math.Log(args[0].DoubleValue));    				case KnownFuncType.Log10:  					return new CalculatedNode(Math.Log10(args[0].DoubleValue));    				case KnownFuncType.Log:  					return new CalculatedNode(Math.Log(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Abs:  					return new CalculatedNode(Math.Abs(args[0].DoubleValue));    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,CalculateValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result += args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Sub:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Mult:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Div:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Pow:  					if (args[1].DoubleValue == 0.5)  						return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));  					else  						return new CalculatedNode(Math.Pow(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Neg:  					return new CalculatedNode(-args[0].DoubleValue);    				case KnownFuncType.Sgn:  					return new CalculatedNode((double)Math.Sign(args[0].DoubleValue));    				case KnownFuncType.Trunc:  					return new CalculatedNode(Math.Truncate(args[0].DoubleValue));    				case KnownFuncType.Round:  					return new CalculatedNode(Math.Round(args[0].DoubleValue));    				case KnownFuncType.Diff:  					return new CalculatedNode(0.0);    				case KnownFuncType.Sqrt:  					return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));    				case KnownFuncType.Sin:  					return new CalculatedNode(Math.Sin(args[0].DoubleValue));    				case KnownFuncType.Cos:  					return new CalculatedNode(Math.Cos(args[0].DoubleValue));    				case KnownFuncType.Tan:  					return new CalculatedNode(Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Cot:  					return new CalculatedNode(1 / Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Arcsin:  					return new CalculatedNode(Math.Asin(args[0].DoubleValue));    				case KnownFuncType.Arccos:  					return new CalculatedNode(Math.Acos(args[0].DoubleValue));    				case KnownFuncType.Arctan:  					return new CalculatedNode(Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Arccot:  					return new CalculatedNode(Math.PI / 2 - Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Sinh:  					return new CalculatedNode(Math.Sinh(args[0].DoubleValue));    				case KnownFuncType.Cosh:  					return new CalculatedNode(Math.Cosh(args[0].DoubleValue));    				case KnownFuncType.Arcsinh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1)));    				case KnownFuncType.Arcosh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1)));    				case KnownFuncType.Ln:  					return new CalculatedNode(Math.Log(args[0].DoubleValue));    				case KnownFuncType.Log10:  					return new CalculatedNode(Math.Log10(args[0].DoubleValue));    				case KnownFuncType.Log:  					return new CalculatedNode(Math.Log(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Abs:  					return new CalculatedNode(Math.Abs(args[0].DoubleValue));    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,ExpValue,The following statement contains a magic number: if (bValue != null)  			{  				if (bValue.Value == 0)  					return new ValueNode(1);  				else if (bValue.Value == 1)  					return funcNode.Childs[0];  				/*else if (funcNode.Childs[0].Type == MathNodeType.Value)  				{  					double a = funcNode.Childs[0].Value.ToDouble();  					double b = bValue.Value.ToDouble();  					double r = b == 0.5 ? Math.Sqrt(a) : Math.Pow(a' b);  					Rational<long> result;  					Rational<long>.FromDecimal((decimal)r' out result);  					return new ValueNode(result);  				}*/  				else if (bValue.Value.IsInteger && funcNode.Childs[0].Type == MathNodeType.Function &&  					((FuncNode)funcNode.Childs[0]).FunctionType == KnownFuncType.Neg)  				{  					if (bValue.Value.Numerator % 2 == 0)  						return new FuncNode(KnownFuncType.Pow' funcNode.Childs[0].Childs[0]' new ValueNode(bValue.Value));  					else  						return new FuncNode(KnownFuncType.Neg' new FuncNode(KnownFuncType.Pow' funcNode.Childs[0].Childs[0]' new ValueNode(bValue.Value)));  				}  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result += args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Sub:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Mult:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Div:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Pow:  					if (args[1].Value.ToDouble() == 0.5)  						temp = Math.Sqrt(args[0].Value.ToDouble());  					else  						temp = Math.Pow(args[0].Value.ToDouble()' args[1].Value.ToDouble());  					break;  				  				case KnownFuncType.Neg:  					return new ValueNode(-args[0].Value);    				case KnownFuncType.Sgn:  					return new ValueNode(new Rational<long>((long)Math.Sign(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Trunc:  					return new ValueNode(new Rational<long>((long)Math.Truncate(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Round:  					return new ValueNode(new Rational<long>((long)Math.Round(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Diff:  					return new ValueNode(0);    				case KnownFuncType.Sqrt:  					temp = Math.Sqrt(args[0].DoubleValue);  					break;    				case KnownFuncType.Sin:  					temp = Math.Sin(args[0].DoubleValue);  					break;    				case KnownFuncType.Cos:  					temp = Math.Cos(args[0].DoubleValue);  					break;    				case KnownFuncType.Tan:  					temp = Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Cot:  					temp = 1 / Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsin:  					temp = Math.Asin(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccos:  					temp = Math.Acos(args[0].DoubleValue);  					break;    				case KnownFuncType.Arctan:  					temp = Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccot:  					temp = Math.PI / 2 - Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Sinh:  					temp = Math.Sinh(args[0].DoubleValue);  					break;    				case KnownFuncType.Cosh:  					temp = Math.Cosh(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsinh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1));  					break;    				case KnownFuncType.Arcosh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1));  					break;    				case KnownFuncType.Exp:  					temp = Math.Exp(args[0].DoubleValue);  					break;    				case KnownFuncType.Ln:  					temp = Math.Log(args[0].DoubleValue);  					break;    				case KnownFuncType.Log10:  					temp = Math.Log10(args[0].DoubleValue);  					break;    				case KnownFuncType.Log:  					temp = Math.Log(args[0].DoubleValue' args[1].DoubleValue);  					break;    				case KnownFuncType.Abs:  					temp = Math.Abs(args[0].DoubleValue);  					break;    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result += args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Sub:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Mult:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Div:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Pow:  					if (args[1].Value.ToDouble() == 0.5)  						temp = Math.Sqrt(args[0].Value.ToDouble());  					else  						temp = Math.Pow(args[0].Value.ToDouble()' args[1].Value.ToDouble());  					break;  				  				case KnownFuncType.Neg:  					return new ValueNode(-args[0].Value);    				case KnownFuncType.Sgn:  					return new ValueNode(new Rational<long>((long)Math.Sign(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Trunc:  					return new ValueNode(new Rational<long>((long)Math.Truncate(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Round:  					return new ValueNode(new Rational<long>((long)Math.Round(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Diff:  					return new ValueNode(0);    				case KnownFuncType.Sqrt:  					temp = Math.Sqrt(args[0].DoubleValue);  					break;    				case KnownFuncType.Sin:  					temp = Math.Sin(args[0].DoubleValue);  					break;    				case KnownFuncType.Cos:  					temp = Math.Cos(args[0].DoubleValue);  					break;    				case KnownFuncType.Tan:  					temp = Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Cot:  					temp = 1 / Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsin:  					temp = Math.Asin(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccos:  					temp = Math.Acos(args[0].DoubleValue);  					break;    				case KnownFuncType.Arctan:  					temp = Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccot:  					temp = Math.PI / 2 - Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Sinh:  					temp = Math.Sinh(args[0].DoubleValue);  					break;    				case KnownFuncType.Cosh:  					temp = Math.Cosh(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsinh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1));  					break;    				case KnownFuncType.Arcosh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1));  					break;    				case KnownFuncType.Exp:  					temp = Math.Exp(args[0].DoubleValue);  					break;    				case KnownFuncType.Ln:  					temp = Math.Log(args[0].DoubleValue);  					break;    				case KnownFuncType.Log10:  					temp = Math.Log10(args[0].DoubleValue);  					break;    				case KnownFuncType.Log:  					temp = Math.Log(args[0].DoubleValue' args[1].DoubleValue);  					break;    				case KnownFuncType.Abs:  					temp = Math.Abs(args[0].DoubleValue);  					break;    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The following statement contains a magic number: try  			{  				if (Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8))  				return new ValueNode(result);  			}  			catch  			{  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The following statement contains a magic number: try  			{  				if (Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8))  				return new ValueNode(result);  			}  			catch  			{  			}
Magic Number,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,SimplifyValues,The following statement contains a magic number: try  			{  				if (Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8))  				return new ValueNode(result);  			}  			catch  			{  			}
Magic Number,MathExpressionsNET,MathFuncGenerator,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,The following statement contains a magic number: if (r < ValueProb)  			{  				r1 = _rand.NextDouble();  				if (r1 < FracProb)  					return new ValueNode(Rational<long>.Approximate((decimal)(MinValue + _rand.NextDouble() * (MaxValue - MinValue))' 0.001m));  				else  					return new ValueNode(_rand.Next(MinValue' MaxValue));  			}  			else if (r < ValueProb + ConstProb && constNames != null && constNames.Length != 0)  			{  				string randConstName = constNames[_rand.Next(constNames.Length)];  				return new ConstNode(randConstName);  			}  			else if (r < ValueProb + ConstProb + VarProb)  			{  				return new VarNode(varName);  			}  			else  			{  				r1 = _rand.NextDouble();  				if (r1 < UnknownFuncProb && unknownFuncNames != null && unknownFuncNames.Length != 0)  				{  					string randFuncName = unknownFuncNames[_rand.Next(unknownFuncNames.Length)];  					return new FuncNode(randFuncName' new List<MathFuncNode>()   					{  						Generate(curDepth + 1' varName' constNames' unknownFuncNames)  					});  				}  				else  				{  					Array values = Enum.GetValues(typeof(KnownFuncType));  					KnownFuncType randFuncType;  					do  					{  						r2 = _rand.NextDouble();  						if (r2 < AdditionFuncProb)  							randFuncType = KnownFuncType.Add;  						else if (r2 < AdditionFuncProb + MultiplicationFuncProb)  							randFuncType = KnownFuncType.Mult;  						else  						{  							r3 = _rand.NextDouble();  							if (r3 < UnaryFuncProb)  								randFuncType = _unaryFuncs[_rand.Next(_unaryFuncs.Length)];  							else  								randFuncType = _binaryFuncs[_rand.Next(_binaryFuncs.Length)];  						}  					}  					while (KnownFunc.SpecFuncs.Contains(randFuncType));    					if (KnownFunc.UnaryFuncsNames.ContainsKey(randFuncType))  						return new FuncNode(randFuncType' Generate(curDepth + 1' varName' constNames' unknownFuncNames));  					else  					{  						if (randFuncType == KnownFuncType.Add)  						{  							int summandsCount = Math.Min(2' _rand.Next(MaxSummandsCount + 1));  							List<MathFuncNode> summands = new List<MathFuncNode>();  							for (int i = 0; i < summandsCount; i++)  								summands.Add(Generate(curDepth + 1' varName' constNames' unknownFuncNames));  							return new FuncNode(KnownFuncType.Add' summands);  						}  						else if (randFuncType == KnownFuncType.Mult)  						{  							int factorsCount = Math.Min(2' _rand.Next(MaxFactorsCount + 1));  							List<MathFuncNode> factors = new List<MathFuncNode>();  							for (int i = 0; i < factorsCount; i++)  								factors.Add(Generate(curDepth + 1' varName' constNames' unknownFuncNames));  							return new FuncNode(KnownFuncType.Mult' factors);  						}  						else  						{  							return new FuncNode(randFuncType'  								Generate(curDepth + 1' varName' constNames' unknownFuncNames)'  								Generate(curDepth + 1' varName' constNames' unknownFuncNames));  						}  					}  				}  			}
Magic Number,MathExpressionsNET,MathFuncGenerator,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,The following statement contains a magic number: if (r < ValueProb)  			{  				r1 = _rand.NextDouble();  				if (r1 < FracProb)  					return new ValueNode(Rational<long>.Approximate((decimal)(MinValue + _rand.NextDouble() * (MaxValue - MinValue))' 0.001m));  				else  					return new ValueNode(_rand.Next(MinValue' MaxValue));  			}  			else if (r < ValueProb + ConstProb && constNames != null && constNames.Length != 0)  			{  				string randConstName = constNames[_rand.Next(constNames.Length)];  				return new ConstNode(randConstName);  			}  			else if (r < ValueProb + ConstProb + VarProb)  			{  				return new VarNode(varName);  			}  			else  			{  				r1 = _rand.NextDouble();  				if (r1 < UnknownFuncProb && unknownFuncNames != null && unknownFuncNames.Length != 0)  				{  					string randFuncName = unknownFuncNames[_rand.Next(unknownFuncNames.Length)];  					return new FuncNode(randFuncName' new List<MathFuncNode>()   					{  						Generate(curDepth + 1' varName' constNames' unknownFuncNames)  					});  				}  				else  				{  					Array values = Enum.GetValues(typeof(KnownFuncType));  					KnownFuncType randFuncType;  					do  					{  						r2 = _rand.NextDouble();  						if (r2 < AdditionFuncProb)  							randFuncType = KnownFuncType.Add;  						else if (r2 < AdditionFuncProb + MultiplicationFuncProb)  							randFuncType = KnownFuncType.Mult;  						else  						{  							r3 = _rand.NextDouble();  							if (r3 < UnaryFuncProb)  								randFuncType = _unaryFuncs[_rand.Next(_unaryFuncs.Length)];  							else  								randFuncType = _binaryFuncs[_rand.Next(_binaryFuncs.Length)];  						}  					}  					while (KnownFunc.SpecFuncs.Contains(randFuncType));    					if (KnownFunc.UnaryFuncsNames.ContainsKey(randFuncType))  						return new FuncNode(randFuncType' Generate(curDepth + 1' varName' constNames' unknownFuncNames));  					else  					{  						if (randFuncType == KnownFuncType.Add)  						{  							int summandsCount = Math.Min(2' _rand.Next(MaxSummandsCount + 1));  							List<MathFuncNode> summands = new List<MathFuncNode>();  							for (int i = 0; i < summandsCount; i++)  								summands.Add(Generate(curDepth + 1' varName' constNames' unknownFuncNames));  							return new FuncNode(KnownFuncType.Add' summands);  						}  						else if (randFuncType == KnownFuncType.Mult)  						{  							int factorsCount = Math.Min(2' _rand.Next(MaxFactorsCount + 1));  							List<MathFuncNode> factors = new List<MathFuncNode>();  							for (int i = 0; i < factorsCount; i++)  								factors.Add(Generate(curDepth + 1' varName' constNames' unknownFuncNames));  							return new FuncNode(KnownFuncType.Mult' factors);  						}  						else  						{  							return new FuncNode(randFuncType'  								Generate(curDepth + 1' varName' constNames' unknownFuncNames)'  								Generate(curDepth + 1' varName' constNames' unknownFuncNames));  						}  					}  				}  			}
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TenInPower,The following statement contains a magic number: for (int l = 0; l < power; l++)  				result *= 10;
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: ulong result = 9;
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: if (power >= 0)  				for (ulong l = 0; l < power - 1; l++)  					result = result * 10 + 9;
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: if (power >= 0)  				for (ulong l = 0; l < power - 1; l++)  					result = result * 10 + 9;
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Parse,The following statement contains a magic number: string[] parts = value.Split(Rational<T>.DelimSet' 2' StringSplitOptions.RemoveEmptyEntries);
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TryParse,The following statement contains a magic number: string[] parts = value.Split(Rational<T>.DelimSet' 2' StringSplitOptions.RemoveEmptyEntries);
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TryParse,The following statement contains a magic number: return (parts.Length == 2);
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,GetHashCode,The following statement contains a magic number: num = (-1521134295 * num) + EqualityComparer<T>.Default.GetHashCode(this.numerator);
Magic Number,MathExpressionsNET,Rational,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,GetHashCode,The following statement contains a magic number: return ((-1521134295 * num) + EqualityComparer<T>.Default.GetHashCode(this.denominator));
Magic Number,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following statement contains a magic number: if (args.Count >= 2)  			{  				KnownFuncType functionType;  				if (KnownFunc.BinaryNamesFuncs.TryGetValue(lowercasename' out functionType))  					FunctionType = functionType;  			}  			else if (args.Count == 1)  			{  				KnownFuncType functionType;  				if (KnownFunc.UnaryNamesFuncs.TryGetValue(lowercasename' out functionType))  					FunctionType = functionType;  				else if (KnownFunc.BinaryNamesFuncs.TryGetValue(lowercasename' out functionType))  					FunctionType = functionType;  			}
Magic Number,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following statement contains a magic number: if (FunctionType == KnownFuncType.Sqrt)  			{  				FunctionType = KnownFuncType.Pow;  				Childs.Add(new ValueNode(new Rational<long>(1' 2)));  			}
Magic Number,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following statement contains a magic number: if (Childs.Count != 0)  				builder.Remove(builder.Length - 2' 2);
Magic Number,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following statement contains a magic number: if (Childs.Count != 0)  				builder.Remove(builder.Length - 2' 2);
Missing Default,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitNode,The following switch statement is missing a default case: switch (node.Type)  			{  				case MathNodeType.Calculated:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8'  						negExpAbs ? Math.Abs(((CalculatedNode)node).Value) : ((CalculatedNode)node).Value));  					break;  				case MathNodeType.Value:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8'  						negExpAbs ? Math.Abs(((ValueNode)node).Value.ToDouble()) : ((ValueNode)node).Value.ToDouble()));  					break;    				case MathNodeType.Constant:  				case MathNodeType.Variable:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldarg' node.ArgNumber));  					break;    				case MathNodeType.Function:  					var funcNode = node as FuncNode;  					var func = FuncNodes[funcNode];  					if (!func.Calculated)  					{  						EmitFunc(funcNode' negExpAbs);  						func.Calculated = true;  						// if (FuncNodes[funcNode].Count > 1) TODO: this optimization disallowed due to derivatives.  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						}  					}  					else  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  					break;  			}
Missing Default,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,EmitFunc,The following switch statement is missing a default case: switch (funcNode.FunctionType)  			{  				case KnownFuncType.Add:  					return EmitAddFunc(funcNode);  				case KnownFuncType.Sub:  					return EmitSubFunc(funcNode);  				case KnownFuncType.Mult:  					return EmitMultFunc(funcNode);  				case KnownFuncType.Div:  					return EmitDivFunc(funcNode);  				case KnownFuncType.Neg:  					return EmitNegFunc(funcNode' negExpAbs);  				case KnownFuncType.Pow:  					return EmitExpFunc(funcNode' negExpAbs);  				case KnownFuncType.Diff:  					return EmitDiffFunc(funcNode);  			}
Missing Default,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,GetDerivative,The following switch statement is missing a default case: switch (node.Type)  			{  				case MathNodeType.Calculated:  					return new CalculatedNode(0.0);  				case MathNodeType.Value:  				case MathNodeType.Constant:  					return new ValueNode(0);  				case MathNodeType.Variable:  					return new ValueNode(1);  				case MathNodeType.Function:  					return GetFuncDerivative((FuncNode)node);  			}
Missing Default,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,MakeSubstitution,The following switch statement is missing a default case: switch (node.Childs[i].Type)  				{  					case MathNodeType.Calculated:  						result.Childs.Add(new CalculatedNode((CalculatedNode)node.Childs[i]));  						break;  					case MathNodeType.Value:  						result.Childs.Add(new ValueNode((ValueNode)node.Childs[i]));  						break;  					case MathNodeType.Constant:  					case MathNodeType.Variable:  						result.Childs.Add(node.Childs[i]);  						break;  					case MathNodeType.Function:  						result.Childs.Add(MakeSubstitution((FuncNode)node.Childs[i]));  						break;  				}
Missing Default,MathExpressionsNET,MathFunc,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncCompilation.cs,Precompile,The following switch statement is missing a default case: switch (func.FunctionType)  				{  					case KnownFuncType.Add:  						node = PrecompileAddFunc(func);  						break;    					case KnownFuncType.Mult:  						node = PrecompileMultFunc(func);  						break;    					case KnownFuncType.Pow:  						node = PrecompileExpFunc(parent' func);  						break;  				}
Missing Default,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following switch statement is missing a default case: switch (node.Childs[i].Type)  				{  					case MathNodeType.Value:  						Childs.Add(new ValueNode(((ValueNode)node.Childs[i]).Value));  						break;  					case MathNodeType.Constant:  					case MathNodeType.Variable:  						Childs.Add(node.Childs[i]);  						break;  					case MathNodeType.Function:  						Childs.Add(new FuncNode((FuncNode)node.Childs[i]));  						break;  				}
Missing Default,MathExpressionsNET,FuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following switch statement is missing a default case: switch ((KnownFuncType)FunctionType)  				{  					case KnownFuncType.Add:  					case KnownFuncType.Sub:  						return ToString(parent' funcType' KnownFunc.AddKnownFuncs);    					case KnownFuncType.Mult:  					case KnownFuncType.Div:  						return ToString(parent' funcType' KnownFunc.MultKnownFuncs);    					case KnownFuncType.Pow:  						return ToString(parent' funcType' KnownFunc.ExpKnownFuncs);    					case KnownFuncType.Neg:  						if (Childs[0].Type == MathNodeType.Function)  						{  							var func = (FuncNode)Childs[0];  							if (KnownFunc.NegKnownFuncs.Contains((KnownFuncType)func.FunctionType))  								return "-(" + Childs[0].ToString(this) + ")";  							else  								return "-" + Childs[0].ToString(this);  						}  						else  							return "-" + Childs[0].ToString(this);    					case KnownFuncType.Diff:  						return Childs[0].Type == MathNodeType.Function && ((FuncNode)Childs[0]).FunctionType != KnownFuncType.Diff ?  							Childs[0].ToString(this) + "'" : "(" +   							Childs[0].ToString(this) + ")'";    					case KnownFuncType.Abs:  						return string.Format("|{0}|"' Childs[0].ToString(this));  				}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (Type)  			{  				case MathNodeType.Function:  					switch (other.Type)  					{  						case MathNodeType.Function:  							if (Name != other.Name)  								result = Name.CompareTo(other.Name);  							else if (Childs.Count != other.Childs.Count)  								result = -Childs.Count.CompareTo(other.Childs.Count);  							else  							{  								for (int i = 0; i < Childs.Count; i++)  								{  									result = Childs[i].CompareTo(other.Childs[i]);  									if (result != 0)  										break;  								}  							}  							break;  						case MathNodeType.Variable:  						case MathNodeType.Constant:  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}  					break;  				case MathNodeType.Variable:  					switch (other.Type)  					{  						case MathNodeType.Function:  							result = 1;  							break;  						case MathNodeType.Variable:  							result = Name.CompareTo(other.Name);  							break;  						case MathNodeType.Constant:  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}  					break;  				case MathNodeType.Constant:  					switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  							result = 1;  							break;  						case MathNodeType.Constant:  							result = Name.CompareTo(other.Name);  							break;  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}  					break;  				case MathNodeType.Value:  					switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  						case MathNodeType.Constant:  							result = 1;  							break;  						case MathNodeType.Value:  							result = ((ValueNode)this).Value.CompareTo(((ValueNode)other).Value);  							break;  						case MathNodeType.Calculated:  							result = ((ValueNode)this).Value.ToDouble(CultureInfo.InvariantCulture).CompareTo(((CalculatedNode)other).Value);  							break;  					}  					break;  				case MathNodeType.Calculated:  					switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  						case MathNodeType.Constant:  							result = 1;  							break;  						case MathNodeType.Value:  							result = ((CalculatedNode)this).Value.CompareTo(((ValueNode)other).Value.ToDouble(CultureInfo.InvariantCulture));  							break;  						case MathNodeType.Calculated:  							result = ((CalculatedNode)this).Value.CompareTo(((CalculatedNode)other).Value);  							break;  					}  					break;  			}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other.Type)  					{  						case MathNodeType.Function:  							if (Name != other.Name)  								result = Name.CompareTo(other.Name);  							else if (Childs.Count != other.Childs.Count)  								result = -Childs.Count.CompareTo(other.Childs.Count);  							else  							{  								for (int i = 0; i < Childs.Count; i++)  								{  									result = Childs[i].CompareTo(other.Childs[i]);  									if (result != 0)  										break;  								}  							}  							break;  						case MathNodeType.Variable:  						case MathNodeType.Constant:  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other.Type)  					{  						case MathNodeType.Function:  							result = 1;  							break;  						case MathNodeType.Variable:  							result = Name.CompareTo(other.Name);  							break;  						case MathNodeType.Constant:  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  							result = 1;  							break;  						case MathNodeType.Constant:  							result = Name.CompareTo(other.Name);  							break;  						case MathNodeType.Value:  						case MathNodeType.Calculated:  							result = -1;  							break;  					}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  						case MathNodeType.Constant:  							result = 1;  							break;  						case MathNodeType.Value:  							result = ((ValueNode)this).Value.CompareTo(((ValueNode)other).Value);  							break;  						case MathNodeType.Calculated:  							result = ((ValueNode)this).Value.ToDouble(CultureInfo.InvariantCulture).CompareTo(((CalculatedNode)other).Value);  							break;  					}
Missing Default,MathExpressionsNET,MathFuncNode,C:\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other.Type)  					{  						case MathNodeType.Function:  						case MathNodeType.Variable:  						case MathNodeType.Constant:  							result = 1;  							break;  						case MathNodeType.Value:  							result = ((CalculatedNode)this).Value.CompareTo(((ValueNode)other).Value.ToDouble(CultureInfo.InvariantCulture));  							break;  						case MathNodeType.Calculated:  							result = ((CalculatedNode)this).Value.CompareTo(((CalculatedNode)other).Value);  							break;  					}
