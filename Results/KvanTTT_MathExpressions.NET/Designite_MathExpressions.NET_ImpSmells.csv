Implementation smell,Namespace,Class,File,Method,Description
Long Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The method has 110 lines of code.
Complex Method,MathExpressionsNET,KnownFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\KnownFunc.cs,KnownFunc,Cyclomatic complexity of the method is 9
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,Cyclomatic complexity of the method is 35
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,ConstToVars,Cyclomatic complexity of the method is 9
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitFunc,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitExpFunc,Cyclomatic complexity of the method is 12
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,OptimizeLocalVariables,Cyclomatic complexity of the method is 13
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,OptimizeInstructions,Cyclomatic complexity of the method is 18
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitInstruction,Cyclomatic complexity of the method is 19
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,GetFuncDerivative,Cyclomatic complexity of the method is 17
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MakeSubstitution,Cyclomatic complexity of the method is 12
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,CalculateValues,Cyclomatic complexity of the method is 33
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,Simplify,Cyclomatic complexity of the method is 13
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,ReduceAddition,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,ReducePowers,Cyclomatic complexity of the method is 10
Complex Method,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,ExpValue,Cyclomatic complexity of the method is 10
Complex Method,MathExpressionsNET,MathFuncGenerator,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,Cyclomatic complexity of the method is 13
Complex Method,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,MathExpressionsNET,MathFuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,Cyclomatic complexity of the method is 18
Complex Method,MathExpressionsNET,ValueNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\ValueNode.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,FromDecimal,Cyclomatic complexity of the method is 13
Long Parameter List,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MathFunc,The method has 5 parameters. Parameters: root' variable' parameters' calculateConstants' simplify
Long Parameter List,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MathFunc,The method has 6 parameters. Parameters: left' right' variable' parameters' simplify' calculateConstants
Long Parameter List,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,FromDecimal,The method has 6 parameters. Parameters: value' result' decimalPlaces' trimZeroes' minPeriodRepeat' digitsForReal
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,Compile,The length of the statement  "				MethodAttributes.Public | MethodAttributes.HideBySig | (Static ? MethodAttributes.Static : 0)' mathFuncAssembly.DoubleType); " is 124.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,AddFuncArgs,The length of the statement  "				method.Parameters.Add(new ParameterDefinition(param.Value.Name' ParameterAttributes.None' MathFuncAssembly.DoubleType)); " is 120.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitMultFunc,The length of the statement  "				return !(func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Children[1].LessThenZero()); " is 130.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitMultFunc,The length of the statement  "				if (func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Children[1].LessThenZero()) " is 124.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitMultFunc,The length of the statement  "					if (IlInstructions[IlInstructions.Count - 1].OpCode == OpCodes.Ldc_R8 && (double)IlInstructions[IlInstructions.Count - 1].Arg == 1.0) " is 133.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitExpFunc,The length of the statement  "					IlInstructions.Add(new OpCodeArg(OpCodes.Call' MathFuncAssembly.TypesReferences[(KnownFuncType)funcNode.FunctionType])); " is 120.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitKnownFunc,The length of the statement  "			if (funcNode.FunctionType != null && MathFuncAssembly.TypesReferences.TryGetValue((KnownFuncType)funcNode.FunctionType' out value)) " is 131.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,PrecompileMultFunc,The length of the statement  "				if (funcNode2.Children[i] is FuncNode funcChildNode && funcChildNode.FunctionType == KnownFuncType.Pow && funcChildNode.Children[1].LessThenZero()) " is 147.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,Simplify,The length of the statement  "							return (MathFuncNode)SimplifyValues(funcNode.FunctionType' funcNode.Children.Select(child => (ValueNode)child).ToList()) " is 120.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MultValues,The length of the statement  "				.Where(child => !(child is ValueNode) && !(child is FuncNode childFuncNode && childFuncNode.FunctionType == KnownFuncType.Neg)) " is 127.
Long Statement,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,ExpValue,The length of the statement  "						return new FuncNode(KnownFuncType.Neg' new FuncNode(KnownFuncType.Pow' funcNode.Children[0].Children[0]' new ValueNode(bValue.Value))); " is 135.
Long Statement,MathExpressionsNET,MathFuncAssemblyCecil,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncAssemblyCecil.cs,Init,The length of the statement  "			InvokeFuncRef = Assembly.MainModule.ImportReference(typeof(Func<double' double>).GetMethod(nameof(System.Reflection.MethodInfo.Invoke))); " is 137.
Long Statement,MathExpressionsNET,MathFuncAssemblyCecil,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncAssemblyCecil.cs,Init,The length of the statement  "			var methodAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName; " is 140.
Long Statement,MathExpressionsNET,MathFuncAssemblyCecil,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncAssemblyCecil.cs,Init,The length of the statement  "			method.Body.Instructions.Add(Instruction.Create(OpCodes.Call' Assembly.MainModule.ImportReference(typeof(object).GetConstructor(new Type[0])))); " is 144.
Long Statement,MathExpressionsNET,MathFuncGenerator,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,The length of the statement  "					return new ValueNode(Rational<long>.Approximate((decimal)(MinValue + _rand.NextDouble() * (MaxValue - MinValue))' 0.001m)); " is 123.
Long Statement,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,BuildTryParser,The length of the statement  "				throw new InvalidOperationException("Underlying Rational type T must support TryParse in order to try-parse Rational<T>."); " is 123.
Long Statement,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,ToDouble,The length of the statement  "			double denominator = provider != null ? this.denominator.ToDouble(provider) : this.denominator.ToDouble(CultureInfo.InvariantCulture); " is 134.
Long Statement,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,ToDouble,The length of the statement  "			return provider != null ? numerator.ToDouble(provider) : numerator.ToDouble(CultureInfo.InvariantCulture) / denominator; " is 120.
Complex Conditional,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitMultFunc,The conditional expression  "func != null && FuncNodes[func].Count == 1 && func.FunctionType == KnownFuncType.Pow && func.Children[1].LessThenZero()"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitExpFunc,The conditional expression  "(funcNode.Children[1] is ValueNode valueNode && valueNode.Value.IsInteger) ||  				(funcNode.Children[1] is CalculatedNode calculatedNode && calculatedNode.Value % 1 == 0)"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitExpFunc,The conditional expression  "(child1 is ValueNode child1ValueNode && child1ValueNode.Value.Abs() == new Rational<long>(1' 2' false)) ||  					(child1 is CalculatedNode child1CalcNode && Math.Abs(child1CalcNode.Value) == 0.5)"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitExpFunc,The conditional expression  "!negExpAbs &&  						(child1 is ValueNode child1ValueNode2 && child1ValueNode2.Value < 0) ||  						(child1 is CalculatedNode child1CalcNode2 && child1CalcNode2.Value < 0)"  is complex.
Complex Conditional,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,BuildMultichildTree,The conditional expression  "neg && (beginNode.FunctionType == KnownFuncType.Add ||  					(beginNode.FunctionType == KnownFuncType.Mult && child == funcNode.Children.First()))"  is complex.
Complex Conditional,MathExpressionsNET,ValueNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\ValueNode.cs,ToString,The conditional expression  "parent.FunctionType == KnownFuncType.Mult || parent.FunctionType == KnownFuncType.Div ||  				parent.FunctionType == KnownFuncType.Pow || parent.FunctionType == KnownFuncType.Neg"  is complex.
Empty Catch Block,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The method has an empty catch block.
Magic Number,MathExpressionsNET,ErrorMessage,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\ErrorMessage.cs,CompareTo,The following statement contains a magic number: return Offset != 0 && other.Offset != 0  						? Offset.CompareTo(other.Offset)  						: ((Line * 1000 + other.Column).CompareTo(Line * 1000 + other.Column));
Magic Number,MathExpressionsNET,ErrorMessage,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\ErrorMessage.cs,CompareTo,The following statement contains a magic number: return Offset != 0 && other.Offset != 0  						? Offset.CompareTo(other.Offset)  						: ((Line * 1000 + other.Column).CompareTo(Line * 1000 + other.Column));
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result += args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Sub:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Mult:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Div:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Pow:  					if (args[1].Value.ToDouble() == 0.5)  						temp = Math.Sqrt(args[0].Value.ToDouble());  					else  						temp = Math.Pow(args[0].Value.ToDouble()' args[1].Value.ToDouble());  					break;  				  				case KnownFuncType.Neg:  					return new ValueNode(-args[0].Value);    				case KnownFuncType.Sgn:  					return new ValueNode(new Rational<long>((long)Math.Sign(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Trunc:  					return new ValueNode(new Rational<long>((long)Math.Truncate(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Round:  					return new ValueNode(new Rational<long>((long)Math.Round(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Diff:  					return new ValueNode(0);    				case KnownFuncType.Sqrt:  					temp = Math.Sqrt(args[0].DoubleValue);  					break;    				case KnownFuncType.Sin:  					temp = Math.Sin(args[0].DoubleValue);  					break;    				case KnownFuncType.Cos:  					temp = Math.Cos(args[0].DoubleValue);  					break;    				case KnownFuncType.Tan:  					temp = Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Cot:  					temp = 1 / Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsin:  					temp = Math.Asin(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccos:  					temp = Math.Acos(args[0].DoubleValue);  					break;    				case KnownFuncType.Arctan:  					temp = Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccot:  					temp = Math.PI / 2 - Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Sinh:  					temp = Math.Sinh(args[0].DoubleValue);  					break;    				case KnownFuncType.Cosh:  					temp = Math.Cosh(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsinh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1));  					break;    				case KnownFuncType.Arcosh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1));  					break;    				case KnownFuncType.Exp:  					temp = Math.Exp(args[0].DoubleValue);  					break;    				case KnownFuncType.Ln:  					temp = Math.Log(args[0].DoubleValue);  					break;    				case KnownFuncType.Log10:  					temp = Math.Log10(args[0].DoubleValue);  					break;    				case KnownFuncType.Log:  					temp = Math.Log(args[0].DoubleValue' args[1].DoubleValue);  					break;    				case KnownFuncType.Abs:  					temp = Math.Abs(args[0].DoubleValue);  					break;    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result += args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Sub:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Mult:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Div:  					result = args[0].Value;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].Value;  					return new ValueNode(result);    				case KnownFuncType.Pow:  					if (args[1].Value.ToDouble() == 0.5)  						temp = Math.Sqrt(args[0].Value.ToDouble());  					else  						temp = Math.Pow(args[0].Value.ToDouble()' args[1].Value.ToDouble());  					break;  				  				case KnownFuncType.Neg:  					return new ValueNode(-args[0].Value);    				case KnownFuncType.Sgn:  					return new ValueNode(new Rational<long>((long)Math.Sign(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Trunc:  					return new ValueNode(new Rational<long>((long)Math.Truncate(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Round:  					return new ValueNode(new Rational<long>((long)Math.Round(args[0].DoubleValue)' 1' false));    				case KnownFuncType.Diff:  					return new ValueNode(0);    				case KnownFuncType.Sqrt:  					temp = Math.Sqrt(args[0].DoubleValue);  					break;    				case KnownFuncType.Sin:  					temp = Math.Sin(args[0].DoubleValue);  					break;    				case KnownFuncType.Cos:  					temp = Math.Cos(args[0].DoubleValue);  					break;    				case KnownFuncType.Tan:  					temp = Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Cot:  					temp = 1 / Math.Tan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsin:  					temp = Math.Asin(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccos:  					temp = Math.Acos(args[0].DoubleValue);  					break;    				case KnownFuncType.Arctan:  					temp = Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Arccot:  					temp = Math.PI / 2 - Math.Atan(args[0].DoubleValue);  					break;    				case KnownFuncType.Sinh:  					temp = Math.Sinh(args[0].DoubleValue);  					break;    				case KnownFuncType.Cosh:  					temp = Math.Cosh(args[0].DoubleValue);  					break;    				case KnownFuncType.Arcsinh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1));  					break;    				case KnownFuncType.Arcosh:  					temp = Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1));  					break;    				case KnownFuncType.Exp:  					temp = Math.Exp(args[0].DoubleValue);  					break;    				case KnownFuncType.Ln:  					temp = Math.Log(args[0].DoubleValue);  					break;    				case KnownFuncType.Log10:  					temp = Math.Log10(args[0].DoubleValue);  					break;    				case KnownFuncType.Log:  					temp = Math.Log(args[0].DoubleValue' args[1].DoubleValue);  					break;    				case KnownFuncType.Abs:  					temp = Math.Abs(args[0].DoubleValue);  					break;    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The following statement contains a magic number: Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8)
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The following statement contains a magic number: Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8)
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,SimplifyValues,The following statement contains a magic number: Rational<long>.FromDecimal((decimal)temp' out result' 14' false' 4' 8)
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,OptimizeInstructions,The following statement contains a magic number: IlInstructions.RemoveRange(i' 2);
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,OptimizeInstructions,The following statement contains a magic number: IlInstructions.RemoveRange(i' 2);
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,OptimizeInstructions,The following statement contains a magic number: IlInstructions.RemoveRange(i' 2);
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitArgLoad,The following statement contains a magic number: switch (argNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldarg_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldarg_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldarg_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldarg_3);  					break;  				default:  					if (argNumber < 256)  						ilProcessor.Emit(OpCodes.Ldarg_S' (byte)argNumber);  					else  						ilProcessor.Emit(OpCodes.Ldarg' (ushort)argNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalLoad,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Ldloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Ldloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Ldloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Ldloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Ldloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Ldloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitLocalSave,The following statement contains a magic number: switch (localNumber)  			{  				case 0:  					ilProcessor.Emit(OpCodes.Stloc_0);  					break;  				case 1:  					ilProcessor.Emit(OpCodes.Stloc_1);  					break;  				case 2:  					ilProcessor.Emit(OpCodes.Stloc_2);  					break;  				case 3:  					ilProcessor.Emit(OpCodes.Stloc_3);  					break;  				default:  					if (localNumber < 256)  						ilProcessor.Emit(OpCodes.Stloc_S' (byte)localNumber);  					else  						ilProcessor.Emit(OpCodes.Stloc' (ushort)localNumber);  					break;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,PrecompileExpFunc,The following statement contains a magic number: funcNode.Children[1].IsValueOrCalculated && funcNode.Children[1].DoubleValue == 0.5
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,CalculateValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result += args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Sub:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Mult:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Div:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Pow:  					if (args[1].DoubleValue == 0.5)  						return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));  					else  						return new CalculatedNode(Math.Pow(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Neg:  					return new CalculatedNode(-args[0].DoubleValue);    				case KnownFuncType.Sgn:  					return new CalculatedNode((double)Math.Sign(args[0].DoubleValue));    				case KnownFuncType.Trunc:  					return new CalculatedNode(Math.Truncate(args[0].DoubleValue));    				case KnownFuncType.Round:  					return new CalculatedNode(Math.Round(args[0].DoubleValue));    				case KnownFuncType.Diff:  					return new CalculatedNode(0.0);    				case KnownFuncType.Sqrt:  					return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));    				case KnownFuncType.Sin:  					return new CalculatedNode(Math.Sin(args[0].DoubleValue));    				case KnownFuncType.Cos:  					return new CalculatedNode(Math.Cos(args[0].DoubleValue));    				case KnownFuncType.Tan:  					return new CalculatedNode(Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Cot:  					return new CalculatedNode(1 / Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Arcsin:  					return new CalculatedNode(Math.Asin(args[0].DoubleValue));    				case KnownFuncType.Arccos:  					return new CalculatedNode(Math.Acos(args[0].DoubleValue));    				case KnownFuncType.Arctan:  					return new CalculatedNode(Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Arccot:  					return new CalculatedNode(Math.PI / 2 - Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Sinh:  					return new CalculatedNode(Math.Sinh(args[0].DoubleValue));    				case KnownFuncType.Cosh:  					return new CalculatedNode(Math.Cosh(args[0].DoubleValue));    				case KnownFuncType.Arcsinh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1)));    				case KnownFuncType.Arcosh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1)));    				case KnownFuncType.Ln:  					return new CalculatedNode(Math.Log(args[0].DoubleValue));    				case KnownFuncType.Log10:  					return new CalculatedNode(Math.Log10(args[0].DoubleValue));    				case KnownFuncType.Log:  					return new CalculatedNode(Math.Log(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Abs:  					return new CalculatedNode(Math.Abs(args[0].DoubleValue));    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,CalculateValues,The following statement contains a magic number: switch (funcType)  			{  				case KnownFuncType.Add:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result += args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Sub:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result -= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Mult:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result *= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Div:  					result = args[0].DoubleValue;  					for (int i = 1; i < args.Count; i++)  						result /= args[i].DoubleValue;  					return new CalculatedNode(result);    				case KnownFuncType.Pow:  					if (args[1].DoubleValue == 0.5)  						return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));  					else  						return new CalculatedNode(Math.Pow(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Neg:  					return new CalculatedNode(-args[0].DoubleValue);    				case KnownFuncType.Sgn:  					return new CalculatedNode((double)Math.Sign(args[0].DoubleValue));    				case KnownFuncType.Trunc:  					return new CalculatedNode(Math.Truncate(args[0].DoubleValue));    				case KnownFuncType.Round:  					return new CalculatedNode(Math.Round(args[0].DoubleValue));    				case KnownFuncType.Diff:  					return new CalculatedNode(0.0);    				case KnownFuncType.Sqrt:  					return new CalculatedNode(Math.Sqrt(args[0].DoubleValue));    				case KnownFuncType.Sin:  					return new CalculatedNode(Math.Sin(args[0].DoubleValue));    				case KnownFuncType.Cos:  					return new CalculatedNode(Math.Cos(args[0].DoubleValue));    				case KnownFuncType.Tan:  					return new CalculatedNode(Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Cot:  					return new CalculatedNode(1 / Math.Tan(args[0].DoubleValue));    				case KnownFuncType.Arcsin:  					return new CalculatedNode(Math.Asin(args[0].DoubleValue));    				case KnownFuncType.Arccos:  					return new CalculatedNode(Math.Acos(args[0].DoubleValue));    				case KnownFuncType.Arctan:  					return new CalculatedNode(Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Arccot:  					return new CalculatedNode(Math.PI / 2 - Math.Atan(args[0].DoubleValue));    				case KnownFuncType.Sinh:  					return new CalculatedNode(Math.Sinh(args[0].DoubleValue));    				case KnownFuncType.Cosh:  					return new CalculatedNode(Math.Cosh(args[0].DoubleValue));    				case KnownFuncType.Arcsinh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue + 1)));    				case KnownFuncType.Arcosh:  					return new CalculatedNode(Math.Log(args[0].DoubleValue + Math.Sqrt(args[0].DoubleValue * args[0].DoubleValue - 1)));    				case KnownFuncType.Ln:  					return new CalculatedNode(Math.Log(args[0].DoubleValue));    				case KnownFuncType.Log10:  					return new CalculatedNode(Math.Log10(args[0].DoubleValue));    				case KnownFuncType.Log:  					return new CalculatedNode(Math.Log(args[0].DoubleValue' args[1].DoubleValue));    				case KnownFuncType.Abs:  					return new CalculatedNode(Math.Abs(args[0].DoubleValue));    				default:  					return null;  			}
Magic Number,MathExpressionsNET,MathFuncGenerator,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFuncGenerator.cs,Generate,The following statement contains a magic number: return new ValueNode(Rational<long>.Approximate((decimal)(MinValue + _rand.NextDouble() * (MaxValue - MinValue))' 0.001m));
Magic Number,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following statement contains a magic number: args.Count() >= 2
Magic Number,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following statement contains a magic number: Children.Add(new ValueNode(new Rational<long>(1' 2)));
Magic Number,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following statement contains a magic number: builder.Remove(builder.Length - 2' 2);
Magic Number,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following statement contains a magic number: builder.Remove(builder.Length - 2' 2);
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TenInPower,The following statement contains a magic number: result *= 10;
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TenInNegPower,The following statement contains a magic number: result /= 10.0m;
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: ulong result = 9;
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: result = result * 10 + 9;
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Nines,The following statement contains a magic number: result = result * 10 + 9;
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,Parse,The following statement contains a magic number: string[] parts = value.Split(Rational<T>.DelimSet' 2' StringSplitOptions.RemoveEmptyEntries);
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TryParse,The following statement contains a magic number: string[] parts = value.Split(Rational<T>.DelimSet' 2' StringSplitOptions.RemoveEmptyEntries);
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,TryParse,The following statement contains a magic number: return (parts.Length == 2);
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,GetHashCode,The following statement contains a magic number: num = (-1521134295 * num) + EqualityComparer<T>.Default.GetHashCode(this.numerator);
Magic Number,MathExpressionsNET,Rational,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Rational.cs,GetHashCode,The following statement contains a magic number: return ((-1521134295 * num) + EqualityComparer<T>.Default.GetHashCode(this.denominator));
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitNode,The following switch statement is missing a default case: switch (node)  			{  				case CalculatedNode calculatedNode:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8'  						negExpAbs ? Math.Abs(calculatedNode.Value) : calculatedNode.Value));  					break;  				case ValueNode valueNode:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldc_R8'  						negExpAbs ? Math.Abs(valueNode.Value.ToDouble()) : valueNode.Value.ToDouble()));  					break;    				case ConstNode constNode:  				case VarNode varNode:  					IlInstructions.Add(new OpCodeArg(OpCodes.Ldarg' node.ArgNumber));  					break;    				case FuncNode funcNode:  					var func = FuncNodes[funcNode];  					if (!func.Calculated)  					{  						EmitFunc(funcNode' negExpAbs);  						func.Calculated = true;  						// if (FuncNodes[funcNode].Count > 1) TODO: this optimization disallowed due to derivatives.  						{  							IlInstructions.Add(new OpCodeArg(OpCodes.Stloc' funcNode.Number));  							IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  						}  					}  					else  						IlInstructions.Add(new OpCodeArg(OpCodes.Ldloc' funcNode.Number));  					break;  			}
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,EmitFunc,The following switch statement is missing a default case: switch (funcNode.FunctionType)  			{  				case KnownFuncType.Add:  					return EmitAddFunc(funcNode);  				case KnownFuncType.Sub:  					return EmitSubFunc(funcNode);  				case KnownFuncType.Mult:  					return EmitMultFunc(funcNode);  				case KnownFuncType.Div:  					return EmitDivFunc(funcNode);  				case KnownFuncType.Neg:  					return EmitNegFunc(funcNode' negExpAbs);  				case KnownFuncType.Pow:  					return EmitExpFunc(funcNode' negExpAbs);  				case KnownFuncType.Diff:  					return EmitDiffFunc(funcNode);  			}
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,GetDerivative,The following switch statement is missing a default case: switch (node)  			{  				case CalculatedNode calculatedNode:  					return new CalculatedNode(0.0);  				case ValueNode valueNode:  				case ConstNode constNode:  					return new ValueNode(0);  				case VarNode varNode:  					return new ValueNode(1);  				case FuncNode funcNode:  					return GetFuncDerivative(funcNode);  			}
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MakeSubstitution,The following switch statement is missing a default case: switch (node)  			{  				case CalculatedNode calculatedNode:  					result = new CalculatedNode(calculatedNode.Value);  					break;  				case ValueNode valueNode:  					result = new ValueNode(valueNode);  					break;  				case ConstNode constNode:  				case VarNode varNode:  					result = node;  					break;  				case FuncNode funcNode:  					result = funcNode.FunctionType != null ?  						new FuncNode((KnownFuncType)funcNode.FunctionType) :  						new FuncNode(node.Name);  					break;  			}
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,MakeSubstitution,The following switch statement is missing a default case: switch (node.Children[i])  				{  					case CalculatedNode calculatedNode:  						result.Children.Add(new CalculatedNode(calculatedNode));  						break;  					case ValueNode valueNode:  						result.Children.Add(new ValueNode(valueNode));  						break;  					case ConstNode constNode:  					case VarNode varNode:  						result.Children.Add(node.Children[i]);  						break;  					case FuncNode funcNode:  						result.Children.Add(MakeSubstitution(funcNode));  						break;  				}
Missing Default,MathExpressionsNET,MathFunc,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\MathFunc.cs,Precompile,The following switch statement is missing a default case: switch (func.FunctionType)  				{  					case KnownFuncType.Add:  						node = PrecompileAddFunc(func);  						break;    					case KnownFuncType.Mult:  						node = PrecompileMultFunc(func);  						break;    					case KnownFuncType.Pow:  						node = PrecompileExpFunc(parent' func);  						break;  				}
Missing Default,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,FuncNode,The following switch statement is missing a default case: switch (node.Children[i])  				{  					case ValueNode valueNode:  						Children.Add(new ValueNode(valueNode.Value));  						break;  					case ConstNode constNode:  					case VarNode varNode:  						Children.Add(node.Children[i]);  						break;  					case FuncNode funcNode:  						Children.Add(new FuncNode(funcNode));  						break;  				}
Missing Default,MathExpressionsNET,FuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\FuncNode.cs,ToString,The following switch statement is missing a default case: switch ((KnownFuncType)FunctionType)  				{  					case KnownFuncType.Add:  					case KnownFuncType.Sub:  						return ToString(parent' funcType' KnownFunc.AddKnownFuncs);    					case KnownFuncType.Mult:  					case KnownFuncType.Div:  						return ToString(parent' funcType' KnownFunc.MultKnownFuncs);    					case KnownFuncType.Pow:  						return ToString(parent' funcType' KnownFunc.ExpKnownFuncs);    					case KnownFuncType.Neg:  						if (Children[0] is FuncNode funcNode)  						{  							if (KnownFunc.NegKnownFuncs.Contains((KnownFuncType)funcNode.FunctionType))  								return "-(" + Children[0].ToString(this) + ")";  							else  								return "-" + Children[0].ToString(this);  						}  						else  							return "-" + Children[0].ToString(this);    					case KnownFuncType.Diff:  						return Children[0] is FuncNode funcNode2 && funcNode2.FunctionType != KnownFuncType.Diff ?  							Children[0].ToString(this) + "'" : "(" +   							Children[0].ToString(this) + ")'";    					case KnownFuncType.Abs:  						return string.Format("|{0}|"' Children[0].ToString(this));  				}
Missing Default,MathExpressionsNET,MathFuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other)  					{  						case FuncNode otherFuncNode:  						case VarNode otherVarNode:  						case ConstNode otherConstNode:  							result = 1;  							break;  						case ValueNode otherValueNode:  							result = valueNode.Value.CompareTo(otherValueNode.Value);  							break;  						case CalculatedNode otherCalculatedNode:  							result = valueNode.Value.ToDouble(CultureInfo.InvariantCulture).CompareTo(otherCalculatedNode.Value);  							break;  					}
Missing Default,MathExpressionsNET,MathFuncNode,D:\research\architectureSmells\repos\KvanTTT_MathExpressions.NET\MathExpressions.NET\Nodes\MathFuncNode.cs,CompareTo,The following switch statement is missing a default case: switch (other)  					{  						case FuncNode otherFuncNode:  						case VarNode otherVarNode:  						case ConstNode otherConstNode:  							result = 1;  							break;  						case ValueNode otherValueNode:  							result = calculatedNode.Value.CompareTo(otherValueNode.Value.ToDouble(CultureInfo.InvariantCulture));  							break;  						case CalculatedNode otherCalculatedNode:  							result = calculatedNode.Value.CompareTo(otherCalculatedNode.Value);  							break;  					}
