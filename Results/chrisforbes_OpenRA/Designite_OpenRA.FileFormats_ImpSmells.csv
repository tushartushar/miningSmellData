Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The method has 102 lines of code.
Complex Method,OpenRA.FileFormats,Huffman,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Huffman,Cyclomatic complexity of the method is 9
Complex Method,OpenRA.FileFormats,MiniYaml,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\MiniYaml.cs,Merge,Cyclomatic complexity of the method is 9
Long Parameter List,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,sub_bignum,The method has 5 parameters. Parameters: dest' src1' src2' carry' len
Long Parameter List,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,sub_bignum,The method has 5 parameters. Parameters: dest' src1' src2' carry' len
Long Parameter List,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_key,The method has 5 parameters. Parameters: n1' n2' n3' n4' len
Long Parameter List,OpenRA.FileFormats,InstallUtils,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\InstallUtils.cs,ExtractFromPackage,The method has 6 parameters. Parameters: srcPath' package' files' destPath' onProgress' onError
Long Parameter List,OpenRA.FileFormats,InstallUtils,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\InstallUtils.cs,CopyFiles,The method has 5 parameters. Parameters: srcPath' files' destPath' onProgress' onError
Long Parameter List,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,ToDictionaryWithConflictLog,The method has 5 parameters. Parameters: source' keySelector' debugName' logKey' logValue
Long Parameter List,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,ToDictionaryWithConflictLog,The method has 6 parameters. Parameters: source' keySelector' elementSelector' debugName' logKey' logValue
Long Parameter List,OpenRA,MouseInput,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\IInputHandler.cs,MouseInput,The method has 5 parameters. Parameters: ev' button' location' mods' multiTapCount
Long Parameter List,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,UnapplyFilter,The method has 5 parameters. Parameters: f' x' a' b' c
Long Statement,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,TryGetValueFromYaml,The length of the statement  "			throw new InvalidOperationException( "TryGetValueFromYaml: unable to load field {0} (of type {1})".F( fieldName' fieldType ) ); " is 127.
Long Statement,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The length of the statement  "					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)); " is 127.
Long Statement,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The length of the statement  "					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255)); " is 162.
Long Statement,OpenRA.FileFormats,LoadUsingAttribute,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,LoaderFunc,The length of the statement  "					loaderFuncCache = (Func<MiniYaml' object>)Delegate.CreateDelegate( typeof( Func<MiniYaml' object> )' field.DeclaringType.GetMethod( Loader' bf ) ); " is 147.
Long Statement,OpenRA.FileFormats,FieldSaver,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,FormatValue,The length of the statement  "			// Don't save floats in settings.yaml using country-specific decimal separators which can be misunderstood as group seperators. " is 127.
Long Statement,OpenRA.FileFormats,MiniYaml,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\MiniYaml.cs,FromDictionary,The length of the statement  "			return new MiniYaml( null' dict.Select( x => new MiniYamlNode( x.Key.ToString()' new MiniYaml( x.Value.ToString() ) ) ).ToList() ); " is 131.
Long Statement,OpenRA.FileFormats,MiniYaml,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\MiniYaml.cs,Merge,The length of the statement  "			var aDict = a.ToDictionaryWithConflictLog(x => x.Key' "MiniYaml.Merge"' null' x => "{0} (at {1})".F(x.Key' x.Location)); " is 120.
Long Statement,OpenRA.FileFormats,MiniYaml,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\MiniYaml.cs,Merge,The length of the statement  "			var bDict = b.ToDictionaryWithConflictLog(x => x.Key' "MiniYaml.Merge"' null' x => "{0} (at {1})".F(x.Key' x.Location)); " is 120.
Long Statement,OpenRA.FileFormats,MiniYaml,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\MiniYaml.cs,Merge,The length of the statement  "					var merged = ( aa == null || bb == null ) ? aa ?? bb : new MiniYamlNode( key' Merge( aa.Value' bb.Value' throwErrors )' loc ); " is 126.
Long Statement,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,ToDictionaryWithConflictLog,The length of the statement  "				string badKeysFormatted = String.Join("' "' dupKeys.Select(p => "{0}: [{1}]".F(logKey(p.Key)' String.Join("'"' p.Value.ToArray()))).ToArray()); " is 143.
Long Statement,OpenRA,int2,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\int2.cs,Swap,The length of the statement  "			return (uint)((orig & 0xff000000) >> 24) | ((orig & 0x00ff0000) >> 8) | ((orig & 0x0000ff00) << 8) | ((orig & 0x000000ff) << 24); " is 129.
Empty Catch Block,OpenRA.FileFormats,FileSystem,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\FileSystem.cs,Mount,The method has an empty catch block.
Empty Catch Block,OpenRA,Platform,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Platform.cs,GetCurrentPlatform,The method has an empty catch block.
Empty Catch Block,OpenRA,Log,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Support\Log.cs,AddChannel,The method has an empty catch block.
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: var p = 2 * l - q;
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				while (trgb[k] < 0) trgb[k] += 1.0f;  				while (trgb[k] > 1) trgb[k] -= 1.0f;  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: for (int k = 0; k < 3; k++)  			{  				if (trgb[k] < 1 / 6.0f) { rgb[k] = (p + ((q - p) * 6 * trgb[k])); }  				else if (trgb[k] >= 1 / 6.0f && trgb[k] < 0.5) { rgb[k] = q; }  				else if (trgb[k] >= 0.5f && trgb[k] < 2.0f / 3) { rgb[k] = (p + ((q - p) * 6 * (2.0f / 3 - trgb[k]))); }  				else { rgb[k] = p; }  			}
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: return Color.FromArgb((int)(rgb[0] * 255)' (int)(rgb[1] * 255)' (int)(rgb[2] * 255));
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: return Color.FromArgb((int)(rgb[0] * 255)' (int)(rgb[1] * 255)' (int)(rgb[2] * 255));
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: return Color.FromArgb((int)(rgb[0] * 255)' (int)(rgb[1] * 255)' (int)(rgb[2] * 255));
Magic Number,OpenRA.FileFormats,ColorRamp,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\ColorRamp.cs,ColorFromHSL,The following statement contains a magic number: return Color.FromArgb((int)(rgb[0] * 255)' (int)(rgb[1] * 255)' (int)(rgb[2] * 255));
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,GetValue,The following statement contains a magic number: if( fieldType == typeof( int ) )  			{  				int res;  				if (int.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if( fieldType == typeof( ushort ) )  			{  				ushort res;  				if (ushort.TryParse(x'out res))  					return res;  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(float))  			{  				float res;  				if (float.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01f : 1f);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(decimal))  			{  				decimal res;  				if (decimal.TryParse(x.Replace("%"'"")'  NumberStyles.Any' NumberFormatInfo.InvariantInfo' out res))  					return res * (x.Contains( '%' ) ? 0.01m : 1m);  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(string))  				return x;    			else if (fieldType == typeof(Color))  			{  				var parts = x.Split(''');  				if (parts.Length == 3)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255));  				if (parts.Length == 4)  					return Color.FromArgb(int.Parse(parts[0]).Clamp(0' 255)' int.Parse(parts[1]).Clamp(0' 255)' int.Parse(parts[2]).Clamp(0' 255)' int.Parse(parts[3]).Clamp(0' 255));  				return InvalidValueAction(x'fieldType' field);  			}    			else if (fieldType == typeof(ColorRamp))  			{  				var parts = x.Split(''');  				if (parts.Length == 4)  					return new ColorRamp(  						(byte)int.Parse(parts[0]).Clamp(0' 255)'  						(byte)int.Parse(parts[1]).Clamp(0' 255)'  						(byte)int.Parse(parts[2]).Clamp(0' 255)'  						(byte)int.Parse(parts[3]).Clamp(0' 255));    				return InvalidValueAction(x' fieldType' field);  			}    			else if (fieldType.IsEnum)  			{  				if (!Enum.GetNames(fieldType).Select(a => a.ToLower()).Contains(x.ToLower()))  					return InvalidValueAction(x' fieldType' field);  				return Enum.Parse(fieldType' x' true);  			}    			else if (fieldType == typeof(bool))  				return ParseYesNo(x' fieldType' field);    			else if (fieldType.IsArray)  			{  				if (x == null)  					return Array.CreateInstance(fieldType.GetElementType()' 0);    				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);    				var ret = Array.CreateInstance(fieldType.GetElementType()' parts.Length);  				for (int i = 0; i < parts.Length; i++)  					ret.SetValue(GetValue(field' fieldType.GetElementType()' parts[i].Trim())' i);  				return ret;  			}  			else if (fieldType == typeof(int2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new int2(int.Parse(parts[0])' int.Parse(parts[1]));  			}  			else if (fieldType == typeof(float2))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				float xx = 0;  				float yy = 0;  				float res;  				if (float.TryParse(parts[0].Replace("%"' "")' out res))  					xx = res * (parts[0].Contains('%') ? 0.01f : 1f);  				if (float.TryParse(parts[1].Replace("%"' "")' out res))  					yy = res * (parts[1].Contains('%') ? 0.01f : 1f);  				return new float2(xx' yy);  			}  			else if (fieldType == typeof(Rectangle))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				return new Rectangle(int.Parse(parts[0])' int.Parse(parts[1])' int.Parse(parts[2])' int.Parse(parts[3]));  			}  			else if (fieldType.IsGenericType && fieldType.GetGenericTypeDefinition() == typeof(Bits<>))  			{  				var parts = x.Split(new char[] { ''' }' StringSplitOptions.RemoveEmptyEntries);  				var argTypes = new Type[] { typeof(string[]) };  				var argValues = new object[] { parts };  				return fieldType.GetConstructor(argTypes).Invoke(argValues);  			}
Magic Number,OpenRA.FileFormats,FieldSaver,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,FormatValue,The following statement contains a magic number: if (t == typeof(Color))  			{  				var c = (Color)v;  				return "{0}'{1}'{2}'{3}".F(((int)c.A).Clamp(0' 255)'  					((int)c.R).Clamp(0' 255)'  					((int)c.G).Clamp(0' 255)'  					((int)c.B).Clamp(0' 255));  			}
Magic Number,OpenRA.FileFormats,FieldSaver,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,FormatValue,The following statement contains a magic number: if (t == typeof(Color))  			{  				var c = (Color)v;  				return "{0}'{1}'{2}'{3}".F(((int)c.A).Clamp(0' 255)'  					((int)c.R).Clamp(0' 255)'  					((int)c.G).Clamp(0' 255)'  					((int)c.B).Clamp(0' 255));  			}
Magic Number,OpenRA.FileFormats,FieldSaver,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,FormatValue,The following statement contains a magic number: if (t == typeof(Color))  			{  				var c = (Color)v;  				return "{0}'{1}'{2}'{3}".F(((int)c.A).Clamp(0' 255)'  					((int)c.R).Clamp(0' 255)'  					((int)c.G).Clamp(0' 255)'  					((int)c.B).Clamp(0' 255));  			}
Magic Number,OpenRA.FileFormats,FieldSaver,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FieldLoader.cs,FormatValue,The following statement contains a magic number: if (t == typeof(Color))  			{  				var c = (Color)v;  				return "{0}'{1}'{2}'{3}".F(((int)c.A).Clamp(0' 255)'  					((int)c.R).Clamp(0' 255)'  					((int)c.G).Clamp(0' 255)'  					((int)c.B).Clamp(0' 255));  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: var sb = (b & 8) != 0;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: b &= 7;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: var delta = (StepTable[index] * b) / 4 + StepTable[index] / 8;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: var delta = (StepTable[index] * b) / 4 + StepTable[index] / 8;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: if (index > 88) index = 88;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,DecodeSample,The following statement contains a magic number: if (index > 88) index = 88;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: var outputSize = raw.Length * 4;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize-- > 0)  			{  				var b = br.ReadByte();    				var t = DecodeSample(b' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);    				t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize-- > 0)  			{  				var b = br.ReadByte();    				var t = DecodeSample(b' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);    				t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize-- > 0)  			{  				var b = br.ReadByte();    				var t = DecodeSample(b' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);    				t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  				output[offset++] = (byte)t;  				output[offset++] = (byte)(t >> 8);  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,SoundLength,The following statement contains a magic number: if (0 != (flags & SoundFlags.Stereo)) samples /= 2;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,SoundLength,The following statement contains a magic number: if (0 != (flags & SoundFlags._16Bit)) samples /= 2;
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize > 0)  			{  				var chunk = Chunk.Read(br);  				for (int n = 0; n < chunk.CompressedSize; n++)  				{  					var b = br.ReadByte();    					var t = DecodeSample(b' ref index' ref currentSample);  					output[offset++] = (byte)t;  					output[offset++] = (byte)(t >> 8);    					if (offset < outputSize)  					{  						/* possible that only half of the final byte is used! */  						t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  						output[offset++] = (byte)t;  						output[offset++] = (byte)(t >> 8);  					}  				}    				dataSize -= 8 + chunk.CompressedSize;  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize > 0)  			{  				var chunk = Chunk.Read(br);  				for (int n = 0; n < chunk.CompressedSize; n++)  				{  					var b = br.ReadByte();    					var t = DecodeSample(b' ref index' ref currentSample);  					output[offset++] = (byte)t;  					output[offset++] = (byte)(t >> 8);    					if (offset < outputSize)  					{  						/* possible that only half of the final byte is used! */  						t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  						output[offset++] = (byte)t;  						output[offset++] = (byte)(t >> 8);  					}  				}    				dataSize -= 8 + chunk.CompressedSize;  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize > 0)  			{  				var chunk = Chunk.Read(br);  				for (int n = 0; n < chunk.CompressedSize; n++)  				{  					var b = br.ReadByte();    					var t = DecodeSample(b' ref index' ref currentSample);  					output[offset++] = (byte)t;  					output[offset++] = (byte)(t >> 8);    					if (offset < outputSize)  					{  						/* possible that only half of the final byte is used! */  						t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  						output[offset++] = (byte)t;  						output[offset++] = (byte)(t >> 8);  					}  				}    				dataSize -= 8 + chunk.CompressedSize;  			}
Magic Number,OpenRA.FileFormats,AudLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\AudLoader.cs,LoadSound,The following statement contains a magic number: while (dataSize > 0)  			{  				var chunk = Chunk.Read(br);  				for (int n = 0; n < chunk.CompressedSize; n++)  				{  					var b = br.ReadByte();    					var t = DecodeSample(b' ref index' ref currentSample);  					output[offset++] = (byte)t;  					output[offset++] = (byte)(t >> 8);    					if (offset < outputSize)  					{  						/* possible that only half of the final byte is used! */  						t = DecodeSample((byte)(b >> 4)' ref index' ref currentSample);  						output[offset++] = (byte)t;  						output[offset++] = (byte)(t >> 8);  					}  				}    				dataSize -= 8 + chunk.CompressedSize;  			}
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: int coded = br.ReadBits(8);
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: int dict = br.ReadBits(8);
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: if (dict < 4 || dict > 6)  				throw new InvalidDataException("Invalid dictionary size");
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: if (dict < 4 || dict > 6)  				throw new InvalidDataException("Invalid dictionary size");
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: do  			{  				// length/distance pair  				if (br.ReadBits(1) == 1)  				{  					// Length  					int symbol = Decode(lencode' br);  					int len = lengthbase[symbol] + br.ReadBits(extra[symbol]);  					if (len == 519) // Magic number for "done"  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						break;  					}    					// Distance  					symbol = len == 2 ? 2 : dict;  					int dist = Decode(distcode' br) << symbol;  					dist += br.ReadBits(symbol);  					dist++;    					if (first && dist > next)  						throw new InvalidDataException("Attempt to jump before data");    					// copy length bytes from distance bytes back  					do  					{  						int dest = next;  						int source = dest - dist;    						int copy = MAXWIN;  						if (next < dist)  						{  							source += copy;  							copy = dist;  						}    						copy -= next;  						if (copy > len)  							copy = len;    						len -= copy;  						next += (ushort)copy;    						// copy with old-fashioned memcpy semantics  						// in case of overlapping ranges. this is NOT  						// the same as Array.Copy()  						while( copy-- > 0 )  							outBuffer[dest++] = outBuffer[source++];    						// Flush window to outstream  						if (next == MAXWIN)  						{  							for (int i = 0; i < next; i++)  								ms.WriteByte(outBuffer[i]);  							next = 0;  							first = false;  						}  					} while (len != 0);  				}  				else // literal value  				{  					int symbol = EncodedLiterals ? Decode(litcode' br) : br.ReadBits(8);  					outBuffer[next++] = (byte)symbol;  					if (next == MAXWIN)  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						next = 0;  						first = false;  					}  				}  			} while (true);
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: do  			{  				// length/distance pair  				if (br.ReadBits(1) == 1)  				{  					// Length  					int symbol = Decode(lencode' br);  					int len = lengthbase[symbol] + br.ReadBits(extra[symbol]);  					if (len == 519) // Magic number for "done"  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						break;  					}    					// Distance  					symbol = len == 2 ? 2 : dict;  					int dist = Decode(distcode' br) << symbol;  					dist += br.ReadBits(symbol);  					dist++;    					if (first && dist > next)  						throw new InvalidDataException("Attempt to jump before data");    					// copy length bytes from distance bytes back  					do  					{  						int dest = next;  						int source = dest - dist;    						int copy = MAXWIN;  						if (next < dist)  						{  							source += copy;  							copy = dist;  						}    						copy -= next;  						if (copy > len)  							copy = len;    						len -= copy;  						next += (ushort)copy;    						// copy with old-fashioned memcpy semantics  						// in case of overlapping ranges. this is NOT  						// the same as Array.Copy()  						while( copy-- > 0 )  							outBuffer[dest++] = outBuffer[source++];    						// Flush window to outstream  						if (next == MAXWIN)  						{  							for (int i = 0; i < next; i++)  								ms.WriteByte(outBuffer[i]);  							next = 0;  							first = false;  						}  					} while (len != 0);  				}  				else // literal value  				{  					int symbol = EncodedLiterals ? Decode(litcode' br) : br.ReadBits(8);  					outBuffer[next++] = (byte)symbol;  					if (next == MAXWIN)  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						next = 0;  						first = false;  					}  				}  			} while (true);
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: do  			{  				// length/distance pair  				if (br.ReadBits(1) == 1)  				{  					// Length  					int symbol = Decode(lencode' br);  					int len = lengthbase[symbol] + br.ReadBits(extra[symbol]);  					if (len == 519) // Magic number for "done"  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						break;  					}    					// Distance  					symbol = len == 2 ? 2 : dict;  					int dist = Decode(distcode' br) << symbol;  					dist += br.ReadBits(symbol);  					dist++;    					if (first && dist > next)  						throw new InvalidDataException("Attempt to jump before data");    					// copy length bytes from distance bytes back  					do  					{  						int dest = next;  						int source = dest - dist;    						int copy = MAXWIN;  						if (next < dist)  						{  							source += copy;  							copy = dist;  						}    						copy -= next;  						if (copy > len)  							copy = len;    						len -= copy;  						next += (ushort)copy;    						// copy with old-fashioned memcpy semantics  						// in case of overlapping ranges. this is NOT  						// the same as Array.Copy()  						while( copy-- > 0 )  							outBuffer[dest++] = outBuffer[source++];    						// Flush window to outstream  						if (next == MAXWIN)  						{  							for (int i = 0; i < next; i++)  								ms.WriteByte(outBuffer[i]);  							next = 0;  							first = false;  						}  					} while (len != 0);  				}  				else // literal value  				{  					int symbol = EncodedLiterals ? Decode(litcode' br) : br.ReadBits(8);  					outBuffer[next++] = (byte)symbol;  					if (next == MAXWIN)  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						next = 0;  						first = false;  					}  				}  			} while (true);
Magic Number,OpenRA.FileFormats,Blast,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Decompress,The following statement contains a magic number: do  			{  				// length/distance pair  				if (br.ReadBits(1) == 1)  				{  					// Length  					int symbol = Decode(lencode' br);  					int len = lengthbase[symbol] + br.ReadBits(extra[symbol]);  					if (len == 519) // Magic number for "done"  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						break;  					}    					// Distance  					symbol = len == 2 ? 2 : dict;  					int dist = Decode(distcode' br) << symbol;  					dist += br.ReadBits(symbol);  					dist++;    					if (first && dist > next)  						throw new InvalidDataException("Attempt to jump before data");    					// copy length bytes from distance bytes back  					do  					{  						int dest = next;  						int source = dest - dist;    						int copy = MAXWIN;  						if (next < dist)  						{  							source += copy;  							copy = dist;  						}    						copy -= next;  						if (copy > len)  							copy = len;    						len -= copy;  						next += (ushort)copy;    						// copy with old-fashioned memcpy semantics  						// in case of overlapping ranges. this is NOT  						// the same as Array.Copy()  						while( copy-- > 0 )  							outBuffer[dest++] = outBuffer[source++];    						// Flush window to outstream  						if (next == MAXWIN)  						{  							for (int i = 0; i < next; i++)  								ms.WriteByte(outBuffer[i]);  							next = 0;  							first = false;  						}  					} while (len != 0);  				}  				else // literal value  				{  					int symbol = EncodedLiterals ? Decode(litcode' br) : br.ReadBits(8);  					outBuffer[next++] = (byte)symbol;  					if (next == MAXWIN)  					{  						for (int i = 0; i < next; i++)  							ms.WriteByte(outBuffer[i]);  						next = 0;  						first = false;  					}  				}  			} while (true);
Magic Number,OpenRA.FileFormats,BitReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,ReadBits,The following statement contains a magic number: while (filled < count)  			{  				if (bitCount == 0)  				{  					bitBuffer = src[offset++];  					bitCount = 8;  				}    				ret |= (bitBuffer & 1) << filled;  				bitBuffer >>= 1;  				bitCount--;  				filled++;  			}
Magic Number,OpenRA.FileFormats,Huffman,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Huffman,The following statement contains a magic number: short[] length = new short[256];
Magic Number,OpenRA.FileFormats,Huffman,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Huffman,The following statement contains a magic number: foreach (byte code in rep)  			{  				int num = (code >> 4) + 1; // Number of codes (top four bits plus 1)  				byte len = (byte)(code & 15); // Code length (low four bits)  				do  				{  					length[s++] = len;  				} while (--num > 0);  			}
Magic Number,OpenRA.FileFormats,Huffman,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blast.cs,Huffman,The following statement contains a magic number: foreach (byte code in rep)  			{  				int num = (code >> 4) + 1; // Number of codes (top four bits plus 1)  				byte len = (byte)(code & 15); // Code length (low four bits)  				do  				{  					length[s++] = len;  				} while (--num > 0);  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i)  			{  				uint a = key[j++ % key.Length];  				uint b = key[j++ % key.Length];  				uint c = key[j++ % key.Length];  				uint d = key[j++ % key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i)  			{  				uint a = key[j++ % key.Length];  				uint b = key[j++ % key.Length];  				uint c = key[j++ % key.Length];  				uint d = key[j++ % key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i)  			{  				uint a = key[j++ % key.Length];  				uint b = key[j++ % key.Length];  				uint c = key[j++ % key.Length];  				uint d = key[j++ % key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i)  			{  				uint a = key[j++ % key.Length];  				uint b = key[j++ % key.Length];  				uint c = key[j++ % key.Length];  				uint d = key[j++ % key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 18; )  			{  				Encrypt(ref l' ref r);  				m_p[i++] = l;  				m_p[i++] = r;  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  				for (int j = 0; j < 256; )  				{  					Encrypt(ref l' ref r);  					m_s[i' j++] = l;  					m_s[i' j++] = r;  				}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  				for (int j = 0; j < 256; )  				{  					Encrypt(ref l' ref r);  					m_s[i' j++] = l;  					m_s[i' j++] = r;  				}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,RunCipher,The following statement contains a magic number: int size = data.Length / 2;
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Encrypt,The following statement contains a magic number: for( int i = 1; i <= 16; i++' x ^= true)  			{  				if (x)  					Round(ref _a' _b' i);  				else  					Round(ref _b' _a' i);  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Encrypt,The following statement contains a magic number: _b ^= m_p[17];
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Decrypt,The following statement contains a magic number: _a ^= m_p[17];
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 16; i >= 1; i--' x ^= true)  			{  				if (x)  					Round(ref _a' _b' i);  				else  					Round(ref _b' _a' i);  			}
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,S,The following statement contains a magic number: return m_s[i' (x >> ((3 - i) << 3)) & 0xff];
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,S,The following statement contains a magic number: return m_s[i' (x >> ((3 - i) << 3)) & 0xff];
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,bf_f,The following statement contains a magic number: return ((S(x' 0) + S(x' 1)) ^ S(x' 2)) + S(x' 3);
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,bf_f,The following statement contains a magic number: return ((S(x' 0) + S(x' 1)) ^ S(x' 2)) + S(x' 3);
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = (i << 16) | (i >> 16);
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = (i << 16) | (i >> 16);
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = ((i << 8) & 0xff00ff00) | ((i >> 8) & 0x00ff00ff);
Magic Number,OpenRA.FileFormats,Blowfish,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = ((i << 8) & 0xff00ff00) | ((i >> 8) & 0x00ff00ff);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,move_key_to_big,The following statement contains a magic number: unsafe  			{  				fixed (uint* _pn = &n[0])  				{  					byte* pn = (byte*)_pn;  					uint i = blen * 4;  					for (; i > klen; i--) pn[i - 1] = (byte)sign;  					for (; i > 0; i--) pn[i - 1] = key[klen - i];  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if (key[j] != 2) return;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if ((key[j] & 0x80) != 0)  			{  				keylen = 0;  				for (i = 0; i < (key[j] & 0x7f); i++) keylen = (keylen << 8) | key[j + i + 1];  				j += (key[j] & 0x7f) + 1;  			}  			else  			{  				keylen = key[j];  				j++;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if (keylen <= len * 4)  				move_key_to_big(n' key.Skip(j).ToArray()' keylen' len);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,bitlen_bignum,The following statement contains a magic number: bitlen = ddlen * 32;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: init_bignum(pubkey.key2' 0x10001' 64);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: key_to_bignum(pubkey.key1' Convert.FromBase64String(pubkeyStr)' 64);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: pubkey.len = bitlen_bignum(pubkey.key1' 64) - 1;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,len_predata,The following statement contains a magic number: uint a = (pubkey.len - 1) / 8;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,len_predata,The following statement contains a magic number: return (55 / a + 1) * (a + 1);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: int i2 = bits / 32;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: if (i2 > 0)  			{  				for (i = 0; i < len - i2; i++) n[i] = n[i + i2];  				for (; i < len; i++) n[i] = 0;  				bits = bits % 32;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: for (i = 0; i < len - 1; i++) n[i] = (n[i] >> bits) | (n[i + 1] << (32 -  		  bits));
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: i2 = bits / 32;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: if (i2 > 0)  			{  				for (i = len - 1; i > i2; i--) n[i] = n[i - i2];  				for (; i > 0; i--) n[i] = 0;  				bits = bits % 32;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: for (i = len - 1; i > 0; i--) n[i] = (n[i] << bits) | (n[i - 1] >> (32 -  		  bits));
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: uint[] n_tmp = new uint[64];
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: bit = ((uint)1) << (n2_bitlen % 32);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: j = ((n2_bitlen + 32) / 32) - 1;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: j = ((n2_bitlen + 32) / 32) - 1;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n2_bytelen = (uint)((n2_bitlen - 1) / 32) * 4;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n2_bytelen = (uint)((n2_bitlen - 1) / 32) * 4;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n_tmp[n2_bytelen / 4] |= ((uint)1) << ((n2_bitlen - 1) & 0x1f);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_len_x2 = (glob1_bitlen + 15) / 16;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_len_x2 = (glob1_bitlen + 15) / 16;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: mov_bignum(glob1_hi' glob1.Skip((int)len_bignum(glob1' len) - 2).ToArray()' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: mov_bignum(glob1_hi' glob1.Skip((int)len_bignum(glob1' len) - 2).ToArray()' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = bitlen_bignum(glob1_hi' 2) - 32;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = bitlen_bignum(glob1_hi' 2) - 32;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: shr_bignum(glob1_hi' (int)glob1_hi_bitlen' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: inv_bignum(glob1_hi_inv' glob1_hi' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: shr_bignum(glob1_hi_inv' 1' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = (glob1_hi_bitlen + 15) % 16 + 1;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = (glob1_hi_bitlen + 15) % 16 + 1;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: inc_bignum(glob1_hi_inv' 2);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32)  			{  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32)  			{  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32)  			{  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_inv_hi = (ushort)(glob1_hi_inv[0] >> 16);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,mul_bignum_word,The following statement contains a magic number: unsafe  			{  				fixed (uint* _pn2 = &n2[0])  				{  					ushort* pn2 = (ushort*)_pn2;    					tmp = 0;  					for (i = 0; i < len; i++)  					{  						tmp = mul * (*pn2) + (*pn1) + tmp;  						*pn1 = (ushort)tmp;  						pn1++;  						pn2++;  						tmp >>= 16;  					}  					*pn1 += (ushort)tmp;  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe  		  {  			  fixed( uint * _psrc2 = &src2[0] )  			  fixed(uint* _pdest = &dest[0])  			  {  				  ushort* psrc2 = (ushort*)_psrc2;  				  ushort* pdest = (ushort*)_pdest;    				  init_bignum(dest' 0' len * 2);  				  for (i = 0; i < len * 2; i++)  					  mul_bignum_word(pdest++' src1' *psrc2++' len * 2);  			  }  		  }
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe  		  {  			  fixed( uint * _psrc2 = &src2[0] )  			  fixed(uint* _pdest = &dest[0])  			  {  				  ushort* psrc2 = (ushort*)_psrc2;  				  ushort* pdest = (ushort*)_pdest;    				  init_bignum(dest' 0' len * 2);  				  for (i = 0; i < len * 2; i++)  					  mul_bignum_word(pdest++' src1' *psrc2++' len * 2);  			  }  		  }
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe  		  {  			  fixed( uint * _psrc2 = &src2[0] )  			  fixed(uint* _pdest = &dest[0])  			  {  				  ushort* psrc2 = (ushort*)_psrc2;  				  ushort* pdest = (ushort*)_pdest;    				  init_bignum(dest' 0' len * 2);  				  for (i = 0; i < len * 2; i++)  					  mul_bignum_word(pdest++' src1' *psrc2++' len * 2);  			  }  		  }
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: uint i = (uint)((((((((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_lo + 0x10000) >> 1)  				 + (((*(wn - 2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  				 >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_hi) >> 1) +  				 (((*wn ^ 0xffff) * glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  				 * (*wn ^ 0xffff) * 2) >> (int)glob1_hi_bitlen);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: uint i = (uint)((((((((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_lo + 0x10000) >> 1)  				 + (((*(wn - 2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  				 >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_hi) >> 1) +  				 (((*wn ^ 0xffff) * glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  				 * (*wn ^ 0xffff) * 2) >> (int)glob1_hi_bitlen);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: uint i = (uint)((((((((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_lo + 0x10000) >> 1)  				 + (((*(wn - 2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  				 >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_hi) >> 1) +  				 (((*wn ^ 0xffff) * glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  				 * (*wn ^ 0xffff) * 2) >> (int)glob1_hi_bitlen);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: uint i = (uint)((((((((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_lo + 0x10000) >> 1)  				 + (((*(wn - 2) ^ 0xffff) * glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  				 >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff) * glob1_hi_inv_hi) >> 1) +  				 (((*wn ^ 0xffff) * glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  				 * (*wn ^ 0xffff) * 2) >> (int)glob1_hi_bitlen);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe  			{  				fixed( uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0])  				{  					mul_bignum(glob2' n2' n3' len);  					glob2[len * 2] = 0;  					g2_len_x2 = len_bignum(glob2' len * 2 + 1) * 2;  					if (g2_len_x2 >= glob1_len_x2)  					{  						inc_bignum(glob2' len * 2 + 1);  						neg_bignum(glob2' len * 2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*)g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*)g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--)  						{  							edi--;  							uint tmp = get_mulword((uint*)edi);  							esi--;  							if (tmp > 0)  							{  								mul_bignum_word(esi' glob1' tmp' 2 * len);  								if ((*edi & 0x8000) == 0)  								{  									if (0 != sub_bignum((uint*)esi' (uint*)esi' g1' 0' (int)len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,clear_tmp_vars,The following statement contains a magic number: init_bignum(glob1_hi_inv' 0' 4);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,clear_tmp_vars,The following statement contains a magic number: init_bignum(glob1_hi' 0' 4);
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: uint[] n_tmp = new uint[64];
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe  			{  				fixed (uint* _pn3 = &n3[0])  				{  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int)bitlen_bignum(n3' n4_len);  					n3_len = (uint)((n3_bitlen + 31) / 32);  					bit_mask = (((uint)1) << ((n3_bitlen - 1) % 32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1)  					{  						if (bit_mask == 0)  						{  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe  			{  				fixed (uint* _pn3 = &n3[0])  				{  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int)bitlen_bignum(n3' n4_len);  					n3_len = (uint)((n3_bitlen + 31) / 32);  					bit_mask = (((uint)1) << ((n3_bitlen - 1) % 32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1)  					{  						if (bit_mask == 0)  						{  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe  			{  				fixed (uint* _pn3 = &n3[0])  				{  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int)bitlen_bignum(n3' n4_len);  					n3_len = (uint)((n3_bitlen + 31) / 32);  					bit_mask = (((uint)1) << ((n3_bitlen - 1) % 32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1)  					{  						if (bit_mask == 0)  						{  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: uint[] n2 = new uint[64];
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: uint[] n3 = new uint[64];
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: uint a = (pubkey.len - 1) / 8;
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: while (a + 1 <= pre_len)  			{  				init_bignum(n2' 0' 64);  				fixed( uint * pn2 = &n2[0] )  					memcpy((byte *)pn2' pre' (int)a + 1);  				calc_a_key(n3' n2' pubkey.key2' pubkey.key1' 64);    				fixed( uint * pn3 = &n3[0] )  					memcpy(buf' (byte *)pn3' (int)a);    				pre_len -= a + 1;  				pre += a + 1;  				buf += a;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: while (a + 1 <= pre_len)  			{  				init_bignum(n2' 0' 64);  				fixed( uint * pn2 = &n2[0] )  					memcpy((byte *)pn2' pre' (int)a + 1);  				calc_a_key(n3' n2' pubkey.key2' pubkey.key1' 64);    				fixed( uint * pn3 = &n3[0] )  					memcpy(buf' (byte *)pn3' (int)a);    				pre_len -= a + 1;  				pre += a + 1;  				buf += a;  			}
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,DecryptKey,The following statement contains a magic number: byte[] dest = new byte[256];
Magic Number,OpenRA.FileFormats,BlowfishKeyProvider,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\BlowfishKeyProvider.cs,DecryptKey,The following statement contains a magic number: return dest.Take(56).ToArray();
Magic Number,OpenRA.FileFormats,FastByteReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Format80.cs,ReadWord,The following statement contains a magic number: return x | (ReadByte() << 8);
Magic Number,OpenRA.FileFormats,Format80,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Format80.cs,DecodeInto,The following statement contains a magic number: while( true )  			{  				byte i = ctx.ReadByte();  				if( ( i & 0x80 ) == 0 )  				{  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ( ( i & 0x70 ) >> 4 ) + 3;  					int rpos = ( ( i & 0xf ) << 8 ) + secondByte;    					ReplicatePrevious( dest' destIndex' destIndex - rpos' count );  					destIndex += count;  				}  				else if( ( i & 0x40 ) == 0 )  				{  					// case 1  					int count = i & 0x3F;  					if( count == 0 )  						return destIndex;    					ctx.CopyTo( dest' destIndex' count );  					destIndex += count;  				}  				else  				{  					int count3 = i & 0x3F;  					if( count3 == 0x3E )  					{  						// case 4  						int count = ctx.ReadWord();  						byte color = ctx.ReadByte();    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = color;  					}  					else if( count3 == 0x3F )  					{  						// case 5  						int count = ctx.ReadWord();  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  					else  					{  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  				}  			}
Magic Number,OpenRA.FileFormats,Format80,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Format80.cs,DecodeInto,The following statement contains a magic number: while( true )  			{  				byte i = ctx.ReadByte();  				if( ( i & 0x80 ) == 0 )  				{  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ( ( i & 0x70 ) >> 4 ) + 3;  					int rpos = ( ( i & 0xf ) << 8 ) + secondByte;    					ReplicatePrevious( dest' destIndex' destIndex - rpos' count );  					destIndex += count;  				}  				else if( ( i & 0x40 ) == 0 )  				{  					// case 1  					int count = i & 0x3F;  					if( count == 0 )  						return destIndex;    					ctx.CopyTo( dest' destIndex' count );  					destIndex += count;  				}  				else  				{  					int count3 = i & 0x3F;  					if( count3 == 0x3E )  					{  						// case 4  						int count = ctx.ReadWord();  						byte color = ctx.ReadByte();    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = color;  					}  					else if( count3 == 0x3F )  					{  						// case 5  						int count = ctx.ReadWord();  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  					else  					{  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  				}  			}
Magic Number,OpenRA.FileFormats,Format80,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Format80.cs,DecodeInto,The following statement contains a magic number: while( true )  			{  				byte i = ctx.ReadByte();  				if( ( i & 0x80 ) == 0 )  				{  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ( ( i & 0x70 ) >> 4 ) + 3;  					int rpos = ( ( i & 0xf ) << 8 ) + secondByte;    					ReplicatePrevious( dest' destIndex' destIndex - rpos' count );  					destIndex += count;  				}  				else if( ( i & 0x40 ) == 0 )  				{  					// case 1  					int count = i & 0x3F;  					if( count == 0 )  						return destIndex;    					ctx.CopyTo( dest' destIndex' count );  					destIndex += count;  				}  				else  				{  					int count3 = i & 0x3F;  					if( count3 == 0x3E )  					{  						// case 4  						int count = ctx.ReadWord();  						byte color = ctx.ReadByte();    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = color;  					}  					else if( count3 == 0x3F )  					{  						// case 5  						int count = ctx.ReadWord();  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  					else  					{  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  				}  			}
Magic Number,OpenRA.FileFormats,Format80,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\FileFormats\Format80.cs,DecodeInto,The following statement contains a magic number: while( true )  			{  				byte i = ctx.ReadByte();  				if( ( i & 0x80 ) == 0 )  				{  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ( ( i & 0x70 ) >> 4 ) + 3;  					int rpos = ( ( i & 0xf ) << 8 ) + secondByte;    					ReplicatePrevious( dest' destIndex' destIndex - rpos' count );  					destIndex += count;  				}  				else if( ( i & 0x40 ) == 0 )  				{  					// case 1  					int count = i & 0x3F;  					if( count == 0 )  						return destIndex;    					ctx.CopyTo( dest' destIndex' count );  					destIndex += count;  				}  				else  				{  					int count3 = i & 0x3F;  					if( count3 == 0x3E )  					{  						// case 4  						int count = ctx.ReadWord();  						byte color = ctx.ReadByte();    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = color;  					}  					else if( count3 == 0x3F )  					{  						// case 5  						int count = ctx.ReadWord();  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  					else  					{  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadWord();  						if( srcIndex >= destIndex )  							throw new NotImplementedException("srcIndex >= destIndex {0} {1}".F(srcIndex' destIndex));    						for( int end = destIndex + count ; destIndex < end ; destIndex++ )  							dest[ destIndex ] = dest[ srcIndex++ ];  					}  				}  			}
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,InstallShieldPackage,The following statement contains a magic number: reader.ReadBytes(8);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,InstallShieldPackage,The following statement contains a magic number: reader.ReadBytes(4);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,InstallShieldPackage,The following statement contains a magic number: reader.ReadBytes(19);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,InstallShieldPackage,The following statement contains a magic number: reader.ReadBytes(4);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,ParseDirectory,The following statement contains a magic number: reader.ReadBytes(ChunkSize - NameLength - 6);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,ParseFile,The following statement contains a magic number: reader.ReadBytes(7);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,ParseFile,The following statement contains a magic number: reader.ReadBytes(12);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,ParseFile,The following statement contains a magic number: reader.ReadBytes(4);
Magic Number,OpenRA.FileFormats,InstallShieldPackage,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\InstallShieldPackage.cs,ParseFile,The following statement contains a magic number: reader.ReadBytes(ChunkSize - NameLength - 30);
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: byte[] keyblock = reader.ReadBytes(80);
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: uint[] h = ReadUints(reader' 2);
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: int byteCount = 6 + numFiles * PackageEntry.Size;
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: h = ReadUints( reader' ( byteCount + 3 ) / 4 );
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: h = ReadUints( reader' ( byteCount + 3 ) / 4 );
Magic Number,OpenRA.FileFormats,MixFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\MixFile.cs,ParseRaHeader,The following statement contains a magic number: dataStart = headerStart + byteCount + ( ( ~byteCount + 1 ) & 7 );
Magic Number,OpenRA.FileFormats,ZipFile,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Filesystem\ZipFile.cs,GetContent,The following statement contains a magic number: using (var z = pkg.GetInputStream(pkg.GetEntry(filename)))  			{  				var ms = new MemoryStream();  				int bufSize = 2048;  				byte[] buf = new byte[bufSize];  				while ((bufSize = z.Read(buf' 0' buf.Length)) > 0)  					ms.Write(buf' 0' bufSize);    				ms.Seek(0' SeekOrigin.Begin);  				return ms;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ImageHeader,The following statement contains a magic number: if (Flags == Dune2ImageFlags.L16_F80_F2_1 ||  				Flags == Dune2ImageFlags.L16_F80_F2_2 ||  				Flags == Dune2ImageFlags.Ln_F80_F2)  			{  				int n = Flags == Dune2ImageFlags.Ln_F80_F2 ? reader.ReadByte() : (byte)16;  				LookupTable = new byte[n];  				for (int i = 0; i < n; i++)  					LookupTable[i] = reader.ReadByte();  			}  			else  			{  				LookupTable = new byte[256];  				for (int i = 0; i < 256; i++)  					LookupTable[i] = (byte)i;  				LookupTable[1] = 0x7f;  				LookupTable[2] = 0x7e;  				LookupTable[3] = 0x7d;  				LookupTable[4] = 0x7c;  			}
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: if (twoByteOffsets)  			{  				offsets[0] = ((temp & 0xFFFF0000) >> 16) + 2; //Offset does not account for image count bytes  				offsets[1] = (temp & 0xFFFF) + 2;  			}  			else  				offsets[0] = temp + 2;
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: if (twoByteOffsets)  			{  				offsets[0] = ((temp & 0xFFFF0000) >> 16) + 2; //Offset does not account for image count bytes  				offsets[1] = (temp & 0xFFFF) + 2;  			}  			else  				offsets[0] = temp + 2;
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: if (twoByteOffsets)  			{  				offsets[0] = ((temp & 0xFFFF0000) >> 16) + 2; //Offset does not account for image count bytes  				offsets[1] = (temp & 0xFFFF) + 2;  			}  			else  				offsets[0] = temp + 2;
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: if (twoByteOffsets)  			{  				offsets[0] = ((temp & 0xFFFF0000) >> 16) + 2; //Offset does not account for image count bytes  				offsets[1] = (temp & 0xFFFF) + 2;  			}  			else  				offsets[0] = temp + 2;
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: for (int i = twoByteOffsets ? 2 : 1; i < ImageCount + 1; i++)  				offsets[i] = (twoByteOffsets ? reader.ReadUInt16() : reader.ReadUInt32()) + 2;
Magic Number,OpenRA.FileFormats,Dune2ShpReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\Dune2ShpReader.cs,Dune2ShpReader,The following statement contains a magic number: for (int i = twoByteOffsets ? 2 : 1; i < ImageCount + 1; i++)  				offsets[i] = (twoByteOffsets ? reader.ReadUInt16() : reader.ReadUInt32()) + 2;
Magic Number,OpenRA.FileFormats,ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\ShpReader.cs,ImageHeader,The following statement contains a magic number: Format = (Format)(data >> 24);
Magic Number,OpenRA.FileFormats,ImageHeader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\ShpReader.cs,WriteTo,The following statement contains a magic number: writer.Write(Offset | ((uint)Format << 24));
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: if (new String(reader.ReadChars(4)) != "FORM")  				throw new InvalidDataException("Invalid vqa (invalid FORM section)");
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: if (new String(reader.ReadChars(8)) != "WVQAVQHD")  				throw new InvalidDataException("Invalid vqa (not WVQAVQHD)");
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: reader.ReadChars(14);
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: origData = new byte[2*blocks.X*blocks.Y];
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: var type = new String(reader.ReadChars(4));
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: if (type != "FINF")  			{  				reader.ReadBytes(27);  				type = new String(reader.ReadChars(4));  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,VqaReader,The following statement contains a magic number: if (type != "FINF")  			{  				reader.ReadBytes(27);  				type = new String(reader.ReadChars(4));  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,CollectAudioData,The following statement contains a magic number: for (var i = 0; i < Frames; i++)  			{  				stream.Seek(offsets[i]' SeekOrigin.Begin);  				BinaryReader reader = new BinaryReader(stream);  				var end = (i < Frames - 1) ? offsets[i + 1] : stream.Length;    				while (reader.BaseStream.Position < end)  				{  					var type = new String(reader.ReadChars(4));  					var length = int2.Swap(reader.ReadUInt32());    					switch (type)  					{  						case "SND0":  						case "SND2":  							var rawAudio = reader.ReadBytes((int)length);  							ms.Write(rawAudio);  							compressed = (type == "SND2");  							break;  						default:  							reader.ReadBytes((int)length);  							break;  					}    					if (reader.PeekChar() == 0) reader.ReadByte();  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,LoadFrame,The following statement contains a magic number: while(reader.BaseStream.Position < end)  			{  				var type = new String(reader.ReadChars(4));  				var length = int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					case "VQFR":  						DecodeVQFR(reader);  					break;  					default:  						// Don't parse sound here.  						reader.ReadBytes((int)length);  						break;  				}    				// Chunks are aligned on even bytes; advance by a byte if the next one is null  				if (reader.PeekChar() == 0) reader.ReadByte();  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeVQFR,The following statement contains a magic number: while(true)  			{  				// Chunks are aligned on even bytes; may be padded with a single null  				if (reader.PeekChar() == 0) reader.ReadByte();  				var type = new String(reader.ReadChars(4));  				int subchunkLength = (int)int2.Swap(reader.ReadUInt32());    				switch(type)  				{  					// Full frame-modifier  					case "CBFZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' cbf );  					break;  					case "CBF0":  						cbf = reader.ReadBytes(subchunkLength);  					break;    					// frame-modifier chunk  					case "CBP0":  					case "CBPZ":  						// Partial buffer is full; dump and recreate  						if (cbChunk == cbParts)  						{  							if (type == "CBP0")  								cbf = (byte[])cbp.Clone();  							else  								Format80.DecodeInto( cbp' cbf );    							cbOffset = cbChunk = 0;  						}    						var bytes = reader.ReadBytes(subchunkLength);  						bytes.CopyTo(cbp'cbOffset);  						cbOffset += subchunkLength;  						cbChunk++;  					break;    					// Palette  					case "CPL0":  						for (int i = 0; i < numColors; i++)  						{  							byte r = (byte)(reader.ReadByte() << 2);  							byte g = (byte)(reader.ReadByte() << 2);  							byte b = (byte)(reader.ReadByte() << 2);  							palette[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  						}  					break;    					// Frame data  					case "VPTZ":  						Format80.DecodeInto( reader.ReadBytes(subchunkLength)' origData );  						// This is the last subchunk  						return;  					default:  						throw new InvalidDataException("Unknown sub-chunk {0}".F(type));  				}  			}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeFrameData,The following statement contains a magic number: for (var y = 0; y < blocks.Y; y++)  				for (var x = 0; x < blocks.X; x++)  				{  					var px = origData[x + y*blocks.X];  					var mod = origData[x + (y + blocks.Y)*blocks.X];  					for (var j = 0; j < blockHeight; j++)  						for (var i = 0; i < blockWidth; i++)  						{  							var cbfi = (mod*256 + px)*8 + j*blockWidth + i;  							byte color = (mod == 0x0f) ? px : cbf[cbfi];  							frameData[y*blockHeight + j' x*blockWidth + i] = palette[color];  						}  				}
Magic Number,OpenRA.FileFormats,VqaReader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\VqaReader.cs,DecodeFrameData,The following statement contains a magic number: for (var y = 0; y < blocks.Y; y++)  				for (var x = 0; x < blocks.X; x++)  				{  					var px = origData[x + y*blocks.X];  					var mod = origData[x + (y + blocks.Y)*blocks.X];  					for (var j = 0; j < blockHeight; j++)  						for (var i = 0; i < blockWidth; i++)  						{  							var cbfi = (mod*256 + px)*8 + j*blockWidth + i;  							byte color = (mod == 0x0f) ? px : cbf[cbfi];  							frameData[y*blockHeight + j' x*blockWidth + i] = palette[color];  						}  				}
Magic Number,OpenRA.FileFormats,InstallUtils,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\InstallUtils.cs,ExtractZip,The following statement contains a magic number: foreach (var entry in z.GetEntries())  			{  				if (!entry.IsFile) continue;    				onProgress(entry.Name);    				Directory.CreateDirectory(Path.Combine(destPath' Path.GetDirectoryName(entry.Name)));  				var path = Path.Combine(destPath' entry.Name);  				extracted.Add(path);    				using (var f = File.Create(path))  				{  					int bufSize = 2048;  					byte[] buf = new byte[bufSize];  					while ((bufSize = z.Read(buf' 0' buf.Length)) > 0)  					f.Write(buf' 0' bufSize);  				}  			}
Magic Number,OpenRA.FileFormats,Terrain,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Map\Terrain.cs,Terrain,The following statement contains a magic number: if (reader.ReadUInt16() == 65535) // ID1 = FFFFh for cnc  			{  				/*ID2 = */reader.ReadUInt16();  				IndexEnd = reader.ReadInt32();  				IndexStart = reader.ReadInt32();  			}  			else // Load as a ra .tem  			{  				stream.Position = 0;  				reader = new BinaryReader( stream );  				Width = reader.ReadUInt16();  				Height = reader.ReadUInt16();    				/*NumTiles = */reader.ReadUInt16();  				reader.ReadUInt16();  				/*XDim = */reader.ReadUInt16();  				/*YDim = */reader.ReadUInt16();  				/*uint FileSize = */reader.ReadUInt32();  				ImgStart = reader.ReadUInt32();  				reader.ReadUInt32();  				reader.ReadUInt32();  				IndexEnd = reader.ReadInt32();  				reader.ReadUInt32();  				IndexStart = reader.ReadInt32();  			}
Magic Number,OpenRA.FileFormats,Terrain,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Map\Terrain.cs,Terrain,The following statement contains a magic number: foreach( byte b in new BinaryReader(stream).ReadBytes(IndexEnd - IndexStart) )  			{  				if (b != 255)  				{  					stream.Position = ImgStart + b * size * size;  					TileBitmapBytes.Add(new BinaryReader(stream).ReadBytes(size * size));  				}  				else  					TileBitmapBytes.Add(null);  			}
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: if (name.Length > 12)  				name = name.Substring(0' 12);
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: if (name.Length > 12)  				name = name.Substring(0' 12);
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: if (name.Length % 4 != 0)  				name = name.PadRight(name.Length + (4 - name.Length % 4)' '\0');
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: if (name.Length % 4 != 0)  				name = name.PadRight(name.Length + (4 - name.Length % 4)' '\0');
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: if (name.Length % 4 != 0)  				name = name.PadRight(name.Length + (4 - name.Length % 4)' '\0');
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: int len = name.Length >> 2;
Magic Number,OpenRA.FileFormats,PackageEntry,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PackageEntry.cs,HashFilename,The following statement contains a magic number: while (len-- != 0)  				result = ((result << 1) | (result >> 31)) + reader.ReadUInt32();
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,ApplyRemap,The following statement contains a magic number: for(int i = 0; i < 256; i++)  				colors[i] = (uint)r.GetRemappedColor(Color.FromArgb((int)colors[i])'i).ToArgb();
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: colors = new uint[256];
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(s))  			{  				for (int i = 0; i < 256; i++)  				{  					byte r = (byte)(reader.ReadByte() << 2);  					byte g = (byte)(reader.ReadByte() << 2);  					byte b = (byte)(reader.ReadByte() << 2);  					colors[i] = (uint)((255 << 24) | (r << 16) | (g << 8) | b);  				}  			}
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: foreach (int i in remapShadow)  				colors[i] = 140u << 24;
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,Palette,The following statement contains a magic number: if (data.Length != 256)  				throw new InvalidDataException("Attempting to create palette with incorrect array size");
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,AsSystemPalette,The following statement contains a magic number: for (var i = 0; i < 256; i++)  				pal.Entries[i] = GetColor(i);
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,AsBitmap,The following statement contains a magic number: var b = new Bitmap(256' 1' PixelFormat.Format32bppArgb);
Magic Number,OpenRA.FileFormats,Palette,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Palette.cs,AsBitmap,The following statement contains a magic number: unsafe              {                  uint* c = (uint*)data.Scan0;                  for (var x = 0; x < 256; x++)  	                *(c + x) = colors[x];              }
Magic Number,OpenRA.FileFormats,PlayerColorRemap,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PlayerColorRemap.cs,PlayerColorRemap,The following statement contains a magic number: if (Ramp[0] > Ramp[15]) // reversed remapping                          {  				baseIndex = Ramp[15];  				for (int i=15; i>0; i--)  					RemapRamp = Ramp.Select(r => r - Ramp[15]).ToArray();  			}
Magic Number,OpenRA.FileFormats,PlayerColorRemap,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PlayerColorRemap.cs,PlayerColorRemap,The following statement contains a magic number: if (Ramp[0] > Ramp[15]) // reversed remapping                          {  				baseIndex = Ramp[15];  				for (int i=15; i>0; i--)  					RemapRamp = Ramp.Select(r => r - Ramp[15]).ToArray();  			}
Magic Number,OpenRA.FileFormats,PlayerColorRemap,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PlayerColorRemap.cs,PlayerColorRemap,The following statement contains a magic number: if (Ramp[0] > Ramp[15]) // reversed remapping                          {  				baseIndex = Ramp[15];  				for (int i=15; i>0; i--)  					RemapRamp = Ramp.Select(r => r - Ramp[15]).ToArray();  			}
Magic Number,OpenRA.FileFormats,PlayerColorRemap,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\PlayerColorRemap.cs,PlayerColorRemap,The following statement contains a magic number: if (Ramp[0] > Ramp[15]) // reversed remapping                          {  				baseIndex = Ramp[15];  				for (int i=15; i>0; i--)  					RemapRamp = Ramp.Select(r => r - Ramp[15]).ToArray();  			}
Magic Number,OpenRA.FileFormats,BitAllocator<T>,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\Bits.cs,GetStrings,The following statement contains a magic number: for( var i = 0; i < 32; i++ )  			{  				var x = 1 << i;  				if ((val & x) != 0)  					yield return bits.Single( a => a.Value == x ).Key;  			}
Magic Number,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,NextPowerOf2,The following statement contains a magic number: v |= v >> 2;
Magic Number,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,NextPowerOf2,The following statement contains a magic number: v |= v >> 4;
Magic Number,OpenRA,Exts,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Exts.cs,NextPowerOf2,The following statement contains a magic number: v |= v >> 8;
Magic Number,OpenRA,int2,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\int2.cs,Swap,The following statement contains a magic number: return (uint)((orig & 0xff000000) >> 24) | ((orig & 0x00ff0000) >> 8) | ((orig & 0x0000ff00) << 8) | ((orig & 0x000000ff) << 24);
Magic Number,OpenRA,int2,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\int2.cs,Swap,The following statement contains a magic number: return (uint)((orig & 0xff000000) >> 24) | ((orig & 0x00ff0000) >> 8) | ((orig & 0x0000ff00) << 8) | ((orig & 0x000000ff) << 24);
Magic Number,OpenRA,int2,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\int2.cs,Swap,The following statement contains a magic number: return (uint)((orig & 0xff000000) >> 24) | ((orig & 0x00ff0000) >> 8) | ((orig & 0x0000ff00) << 8) | ((orig & 0x000000ff) << 24);
Magic Number,OpenRA,int2,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Primitives\int2.cs,Swap,The following statement contains a magic number: return (uint)((orig & 0xff000000) >> 24) | ((orig & 0x00ff0000) >> 8) | ((orig & 0x0000ff00) << 8) | ((orig & 0x000000ff) << 24);
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following statement contains a magic number: using (var br = new BinaryReader(s))  			{  				var signature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };  				foreach (var b in signature)  					if (br.ReadByte() != b)  						throw new InvalidDataException("PNG Signature is bogus");    				Bitmap bitmap = null;  				Color[] palette = null;  				List<byte> data = new List<byte>();    				for (; ; )  				{  					var length = IPAddress.NetworkToHostOrder(br.ReadInt32());  					var type = Encoding.UTF8.GetString(br.ReadBytes(4));  					var content = br.ReadBytes(length);  					/*var crc = */br.ReadInt32();    					using (var ms = new MemoryStream(content))  					using (var cr = new BinaryReader(ms))  						switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}  				}  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,UnapplyFilter,The following statement contains a magic number: switch (f)  			{  				case PngFilter.None: return x;  				case PngFilter.Sub: return (byte)(x + a);  				case PngFilter.Up: return (byte)(x + b);  				case PngFilter.Average: return (byte)(x + (a + b) / 2);  				case PngFilter.Paeth: return (byte)(x + Paeth(a' b' c));  				default:  					throw new InvalidOperationException("Unsupported Filter");  			}
Magic Number,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,MakePixelFormat,The following statement contains a magic number: if (bitDepth == 8 && colorType == (PngColorType.Indexed | PngColorType.Color))  				return PixelFormat.Format8bppIndexed;
Magic Number,OpenRA.FileFormats.Graphics,ShpWriter,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\ShpWriter.cs,Write,The following statement contains a magic number: var dataOffset = 14 + (compressedFrames.Length + 2) * ImageHeader.SizeOnDisk;
Magic Number,OpenRA.FileFormats.Graphics,ShpWriter,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\ShpWriter.cs,Write,The following statement contains a magic number: var dataOffset = 14 + (compressedFrames.Length + 2) * ImageHeader.SizeOnDisk;
Magic Number,OpenRA.Support,Stopwatch,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Support\Stopwatch.cs,ElapsedTime,The following statement contains a magic number: return sw.Elapsed.TotalMilliseconds / 1000.0;
Magic Number,OpenRA.Support,Timer,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Support\Timer.cs,Time,The following statement contains a magic number: if( dt > 0.0001 )  				Log.Write("perf"' message' dt );
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Random,The following statement contains a magic number: for (var i = 1u; i < mt.Length; i++)  				mt[i] = 1812433253u * (mt[i - 1] ^ (mt[i - 1] >> 30)) + i;
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= ((y << 7) & 2636928640);
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= ((y << 7) & 2636928640);
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= ((y << 15) & 4022730752);
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= ((y << 15) & 4022730752);
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: y ^= y >> 18;
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Next,The following statement contains a magic number: index = (index + 1) % 624;
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Generate,The following statement contains a magic number: unchecked  			{  				for (var i = 0u; i < mt.Length; i++)  				{  					var y = (mt[i] & 0x80000000) | (mt[(i + 1) % 624] & 0x7fffffff);  					mt[i] = mt[(i + 397u) % 624u] ^ (y >> 1);  					if ((y & 1) == 1)  						mt[i] = (mt[i] ^ 2567483615);  				}  			}
Magic Number,OpenRA.Thirdparty,Random,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Thirdparty\Random.cs,Generate,The following statement contains a magic number: unchecked  			{  				for (var i = 0u; i < mt.Length; i++)  				{  					var y = (mt[i] & 0x80000000) | (mt[(i + 1) % 624] & 0x7fffffff);  					mt[i] = mt[(i + 397u) % 624u] ^ (y >> 1);  					if ((y & 1) == 1)  						mt[i] = (mt[i] ^ 2567483615);  				}  			}
Missing Default,OpenRA.FileFormats.Graphics,PngLoader,C:\repos\chrisforbes_OpenRA\OpenRA.FileFormats\Graphics\PngLoader.cs,Load,The following switch statement is missing a default case: switch (type)  						{  							case "IHDR":  								{    									var width = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var height = IPAddress.NetworkToHostOrder(cr.ReadInt32());  									var bitDepth = cr.ReadByte();  									var colorType = (PngColorType)cr.ReadByte();  									var compression = cr.ReadByte();  									/*var filter = */cr.ReadByte();  									var interlace = cr.ReadByte();    									if (compression != 0) throw new InvalidDataException("Compression method not supported");  									if (interlace != 0) throw new InvalidDataException("Interlacing not supported");    									bitmap = new Bitmap(width' height' MakePixelFormat(bitDepth' colorType));    								}  								break;    							case "PLTE":  								{  									palette = new Color[256];  									for (var i = 0; i < 256; i++)  									{  										var r = cr.ReadByte(); var g = cr.ReadByte(); var b = cr.ReadByte();  										palette[i] = Color.FromArgb(r' g' b);  									}  								}  								break;    							case "tRNS":  								{  									for (var i = 0; i < length; i++)  										palette[i] = Color.FromArgb(cr.ReadByte()' palette[i]);  								}  								break;    							case "IDAT":  								{  									data.AddRange(content);  								}  								break;    							case "IEND":  								{  									var bits = bitmap.LockBits(bitmap.Bounds()'  										ImageLockMode.WriteOnly' PixelFormat.Format8bppIndexed);    									using (var ns = new MemoryStream(data.ToArray()))  									{  										// 'zlib' flags bytes; confuses the DeflateStream.  										/*var flags = (byte)*/ns.ReadByte();  										/*var moreFlags = (byte)*/ns.ReadByte();    										using (var ds = new DeflateStream(ns' CompressionMode.Decompress))  										using (var dr = new BinaryReader(ds))  										{  											var prevLine = new byte[bitmap.Width];	// all zero  											for (var y = 0; y < bitmap.Height; y++)  											{  												var filter = (PngFilter)dr.ReadByte();  												var line = dr.ReadBytes(bitmap.Width);    												for (var i = 0; i < bitmap.Width; i++)  													line[i] = i > 0  														? UnapplyFilter(filter' line[i]' line[i - 1]' prevLine[i]' prevLine[i - 1])  														: UnapplyFilter(filter' line[i]' 0' prevLine[i]' 0);    												Marshal.Copy(line' 0' new IntPtr(bits.Scan0.ToInt64() + y * bits.Stride)' line.Length);  												prevLine = line;  											}  										}  									}    									bitmap.UnlockBits(bits);    									using (var temp = new Bitmap(1' 1' PixelFormat.Format8bppIndexed))  									{  										var cp = temp.Palette;  										for (var i = 0; i < 256; i++)  											cp.Entries[i] = palette[i];		// finalize the palette.  										bitmap.Palette = cp;  										return bitmap;  									}  								}  						}
