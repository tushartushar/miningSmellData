Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The method has 102 lines of code.
Long Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The method has 187 lines of code.
Long Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The method has 196 lines of code.
Long Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The method has 125 lines of code.
Long Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The method has 133 lines of code.
Long Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The method has 183 lines of code.
Long Method,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The method has 109 lines of code.
Long Method,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The method has 581 lines of code.
Long Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,SwitchNodes,The method has 152 lines of code.
Complex Method,Mono.TextEditor.Highlighting,Rule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Rule.cs,GetIsValid,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Highlighting,Rule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Rule.cs,ReadNode,Cyclomatic complexity of the method is 19
Complex Method,Mono.TextEditor.Highlighting,CSharpNumberMatch,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,TryMatch,Cyclomatic complexity of the method is 13
Complex Method,Mono.TextEditor.Highlighting,SyntaxMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxMode.cs,GetChunks,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor.Highlighting,XmlReadHelper,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\XmlReadHelper.cs,ReadList,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor.Highlighting,Regex,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting.Regex\Regex.cs,TryMatch,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Highlighting,SyntaxModeService,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxModeService.cs,LoadStylesAndModes,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor.Highlighting,SyntaxModeService,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxModeService.cs,LoadStylesAndModes,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,Create,Cyclomatic complexity of the method is 25
Complex Method,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,LoadFrom,Cyclomatic complexity of the method is 18
Complex Method,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Save,Cyclomatic complexity of the method is 25
Complex Method,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,Cyclomatic complexity of the method is 21
Complex Method,Mono.TextEditor.Highlighting,AmbientColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\AmbientColor.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Highlighting,AmbientColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\AmbientColor.cs,Import,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,ConvertToPangoMarkup,Cyclomatic complexity of the method is 18
Complex Method,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,FormatString,Cyclomatic complexity of the method is 20
Complex Method,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,DeleteSelection,Cyclomatic complexity of the method is 26
Complex Method,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,PasteText,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,BasicSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,ReplaceAll,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,RegexSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,ReplaceAll,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InsertCharacter,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,HandleKeypress,Cyclomatic complexity of the method is 35
Complex Method,Mono.TextEditor,DefaultBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketForward,Cyclomatic complexity of the method is 21
Complex Method,Mono.TextEditor,DefaultBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,GetLastSourceCodePosition,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,DefaultBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketBackward,Cyclomatic complexity of the method is 22
Complex Method,Mono.TextEditor,InsertionCursorEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\InsertionCursorEditMode.cs,HandleKeypress,Cyclomatic complexity of the method is 23
Complex Method,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Left,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Right,Cyclomatic complexity of the method is 12
Complex Method,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,InternalCaretMoveHome,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,LineEnd,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,MiscActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\MiscActions.cs,RemoveTabInLine,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,MiscActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\MiscActions.cs,RemoveIndentSelection,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,MiscActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\MiscActions.cs,InsertTab,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,MiscActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\MiscActions.cs,InsertNewLine,Cyclomatic complexity of the method is 32
Complex Method,Mono.TextEditor,MiscActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\MiscActions.cs,TransposeCharacters,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Backspace,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Delete,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,SegmentTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SegmentTree.cs,UpdateOnTextReplace,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,SegmentTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SegmentTree.cs,GetSegmentsOverlapping,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,TreeSegment,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SegmentTree.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,UpdateFoldSegmentWorker,Cyclomatic complexity of the method is 12
Complex Method,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,SearchPatternWorkerDoWork,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetCaretChar,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,Cyclomatic complexity of the method is 23
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,Cyclomatic complexity of the method is 26
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,InternalHandleSelection,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateTabsAndSpaces,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,Cyclomatic complexity of the method is 43
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,Cyclomatic complexity of the method is 24
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,Cyclomatic complexity of the method is 35
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,Cyclomatic complexity of the method is 45
Complex Method,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor,DefaultSelectionSurroundingProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISelectionSurroundingProvider.cs,GetSelectionSurroundings,Cyclomatic complexity of the method is 18
Complex Method,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,HandleEditorCaretPositionChanged,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,Cyclomatic complexity of the method is 25
Complex Method,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TextEditorDataSelectionChanged,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,RenderMargins,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TooltipTimer,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnAnimationActorStep,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,OnActorStep,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,RemoveCore,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,Cyclomatic complexity of the method is 15
Complex Method,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,Cyclomatic complexity of the method is 296
Complex Method,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,ApplyActionToSelection,Cyclomatic complexity of the method is 36
Complex Method,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ToggleCase,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetEditObjectCharAction,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetNavCharAction,Cyclomatic complexity of the method is 18
Complex Method,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,Cyclomatic complexity of the method is 31
Complex Method,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,Cyclomatic complexity of the method is 15
Complex Method,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,AppendToString,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,Cyclomatic complexity of the method is 18
Complex Method,Mono.TextEditor.Vi,ViBuilderContext,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilderContext.cs,InsertChar,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,SetMode,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,OnCaretPositionChanged,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,SetRegisterContents,Cyclomatic complexity of the method is 26
Complex Method,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.PopupWindow,TooltipWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\TooltipWindow.cs,OnSizeAllocated,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.PopupWindow,ListWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWindow.cs,ProcessKey,Cyclomatic complexity of the method is 34
Complex Method,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,Cyclomatic complexity of the method is 13
Complex Method,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,Cyclomatic complexity of the method is 12
Complex Method,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnActorStep,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RecalculateSpacings,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RemoveCore,Cyclomatic complexity of the method is 11
Complex Method,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,CreateDiffs,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,LCS,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,Cyclomatic complexity of the method is 12
Complex Method,Mono.TextEditor.Utils,TextFileUtility,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\TextFileUtility.cs,WriteText,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,AppendRtfText,Cyclomatic complexity of the method is 23
Complex Method,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,GenerateRtf,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Utils,HtmlWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\HtmlWriter.cs,AppendHtmlText,Cyclomatic complexity of the method is 24
Complex Method,Mono.TextEditor.Utils,CompressingTreeList,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\CompressingTreeList.cs,InsertRange,Cyclomatic complexity of the method is 8
Complex Method,Mono.TextEditor.Utils,CompressingTreeList,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\CompressingTreeList.cs,RemoveRange,Cyclomatic complexity of the method is 9
Complex Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,Remove,Cyclomatic complexity of the method is 14
Complex Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,RotateRightLeft,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,RotateLeftRight,Cyclomatic complexity of the method is 16
Complex Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,Cyclomatic complexity of the method is 10
Complex Method,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,SwitchNodes,Cyclomatic complexity of the method is 35
Long Parameter List,Mono.TextEditor.Highlighting,SyntaxModeService,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxModeService.cs,ScanSpans,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,SemanticRule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SemanticRule.cs,Analyze,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,HighlightUrlSemanticRule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SemanticRule.cs,Analyze,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InternalHandleKeypress,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,DrawLine,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,Line,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineX,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineY,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,HandleKeypress,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,Selection,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Selection.cs,Selection,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,IBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketForward,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,IBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketBackward,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,DefaultBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketForward,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,DefaultBracketMatcher,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\IBracketMatcher.cs,SearchMatchingBracketBackward,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The method has 9 parameters.
Long Parameter List,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PastePlainText,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CodeSegmentPreviewWindow,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,DashedLineMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\DashedLineMargin.cs,Draw,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,DrawRoundRectangle,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,DrawRoundRectangle,The method has 10 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,WindowsGetUsableMonitorGeometry,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,ShowContextMenu,The method has 10 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,TranslateKeyboardState,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,gtk_tree_view_get_tooltip_context,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetTooltipContext,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,gtk_icon_set_render_icon_scaled,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,RenderIcon,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,DrawGutterBackground,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,Margin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\Margin.cs,Draw,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,MarginMouseEventArgs,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\Margin.cs,MarginMouseEventArgs,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,MarginMouseEventArgs,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\Margin.cs,MarginMouseEventArgs,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,BookmarkMarginDrawEventArgs,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,BookmarkMarginDrawEventArgs,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,FoldSegment,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\FoldSegment.cs,FoldSegment,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The method has 13 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetCachedChunks,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,InternalHandleSelection,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleSelection,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawSpaceMarker,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateTabsAndSpaces,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateMatchingBracket,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaretLineMarker,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawIndent,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The method has 15 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawEolMarker,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,TooltipProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TooltipProvider.cs,ShowTooltipWindow,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,Draw,The method has 9 parameters.
Long Parameter List,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,Draw,The method has 9 parameters.
Long Parameter List,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,InternalDraw,The method has 11 parameters.
Long Parameter List,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The method has 8 parameters.
Long Parameter List,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,Initialize,The method has 12 parameters.
Long Parameter List,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragDataReceived,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,TextEditor,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,RemoveCore,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,AddAnimatedWidget,The method has 6 parameters.
Long Parameter List,Mono.TextEditor,MarginDrawMetrics,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\MarginMarker.cs,MarginDrawMetrics,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,UnderlineMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UnderlineMarker.cs,InternalDraw,The method has 11 parameters.
Long Parameter List,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,UrlMarker,The method has 7 parameters.
Long Parameter List,Mono.TextEditor,ActionMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\ActionMargin.cs,DrawMarginBackground,The method has 5 parameters.
Long Parameter List,Mono.TextEditor,ActionMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\ActionMargin.cs,Draw,The method has 8 parameters.
Long Parameter List,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForChar,The method has 6 parameters.
Long Parameter List,Mono.TextEditor.Vi,ViBuilders,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilders.cs,InsertBuilder,The method has 5 parameters.
Long Parameter List,Mono.TextEditor.Theatrics,AnimatedWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedWidget.cs,AnimatedWidget,The method has 5 parameters.
Long Parameter List,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,Pack,The method has 5 parameters.
Long Parameter List,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RemoveCore,The method has 6 parameters.
Long Parameter List,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RemoveCore,The method has 6 parameters.
Long Parameter List,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The method has 8 parameters.
Long Parameter List,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,LCS,The method has 8 parameters.
Long Parameter List,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,GetDiffString,The method has 5 parameters.
Long Identifier,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CodeSegmentPreviewWindow,The length of the parameter hideCodeSegmentPreviewInformString is 34.
Long Identifier,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CodeSegmentPreviewWindow,The length of the parameter hideCodeSegmentPreviewInformString is 34.
Long Statement,Mono.TextEditor.Highlighting,Match,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,Read,The length of the statement  "		result.regex = new System.Text.RegularExpressions.Regex (result.Pattern' result.IgnoreCase ? RegexOptions.Compiled | RegexOptions.IgnoreCase : RegexOptions.Compiled); " is 166.
Long Statement,Mono.TextEditor.Highlighting,Match,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,Read,The length of the statement  "	result2.regex = new System.Text.RegularExpressions.Regex (result2.Pattern' RegexOptions.Compiled | RegexOptions.IgnoreCase); " is 124.
Long Statement,Mono.TextEditor.Highlighting,Span,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Span.cs,GetIsValid,The length of the statement  "	return (string.IsNullOrEmpty (Color) || style.GetChunkStyle (Color) != null) && (string.IsNullOrEmpty (TagColor) || style.GetChunkStyle (TagColor) != null) && (string.IsNullOrEmpty (NextColor) || style.GetChunkStyle (NextColor) != null); " is 237.
Long Statement,Mono.TextEditor.Highlighting,Span,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Span.cs,ToString,The length of the statement  "	return String.Format ("[Span: Color={0}' Rule={1}' Begin={2}' End={3}' Escape={4}' stopAtEol={5}]"' Color' Rule' Begin' End' Escape == null ? "not set" : "'" + Escape + "'"' StopAtEol); " is 185.
Long Statement,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,Equals,The length of the statement  "	return Name == other.Name && Foreground.Equals (other.Foreground) && Background.Equals (other.Background) && FontWeight == other.FontWeight && FontStyle == other.FontStyle; " is 172.
Long Statement,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,GetHashCode,The length of the statement  "		return (Name != null ? Name.GetHashCode () : 0) ^ Foreground.GetHashCode () ^ Background.GetHashCode () ^ FontWeight.GetHashCode () ^ FontStyle.GetHashCode (); " is 159.
Long Statement,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,Create,The length of the statement  "					throw new InvalidDataException (el.Value + " is no valid text weight values are: " + string.Join ("'"' Enum.GetNames (typeof(FontWeight)))); " is 140.
Long Statement,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,Create,The length of the statement  "					throw new InvalidDataException (el.Value + " is no valid text weight values are: " + string.Join ("'"' Enum.GetNames (typeof(FontStyle)))); " is 139.
Long Statement,Mono.TextEditor.Highlighting,ChunkStyle,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ChunkStyle.cs,ToString,The length of the statement  "	return string.Format ("[ChunkStyle: Name={0}' CairoColor={1}' CairoBackgroundColor={2}' FontWeight={3}' FontStyle={4}]"' Name' ColorToString (Foreground)' ColorToString (Background)' FontWeight' FontStyle); " is 206.
Long Statement,Mono.TextEditor.Highlighting,ColorDescriptionAttribute,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorDescriptionAttribute.cs,ToString,The length of the statement  "	return string.Format ("[ColorDescriptionAttribute: Name={0}' Description={1}' VSSetting={2}]"' Name' Description' VSSetting); " is 125.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,LoadFrom,The length of the statement  "	var reader = System.Runtime.Serialization.Json.JsonReaderWriterFactory.CreateJsonReader (stream' new System.Xml.XmlDictionaryReaderQuotas ()); " is 142.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,AlphaBlend,The length of the statement  "	return new Cairo.Color ((1.0 - alpha) * back.R + alpha * fore.R' (1.0 - alpha) * back.G + alpha * fore.G' (1.0 - alpha) * back.B + alpha * fore.B); " is 147.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The length of the statement  "	result.IndentationGuide.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.3))); " is 136.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The length of the statement  "	result.TooltipPagerTriangle.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.8))); " is 140.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The length of the statement  "	result.TooltipBorder.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.5))); " is 133.
Long Statement,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The length of the statement  "	var defaultStyle = SyntaxModeService.GetColorStyle (HslColor.Brightness (result.PlainText.Background) < 0.5 ? "Monokai" : TextEditorOptions.DefaultColorStyle); " is 159.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The length of the statement  "			bool setBold = (styleStack.Count > 0 && styleStack.Peek ().FontWeight != chunkStyle.FontWeight) || chunkStyle.FontWeight != FontWeight.Normal; " is 142.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The length of the statement  "			bool setItalic = (styleStack.Count > 0 && styleStack.Peek ().FontStyle != chunkStyle.FontStyle) || chunkStyle.FontStyle != FontStyle.Normal; " is 140.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The length of the statement  "			bool setUnderline = chunkStyle.Underline && (styleStack.Count == 0 || !styleStack.Peek ().Underline) || !chunkStyle.Underline && (styleStack.Count == 0 || styleStack.Peek ().Underline); " is 185.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The length of the statement  "			bool setColor = styleStack.Count == 0 || TextViewMargin.GetPixel (styleStack.Peek ().Foreground) != TextViewMargin.GetPixel (chunkStyle.Foreground); " is 148.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The length of the statement  "			result.Append (ConvertToPangoMarkup (Document.GetTextBetween (chunk.Offset' System.Math.Min (chunk.EndOffset' Document.TextLength))' replaceTabs)); " is 147.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,InsertAtCaret,The length of the statement  "			MainSelection = new Selection (new DocumentLocation (selection.Anchor.Line' GetLine (selection.Anchor.Line).GetLogicalColumn (this' visualColumn))' new DocumentLocation (selection.Lead.Line' GetLine (selection.Lead.Line).GetLogicalColumn (this' visualColumn))' SelectionMode.Block); " is 282.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,FixVirtualIndentation,The length of the statement  "	if (line != null && line.Length > 0 && GetIndentationString (Caret.Location) == Document.GetTextAt (line.Offset' line.Length)) " is 126.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,FixVirtualIndentation,The length of the statement  "	if (line != null && line.Length > 0 && GetIndentationString (lineNumber' line.Length + 1) == Document.GetTextAt (line.Offset' line.Length)) " is 139.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,SetSelectLines,The length of the statement  "	MainSelection = new Selection (document.OffsetToLocation (Document.GetLine (from).Offset)' document.OffsetToLocation (Document.GetLine (to).EndOffsetIncludingDelimiter)); " is 170.
Long Statement,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,DeleteSelection,The length of the statement  "		MainSelection = selection.WithRange (new DocumentLocation (selection.Anchor.Line' column)' new DocumentLocation (selection.Lead.Line' column)); " is 143.
Long Statement,Mono.TextEditor,HighlightUrlSemanticRule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SemanticRule.cs,Analyze,The length of the statement  "			doc.AddMarker (line' new UrlMarker (doc' line' m.Value' UrlType.Url' syntax' startColumn + m.Index' startColumn + m.Index + m.Length)' false); " is 142.
Long Statement,Mono.TextEditor,HighlightUrlSemanticRule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SemanticRule.cs,Analyze,The length of the statement  "			doc.AddMarker (line' new UrlMarker (doc' line' m.Value' UrlType.Email' syntax' startColumn + m.Index' startColumn + m.Index + m.Length)' false); " is 144.
Long Statement,Mono.TextEditor,SearchResult,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\SearchResult.cs,ToString,The length of the statement  "	return string.Format ("[SearchResult: Offset={0}' Length={1}' SearchWrapped={2}]"' this.Offset' this.Length' this.SearchWrapped); " is 129.
Long Statement,Mono.TextEditor,Caret,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Caret.cs,CheckColumn,The length of the statement  "	if (TextEditorData.HasIndentationTracker && TextEditorData.Options.IndentStyle == IndentStyle.Virtual && curLine.Length == 0) { " is 127.
Long Statement,Mono.TextEditor,Caret,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Caret.cs,SetColumn,The length of the statement  "	if (TextEditorData.HasIndentationTracker && TextEditorData.Options.IndentStyle == IndentStyle.Virtual && curLine.GetVisualColumn (TextEditorData' column) < DesiredColumn) { " is 172.
Long Statement,Mono.TextEditor,Caret,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Caret.cs,UpdateCaretPosition,The length of the statement  "	if (TextEditorData.HasIndentationTracker && TextEditorData.Options.IndentStyle == IndentStyle.Virtual && curLine.Length == 0) { " is 127.
Long Statement,Mono.TextEditor,BasicSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,GetMatchAt,The length of the statement  "	if ((!string.IsNullOrEmpty (SearchRequest.SearchPattern)) && offset + searchRequest.SearchPattern.Length <= doc.TextLength && compiledPattern.Length > 0) { " is 155.
Long Statement,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,IsSpecialKeyForSelection,The length of the statement  "	return textEditorData.SelectionSurroundingProvider.GetSelectionSurroundings (textEditorData' unicodeKey' out start' out end); " is 125.
Long Statement,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InsertCharacter,The length of the statement  "		if (textEditorData.IsSomethingSelected && textEditorData.Options.EnableSelectionWrappingKeys && IsSpecialKeyForSelection (unicodeKey)) { " is 136.
Long Statement,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InsertCharacter,The length of the statement  "		textEditorData.DeleteSelectedText (textEditorData.IsSomethingSelected ? textEditorData.MainSelection.SelectionMode != SelectionMode.Block : true); " is 146.
Long Statement,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InsertCharacter,The length of the statement  "							textToInsert = new string ('\t'' (charsToInsert - spaceCount) / editor.Options.TabSize) + new string (' '' spaceCount) + text; " is 126.
Long Statement,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,InsertCharacter,The length of the statement  "					textEditorData.MainSelection = new Selection (new DocumentLocation (selection.Anchor.Line' textEditorData.GetLine (selection.Anchor.Line).GetLogicalColumn (textEditorData' visualColumn))' new DocumentLocation (selection.Lead.Line' textEditorData.GetLine (selection.Lead.Line).GetLogicalColumn (textEditorData' visualColumn))' SelectionMode.Block); " is 347.
Long Statement,Mono.TextEditor,SimpleEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\SimpleEditMode.cs,InitCommonBindings,The length of the statement  "	keyBindings.Add (GetKeyCode (Gdk.Key.Return' Gdk.ModifierType.ControlMask)' MiscActions.InsertNewLinePreserveCaretPosition); " is 124.
Long Statement,Mono.TextEditor,SimpleEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\SimpleEditMode.cs,InitDefaultBindings,The length of the statement  "	keyBindings.Add (GetKeyCode (Gdk.Key.D' Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)' DeleteActions.CaretLineToEnd); " is 130.
Long Statement,Mono.TextEditor,SimpleEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\SimpleEditMode.cs,InitMacBindings,The length of the statement  "	keyBindings.Add (GetKeyCode (Gdk.Key.a' Gdk.ModifierType.ControlMask | Gdk.ModifierType.ShiftMask)' SelectionActions.MoveLineHome); " is 131.
Long Statement,Mono.TextEditor,SimpleEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\SimpleEditMode.cs,InitMacBindings,The length of the statement  "	keyBindings.Add (GetKeyCode (Gdk.Key.e' Gdk.ModifierType.ControlMask | Gdk.ModifierType.ShiftMask)' SelectionActions.MoveLineEnd); " is 130.
Long Statement,Mono.TextEditor,TextLink,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,ToString,The length of the statement  "	return string.Format ("[TextLink: Name={0}' Links={1}' IsEditable={2}' Tooltip={3}' CurrentText={4}' Values=({5})]"' Name' Links.Count' IsEditable' Tooltip' CurrentText' Values.Count); " is 184.
Long Statement,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,HandlePositionChanged,The length of the statement  "	TextLink link = links.Find (l => !l.PrimaryLink.IsInvalid && l.PrimaryLink.Offset <= caretOffset && caretOffset <= l.PrimaryLink.EndOffset); " is 140.
Long Statement,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,Setlink,The length of the statement  "	Editor.MainSelection = new Selection (Editor.Document.OffsetToLocation (baseOffset + link.PrimaryLink.Offset)' Editor.Document.OffsetToLocation (baseOffset + link.PrimaryLink.EndOffset)); " is 187.
Long Statement,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,UpdateLinksOnTextReplace,The length of the statement  "	if (!IsInUpdate && !links.Any (link => link.Links.Any (segment => segment.Contains (offset) || segment.EndOffset == offset))) { " is 127.
Long Statement,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,GotoNextLink,The length of the statement  "	TextLink nextLink = links.Find (l => l.IsEditable && l.PrimaryLink.Offset > (link != null ? link.PrimaryLink.EndOffset : caretOffset)); " is 135.
Long Statement,Mono.TextEditor,TextLinkEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,GotoPreviousLink,The length of the statement  "	var prevLink = links.FindLast (l => l.IsEditable && l.PrimaryLink.Offset < (link != null ? link.PrimaryLink.Offset : caretOffset)); " is 131.
Long Statement,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The length of the statement  "			if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) { " is 238.
Long Statement,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The length of the statement  "					fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor; " is 137.
Long Statement,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The length of the statement  "					rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor; " is 142.
Long Statement,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The length of the statement  "					fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor; " is 141.
Long Statement,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The length of the statement  "					rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color; " is 134.
Long Statement,Mono.TextEditor,Selection,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Selection.cs,ToString,The length of the statement  "	return string.Format ("[Selection: Anchor={0}' Lead={1}' MinLine={2}' MaxLine={3}' SelectionMode={4}]"' Anchor' Lead' MinLine' MaxLine' SelectionMode); " is 151.
Long Statement,Mono.TextEditor,InsertionPoint,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\InsertionCursorEditMode.cs,ToString,The length of the statement  "	return string.Format ("[InsertionPoint: Location={0}' LineBefore={1}' LineAfter={2}]"' Location' LineBefore' LineAfter); " is 120.
Long Statement,Mono.TextEditor,HeightTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HeightTree.cs,YToLineNumber,The length of the statement  "			return y < 0 ? DocumentLocation.MinLine + (int)(y / editor.LineHeight) : tree.Root.totalCount + (int)((y - tree.Root.totalHeight) / editor.LineHeight); " is 151.
Long Statement,Mono.TextEditor,HeightTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HeightTree.cs,GetSingleLineNode,The length of the statement  "	Debug.Assert (lineNumber == node.GetLineNumber ()' lineNumber + " should match node line number " + node.GetLineNumber () + " (max: " + tree.Root.totalCount + ")"); " is 164.
Long Statement,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Left,The length of the statement  "			if (data.HasIndentationTracker && data.Options.IndentStyle == IndentStyle.Virtual && nextLocation.Column == DocumentLocation.MinColumn) " is 135.
Long Statement,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Right,The length of the statement  "			if (data.HasIndentationTracker && data.Options.IndentStyle == IndentStyle.Virtual && data.Caret.Column == DocumentLocation.MinColumn) { " is 135.
Long Statement,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Up,The length of the statement  "			int col = data.MainSelection.Anchor > data.MainSelection.Lead ? data.MainSelection.Lead.Column : data.MainSelection.Anchor.Column; " is 130.
Long Statement,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Up,The length of the statement  "			data.Caret.Location = (line >= DocumentLocation.MinLine) ? new DocumentLocation (line' col) : new DocumentLocation (DocumentLocation.MinLine' DocumentLocation.MinColumn); " is 170.
Long Statement,Mono.TextEditor,CaretMoveActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\CaretMoveActions.cs,Down,The length of the statement  "			int col = data.MainSelection.Anchor > data.MainSelection.Lead ? data.MainSelection.Lead.Column : data.MainSelection.Anchor.Column; " is 130.
Long Statement,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PastePlainText,The length of the statement  "				textToInsert = new string ('\t'' (charsToInsert - spaceCount) / data.Options.TabSize) + new string (' '' spaceCount) + text; " is 124.
Long Statement,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,Paste,The length of the statement  "	PasteFrom (Clipboard.Get (CopyOperation.CLIPBOARD_ATOM)' data' false' data.IsSomethingSelected ? data.SelectionRange.Offset : data.Caret.Offset); " is 145.
Long Statement,Mono.TextEditor,ScrollActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ScrollActions.cs,Down,The length of the statement  "	var newValue = System.Math.Min (data.VAdjustment.Upper - data.VAdjustment.PageSize' data.VAdjustment.Value + data.VAdjustment.StepIncrement); " is 141.
Long Statement,Mono.TextEditor,ScrollActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ScrollActions.cs,PageDown,The length of the statement  "	var newValue = System.Math.Min (data.VAdjustment.Upper - data.VAdjustment.PageSize' data.VAdjustment.Value + data.VAdjustment.PageSize); " is 136.
Long Statement,Mono.TextEditor,FoldActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\FoldActions.cs,GetOutermostClosedFold,The length of the statement  "			if (fold.IsFolded && data.LogicalToVisualLine (data.OffsetToLineNumber (fold.Offset)) == lineNumber && fold.Offset <= startOffset && fold.EndOffset >= endOffset) { " is 163.
Long Statement,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,SetSegment,The length of the statement  "	layout.SetMarkup (editor.GetTextEditorData ().GetMarkup (segment.Offset' segment.Length' removeIndent) + (pushedLineLimit ? Environment.NewLine + "..." : "")); " is 159.
Long Statement,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The length of the statement  "	this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5))); " is 162.
Long Statement,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Backspace,The length of the statement  "			if (data.MainSelection.SelectionMode == SelectionMode.Block && visualAnchorLocation.Column == visualLeadLocation.Column) { " is 122.
Long Statement,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Backspace,The length of the statement  "				data.MainSelection = new Selection (new DocumentLocation (data.MainSelection.Anchor.Line' data.GetLine (data.MainSelection.Anchor.Line).GetLogicalColumn (data' visualColumn))' new DocumentLocation (data.MainSelection.Lead.Line' data.GetLine (data.MainSelection.Lead.Line).GetLogicalColumn (data' visualColumn))' SelectionMode.Block); " is 333.
Long Statement,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Backspace,The length of the statement  "				data.Caret.Location = new DocumentLocation (data.Caret.Line - 1' data.IndentationTracker.GetVirtualIndentationColumn (data.Caret.Line - 1' 1)); " is 143.
Long Statement,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Backspace,The length of the statement  "				data.Replace (lineAbove.EndOffsetIncludingDelimiter - lineAbove.DelimiterLength' lineAbove.DelimiterLength' data.IndentationTracker.GetIndentationString (data.Caret.Line - 1' 1)); " is 179.
Long Statement,Mono.TextEditor,DeleteActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\DeleteActions.cs,Delete,The length of the statement  "			if (data.MainSelection.SelectionMode == SelectionMode.Block && data.MainSelection.Anchor.Column == data.MainSelection.Lead.Column) { " is 132.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "	ISyntaxMode mode = Document.SyntaxMode != null && editor.Options.EnableSyntaxHighlighting ? Document.SyntaxMode : new SyntaxMode (Document); " is 140.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		for (var curLine = segmentStartLine; curLine != endLine && y < editor.VAdjustment.Value + editor.Allocation.Height; curLine = curLine.NextLine) { " is 145.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentStartLine' segmentStartLine.Offset' segmentStartLine.Length' -1' -1); " is 132.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		xPos = System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleStart.X / Pango.Scale.PangoScale) - xPadding); " is 164.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentEndLine' segmentEndLine.Offset' segmentEndLine.Length' -1' -1); " is 126.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		xPos = System.Math.Min (xPos' System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleEnd.X / Pango.Scale.PangoScale) - xPadding)); " is 186.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "			rectangleWidth = System.Math.Max ((rectangles [i + 1].X + rectangles [i + 1].Width + rightMarginPadding) - xPos' rectangleWidth); " is 129.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2); " is 214.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "				DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2); " is 214.
Long Statement,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The length of the statement  "		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height); " is 154.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,IsContextMenuButton,The length of the statement  "		if (!oldMacKeyHacks && evt.Button == 1 && (evt.State & Gdk.ModifierType.ControlMask) != 0 && (evt.State & (Gdk.ModifierType.Button2Mask | Gdk.ModifierType.Button3Mask)) == 0) { " is 176.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The length of the statement  "	const Gdk.ModifierType accelMods = Gdk.ModifierType.ShiftMask | Gdk.ModifierType.Mod1Mask | Gdk.ModifierType.ControlMask | Gdk.ModifierType.SuperMask | Gdk.ModifierType.MetaMask; " is 178.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The length of the statement  "	TranslateKeyboardState (evt' Gdk.ModifierType.None' 0' out keyval' out effectiveGroup' out level' out consumedModifiers); " is 121.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The length of the statement  "		keymap.TranslateKeyboardState (evt.HardwareKeycode' Gdk.ModifierType.ShiftMask' 0' out keyval' out effectiveGroup' out level' out consumedModifiers); " is 149.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The length of the statement  "		TranslateKeyboardState (evt' modifier & ~Gdk.ModifierType.ShiftMask' 1' out keyval' out effectiveGroup' out level' out consumedModifiers); " is 138.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,TranslateKeyboardState,The length of the statement  "	keymap.TranslateKeyboardState (hardware_keycode' state' group' out keyval' out effective_group' out level' out consumed_modifiers); " is 131.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,CreateForallCallback,The length of the statement  "	il.Emit (OpCodes.Call' typeof(GLib.ObjectManager).GetMethod ("gtksharp_get_type_id"' BindingFlags.Static | BindingFlags.NonPublic)); " is 132.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,CreateForallCallback,The length of the statement  "	il.Emit (OpCodes.Call' typeof(Gtk.Container).GetMethod ("gtksharp_container_base_forall"' BindingFlags.Static | BindingFlags.NonPublic)); " is 137.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,CreateForallCallback,The length of the statement  "	il.Emit (OpCodes.Newobj' typeof(Gtk.Callback).GetConstructor (BindingFlags.Instance | BindingFlags.Public' null' new Type[] { " is 125.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,CreateForallCallback,The length of the statement  "	var forallMeth = typeof(Gtk.Container).GetMethod ("ForAll"' BindingFlags.Instance | BindingFlags.NonPublic' null' new Type[] { " is 126.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetTooltipContext,The length of the statement  "	bool result = gtk_tree_view_get_tooltip_context (tree.Handle' ref x' ref y' keyboardTip' out handle' out intPtr2' intPtr); " is 122.
Long Statement,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,RenderIcon,The length of the statement  "		IntPtr o = gtk_icon_set_render_icon_scaled (iconset.Handle' (style != null) ? style.Handle : IntPtr.Zero' (int)direction' (int)state' (int)size' (widget != null) ? widget.Handle : IntPtr.Zero' intPtr' ref scale); " is 212.
Long Statement,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The length of the statement  "	var gutterMarker = lineSegment != null ? (MarginMarker)lineSegment.Markers.FirstOrDefault (marker => marker is MarginMarker && ((MarginMarker)marker).CanDraw (this)) : null; " is 173.
Long Statement,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The length of the statement  "		bool hasDrawn = gutterMarker.DrawBackground (editor' cr' new MarginDrawMetrics (this' area' lineSegment' line' x' y' lineHeight)); " is 130.
Long Statement,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The length of the statement  "				backgroundIsDrawn = marginMarker.DrawBackground (editor' ctx' new MarginDrawMetrics (this' area' lineSegment' line' x' y' lineHeight)); " is 135.
Long Statement,Mono.TextEditor,DocumentChangeEventArgs,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\DocumentChangeEventArgs.cs,ToString,The length of the statement  "	return string.Format ("[ReplaceEventArgs: Offset={0}' RemovedText={1}' RemovalLength={2}' InsertedText={3}' InsertionLength={4}]"' Offset' RemovedText != null ? RemovedText.Text : "null"' RemovalLength' InsertedText != null ? InsertedText.Text : "null"' InsertionLength); " is 271.
Long Statement,Mono.TextEditor,FoldSegment,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\FoldSegment.cs,ToString,The length of the statement  "	return string.Format ("[FoldSegment: IsFolded={0}' Description={1}' Column={2}' Offset={3}' Length={4}' StartLine={5}' EndLine={6}' EndColumn={7}' FoldingType={8}]"' IsFolded' Description' Column' Offset' Length' StartLine' EndLine' EndColumn' FoldingType); " is 257.
Long Statement,Mono.TextEditor,LineSplitter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\LineSplitter.cs,GetNode,The length of the statement  "		Debug.Assert (false' "index must be >=0 but was " + index + "." + Environment.NewLine + "Stack trace:" + Environment.StackTrace); " is 129.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,LocationToOffset,The length of the statement  "	return System.Math.Min (TextLength' line.Offset + System.Math.Max (0' System.Math.Min (line.Length' location.Column - 1))); " is 123.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,OptimizeTypedUndo,The length of the statement  "	if (top.Args == null || top.Args.InsertedText == null || top.Args.InsertionLength != 1 || (top is KeyboardStackUndo && ((KeyboardStackUndo)top).IsClosed)) { " is 156.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,OptimizeTypedUndo,The length of the statement  "	if (keyUndo.Args != null && keyUndo.Args.Offset + 1 != top.Args.Offset || !char.IsLetterOrDigit (top.Args.InsertedText.GetCharAt (0))) { " is 136.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,EnsureOffsetIsUnfolded,The length of the statement  "	foreach (FoldSegment fold in GetFoldingsFromOffset (offset).Where (f => f.IsFolded && f.Offset < offset && offset < f.EndOffset)) { " is 131.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,IsWholeWordAt,The length of the statement  "	return (offset == 0 || IsWordSeparator (GetCharAt (offset - 1))) && (offset + length == TextLength || IsWordSeparator (GetCharAt (offset + length))); " is 149.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,SearchMatchingBracketForward,The length of the statement  "	return bracketMatcher.SearchMatchingBracketForward (worker' this' offset' closingBrackets [bracket]' openBrackets [bracket]); " is 125.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,SearchMatchingBracketBackward,The length of the statement  "	return bracketMatcher.SearchMatchingBracketBackward (worker' this' offset' openBrackets [bracket]' closingBrackets [bracket]); " is 126.
Long Statement,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,Diff,The length of the statement  "	return Mono.TextEditor.Utils.Diff.GetDiff<int> (this.GetDiffCodes (ref codeCounter' codeDictionary' includeEol)' changedDocument.GetDiffCodes (ref codeCounter' codeDictionary' includeEol)); " is 189.
Long Statement,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPangoString,The length of the statement  "	return string.Format ("#{0:x2}{1:x2}{2:x2}"' (int)(resultColor.R * 255)' (int)(resultColor.G * 255)' (int)(resultColor.B * 255)); " is 129.
Long Statement,Mono.TextEditor,WordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\IWordFindStrategy.cs,ScanWord,The length of the statement  "		if (char.IsWhiteSpace (first) && !char.IsWhiteSpace (ch) || IsNoIdentifierPart (first) && !IsNoIdentifierPart (ch) || (char.IsLetterOrDigit (first) || first == '_') && !(char.IsLetterOrDigit (ch) || ch == '_')) " is 210.
Long Statement,Mono.TextEditor,SelectionActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\SelectionActions.cs,StartLineSelection,The length of the statement  "		data.MainSelection = new Selection (new DocumentLocation (data.Caret.Line' DocumentLocation.MinColumn)' new DocumentLocation (data.Caret.Line' DocumentLocation.MinColumn)); " is 172.
Long Statement,Mono.TextEditor,SelectionActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\SelectionActions.cs,SelectAll,The length of the statement  "	data.MainSelection = new Selection (new DocumentLocation (DocumentLocation.MinLine' DocumentLocation.MinColumn)' data.OffsetToLocation (data.Length)); " is 150.
Long Statement,Mono.TextEditor,SelectionActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\SelectionActions.cs,ExpandSelectionToLine,The length of the statement  "		var selection = TextSegment.FromBounds (System.Math.Min (range.Offset' curLineSegment.Offset)' System.Math.Max (range.EndOffset' curLineSegment.EndOffset)); " is 156.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,UpdateBracketHighlighting,The length of the statement  "	if (Caret.Mode != CaretMode.Insert || (offset >= 0 && offset < Document.TextLength && !TextDocument.IsBracket (Document.GetCharAt (offset)))) " is 141.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,UpdateBracketHighlighting,The length of the statement  "	if (highlightBracketOffset >= 0 && (offset >= Document.TextLength || !TextDocument.IsBracket (Document.GetCharAt (offset)))) { " is 126.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The length of the statement  "		this.textEditor.GetTextEditorData ().LineHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale); " is 138.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The length of the statement  "	using (var metrics = textEditor.PangoContext.GetMetrics (textEditor.Options.GutterFont' textEditor.PangoContext.Language)) { " is 124.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The length of the statement  "		this.textEditor.GetTextEditorData ().LineHeight = System.Math.Max (this.textEditor.GetTextEditorData ().LineHeight' System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale)); " is 205.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ResetCaretBlink,The length of the statement  "	blinkTimeout = GLib.Timeout.Add ((uint)(Gtk.Settings.Default.CursorBlinkTime * cursorOnMultiplier / cursorDivider)' UpdateCaret); " is 129.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,UpdateCaret,The length of the statement  "	textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom' (int)(caretRectangle.Y + (textEditor.VAdjustment.Value - caretVAdjustmentValue))' caretRectangle.Width + 2 * (int)textEditor.Options.Zoom' caretRectangle.Height); " is 246.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,SetVisibleCaretPosition,The length of the statement  "	GtkWorkarounds.SetImCursorLocation (textEditor.IMContext' textEditor.GdkWindow' new Rectangle ((int)nonPreeditX' (int)nonPreeditY' 0' (int)(LineHeight - 1))); " is 158.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The length of the statement  "	if (!this.textEditor.IsInDrag && !(this.caretX >= 0 && (!this.textEditor.IsSomethingSelected || this.textEditor.SelectionRange.Length == 0))) " is 141.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The length of the statement  "			cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height); " is 134.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The length of the statement  "			cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5); " is 181.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetSelectionOffsets,The length of the statement  "				selectionStart = lineOffset + line.GetLogicalColumn (this.textEditor.GetTextEditorData ()' System.Math.Min (visStart.Column' visEnd.Column)) - 1; " is 145.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetSelectionOffsets,The length of the statement  "				selectionEnd = lineOffset + line.GetLogicalColumn (this.textEditor.GetTextEditorData ()' System.Math.Max (visStart.Column' visEnd.Column)) - 1; " is 143.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "		if (descriptor.Equals (line' offset' length' selectionStart' selectionEnd' out isInvalid) && descriptor.Layout != null) { " is 121.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "			HandleSelection (lineOffset' logicalRulerColumn' selectionStart' selectionEnd' chunk.Offset' chunk.EndOffset' delegate (int start' int end) { " is 141.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "				if (!chunkStyle.TransparentBackground && GetPixel (ColorStyle.PlainText.Background) != GetPixel (chunkStyle.Background)) { " is 122.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "						if (spanStyle != null && !spanStyle.TransparentBackground && GetPixel (ColorStyle.PlainText.Background) != GetPixel (spanStyle.Background)) { " is 141.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "		var ei = TranslateToUTF8Index (lineChars' (uint)(textEditor.preeditOffset - offset + preeditLength)' ref curIndex' ref byteIndex); " is 130.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CreateLinePartLayout,The length of the statement  "	//			textEditor.GetTextEditorData ().HeightTree.SetLineHeight (line.LineNumber' System.Math.Max (LineHeight' wrapper.Height)); " is 126.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleSelection,The length of the statement  "	if (textEditor.Options.ShowRuler && selectionStartColumn < logicalRulerColumn && logicalRulerColumn < selectionEndColumn && startOffset < rulerOffset && rulerOffset < endOffset) { " is 179.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,TranslateToUTF8Index,The length of the statement  "		throw new ArgumentOutOfRangeException ("textIndex"' " must be <= charArrayLength (" + charArray.Length + ") was :" + textIndex); " is 128.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateTabsAndSpaces,The length of the statement  "		Pango.Rectangle pos = layout.Layout.IndexToPos ((int)TranslateToUTF8Index (layout.LineChars' (uint)i' ref curIndex' ref byteIndex)); " is 132.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateTabsAndSpaces,The length of the statement  "		Pango.Rectangle pos2 = layout.Layout.IndexToPos ((int)TranslateToUTF8Index (layout.LineChars' (uint)i + 1' ref curIndex' ref byteIndex)); " is 137.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateMatchingBracket,The length of the statement  "		Pango.Rectangle rect = layout.Layout.IndexToPos ((int)TranslateToUTF8Index (layout.LineChars' (uint)index' ref curIndex' ref byteIndex)); " is 137.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateMatchingBracket,The length of the statement  "		var bracketMatch = new Cairo.Rectangle (xPos + rect.X / Pango.Scale.PangoScale + 0.5' y + 0.5' (rect.Width / Pango.Scale.PangoScale) - 1' (rect.Height / Pango.Scale.PangoScale) - 1); " is 182.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetLayout,The length of the statement  "	ISyntaxMode mode = Document.SyntaxMode != null && textEditor.Options.EnableSyntaxHighlighting ? Document.SyntaxMode : new SyntaxMode (Document); " is 144.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "	ISyntaxMode mode = Document.SyntaxMode != null && textEditor.Options.EnableSyntaxHighlighting ? Document.SyntaxMode : new SyntaxMode (Document); " is 144.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "	LayoutWrapper layout = CreateLinePartLayout (mode' line' logicalRulerColumn' offset' length' selectionStartOffset' selectionEndOffset); " is 135.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "			DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (x1 / Pango.Scale.PangoScale + position' y' (x2 - x1) / Pango.Scale.PangoScale + 1' _lineHeight)' bg.Color' true); " is 219.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "			DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (xPos + startX' startY' endX - startX' LineHeight)' this.SelectionColor.Background' true); " is 195.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "			DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (xPos + startX' startY' textEditor.Allocation.Width - xPos - startX' LineHeight)' this.SelectionColor.Background' true); " is 225.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "				DrawRectangleWithRuler (cr' xPos' new Cairo.Rectangle (xPos' startY + LineHeight' textEditor.Allocation.Width - xPos' endY - startY - LineHeight)' this.SelectionColor.Background' true); " is 185.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "			DrawRectangleWithRuler (cr' xPos' new Cairo.Rectangle (xPos' endY' endX' LineHeight)' this.SelectionColor.Background' true); " is 124.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "			HandleSelection (lineOffset' logicalRulerColumn' selectionStartOffset' selectionEndOffset' System.Math.Max (lineOffset' firstSearch.Offset)' System.Math.Min (lineOffset + line.Length' firstSearch.EndOffset)' delegate (int start' int end) { " is 239.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "					cr.SetSourceColor (MainSearchResult.IsInvalid || MainSearchResult.Offset != firstSearch.Offset ? ColorStyle.SearchResult.Color : ColorStyle.SearchResultMain.Color); " is 164.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "	if (textEditor.Options.ShowWhitespaces != ShowWhitespaces.Never && !(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection)) " is 164.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "				DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (startX' y' endX - startX' _lineHeight)' this.SelectionColor.Background' true); " is 184.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "						if (textEditor.IsSomethingSelected && (selectionStartOffset < offset || selectionStartOffset == selectionEndOffset) && BackgroundRenderer == null) " is 146.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "							DecorateTabsAndSpaces (cr' wrapper' offset' length' xPos' y' selectionStartOffset' selectionEndOffset + wrapper.LineChars.Length); " is 130.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "					if ((!textEditor.IsSomethingSelected || (selectionStartOffset >= offset && selectionStartOffset != selectionEndOffset)) && (HighlightCaretLine || textEditor.Options.HighlightCaretLine) && Caret.Line == lineNumber) " is 213.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "						DecorateLineBg (cr' wrapper' offset' length' xPos' y' selectionStartOffset + virtualSpaceMod' selectionEndOffset + wrapper.LineChars.Length); " is 141.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The length of the statement  "						DecorateTabsAndSpaces (cr' wrapper' offset' length' xPos' y' selectionStartOffset' selectionEndOffset + wrapper.LineChars.Length); " is 130.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CalculateClickLocation,The length of the statement  "	if (line != null && clickLocation.Column >= line.Length + 1 && GetWidth (Document.GetTextAt (line.SegmentIncludingDelimiter) + "-") < x) { " is 138.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,CalculateClickLocation,The length of the statement  "		if (textEditor.GetTextEditorData ().HasIndentationTracker && textEditor.Options.IndentStyle == IndentStyle.Virtual && clickLocation.Column == 1) { " is 146.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The length of the statement  "			textEditor.MainSelection = new Selection (textEditor.Document.OffsetToLocation (mouseWordStart)' textEditor.Document.OffsetToLocation (mouseWordEnd)); " is 150.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The length of the statement  "		if (textEditor.IsSomethingSelected && IsInsideSelection (clickLocation) && clickLocation != textEditor.Caret.Location) { " is 120.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The length of the statement  "			textEditor.SelectionRange = new TextSegment (oldVersion.MoveOffsetTo (Document.Version' selectionRange.Offset)' selectionRange.Length); " is 135.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,IsInsideSelection,The length of the statement  "		return selection.MinLine <= clickLocation.Line && clickLocation.Line <= selection.MaxLine && minColumn <= clickLocation.Column && clickLocation.Column <= maxColumn; " is 164.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ShowTooltip,The length of the statement  "		var geometry = this.textEditor.Screen.GetUsableMonitorGeometry (this.textEditor.Screen.GetMonitorAtPoint (ox + x' oy + y)); " is 123.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ScanWord,The length of the statement  "		return forwardDirection ? System.Math.Min (line.Offset + line.Length' offset + 1) : System.Math.Max (line.Offset' offset); " is 122.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ScanWord,The length of the statement  "		if (char.IsWhiteSpace (first) && !char.IsWhiteSpace (ch) || WordFindStrategy.IsNoIdentifierPart (first) && !WordFindStrategy.IsNoIdentifierPart (ch) || (char.IsLetterOrDigit (first) || first == '_') && !(char.IsLetterOrDigit (ch) || ch == '_')) " is 244.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The length of the statement  "					textEditor.MainSelection = new Selection (Document.OffsetToLocation (mouseWordEnd)' Caret.Location' textEditor.MainSelection.SelectionMode); " is 140.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The length of the statement  "					textEditor.MainSelection = new Selection (Document.OffsetToLocation (mouseWordStart)' Caret.Location' textEditor.MainSelection.SelectionMode); " is 142.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The length of the statement  "				textEditor.MainSelection = new Selection (textEditor.OffsetToLocation (mouseWordStart)' Caret.Location' textEditor.MainSelection.SelectionMode); " is 144.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The length of the statement  "				textEditor.MainSelection = new Selection (textEditor.OffsetToLocation (mouseWordEnd)' Caret.Location' textEditor.MainSelection.SelectionMode); " is 142.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,The length of the statement  "					var txt = Document.GetTextAt (offset' System.Math.Max (0' System.Math.Min (foldOffset - offset' Document.TextLength - offset))); " is 128.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight); " is 154.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment); " is 135.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2); " is 122.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false); " is 254.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2)); " is 138.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' line.Offset + line.Length - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight); " is 169.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "	bool isEolSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionMode == SelectionMode.Normal && (textEditor.MainSelection.Contains (lineNr' 1) || lineNr == textEditor.MainSelection.Start.Line); " is 227.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "	if (textEditor.SelectionMode == SelectionMode.Block && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (line.Offset + line.Length)) { " is 154.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "				DrawRectangleWithRuler (cr' x' new Cairo.Rectangle (lineArea.X' lineArea.Y' x1 - lineArea.X' lineArea.Height)' defaultBgColor' false); " is 134.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "			DrawRectangleWithRuler (cr' x' new Cairo.Rectangle (lineArea.X' lineArea.Y' x2 - lineArea.X' lineArea.Height)' this.SelectionColor.Background' false); " is 150.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "					lineArea = new Cairo.Rectangle (lineArea.X + vwrapper.Width' lineArea.Y + System.Math.Max (0' wrapper.Height - LineHeight)' textEditor.Allocation.Width - (lineArea.X + vwrapper.Width)' LineHeight); " is 197.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "				lineArea = new Cairo.Rectangle (eolStartX' lineArea.Y + System.Math.Max (0' wrapper.Height - LineHeight)' textEditor.Allocation.Width - eolStartX' LineHeight); " is 159.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "					if (!spanStyle.TransparentBackground && GetPixel (ColorStyle.PlainText.Background) != GetPixel (spanStyle.Background)) { " is 120.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The length of the statement  "					if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line) " is 266.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,LocationToPoint,The length of the statement  "	return useAbsoluteCoordinates ? new Cairo.Point (x' y) : new Cairo.Point (x - (int)this.textEditor.HAdjustment.Value' y - (int)this.textEditor.VAdjustment.Value); " is 162.
Long Statement,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ColumnToX,The length of the statement  "		index = (int)TranslateToUTF8Index (wrapper.LineChars' (uint)System.Math.Min (System.Math.Max (0' column)' wrapper.LineChars.Length)' ref curIndex' ref byteIndex); " is 162.
Long Statement,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "			if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) { " is 124.
Long Statement,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "			else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) { " is 196.
Long Statement,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The length of the statement  "			else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) { " is 209.
Long Statement,Mono.TextEditor,DocumentLine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\DocumentLine.cs,ToString,The length of the statement  "	return String.Format ("[DocumentLine: Offset={0}' Length={1}' DelimiterLength={2}' StartSpan={3}]"' Offset' LengthIncludingDelimiter' DelimiterLength' StartSpan == null ? "null" : StartSpan.Count.ToString ()); " is 209.
Long Statement,Mono.TextEditor,DefaultSelectionSurroundingProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISelectionSurroundingProvider.cs,HandleSpecialSelectionKey,The length of the statement  "		textEditorData.MainSelection = new Selection (new DocumentLocation (selection.Anchor.Line' endCol == selection.Anchor.Column ? endCol + start.Length : startCol + 1 + start.Length)' new DocumentLocation (selection.Lead.Line' endCol == selection.Anchor.Column ? startCol + 1 + start.Length : endCol + start.Length)' Mono.TextEditor.SelectionMode.Block); " is 351.
Long Statement,Mono.TextEditor,DefaultSelectionSurroundingProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISelectionSurroundingProvider.cs,HandleSpecialSelectionKey,The length of the statement  "		textEditorData.Document.CommitMultipleLineUpdate (textEditorData.MainSelection.MinLine' textEditorData.MainSelection.MaxLine); " is 126.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The length of the statement  "	var drawArea = new Cairo.Rectangle (System.Math.Floor (x + (Width - foldSegmentSize) / 2) + 0.5' System.Math.Floor (y + (editor.LineHeight - foldSegmentSize) / 2) + 0.5' foldSegmentSize' foldSegmentSize); " is 204.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The length of the statement  "	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2); " is 232.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The length of the statement  "		ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10); " is 233.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The length of the statement  "	var marker = lineSegment != null ? (MarginMarker)lineSegment.Markers.FirstOrDefault (m => m is MarginMarker && ((MarginMarker)m).CanDraw (this)) : null; " is 152.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The length of the statement  "		bool hasDrawn = marker.DrawBackground (editor' cr' new MarginDrawMetrics (this' area' lineSegment' line' x' y' lineHeight)); " is 124.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The length of the statement  "				cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height); " is 204.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The length of the statement  "					cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height); " is 120.
Long Statement,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The length of the statement  "				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height); " is 126.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,HAdjustmentValueChanged,The length of the statement  "	QueueDrawArea ((int)this.textViewMargin.XOffset' 0' this.Allocation.Width - (int)this.textViewMargin.XOffset' this.Allocation.Height); " is 134.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TextEditorDataSelectionChanged,The length of the statement  "		this.RedrawMarginLines (this.textViewMargin' System.Math.Min (System.Math.Min (oldStartLine' oldEndLine)' System.Math.Min (startLine' endLine))' System.Math.Max (System.Math.Max (oldStartLine' oldEndLine)' System.Math.Max (startLine' endLine))); " is 245.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TextEditorDataSelectionChanged,The length of the statement  "			this.RedrawMarginLines (this.textViewMargin' System.Math.Max (0' System.Math.Min (from' to) - 1)' System.Math.Max (from' to)); " is 126.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnRealized,The length of the statement  "	WindowAttributesType mask = WindowAttributesType.X | WindowAttributesType.Y | WindowAttributesType.Colormap | WindowAttributesType.Visual; " is 138.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SimulateKeyPress,The length of the statement  "		ModifierType filteredModifiers = modifier & (ModifierType.ShiftMask | ModifierType.Mod1Mask | ModifierType.ControlMask | ModifierType.MetaMask | ModifierType.SuperMask); " is 169.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnKeyPressEvent,The length of the statement  "	if ((key == Gdk.Key.space || key == Gdk.Key.parenleft || key == Gdk.Key.parenright) && (mod & Gdk.ModifierType.ShiftMask) == Gdk.ModifierType.ShiftMask) " is 152.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragDataReceived,The length of the statement  "				var start = Document.OffsetToLocation (selection.GetSelectionRange (textEditorData).Offset + selection_data.Text.Length); " is 121.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragDataReceived,The length of the statement  "				var end = Document.OffsetToLocation (selection.GetSelectionRange (textEditorData).Offset + selection_data.Text.Length + selection.GetSelectionRange (textEditorData).Length); " is 173.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragMotion,The length of the statement  "	if (!selection.IsEmpty && offset >= this.selection.GetSelectionRange (textEditorData).Offset && offset < this.selection.GetSelectionRange (textEditorData).EndOffset) { " is 167.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragMotion,The length of the statement  "		Gdk.Drag.Status (context' (context.Actions & DragAction.Move) == DragAction.Move ? DragAction.Move : DragAction.Copy' time); " is 124.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The length of the statement  "		if (textViewMargin.inDrag && margin == this.textViewMargin && Gtk.Drag.CheckThreshold (this' (int)pressPositionX' (int)pressPositionY' (int)x' (int)y)) { " is 153.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The length of the statement  "			DragContext context = Gtk.Drag.Begin (this' ClipboardActions.CopyOperation.TargetList' DragAction.Move | DragAction.Copy' 1' e); " is 128.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The length of the statement  "				CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300); " is 134.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,FireMotionEvent,The length of the statement  "		margin.MouseHover (new MarginMouseEventArgs (textEditorData.Parent' EventType.MotionNotify' mouseButtonPressed' x - startPos' y' state)); " is 137.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,CenterTo,The length of the statement  "	// The adjustment does this check' but does it after assigning the value' so the value may be out of bounds for a while. " is 120.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ScrollTo,The length of the statement  "			else if (this.textEditorData.VAdjustment.Value + this.textEditorData.VAdjustment.PageSize - this.LineHeight < caretPosition) { " is 126.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnScrollEvent,The length of the statement  "	var modifier = !Platform.IsMac ? Gdk.ModifierType.ControlMask //Mac window manager already uses control-scroll' so use command " is 126.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetAdjustments,The length of the statement  "		this.textEditorData.VAdjustment.SetBounds (0' System.Math.Max (allocation.Height' maxY)' LineHeight' allocation.Height' allocation.Height); " is 139.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,RenderMargins,The length of the statement  "	this.TextViewMargin.rulerX = Options.RulerColumn * this.TextViewMargin.CharWidth - this.textEditorData.HAdjustment.Value; " is 121.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,RenderMargins,The length of the statement  "				margin.Draw (margin == textViewMargin ? textViewCr : cr' cairoRectangle' line' logicalLineNumber' margin.XOffset' curY' lineHeight); " is 132.
Long Statement,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TooltipTimer,The length of the statement  "			tw = provider.ShowTooltipWindow (editor' nextTipOffset' nextTipModifierState' tipX + (int)TextViewMargin.XOffset' tipY' item); " is 126.
Long Statement,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,MoveToTop,The length of the statement  "	List<EditorContainerChild> newChilds = new List<EditorContainerChild> (containerChildren.Where (child => child != editorContainerChild)); " is 137.
Long Statement,Mono.TextEditor,LineBackgroundMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\LineBackgroundMarker.cs,DrawBackground,The length of the statement  "	cr.Rectangle (metrics.TextRenderStartPosition' y' metrics.TextRenderEndPosition - metrics.TextRenderStartPosition' editor.LineHeight); " is 134.
Long Statement,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The length of the statement  "		int x_pos = layout.IndexToPos ((int)metrics.Layout.TranslateToUTF8Index ((uint)(start - startOffset)' ref curIndex' ref byteIndex)).X; " is 134.
Long Statement,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The length of the statement  "		x_pos = layout.IndexToPos ((int)metrics.Layout.TranslateToUTF8Index ((uint)(end - startOffset)' ref curIndex' ref byteIndex)).X; " is 128.
Long Statement,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The length of the statement  "		cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5); " is 169.
Long Statement,Mono.TextEditor,ActionMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\ActionMargin.cs,Draw,The length of the statement  "	var marker = lineSegment != null ? (MarginMarker)lineSegment.Markers.FirstOrDefault (m => m is MarginMarker && ((MarginMarker)m).CanDraw (this)) : null; " is 152.
Long Statement,Mono.TextEditor,ActionMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\ActionMargin.cs,Draw,The length of the statement  "		drawBackground = !marker.DrawBackground (editor' cr' new MarginDrawMetrics (this' area' lineSegment' line' x' y' lineHeight)); " is 126.
Long Statement,Mono.TextEditor,DiffTracker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\DiffTracker.cs,SetBaseDocument,The length of the statement  "		lineStates.InsertRange (0' document.LineCount + 1' new LineChangeInfo (Mono.TextEditor.TextDocument.LineState.Unchanged)); " is 122.
Long Statement,Mono.TextEditor,DiffTracker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\DiffTracker.cs,Reset,The length of the statement  "	lineStates.InsertRange (0' trackDocument.LineCount + 1' new LineChangeInfo (Mono.TextEditor.TextDocument.LineState.Unchanged)); " is 127.
Long Statement,Mono.TextEditor,GtkUtil,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkUtil.cs,ToCairoColor,The length of the statement  "	return new Cairo.Color ((double)color.Red / ushort.MaxValue' (double)color.Green / ushort.MaxValue' (double)color.Blue / ushort.MaxValue); " is 138.
Long Statement,Mono.TextEditor,GtkUtil,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkUtil.cs,ToXwtColor,The length of the statement  "	return new Xwt.Drawing.Color ((double)color.Red / ushort.MaxValue' (double)color.Green / ushort.MaxValue' (double)color.Blue / ushort.MaxValue); " is 144.
Long Statement,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,PasteAfter,The length of the statement  "		Gtk.Clipboard.Get (ClipboardActions.CopyOperation.CLIPBOARD_ATOM).RequestText (delegate (Gtk.Clipboard cb' string contents) { " is 125.
Long Statement,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,PasteBefore,The length of the statement  "		Gtk.Clipboard.Get (ClipboardActions.CopyOperation.CLIPBOARD_ATOM).RequestText (delegate (Gtk.Clipboard cb' string contents) { " is 125.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	var matchingStartBrace = endTokenOffset.HasValue ? data.Document.GetMatchingBracketOffset (endTokenOffset.GetValueOrDefault ()) : -1; " is 133.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	if (matchingStartBrace >= 0 && (!startTokenOffset.HasValue || matchingStartBrace != startTokenOffset.GetValueOrDefault ())) " is 123.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,TryFindSymbolBlock,The length of the statement  "	var matchingEndBrace = startTokenOffset.HasValue && data.GetCharAt (offset) != end ? data.Document.GetMatchingBracketOffset (startTokenOffset.GetValueOrDefault ()) : -1; " is 169.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,RetreatFromLineEnd,The length of the statement  "		while (DocumentLocation.MinColumn < data.Caret.Column && (data.Caret.Offset >= data.Document.TextLength || IsEol (data.Document.GetCharAt (data.Caret.Offset)))) { " is 162.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "		//Console.WriteLine ("oc{0}:{1} oa{2}:{3} ol{4}:{5}"' oldCaret.Line' oldCaret.Column' oldAnchor.Line' oldAnchor.Column' oldLead.Line' oldLead.Column); " is 150.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "		//Console.WriteLine ("nc{0}:{1} na{2}:{3} nl{4}:{5}"' newCaret.Line' newCaret.Line' newAnchor.Line' newAnchor.Column' newLead.Line' newLead.Column); " is 148.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "			if (oldAnchor < oldLead && newAnchor > newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line + 1) || (newLead.Line == newAnchor.Line - 1 && oldLead.Line == oldAnchor.Line))) " is 197.
Long Statement,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The length of the statement  "			else if (oldAnchor > oldLead && newAnchor < newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line - 1) || (newLead.Line == newAnchor.Line + 1 && oldLead.Line == oldAnchor.Line))) " is 202.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextSubwordOffset,The length of the statement  "	for (c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 139.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (myoffset); !char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 145.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindNextWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (++myoffset)) " is 144.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevSubwordOffset,The length of the statement  "	for (c = doc.GetCharAt (myoffset); char.IsWhiteSpace (c) && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (--myoffset)) " is 139.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevSubwordOffset,The length of the statement  "	for (; GetCharacterClass (c) == initialClass && 0 <= myoffset && doc.TextLength - 1 > myoffset; c = doc.GetCharAt (--myoffset)) " is 127.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (offset); char.IsWhiteSpace (c) && 0 < offset && doc.TextLength > offset; c = doc.GetCharAt (--offset)) " is 131.
Long Statement,Mono.TextEditor.Vi,ViWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViWordFindStrategy.cs,FindPrevWordOffset,The length of the statement  "	for (char c = doc.GetCharAt (offset); !char.IsWhiteSpace (c) && 0 < offset && doc.TextLength > offset; c = doc.GetCharAt (--offset)) " is 132.
Long Statement,Mono.TextEditor.Vi,ViBuilderContext,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilderContext.cs,InsertChar,The length of the statement  "				data.MainSelection = data.MainSelection.WithRange (new DocumentLocation (data.MainSelection.Anchor.Line' caret.Column + 1)' new DocumentLocation (data.MainSelection.Lead.Line' caret.Column + 1)); " is 195.
Long Statement,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,The length of the statement  "		if (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9')) " is 139.
Long Statement,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,IsValidRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validRegisters.Contains (c)); " is 175.
Long Statement,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,IsValidSetRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validSetRegisters.Contains (c)); " is 178.
Long Statement,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,IsValidGetRegister,The length of the statement  "	return (((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9') || validGetRegisters.Contains (c)); " is 178.
Long Statement,Mono.TextEditor.PopupWindow,TooltipWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\TooltipWindow.cs,OnExposeEvent,The length of the statement  "	Gtk.Style.PaintFlatBox (Style' this.GdkWindow' StateType.Normal' ShadowType.Out' evnt.Area' this' "tooltip"' 0' 0' winWidth' winHeight); " is 136.
Long Statement,Mono.TextEditor.PopupWindow,ListWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWindow.cs,ProcessKey,The length of the statement  "		return (list.SelectionDisabled ? ListWindowKeyAction.Process : (ListWindowKeyAction.Complete | ListWindowKeyAction.Ignore)) | ListWindowKeyAction.CloseWindow; " is 158.
Long Statement,Mono.TextEditor.PopupWindow,ListWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWindow.cs,OnExposeEvent,The length of the statement  "	this.GdkWindow.DrawRectangle (this.Style.ForegroundGC (StateType.Insensitive)' false' 0' 0' winWidth - 1' winHeight - 1); " is 121.
Long Statement,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The length of the statement  "		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2); " is 135.
Long Statement,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The length of the statement  "		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1); " is 185.
Long Statement,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The length of the statement  "				FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height); " is 134.
Long Statement,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The length of the statement  "			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2); " is 170.
Long Statement,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The length of the statement  "			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1); " is 197.
Long Statement,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The length of the statement  "		return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0); " is 133.
Long Statement,Mono.TextEditor.Theatrics,AnimatedWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedWidget.cs,OnWidgetDestroyed,The length of the statement  "		canvas.DrawDrawable (Style.BackgroundGC (State)' GdkWindow' widget_alloc.X' widget_alloc.Y' 0' 0' widget_alloc.Width' widget_alloc.Height); " is 139.
Long Statement,Mono.TextEditor.Theatrics,AnimatedWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedWidget.cs,OnExposeEvent,The length of the statement  "		GdkWindow.DrawDrawable (Style.BackgroundGC (State)' canvas' 0' 0' widget_alloc.X' widget_alloc.Y' widget_alloc.Width' widget_alloc.Height); " is 139.
Long Statement,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RecalculateSpacings,The length of the statement  "				if (widget.AnimationState == AnimationState.Coming || widget.AnimationState == AnimationState.Idle || widget.Node.Next == null) { " is 129.
Long Statement,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RecalculateSpacings,The length of the statement  "				if (widget.AnimationState == AnimationState.Coming || widget.AnimationState == AnimationState.Idle || widget.Node.Previous == null) { " is 133.
Long Statement,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,RemoveCore,The length of the statement  "		throw new ArgumentException ("Cannot remove the specified widget because it has not been added to this container or it has already been removed."' "widget"); " is 157.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "	var childRectangle = new Rectangle (allocation.X + margin' allocation.Y + margin' allocation.Width - vwidth - margin * 2' allocation.Height - hheight - margin * 2); " is 164.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "			child.Child.SizeAllocate (new Rectangle (childRectangle.RightInside ()' childRectangle.Y + vChildTopHeight' allocation.Width - vwidth' child.Child.Requisition.Height)); " is 168.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "		vScrollBar.SizeAllocate (new Rectangle (childRectangle.X + childRectangle.Width + margin' childRectangle.Y + vChildTopHeight' vwidth' Allocation.Height - v - vChildTopHeight - margin)); " is 185.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "		vAdjustment.Value = System.Math.Max (System.Math.Min (vAdjustment.Upper - vAdjustment.PageSize' vAdjustment.Value)' vAdjustment.Lower); " is 135.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "		hScrollBar.SizeAllocate (new Rectangle (allocation.X' childRectangle.Y + childRectangle.Height + margin' allocation.Width - v' hheight)); " is 137.
Long Statement,Mono.TextEditor.Theatrics,SmartScrolledWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\SmartScrolledWindow.cs,OnSizeAllocated,The length of the statement  "		hScrollBar.Value = System.Math.Max (System.Math.Min (hAdjustment.Upper - hAdjustment.PageSize' hScrollBar.Value)' hAdjustment.Lower); " is 133.
Long Statement,Mono.TextEditor.Utils,Hunk,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,ToString,The length of the statement  "	return string.Format ("[Hunk: InsertStart={0}' RemoveStart={1}' Removed={2}' Inserted={3}]"' InsertStart' RemoveStart' Removed' Inserted); " is 138.
Long Statement,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,CreateDiffs,The length of the statement  "		if (lineA < baseData.Length && !baseData.Modified [lineA] && lineB < changedData.Length && !changedData.Modified [lineB]) { " is 123.
Long Statement,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,GetDiffString,The length of the statement  "	return GetDiffString (baseDocument.Diff (changedDocument)' baseDocument' changedDocument' baseDocument.FileName' changedDocument.FileName); " is 139.
Long Statement,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The length of the statement  "	if (parent.Color == RedBlackColor.Black && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Black) { " is 191.
Long Statement,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The length of the statement  "	if (parent.Color == RedBlackColor.Red && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Black) { " is 189.
Long Statement,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The length of the statement  "	if (node == parent.Left && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Red && GetColorSafe (sibling.Right) == RedBlackColor.Black) { " is 173.
Long Statement,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The length of the statement  "	else if (node == parent.Right && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Red && GetColorSafe (sibling.Left) == RedBlackColor.Black) { " is 179.
Long Statement,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,AppendNode,The length of the statement  "	builder.Append (GetIndent (indent) + "Node (" + (node.Color == RedBlackColor.Red ? "r" : "b") + "):" + node + Environment.NewLine); " is 131.
Long Statement,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,GenerateRtf,The length of the statement  "		double fontSize = Double.Parse (fontName.Substring (fontName.LastIndexOf (' ') + 1)' System.Globalization.CultureInfo.InvariantCulture) * 2; " is 140.
Long Statement,Mono.TextEditor.Utils,ColoredSegment,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\HtmlWriter.cs,GetChunks,The length of the statement  "		copiedColoredChunks.Add (data.GetChunks (line' offset' length).Select (chunk => new ColoredSegment (chunk' data.Document)).ToList ()); " is 134.
Long Statement,Mono.TextEditor.Utils,HtmlWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\HtmlWriter.cs,GenerateCFHtmlHeader,The length of the statement  "	return "Version:0.9" + Environment.NewLine + string.Format ("StartHTML: {0:d8}"' startHTML) + Environment.NewLine + string.Format ("EndHTML: {0:d8}"' endHTML) + Environment.NewLine + string.Format ("StartFragment: {0:d8}"' startFragment) + Environment.NewLine + string.Format ("EndFragment: {0:d8}"' endFragment) + Environment.NewLine; " is 335.
Long Statement,Mono.TextEditor.Utils,CompressingTreeList,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - Count)); " is 122.
Long Statement,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,CopyTo,The length of the statement  "		throw new ArgumentOutOfRangeException ("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - Count)); " is 122.
Complex Conditional,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,GetMarkup,The conditional expression  "setColor || setBold || setItalic || setUnderline"  is complex.
Complex Conditional,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The conditional expression  "(BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)"  is complex.
Complex Conditional,Mono.TextEditor,FoldActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\FoldActions.cs,GetOutermostClosedFold,The conditional expression  "fold.IsFolded && data.LogicalToVisualLine (data.OffsetToLineNumber (fold.Offset)) == lineNumber && fold.Offset <= startOffset && fold.EndOffset >= endOffset"  is complex.
Complex Conditional,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,IsContextMenuButton,The conditional expression  "!oldMacKeyHacks && evt.Button == 1 && (evt.State & Gdk.ModifierType.ControlMask) != 0 && (evt.State & (Gdk.ModifierType.Button2Mask | Gdk.ModifierType.Button3Mask)) == 0"  is complex.
Complex Conditional,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,OptimizeTypedUndo,The conditional expression  "top.Args == null || top.Args.InsertedText == null || top.Args.InsertionLength != 1 || (top is KeyboardStackUndo && ((KeyboardStackUndo)top).IsClosed)"  is complex.
Complex Conditional,Mono.TextEditor,WordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\IWordFindStrategy.cs,ScanWord,The conditional expression  "char.IsWhiteSpace (first) && !char.IsWhiteSpace (ch) || IsNoIdentifierPart (first) && !IsNoIdentifierPart (ch) || (char.IsLetterOrDigit (first) || first == '_') && !(char.IsLetterOrDigit (ch) || ch == '_')"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,UpdateBracketHighlighting,The conditional expression  "Caret.Mode != CaretMode.Insert || (offset >= 0 && offset < Document.TextLength && !TextDocument.IsBracket (Document.GetCharAt (offset)))"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,SetVisibleCaretPosition,The conditional expression  "x == caretX && y == caretY && this.nonPreeditX == nonPreeditX && this.nonPreeditY == nonPreeditY"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The conditional expression  "!this.textEditor.IsInDrag && !(this.caretX >= 0 && (!this.textEditor.IsSomethingSelected || this.textEditor.SelectionRange.Length == 0))"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The conditional expression  "win == null || Settings.Default.CursorBlink && !Caret.IsVisible || !caretBlink"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleSelection,The conditional expression  "textEditor.Options.ShowRuler && selectionStartColumn < logicalRulerColumn && logicalRulerColumn < selectionEndColumn && startOffset < rulerOffset && rulerOffset < endOffset"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The conditional expression  "!isSelectionDrawn && (layout.StartSet || selectionStartOffset == offset + length) && BackgroundRenderer == null"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The conditional expression  "textEditor.IsSomethingSelected && (selectionStartOffset < offset || selectionStartOffset == selectionEndOffset) && BackgroundRenderer == null"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The conditional expression  "(!textEditor.IsSomethingSelected || (selectionStartOffset >= offset && selectionStartOffset != selectionEndOffset)) && (HighlightCaretLine || textEditor.Options.HighlightCaretLine) && Caret.Line == lineNumber"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawEolMarker,The conditional expression  "line != null && line.NextLine != null && line.NextLine.StartSpan != null && line.NextLine.StartSpan.Count > 0"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ScanWord,The conditional expression  "char.IsWhiteSpace (first) && !char.IsWhiteSpace (ch) || WordFindStrategy.IsNoIdentifierPart (first) && !WordFindStrategy.IsNoIdentifierPart (ch) || (char.IsLetterOrDigit (first) || first == '_') && !(char.IsLetterOrDigit (ch) || ch == '_')"  is complex.
Complex Conditional,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The conditional expression  "textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line"  is complex.
Complex Conditional,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The conditional expression  "current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))"  is complex.
Complex Conditional,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The conditional expression  "current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter"  is complex.
Complex Conditional,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The conditional expression  "current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnKeyPressEvent,The conditional expression  "(key == Gdk.Key.space || key == Gdk.Key.parenleft || key == Gdk.Key.parenright) && (mod & Gdk.ModifierType.ShiftMask) == Gdk.ModifierType.ShiftMask"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ScrollTo,The conditional expression  "isDisposed || p.Line < 0 || p.Line > Document.LineCount || inCaretScroll"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,RangeToRectangle,The conditional expression  "start.Column < 0 || start.Line < 0 || end.Column < 0 || end.Line < 0"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,RangeToRectangle,The conditional expression  "startPt.Y != endPt.Y || startPt.X < 0 || startPt.Y < 0 || width < 0"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ShowTooltip,The conditional expression  "xloc >= wx && xloc < wx + ww && yloc >= tipY && yloc < tipY + 20 + wh"  is complex.
Complex Conditional,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,HideTooltip,The conditional expression  "x >= 0 && y >= 0 && x < w && y < h"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The conditional expression  "text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\')"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The conditional expression  "oldAnchor < oldLead && newAnchor > newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line + 1) || (newLead.Line == newAnchor.Line - 1 && oldLead.Line == oldAnchor.Line))"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,VisualSelectionFromMoveAction,The conditional expression  "oldAnchor > oldLead && newAnchor < newLead && ((newLead.Line == newAnchor.Line && oldLead.Line == oldAnchor.Line - 1) || (newLead.Line == newAnchor.Line + 1 && oldLead.Line == oldAnchor.Line))"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViBuilders,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilders.cs,InsertBuilder,The conditional expression  "(noModifiers && l.Key == Key.Escape) || (l.Char == 'c' && (l.Modifiers & ModifierType.ControlMask) != 0)"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,GetRegisterContents,The conditional expression  "((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z') || ((int)'0' <= regInt && regInt <= (int)'9')"  is complex.
Complex Conditional,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,SetRegisterContents,The conditional expression  "((int)'a' <= regInt && regInt <= (int)'z') || ((int)'A' <= regInt && regInt <= (int)'Z')"  is complex.
Complex Conditional,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,CreateDiffs,The conditional expression  "lineA < baseData.Length && !baseData.Modified [lineA] && lineB < changedData.Length && !changedData.Modified [lineB]"  is complex.
Complex Conditional,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The conditional expression  "parent.Color == RedBlackColor.Black && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Black"  is complex.
Complex Conditional,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The conditional expression  "parent.Color == RedBlackColor.Red && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Black"  is complex.
Complex Conditional,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The conditional expression  "node == parent.Left && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Left) == RedBlackColor.Red && GetColorSafe (sibling.Right) == RedBlackColor.Black"  is complex.
Complex Conditional,Mono.TextEditor.Utils,RedBlackTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RedBlackTree.cs,DeleteOneChild,The conditional expression  "node == parent.Right && sibling.Color == RedBlackColor.Black && GetColorSafe (sibling.Right) == RedBlackColor.Red && GetColorSafe (sibling.Left) == RedBlackColor.Black"  is complex.
Virtual Method Call from Constructor,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,TextEditor,The constructor "TextEditor" calls a virtual method "OptionsChanged".
Empty Catch Block,Mono.TextEditor,Platform,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Platform.cs,IsRunningOnMac,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,FixContainerLeak,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetOverlayScrollbarPolicy,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetOverlayScrollbarPolicy,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetOverlayScrollbarPolicy,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetOverlayScrollbarPolicy,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetSourceScale,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetSourceScale,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetSourceScaleWildcarded,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetSourceScaleWildcarded,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,Get2xVariant,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,Get2xVariant,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetScaleFactor,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetScaleFactor,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetScaleFactor,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetScaleFactor,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,RenderIcon,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,RenderIcon,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,GtkGestures,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkGestures.cs,GtkGestures,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor,DiffTracker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\DiffTracker.cs,GetLineState,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor.Utils,TextFileUtility,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\TextFileUtility.cs,WriteText,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor.Utils,TextFileUtility,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\TextFileUtility.cs,SystemRename,The method has an empty catch block.
Empty Catch Block,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,GenerateRtf,The method has an empty catch block.
Magic Number,Mono.TextEditor.Highlighting,CSharpNumberMatch,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,TryMatch,The following statement contains a magic number: if (matchOffset + 1 < text.Length && text [matchOffset] == '0' && Char.ToUpper (text [matchOffset + 1]) == 'X') {  	i += 2;  	// skip 0x  	while (i < text.Length) {  		char ch = Char.ToUpper (text [i]);  		if (!(Char.IsDigit (ch) || ('A' <= ch && ch <= 'F')))  			break;  		i++;  	}  	ReadNonFloatEnd (text' ref i);  	return new[] {  		i - matchOffset  	};  }  else {  	if (i >= text.Length || !Char.IsDigit (text [i]))  		return emptyMatch;  	i++;  	while (i < text.Length && Char.IsDigit (text [i]))  		i++;  }  
Magic Number,Mono.TextEditor.Highlighting,CSharpNumberMatch,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,TryMatch,The following statement contains a magic number: i += 2;  
Magic Number,Mono.TextEditor.Highlighting,SyntaxMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxMode.cs,ColorToPangoMarkup,The following statement contains a magic number: return string.Format ("#{0:X2}{1:X2}{2:X2}"' color.Red >> 8' color.Green >> 8' color.Blue >> 8);  
Magic Number,Mono.TextEditor.Highlighting,SyntaxMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxMode.cs,ColorToPangoMarkup,The following statement contains a magic number: return string.Format ("#{0:X2}{1:X2}{2:X2}"' color.Red >> 8' color.Green >> 8' color.Blue >> 8);  
Magic Number,Mono.TextEditor.Highlighting,SyntaxMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxMode.cs,ColorToPangoMarkup,The following statement contains a magic number: return string.Format ("#{0:X2}{1:X2}{2:X2}"' color.Red >> 8' color.Green >> 8' color.Blue >> 8);  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ParseColor,The following statement contains a magic number: if (value.Length == 9 && value.StartsWith ("#"' StringComparison.Ordinal)) {  	double r = ((double)int.Parse (value.Substring (1' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double g = ((double)int.Parse (value.Substring (3' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double b = ((double)int.Parse (value.Substring (5' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	double a = ((double)int.Parse (value.Substring (7' 2)' System.Globalization.NumberStyles.HexNumber)) / 255;  	return new Cairo.Color (r' g' b' a);  }  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,ColorToMarkup,The following statement contains a magic number: if (a == 255)  	return string.Format ("#{0:X2}{1:X2}{2:X2}"' r' g' b);  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The following statement contains a magic number: result.IndentationGuide.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.3)));  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The following statement contains a magic number: h.L += 0.01;  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The following statement contains a magic number: result.TooltipPagerTriangle.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.8)));  
Magic Number,Mono.TextEditor.Highlighting,ColorScheme,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\ColorScheme.cs,Import,The following statement contains a magic number: result.TooltipBorder.Colors.Add (Tuple.Create ("color"' AlphaBlend (result.PlainText.Foreground' result.PlainText.Background' 0.5)));  
Magic Number,Mono.TextEditor.Highlighting,AmbientColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\AmbientColor.cs,Import,The following statement contains a magic number: foreach (var attr in attrs) {  	var info = attr.Split ('=');  	if (info.Length != 2)  		continue;  	var idx = info [1].LastIndexOf ('/');  	var source = info [1].Substring (0' idx);  	var dest = info [1].Substring (idx + 1);  	ColorScheme.VSSettingColor color;  	if (!colors.TryGetValue (source' out color))  		continue;  	result.Name = color.Name;  	string colorString;  	switch (dest) {  	case "Foreground":  		colorString = color.Foreground;  		break;  	case "Background":  		colorString = color.Background;  		break;  	default:  		throw new InvalidDataException ("Invalid attribute source: " + dest);  	}  	result.Colors.Add (Tuple.Create (info [0]' ColorScheme.ImportVsColor (colorString)));  }  
Magic Number,Mono.TextEditor.Highlighting,AmbientColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\AmbientColor.cs,Import,The following statement contains a magic number: if (info.Length != 2)  	continue;  
Magic Number,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,TextEditorData,The following statement contains a magic number: LineHeight = 16;  
Magic Number,Mono.TextEditor,BasicSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,SearchBackward,The following statement contains a magic number: if (!string.IsNullOrEmpty (SearchRequest.SearchPattern)) {  	// TODO: Optimize  	for (int i = 0; i < args.Text.Length; i++) {  		int offset = (fromOffset + args.Text.Length * 2 - 1 - i) % args.Text.Length;  		if (worker != null && worker.CancellationPending)  			return null;  		if (IsMatchAt (offset) && (searchRequest.SearchRegion.IsInvalid || searchRequest.SearchRegion.Contains (offset)))  			return new SearchResult (offset' searchRequest.SearchPattern.Length' offset > fromOffset);  	}  }  
Magic Number,Mono.TextEditor,BasicSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,SearchBackward,The following statement contains a magic number: for (int i = 0; i < args.Text.Length; i++) {  	int offset = (fromOffset + args.Text.Length * 2 - 1 - i) % args.Text.Length;  	if (worker != null && worker.CancellationPending)  		return null;  	if (IsMatchAt (offset) && (searchRequest.SearchRegion.IsInvalid || searchRequest.SearchRegion.Contains (offset)))  		return new SearchResult (offset' searchRequest.SearchPattern.Length' offset > fromOffset);  }  
Magic Number,Mono.TextEditor,BasicSearchEngine,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\ISearchEngine.cs,ReplaceAll,The following statement contains a magic number: if (searchResults.Count < 100) {  	using (var undo = textEditorData.OpenUndoGroup ()) {  		for (int i = searchResults.Count - 1; i >= 0; i--) {  			Replace (searchResults [i]' withPattern);  		}  		if (searchResults.Count > 0)  			textEditorData.ClearSelection ();  	}  }  else {  	char[] oldText = text.ToCharArray ();  	var newText = new char[oldText.Length + searchResults.Count * (withPattern.Length - compiledPattern.Length)];  	char[] pattern = withPattern.ToCharArray ();  	int curOffset = 0' destOffset = 0;  	foreach (var sr in searchResults) {  		var length = sr.Offset - curOffset;  		Array.Copy (oldText' curOffset' newText' destOffset' length);  		destOffset += length;  		Array.Copy (pattern' 0' newText' destOffset' pattern.Length);  		destOffset += withPattern.Length;  		curOffset = sr.EndOffset;  	}  	var l = textEditorData.Length - curOffset;  	Array.Copy (oldText' curOffset' newText' destOffset' l);  	textEditorData.Replace (0' textEditorData.Length' new string (newText));  	textEditorData.ClearSelection ();  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: if (lineSegment.IsBookmarked) {  	var color1 = editor.ColorStyle.Bookmarks.Color;  	var color2 = editor.ColorStyle.Bookmarks.SecondColor;  	DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  	using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  		pat.AddColorStop (0' color1);  		pat.AddColorStop (1' color2);  		cr.SetSource (pat);  		cr.FillPreserve ();  	}  	using (var pat = new Cairo.LinearGradient (x' y + height' x + width' y)) {  		pat.AddColorStop (0' color2);  		//pat.AddColorStop (1' color1);  		cr.SetSource (pat);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: DrawRoundRectangle (cr' x + 1' y + 1' 8' width - 4' height - 4);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  	pat.AddColorStop (0' color1);  	pat.AddColorStop (1' color2);  	cr.SetSource (pat);  	cr.FillPreserve ();  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  	pat.AddColorStop (0' color1);  	pat.AddColorStop (1' color2);  	cr.SetSource (pat);  	cr.FillPreserve ();  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawIcon,The following statement contains a magic number: using (var pat = new Cairo.LinearGradient (x + width / 4' y' x + width / 2' y + height - 4)) {  	pat.AddColorStop (0' color1);  	pat.AddColorStop (1' color2);  	cr.SetSource (pat);  	cr.FillPreserve ();  }  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: if (radius_x > w - radius_x)  	radius_x = w / 2;  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: radius_x = w / 2;  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: if (radius_y > h - radius_y)  	radius_y = h / 2;  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: radius_y = h / 2;  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: cr.RelLineTo (w - 2 * radius_x' 0.0);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: cr.RelLineTo (0' h - 2 * radius_y);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: cr.RelLineTo (-w + 2 * radius_x' 0);  
Magic Number,Mono.TextEditor,BookmarkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\BookmarkMarker.cs,DrawRoundRectangle,The following statement contains a magic number: cr.RelLineTo (0' -h + 2 * radius_y);  
Magic Number,Mono.TextEditor,EditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\EditMode.cs,GetKeyCode,The following statement contains a magic number: return GetKeyCode (key) | (int)(m << 16);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,GetColorString,The following statement contains a magic number: return string.Format ("#{0:X02}{1:X02}{2:X02}"' color.Red / 256' color.Green / 256' color.Blue / 256);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,GetColorString,The following statement contains a magic number: return string.Format ("#{0:X02}{1:X02}{2:X02}"' color.Red / 256' color.Green / 256' color.Blue / 256);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,GetColorString,The following statement contains a magic number: return string.Format ("#{0:X02}{1:X02}{2:X02}"' color.Red / 256' color.Green / 256' color.Blue / 256);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineX,The following statement contains a magic number: cr.MoveTo (x1 + 0.5' y1);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineX,The following statement contains a magic number: cr.LineTo (x2 + 0.5' y2);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineY,The following statement contains a magic number: cr.MoveTo (x1' y1 + 0.5);  
Magic Number,Mono.TextEditor,HelperMethods,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\HelperMethods.cs,SharpLineY,The following statement contains a magic number: cr.LineTo (x2' y2 + 0.5);  
Magic Number,Mono.TextEditor,TextLinkTooltipProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,GetRequiredPosition,The following statement contains a magic number: xalign = 0.5;  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (var link in mode.Links) {  	if (!link.IsEditable)  		continue;  	bool isPrimaryHighlighted = link.PrimaryLink.Offset <= caretOffset && caretOffset <= link.PrimaryLink.EndOffset;  	foreach (TextSegment segment in link.Links) {  		if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  			int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  			int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  			int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  			int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  			x_pos = (int)(x_pos / Pango.Scale.PangoScale);  			x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  			Cairo.Color fillGc' rectangleGc;  			if (segment == link.PrimaryLink) {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			}  			else {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  			}  			// Draw segment  			double x1 = metrics.TextRenderStartPosition + x_pos - 1;  			double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  			cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  			cr.SetSourceColor (fillGc);  			cr.FillPreserve ();  			cr.SetSourceColor (rectangleGc);  			cr.Stroke ();  		}  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (var link in mode.Links) {  	if (!link.IsEditable)  		continue;  	bool isPrimaryHighlighted = link.PrimaryLink.Offset <= caretOffset && caretOffset <= link.PrimaryLink.EndOffset;  	foreach (TextSegment segment in link.Links) {  		if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  			int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  			int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  			int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  			int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  			x_pos = (int)(x_pos / Pango.Scale.PangoScale);  			x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  			Cairo.Color fillGc' rectangleGc;  			if (segment == link.PrimaryLink) {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			}  			else {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  			}  			// Draw segment  			double x1 = metrics.TextRenderStartPosition + x_pos - 1;  			double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  			cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  			cr.SetSourceColor (fillGc);  			cr.FillPreserve ();  			cr.SetSourceColor (rectangleGc);  			cr.Stroke ();  		}  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (var link in mode.Links) {  	if (!link.IsEditable)  		continue;  	bool isPrimaryHighlighted = link.PrimaryLink.Offset <= caretOffset && caretOffset <= link.PrimaryLink.EndOffset;  	foreach (TextSegment segment in link.Links) {  		if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  			int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  			int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  			int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  			int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  			x_pos = (int)(x_pos / Pango.Scale.PangoScale);  			x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  			Cairo.Color fillGc' rectangleGc;  			if (segment == link.PrimaryLink) {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			}  			else {  				fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  				rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  			}  			// Draw segment  			double x1 = metrics.TextRenderStartPosition + x_pos - 1;  			double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  			cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  			cr.SetSourceColor (fillGc);  			cr.FillPreserve ();  			cr.SetSourceColor (rectangleGc);  			cr.Stroke ();  		}  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (TextSegment segment in link.Links) {  	if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  		int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  		int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  		int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  		int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  		x_pos = (int)(x_pos / Pango.Scale.PangoScale);  		x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  		Cairo.Color fillGc' rectangleGc;  		if (segment == link.PrimaryLink) {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		}  		else {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  		}  		// Draw segment  		double x1 = metrics.TextRenderStartPosition + x_pos - 1;  		double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  		cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  		cr.SetSourceColor (fillGc);  		cr.FillPreserve ();  		cr.SetSourceColor (rectangleGc);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (TextSegment segment in link.Links) {  	if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  		int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  		int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  		int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  		int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  		x_pos = (int)(x_pos / Pango.Scale.PangoScale);  		x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  		Cairo.Color fillGc' rectangleGc;  		if (segment == link.PrimaryLink) {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		}  		else {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  		}  		// Draw segment  		double x1 = metrics.TextRenderStartPosition + x_pos - 1;  		double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  		cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  		cr.SetSourceColor (fillGc);  		cr.FillPreserve ();  		cr.SetSourceColor (rectangleGc);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: foreach (TextSegment segment in link.Links) {  	if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  		int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  		int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  		int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  		int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  		x_pos = (int)(x_pos / Pango.Scale.PangoScale);  		x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  		Cairo.Color fillGc' rectangleGc;  		if (segment == link.PrimaryLink) {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		}  		else {  			fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  			rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  		}  		// Draw segment  		double x1 = metrics.TextRenderStartPosition + x_pos - 1;  		double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  		cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  		cr.SetSourceColor (fillGc);  		cr.FillPreserve ();  		cr.SetSourceColor (rectangleGc);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  	int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  	int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  	int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  	int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  	x_pos = (int)(x_pos / Pango.Scale.PangoScale);  	x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  	Cairo.Color fillGc' rectangleGc;  	if (segment == link.PrimaryLink) {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  	}  	else {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  	}  	// Draw segment  	double x1 = metrics.TextRenderStartPosition + x_pos - 1;  	double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  	cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  	cr.SetSourceColor (fillGc);  	cr.FillPreserve ();  	cr.SetSourceColor (rectangleGc);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  	int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  	int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  	int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  	int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  	x_pos = (int)(x_pos / Pango.Scale.PangoScale);  	x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  	Cairo.Color fillGc' rectangleGc;  	if (segment == link.PrimaryLink) {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  	}  	else {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  	}  	// Draw segment  	double x1 = metrics.TextRenderStartPosition + x_pos - 1;  	double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  	cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  	cr.SetSourceColor (fillGc);  	cr.FillPreserve ();  	cr.SetSourceColor (rectangleGc);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: if ((BaseOffset + segment.Offset <= metrics.TextStartOffset && metrics.TextStartOffset < BaseOffset + segment.EndOffset) || (metrics.TextStartOffset <= BaseOffset + segment.Offset && BaseOffset + segment.Offset < metrics.TextEndOffset)) {  	int strOffset = BaseOffset + segment.Offset - metrics.TextStartOffset;  	int strEndOffset = BaseOffset + segment.EndOffset - metrics.TextStartOffset;  	int x_pos = metrics.Layout.Layout.IndexToPos (strOffset).X;  	int x_pos2 = metrics.Layout.Layout.IndexToPos (strEndOffset).X;  	x_pos = (int)(x_pos / Pango.Scale.PangoScale);  	x_pos2 = (int)(x_pos2 / Pango.Scale.PangoScale);  	Cairo.Color fillGc' rectangleGc;  	if (segment == link.PrimaryLink) {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.PrimaryTemplateHighlighted.SecondColor : editor.ColorStyle.PrimaryTemplate.SecondColor;  	}  	else {  		fillGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.SecondColor : editor.ColorStyle.SecondaryTemplate.SecondColor;  		rectangleGc = isPrimaryHighlighted ? editor.ColorStyle.SecondaryTemplateHighlighted.Color : editor.ColorStyle.SecondaryTemplate.Color;  	}  	// Draw segment  	double x1 = metrics.TextRenderStartPosition + x_pos - 1;  	double x2 = metrics.TextRenderStartPosition + x_pos2 - 1 + 0.5;  	cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  	cr.SetSourceColor (fillGc);  	cr.FillPreserve ();  	cr.SetSourceColor (rectangleGc);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawBackground,The following statement contains a magic number: cr.Rectangle (x1 + 0.5' y + 0.5' x2 - x1' editor.LineHeight - 1);  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawForeground,The following statement contains a magic number: if (metrics.LineNumber <= editor.Document.LineCount) {  	// Due to a mac? gtk bug I need to re-create the layout here  	// otherwise I get pango exceptions.  	using (var layout = PangoUtil.CreateLayout (editor)) {  		layout.FontDescription = editor.Options.Font;  		layout.Width = (int)width;  		layout.Alignment = Pango.Alignment.Right;  		layout.SetText (metrics.LineNumber.ToString ());  		cr.Save ();  		cr.Translate (metrics.X + (int)width + (editor.Options.ShowFoldMargin ? 0 : -2)' metrics.Y);  		cr.SetSourceColor (lineNumberBgGC);  		cr.ShowLayout (layout);  		cr.Restore ();  	}  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawForeground,The following statement contains a magic number: using (var layout = PangoUtil.CreateLayout (editor)) {  	layout.FontDescription = editor.Options.Font;  	layout.Width = (int)width;  	layout.Alignment = Pango.Alignment.Right;  	layout.SetText (metrics.LineNumber.ToString ());  	cr.Save ();  	cr.Translate (metrics.X + (int)width + (editor.Options.ShowFoldMargin ? 0 : -2)' metrics.Y);  	cr.SetSourceColor (lineNumberBgGC);  	cr.ShowLayout (layout);  	cr.Restore ();  }  
Magic Number,Mono.TextEditor,TextLinkMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextLinkEditMode.cs,DrawForeground,The following statement contains a magic number: cr.Translate (metrics.X + (int)width + (editor.Options.ShowFoldMargin ? 0 : -2)' metrics.Y);  
Magic Number,Mono.TextEditor,Platform,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Platform.cs,IsRunningOnMac,The following statement contains a magic number: try {  	buf = Marshal.AllocHGlobal (8192);  	// This is a hacktastic way of getting sysname from uname ()  	if (uname (buf) == 0) {  		string os = Marshal.PtrToStringAnsi (buf);  		if (os == "Darwin")  			return true;  	}  }  catch {  }  finally {  	if (buf != IntPtr.Zero)  		Marshal.FreeHGlobal (buf);  }  
Magic Number,Mono.TextEditor,Platform,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Platform.cs,IsRunningOnMac,The following statement contains a magic number: buf = Marshal.AllocHGlobal (8192);  
Magic Number,Mono.TextEditor,HelpWindowEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\InsertionCursorEditMode.cs,PositionHelpWindow,The following statement contains a magic number: editor.TextArea.MoveTopLevelWidget (HelpWindow' x' y - req.Height / 2);  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (clipboard.WaitIsTargetAvailable (CopyOperation.MD_ATOM)) {  	clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  		if (selectionData.Length > 0) {  			byte[] selBytes = selectionData.Data;  			var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  			byte[] copyData = new byte[upperBound];  			Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  			var rawTextOffset = 1 + 1 + copyData.Length;  			string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  			bool pasteBlock = (selBytes [0] & 1) == 1;  			bool pasteLine = (selBytes [0] & 2) == 2;  			if (pasteBlock) {  				using (var undo = data.OpenUndoGroup ()) {  					var version = data.Document.Version;  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					int startLine = data.Caret.Line;  					data.EnsureCaretIsNotVirtual ();  					insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  					data.Caret.PreserveSelection = true;  					var lines = new List<string> ();  					int offset = 0;  					while (true) {  						var delimiter = LineSplitter.NextDelimiter (text' offset);  						if (delimiter.IsInvalid)  							break;  						int delimiterEndOffset = delimiter.EndOffset;  						lines.Add (text.Substring (offset' delimiter.Offset - offset));  						offset = delimiterEndOffset;  					}  					if (offset < text.Length)  						lines.Add (text.Substring (offset' text.Length - offset));  					int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  					int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  					int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  					DocumentLine curLine;  					int lineCol = col;  					result = 0;  					for (int i = 0; i < lines.Count; i++) {  						while (data.Document.LineCount <= lineNr + i) {  							data.Insert (data.Document.TextLength' Environment.NewLine);  							result += Environment.NewLine.Length;  						}  						curLine = data.Document.GetLine (lineNr + i);  						if (lines [i].Length > 0) {  							lineCol = curLine.GetLogicalColumn (data' visCol);  							if (curLine.Length + 1 < lineCol) {  								result += lineCol - curLine.Length;  								data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  							}  							data.Insert (curLine.Offset + lineCol' lines [i]);  							result += lines [i].Length;  						}  						if (!preserveState)  							data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  					}  					if (!preserveState)  						data.ClearSelection ();  					data.FixVirtualIndentation (startLine);  					data.Caret.PreserveSelection = false;  				}  			}  			else if (pasteLine) {  				using (var undo = data.OpenUndoGroup ()) {  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					data.EnsureCaretIsNotVirtual ();  					data.Caret.PreserveSelection = true;  					result = text.Length;  					DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  					result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  					if (!preserveState)  						data.ClearSelection ();  					data.Caret.PreserveSelection = false;  					data.FixVirtualIndentation (curLine.LineNumber);  				}  			}  			else {  				result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  			}  		}  	});  	// we got MD_ATOM text - no need to request text. (otherwise buffer may get copied twice).  	return result;  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (clipboard.WaitIsTargetAvailable (CopyOperation.MD_ATOM)) {  	clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  		if (selectionData.Length > 0) {  			byte[] selBytes = selectionData.Data;  			var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  			byte[] copyData = new byte[upperBound];  			Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  			var rawTextOffset = 1 + 1 + copyData.Length;  			string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  			bool pasteBlock = (selBytes [0] & 1) == 1;  			bool pasteLine = (selBytes [0] & 2) == 2;  			if (pasteBlock) {  				using (var undo = data.OpenUndoGroup ()) {  					var version = data.Document.Version;  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					int startLine = data.Caret.Line;  					data.EnsureCaretIsNotVirtual ();  					insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  					data.Caret.PreserveSelection = true;  					var lines = new List<string> ();  					int offset = 0;  					while (true) {  						var delimiter = LineSplitter.NextDelimiter (text' offset);  						if (delimiter.IsInvalid)  							break;  						int delimiterEndOffset = delimiter.EndOffset;  						lines.Add (text.Substring (offset' delimiter.Offset - offset));  						offset = delimiterEndOffset;  					}  					if (offset < text.Length)  						lines.Add (text.Substring (offset' text.Length - offset));  					int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  					int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  					int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  					DocumentLine curLine;  					int lineCol = col;  					result = 0;  					for (int i = 0; i < lines.Count; i++) {  						while (data.Document.LineCount <= lineNr + i) {  							data.Insert (data.Document.TextLength' Environment.NewLine);  							result += Environment.NewLine.Length;  						}  						curLine = data.Document.GetLine (lineNr + i);  						if (lines [i].Length > 0) {  							lineCol = curLine.GetLogicalColumn (data' visCol);  							if (curLine.Length + 1 < lineCol) {  								result += lineCol - curLine.Length;  								data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  							}  							data.Insert (curLine.Offset + lineCol' lines [i]);  							result += lines [i].Length;  						}  						if (!preserveState)  							data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  					}  					if (!preserveState)  						data.ClearSelection ();  					data.FixVirtualIndentation (startLine);  					data.Caret.PreserveSelection = false;  				}  			}  			else if (pasteLine) {  				using (var undo = data.OpenUndoGroup ()) {  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					data.EnsureCaretIsNotVirtual ();  					data.Caret.PreserveSelection = true;  					result = text.Length;  					DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  					result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  					if (!preserveState)  						data.ClearSelection ();  					data.Caret.PreserveSelection = false;  					data.FixVirtualIndentation (curLine.LineNumber);  				}  			}  			else {  				result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  			}  		}  	});  	// we got MD_ATOM text - no need to request text. (otherwise buffer may get copied twice).  	return result;  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (clipboard.WaitIsTargetAvailable (CopyOperation.MD_ATOM)) {  	clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  		if (selectionData.Length > 0) {  			byte[] selBytes = selectionData.Data;  			var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  			byte[] copyData = new byte[upperBound];  			Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  			var rawTextOffset = 1 + 1 + copyData.Length;  			string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  			bool pasteBlock = (selBytes [0] & 1) == 1;  			bool pasteLine = (selBytes [0] & 2) == 2;  			if (pasteBlock) {  				using (var undo = data.OpenUndoGroup ()) {  					var version = data.Document.Version;  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					int startLine = data.Caret.Line;  					data.EnsureCaretIsNotVirtual ();  					insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  					data.Caret.PreserveSelection = true;  					var lines = new List<string> ();  					int offset = 0;  					while (true) {  						var delimiter = LineSplitter.NextDelimiter (text' offset);  						if (delimiter.IsInvalid)  							break;  						int delimiterEndOffset = delimiter.EndOffset;  						lines.Add (text.Substring (offset' delimiter.Offset - offset));  						offset = delimiterEndOffset;  					}  					if (offset < text.Length)  						lines.Add (text.Substring (offset' text.Length - offset));  					int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  					int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  					int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  					DocumentLine curLine;  					int lineCol = col;  					result = 0;  					for (int i = 0; i < lines.Count; i++) {  						while (data.Document.LineCount <= lineNr + i) {  							data.Insert (data.Document.TextLength' Environment.NewLine);  							result += Environment.NewLine.Length;  						}  						curLine = data.Document.GetLine (lineNr + i);  						if (lines [i].Length > 0) {  							lineCol = curLine.GetLogicalColumn (data' visCol);  							if (curLine.Length + 1 < lineCol) {  								result += lineCol - curLine.Length;  								data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  							}  							data.Insert (curLine.Offset + lineCol' lines [i]);  							result += lines [i].Length;  						}  						if (!preserveState)  							data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  					}  					if (!preserveState)  						data.ClearSelection ();  					data.FixVirtualIndentation (startLine);  					data.Caret.PreserveSelection = false;  				}  			}  			else if (pasteLine) {  				using (var undo = data.OpenUndoGroup ()) {  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					data.EnsureCaretIsNotVirtual ();  					data.Caret.PreserveSelection = true;  					result = text.Length;  					DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  					result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  					if (!preserveState)  						data.ClearSelection ();  					data.Caret.PreserveSelection = false;  					data.FixVirtualIndentation (curLine.LineNumber);  				}  			}  			else {  				result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  			}  		}  	});  	// we got MD_ATOM text - no need to request text. (otherwise buffer may get copied twice).  	return result;  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (clipboard.WaitIsTargetAvailable (CopyOperation.MD_ATOM)) {  	clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  		if (selectionData.Length > 0) {  			byte[] selBytes = selectionData.Data;  			var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  			byte[] copyData = new byte[upperBound];  			Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  			var rawTextOffset = 1 + 1 + copyData.Length;  			string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  			bool pasteBlock = (selBytes [0] & 1) == 1;  			bool pasteLine = (selBytes [0] & 2) == 2;  			if (pasteBlock) {  				using (var undo = data.OpenUndoGroup ()) {  					var version = data.Document.Version;  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					int startLine = data.Caret.Line;  					data.EnsureCaretIsNotVirtual ();  					insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  					data.Caret.PreserveSelection = true;  					var lines = new List<string> ();  					int offset = 0;  					while (true) {  						var delimiter = LineSplitter.NextDelimiter (text' offset);  						if (delimiter.IsInvalid)  							break;  						int delimiterEndOffset = delimiter.EndOffset;  						lines.Add (text.Substring (offset' delimiter.Offset - offset));  						offset = delimiterEndOffset;  					}  					if (offset < text.Length)  						lines.Add (text.Substring (offset' text.Length - offset));  					int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  					int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  					int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  					DocumentLine curLine;  					int lineCol = col;  					result = 0;  					for (int i = 0; i < lines.Count; i++) {  						while (data.Document.LineCount <= lineNr + i) {  							data.Insert (data.Document.TextLength' Environment.NewLine);  							result += Environment.NewLine.Length;  						}  						curLine = data.Document.GetLine (lineNr + i);  						if (lines [i].Length > 0) {  							lineCol = curLine.GetLogicalColumn (data' visCol);  							if (curLine.Length + 1 < lineCol) {  								result += lineCol - curLine.Length;  								data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  							}  							data.Insert (curLine.Offset + lineCol' lines [i]);  							result += lines [i].Length;  						}  						if (!preserveState)  							data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  					}  					if (!preserveState)  						data.ClearSelection ();  					data.FixVirtualIndentation (startLine);  					data.Caret.PreserveSelection = false;  				}  			}  			else if (pasteLine) {  				using (var undo = data.OpenUndoGroup ()) {  					if (!preserveSelection)  						data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  					data.EnsureCaretIsNotVirtual ();  					data.Caret.PreserveSelection = true;  					result = text.Length;  					DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  					result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  					if (!preserveState)  						data.ClearSelection ();  					data.Caret.PreserveSelection = false;  					data.FixVirtualIndentation (curLine.LineNumber);  				}  			}  			else {  				result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  			}  		}  	});  	// we got MD_ATOM text - no need to request text. (otherwise buffer may get copied twice).  	return result;  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  	if (selectionData.Length > 0) {  		byte[] selBytes = selectionData.Data;  		var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  		byte[] copyData = new byte[upperBound];  		Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  		var rawTextOffset = 1 + 1 + copyData.Length;  		string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  		bool pasteBlock = (selBytes [0] & 1) == 1;  		bool pasteLine = (selBytes [0] & 2) == 2;  		if (pasteBlock) {  			using (var undo = data.OpenUndoGroup ()) {  				var version = data.Document.Version;  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				int startLine = data.Caret.Line;  				data.EnsureCaretIsNotVirtual ();  				insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  				data.Caret.PreserveSelection = true;  				var lines = new List<string> ();  				int offset = 0;  				while (true) {  					var delimiter = LineSplitter.NextDelimiter (text' offset);  					if (delimiter.IsInvalid)  						break;  					int delimiterEndOffset = delimiter.EndOffset;  					lines.Add (text.Substring (offset' delimiter.Offset - offset));  					offset = delimiterEndOffset;  				}  				if (offset < text.Length)  					lines.Add (text.Substring (offset' text.Length - offset));  				int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  				int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  				int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  				DocumentLine curLine;  				int lineCol = col;  				result = 0;  				for (int i = 0; i < lines.Count; i++) {  					while (data.Document.LineCount <= lineNr + i) {  						data.Insert (data.Document.TextLength' Environment.NewLine);  						result += Environment.NewLine.Length;  					}  					curLine = data.Document.GetLine (lineNr + i);  					if (lines [i].Length > 0) {  						lineCol = curLine.GetLogicalColumn (data' visCol);  						if (curLine.Length + 1 < lineCol) {  							result += lineCol - curLine.Length;  							data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  						}  						data.Insert (curLine.Offset + lineCol' lines [i]);  						result += lines [i].Length;  					}  					if (!preserveState)  						data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  				}  				if (!preserveState)  					data.ClearSelection ();  				data.FixVirtualIndentation (startLine);  				data.Caret.PreserveSelection = false;  			}  		}  		else if (pasteLine) {  			using (var undo = data.OpenUndoGroup ()) {  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				data.EnsureCaretIsNotVirtual ();  				data.Caret.PreserveSelection = true;  				result = text.Length;  				DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  				result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  				if (!preserveState)  					data.ClearSelection ();  				data.Caret.PreserveSelection = false;  				data.FixVirtualIndentation (curLine.LineNumber);  			}  		}  		else {  			result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  		}  	}  });  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  	if (selectionData.Length > 0) {  		byte[] selBytes = selectionData.Data;  		var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  		byte[] copyData = new byte[upperBound];  		Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  		var rawTextOffset = 1 + 1 + copyData.Length;  		string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  		bool pasteBlock = (selBytes [0] & 1) == 1;  		bool pasteLine = (selBytes [0] & 2) == 2;  		if (pasteBlock) {  			using (var undo = data.OpenUndoGroup ()) {  				var version = data.Document.Version;  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				int startLine = data.Caret.Line;  				data.EnsureCaretIsNotVirtual ();  				insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  				data.Caret.PreserveSelection = true;  				var lines = new List<string> ();  				int offset = 0;  				while (true) {  					var delimiter = LineSplitter.NextDelimiter (text' offset);  					if (delimiter.IsInvalid)  						break;  					int delimiterEndOffset = delimiter.EndOffset;  					lines.Add (text.Substring (offset' delimiter.Offset - offset));  					offset = delimiterEndOffset;  				}  				if (offset < text.Length)  					lines.Add (text.Substring (offset' text.Length - offset));  				int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  				int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  				int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  				DocumentLine curLine;  				int lineCol = col;  				result = 0;  				for (int i = 0; i < lines.Count; i++) {  					while (data.Document.LineCount <= lineNr + i) {  						data.Insert (data.Document.TextLength' Environment.NewLine);  						result += Environment.NewLine.Length;  					}  					curLine = data.Document.GetLine (lineNr + i);  					if (lines [i].Length > 0) {  						lineCol = curLine.GetLogicalColumn (data' visCol);  						if (curLine.Length + 1 < lineCol) {  							result += lineCol - curLine.Length;  							data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  						}  						data.Insert (curLine.Offset + lineCol' lines [i]);  						result += lines [i].Length;  					}  					if (!preserveState)  						data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  				}  				if (!preserveState)  					data.ClearSelection ();  				data.FixVirtualIndentation (startLine);  				data.Caret.PreserveSelection = false;  			}  		}  		else if (pasteLine) {  			using (var undo = data.OpenUndoGroup ()) {  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				data.EnsureCaretIsNotVirtual ();  				data.Caret.PreserveSelection = true;  				result = text.Length;  				DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  				result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  				if (!preserveState)  					data.ClearSelection ();  				data.Caret.PreserveSelection = false;  				data.FixVirtualIndentation (curLine.LineNumber);  			}  		}  		else {  			result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  		}  	}  });  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  	if (selectionData.Length > 0) {  		byte[] selBytes = selectionData.Data;  		var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  		byte[] copyData = new byte[upperBound];  		Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  		var rawTextOffset = 1 + 1 + copyData.Length;  		string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  		bool pasteBlock = (selBytes [0] & 1) == 1;  		bool pasteLine = (selBytes [0] & 2) == 2;  		if (pasteBlock) {  			using (var undo = data.OpenUndoGroup ()) {  				var version = data.Document.Version;  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				int startLine = data.Caret.Line;  				data.EnsureCaretIsNotVirtual ();  				insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  				data.Caret.PreserveSelection = true;  				var lines = new List<string> ();  				int offset = 0;  				while (true) {  					var delimiter = LineSplitter.NextDelimiter (text' offset);  					if (delimiter.IsInvalid)  						break;  					int delimiterEndOffset = delimiter.EndOffset;  					lines.Add (text.Substring (offset' delimiter.Offset - offset));  					offset = delimiterEndOffset;  				}  				if (offset < text.Length)  					lines.Add (text.Substring (offset' text.Length - offset));  				int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  				int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  				int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  				DocumentLine curLine;  				int lineCol = col;  				result = 0;  				for (int i = 0; i < lines.Count; i++) {  					while (data.Document.LineCount <= lineNr + i) {  						data.Insert (data.Document.TextLength' Environment.NewLine);  						result += Environment.NewLine.Length;  					}  					curLine = data.Document.GetLine (lineNr + i);  					if (lines [i].Length > 0) {  						lineCol = curLine.GetLogicalColumn (data' visCol);  						if (curLine.Length + 1 < lineCol) {  							result += lineCol - curLine.Length;  							data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  						}  						data.Insert (curLine.Offset + lineCol' lines [i]);  						result += lines [i].Length;  					}  					if (!preserveState)  						data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  				}  				if (!preserveState)  					data.ClearSelection ();  				data.FixVirtualIndentation (startLine);  				data.Caret.PreserveSelection = false;  			}  		}  		else if (pasteLine) {  			using (var undo = data.OpenUndoGroup ()) {  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				data.EnsureCaretIsNotVirtual ();  				data.Caret.PreserveSelection = true;  				result = text.Length;  				DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  				result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  				if (!preserveState)  					data.ClearSelection ();  				data.Caret.PreserveSelection = false;  				data.FixVirtualIndentation (curLine.LineNumber);  			}  		}  		else {  			result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  		}  	}  });  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: clipboard.RequestContents (CopyOperation.MD_ATOM' delegate (Clipboard clp' SelectionData selectionData) {  	if (selectionData.Length > 0) {  		byte[] selBytes = selectionData.Data;  		var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  		byte[] copyData = new byte[upperBound];  		Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  		var rawTextOffset = 1 + 1 + copyData.Length;  		string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  		bool pasteBlock = (selBytes [0] & 1) == 1;  		bool pasteLine = (selBytes [0] & 2) == 2;  		if (pasteBlock) {  			using (var undo = data.OpenUndoGroup ()) {  				var version = data.Document.Version;  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				int startLine = data.Caret.Line;  				data.EnsureCaretIsNotVirtual ();  				insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  				data.Caret.PreserveSelection = true;  				var lines = new List<string> ();  				int offset = 0;  				while (true) {  					var delimiter = LineSplitter.NextDelimiter (text' offset);  					if (delimiter.IsInvalid)  						break;  					int delimiterEndOffset = delimiter.EndOffset;  					lines.Add (text.Substring (offset' delimiter.Offset - offset));  					offset = delimiterEndOffset;  				}  				if (offset < text.Length)  					lines.Add (text.Substring (offset' text.Length - offset));  				int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  				int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  				int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  				DocumentLine curLine;  				int lineCol = col;  				result = 0;  				for (int i = 0; i < lines.Count; i++) {  					while (data.Document.LineCount <= lineNr + i) {  						data.Insert (data.Document.TextLength' Environment.NewLine);  						result += Environment.NewLine.Length;  					}  					curLine = data.Document.GetLine (lineNr + i);  					if (lines [i].Length > 0) {  						lineCol = curLine.GetLogicalColumn (data' visCol);  						if (curLine.Length + 1 < lineCol) {  							result += lineCol - curLine.Length;  							data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  						}  						data.Insert (curLine.Offset + lineCol' lines [i]);  						result += lines [i].Length;  					}  					if (!preserveState)  						data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  				}  				if (!preserveState)  					data.ClearSelection ();  				data.FixVirtualIndentation (startLine);  				data.Caret.PreserveSelection = false;  			}  		}  		else if (pasteLine) {  			using (var undo = data.OpenUndoGroup ()) {  				if (!preserveSelection)  					data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  				data.EnsureCaretIsNotVirtual ();  				data.Caret.PreserveSelection = true;  				result = text.Length;  				DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  				result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  				if (!preserveState)  					data.ClearSelection ();  				data.Caret.PreserveSelection = false;  				data.FixVirtualIndentation (curLine.LineNumber);  			}  		}  		else {  			result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  		}  	}  });  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (selectionData.Length > 0) {  	byte[] selBytes = selectionData.Data;  	var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  	byte[] copyData = new byte[upperBound];  	Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  	var rawTextOffset = 1 + 1 + copyData.Length;  	string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  	bool pasteBlock = (selBytes [0] & 1) == 1;  	bool pasteLine = (selBytes [0] & 2) == 2;  	if (pasteBlock) {  		using (var undo = data.OpenUndoGroup ()) {  			var version = data.Document.Version;  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			int startLine = data.Caret.Line;  			data.EnsureCaretIsNotVirtual ();  			insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  			data.Caret.PreserveSelection = true;  			var lines = new List<string> ();  			int offset = 0;  			while (true) {  				var delimiter = LineSplitter.NextDelimiter (text' offset);  				if (delimiter.IsInvalid)  					break;  				int delimiterEndOffset = delimiter.EndOffset;  				lines.Add (text.Substring (offset' delimiter.Offset - offset));  				offset = delimiterEndOffset;  			}  			if (offset < text.Length)  				lines.Add (text.Substring (offset' text.Length - offset));  			int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  			int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  			int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  			DocumentLine curLine;  			int lineCol = col;  			result = 0;  			for (int i = 0; i < lines.Count; i++) {  				while (data.Document.LineCount <= lineNr + i) {  					data.Insert (data.Document.TextLength' Environment.NewLine);  					result += Environment.NewLine.Length;  				}  				curLine = data.Document.GetLine (lineNr + i);  				if (lines [i].Length > 0) {  					lineCol = curLine.GetLogicalColumn (data' visCol);  					if (curLine.Length + 1 < lineCol) {  						result += lineCol - curLine.Length;  						data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  					}  					data.Insert (curLine.Offset + lineCol' lines [i]);  					result += lines [i].Length;  				}  				if (!preserveState)  					data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  			}  			if (!preserveState)  				data.ClearSelection ();  			data.FixVirtualIndentation (startLine);  			data.Caret.PreserveSelection = false;  		}  	}  	else if (pasteLine) {  		using (var undo = data.OpenUndoGroup ()) {  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			data.EnsureCaretIsNotVirtual ();  			data.Caret.PreserveSelection = true;  			result = text.Length;  			DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  			result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  			if (!preserveState)  				data.ClearSelection ();  			data.Caret.PreserveSelection = false;  			data.FixVirtualIndentation (curLine.LineNumber);  		}  	}  	else {  		result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  	}  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (selectionData.Length > 0) {  	byte[] selBytes = selectionData.Data;  	var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  	byte[] copyData = new byte[upperBound];  	Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  	var rawTextOffset = 1 + 1 + copyData.Length;  	string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  	bool pasteBlock = (selBytes [0] & 1) == 1;  	bool pasteLine = (selBytes [0] & 2) == 2;  	if (pasteBlock) {  		using (var undo = data.OpenUndoGroup ()) {  			var version = data.Document.Version;  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			int startLine = data.Caret.Line;  			data.EnsureCaretIsNotVirtual ();  			insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  			data.Caret.PreserveSelection = true;  			var lines = new List<string> ();  			int offset = 0;  			while (true) {  				var delimiter = LineSplitter.NextDelimiter (text' offset);  				if (delimiter.IsInvalid)  					break;  				int delimiterEndOffset = delimiter.EndOffset;  				lines.Add (text.Substring (offset' delimiter.Offset - offset));  				offset = delimiterEndOffset;  			}  			if (offset < text.Length)  				lines.Add (text.Substring (offset' text.Length - offset));  			int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  			int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  			int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  			DocumentLine curLine;  			int lineCol = col;  			result = 0;  			for (int i = 0; i < lines.Count; i++) {  				while (data.Document.LineCount <= lineNr + i) {  					data.Insert (data.Document.TextLength' Environment.NewLine);  					result += Environment.NewLine.Length;  				}  				curLine = data.Document.GetLine (lineNr + i);  				if (lines [i].Length > 0) {  					lineCol = curLine.GetLogicalColumn (data' visCol);  					if (curLine.Length + 1 < lineCol) {  						result += lineCol - curLine.Length;  						data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  					}  					data.Insert (curLine.Offset + lineCol' lines [i]);  					result += lines [i].Length;  				}  				if (!preserveState)  					data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  			}  			if (!preserveState)  				data.ClearSelection ();  			data.FixVirtualIndentation (startLine);  			data.Caret.PreserveSelection = false;  		}  	}  	else if (pasteLine) {  		using (var undo = data.OpenUndoGroup ()) {  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			data.EnsureCaretIsNotVirtual ();  			data.Caret.PreserveSelection = true;  			result = text.Length;  			DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  			result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  			if (!preserveState)  				data.ClearSelection ();  			data.Caret.PreserveSelection = false;  			data.FixVirtualIndentation (curLine.LineNumber);  		}  	}  	else {  		result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  	}  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (selectionData.Length > 0) {  	byte[] selBytes = selectionData.Data;  	var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  	byte[] copyData = new byte[upperBound];  	Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  	var rawTextOffset = 1 + 1 + copyData.Length;  	string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  	bool pasteBlock = (selBytes [0] & 1) == 1;  	bool pasteLine = (selBytes [0] & 2) == 2;  	if (pasteBlock) {  		using (var undo = data.OpenUndoGroup ()) {  			var version = data.Document.Version;  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			int startLine = data.Caret.Line;  			data.EnsureCaretIsNotVirtual ();  			insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  			data.Caret.PreserveSelection = true;  			var lines = new List<string> ();  			int offset = 0;  			while (true) {  				var delimiter = LineSplitter.NextDelimiter (text' offset);  				if (delimiter.IsInvalid)  					break;  				int delimiterEndOffset = delimiter.EndOffset;  				lines.Add (text.Substring (offset' delimiter.Offset - offset));  				offset = delimiterEndOffset;  			}  			if (offset < text.Length)  				lines.Add (text.Substring (offset' text.Length - offset));  			int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  			int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  			int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  			DocumentLine curLine;  			int lineCol = col;  			result = 0;  			for (int i = 0; i < lines.Count; i++) {  				while (data.Document.LineCount <= lineNr + i) {  					data.Insert (data.Document.TextLength' Environment.NewLine);  					result += Environment.NewLine.Length;  				}  				curLine = data.Document.GetLine (lineNr + i);  				if (lines [i].Length > 0) {  					lineCol = curLine.GetLogicalColumn (data' visCol);  					if (curLine.Length + 1 < lineCol) {  						result += lineCol - curLine.Length;  						data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  					}  					data.Insert (curLine.Offset + lineCol' lines [i]);  					result += lines [i].Length;  				}  				if (!preserveState)  					data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  			}  			if (!preserveState)  				data.ClearSelection ();  			data.FixVirtualIndentation (startLine);  			data.Caret.PreserveSelection = false;  		}  	}  	else if (pasteLine) {  		using (var undo = data.OpenUndoGroup ()) {  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			data.EnsureCaretIsNotVirtual ();  			data.Caret.PreserveSelection = true;  			result = text.Length;  			DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  			result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  			if (!preserveState)  				data.ClearSelection ();  			data.Caret.PreserveSelection = false;  			data.FixVirtualIndentation (curLine.LineNumber);  		}  	}  	else {  		result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  	}  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: if (selectionData.Length > 0) {  	byte[] selBytes = selectionData.Data;  	var upperBound = System.Math.Max (0' System.Math.Min (selBytes [1]' selBytes.Length - 2));  	byte[] copyData = new byte[upperBound];  	Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  	var rawTextOffset = 1 + 1 + copyData.Length;  	string text = Encoding.UTF8.GetString (selBytes' rawTextOffset' selBytes.Length - rawTextOffset);  	bool pasteBlock = (selBytes [0] & 1) == 1;  	bool pasteLine = (selBytes [0] & 2) == 2;  	if (pasteBlock) {  		using (var undo = data.OpenUndoGroup ()) {  			var version = data.Document.Version;  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			int startLine = data.Caret.Line;  			data.EnsureCaretIsNotVirtual ();  			insertionOffset = version.MoveOffsetTo (data.Document.Version' insertionOffset);  			data.Caret.PreserveSelection = true;  			var lines = new List<string> ();  			int offset = 0;  			while (true) {  				var delimiter = LineSplitter.NextDelimiter (text' offset);  				if (delimiter.IsInvalid)  					break;  				int delimiterEndOffset = delimiter.EndOffset;  				lines.Add (text.Substring (offset' delimiter.Offset - offset));  				offset = delimiterEndOffset;  			}  			if (offset < text.Length)  				lines.Add (text.Substring (offset' text.Length - offset));  			int lineNr = data.Document.OffsetToLineNumber (insertionOffset);  			int col = insertionOffset - data.Document.GetLine (lineNr).Offset;  			int visCol = data.Document.GetLine (lineNr).GetVisualColumn (data' col);  			DocumentLine curLine;  			int lineCol = col;  			result = 0;  			for (int i = 0; i < lines.Count; i++) {  				while (data.Document.LineCount <= lineNr + i) {  					data.Insert (data.Document.TextLength' Environment.NewLine);  					result += Environment.NewLine.Length;  				}  				curLine = data.Document.GetLine (lineNr + i);  				if (lines [i].Length > 0) {  					lineCol = curLine.GetLogicalColumn (data' visCol);  					if (curLine.Length + 1 < lineCol) {  						result += lineCol - curLine.Length;  						data.Insert (curLine.Offset + curLine.Length' new string (' '' lineCol - curLine.Length));  					}  					data.Insert (curLine.Offset + lineCol' lines [i]);  					result += lines [i].Length;  				}  				if (!preserveState)  					data.Caret.Offset = curLine.Offset + lineCol + lines [i].Length;  			}  			if (!preserveState)  				data.ClearSelection ();  			data.FixVirtualIndentation (startLine);  			data.Caret.PreserveSelection = false;  		}  	}  	else if (pasteLine) {  		using (var undo = data.OpenUndoGroup ()) {  			if (!preserveSelection)  				data.DeleteSelectedText (!data.IsSomethingSelected || data.MainSelection.SelectionMode != SelectionMode.Block);  			data.EnsureCaretIsNotVirtual ();  			data.Caret.PreserveSelection = true;  			result = text.Length;  			DocumentLine curLine = data.Document.GetLine (data.Caret.Line);  			result = PastePlainText (data' curLine.Offset' text + data.EolMarker' preserveSelection' copyData);  			if (!preserveState)  				data.ClearSelection ();  			data.Caret.PreserveSelection = false;  			data.FixVirtualIndentation (curLine.LineNumber);  		}  	}  	else {  		result = PastePlainText (data' insertionOffset' text' preserveSelection' copyData);  	}  }  
Magic Number,Mono.TextEditor,ClipboardActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\ClipboardActions.cs,PasteFrom,The following statement contains a magic number: Array.Copy (selBytes' 2' copyData' 0' copyData.Length);  
Magic Number,Mono.TextEditor,CodeSegmentEditorWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentEditorWindow.cs,CodeSegmentEditorWindow,The following statement contains a magic number: options.Zoom = 0.8;  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,CalculateSize,The following statement contains a magic number: this.SetSizeRequest (System.Math.Max (1' System.Math.Min (w + 3' geometry.Width * 2 / 5))' System.Math.Max (1' System.Math.Min (h + 3' geometry.Height * 2 / 5)));  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: ev.Window.DrawRectangle (textBgGC' false' 1' 1' this.Allocation.Width - 3' this.Allocation.Height - 3);  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: ev.Window.DrawRectangle (textBgGC' false' 1' 1' this.Allocation.Width - 3' this.Allocation.Height - 3);  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: if (!HideCodeSegmentPreviewInformString) {  	informLayout.SetText (CodeSegmentPreviewInformString);  	int w' h;  	informLayout.GetPixelSize (out w' out h);  	PreviewInformStringHeight = h;  	ev.Window.DrawRectangle (foldBgGC' true' Allocation.Width - w - 3' Allocation.Height - h' w + 2' h - 1);  	ev.Window.DrawLayout (foldGC' Allocation.Width - w - 3' Allocation.Height - h' informLayout);  }  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: if (!HideCodeSegmentPreviewInformString) {  	informLayout.SetText (CodeSegmentPreviewInformString);  	int w' h;  	informLayout.GetPixelSize (out w' out h);  	PreviewInformStringHeight = h;  	ev.Window.DrawRectangle (foldBgGC' true' Allocation.Width - w - 3' Allocation.Height - h' w + 2' h - 1);  	ev.Window.DrawLayout (foldGC' Allocation.Width - w - 3' Allocation.Height - h' informLayout);  }  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: if (!HideCodeSegmentPreviewInformString) {  	informLayout.SetText (CodeSegmentPreviewInformString);  	int w' h;  	informLayout.GetPixelSize (out w' out h);  	PreviewInformStringHeight = h;  	ev.Window.DrawRectangle (foldBgGC' true' Allocation.Width - w - 3' Allocation.Height - h' w + 2' h - 1);  	ev.Window.DrawLayout (foldGC' Allocation.Width - w - 3' Allocation.Height - h' informLayout);  }  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: ev.Window.DrawRectangle (foldBgGC' true' Allocation.Width - w - 3' Allocation.Height - h' w + 2' h - 1);  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: ev.Window.DrawRectangle (foldBgGC' true' Allocation.Width - w - 3' Allocation.Height - h' w + 2' h - 1);  
Magic Number,Mono.TextEditor,CodeSegmentPreviewWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\CodeSegmentPreviewWindow.cs,OnExposeEvent,The following statement contains a magic number: ev.Window.DrawLayout (foldGC' Allocation.Width - w - 3' Allocation.Height - h' informLayout);  
Magic Number,Mono.TextEditor,DashedLineMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\DashedLineMargin.cs,Draw,The following statement contains a magic number: cr.MoveTo (x + 0.5' y);  
Magic Number,Mono.TextEditor,DashedLineMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\DashedLineMargin.cs,Draw,The following statement contains a magic number: cr.LineTo (x + 0.5' y + lineHeight);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,FoldingScreenbackgroundRenderer,The following statement contains a magic number: timeout = GLib.Timeout.Add (30' delegate {  	editor.QueueDraw ();  	var cont = (DateTime.Now - startTime).TotalMilliseconds < animationLength;  	if (!cont)  		timeout = 0;  	return cont;  });  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  }  else {  	hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  }  else {  	hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  }  else {  	hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  }  else {  	hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  }  else {  	hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: hslColor.L = hslColor.L * 0.81 + hslColor.L * 0.25 * (colorCount - colorPosition) / colorCount;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,GetColor,The following statement contains a magic number: hslColor.L = hslColor.L * 0.86 + hslColor.L * 0.1 * colorPosition / colorCount;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = foldSegments.Count - 1; i >= 0; i--) {  	var segment = foldSegments [i];  	if (segment.IsInvalid)  		continue;  	var segmentStartLine = segment.StartLine;  	var segmentEndLine = segment.EndLine;  	int curWidth = 0;  	var endLine = segmentEndLine.NextLine;  	var y = editor.LineToY (segmentStartLine.LineNumber);  	if (y < editor.VAdjustment.Value) {  		segmentStartLine = editor.GetLine (editor.YToLine (editor.VAdjustment.Value));  		y = editor.LineToY (segmentStartLine.LineNumber);  	}  	for (var curLine = segmentStartLine; curLine != endLine && y < editor.VAdjustment.Value + editor.Allocation.Height; curLine = curLine.NextLine) {  		var curLayout = textViewMargin.CreateLinePartLayout (mode' curLine' curLine.Offset' curLine.Length' -1' -1);  		var width = (int)(curLayout.Width);  		curWidth = System.Math.Max (curWidth' width);  		y += editor.GetLineHeight (curLine);  	}  	double xPos = textViewMargin.XOffset;  	double rectangleWidth = 0' rectangleHeight = 0;  	lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentStartLine' segmentStartLine.Offset' segmentStartLine.Length' -1' -1);  	var rectangleStart = lineLayout.Layout.IndexToPos (GetFirstNonWsIdx (lineLayout.Layout.Text));  	xPos = System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleStart.X / Pango.Scale.PangoScale) - xPadding);  	lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentEndLine' segmentEndLine.Offset' segmentEndLine.Length' -1' -1);  	var rectangleEnd = lineLayout.Layout.IndexToPos (GetFirstNonWsIdx (lineLayout.Layout.Text));  	xPos = System.Math.Min (xPos' System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleEnd.X / Pango.Scale.PangoScale) - xPadding));  	rectangleWidth = textViewMargin.XOffset + textViewMargin.TextStartPosition + curWidth - xPos + xPadding * 2;  	if (i < foldSegments.Count - 1) {  		rectangleWidth = System.Math.Max ((rectangles [i + 1].X + rectangles [i + 1].Width + rightMarginPadding) - xPos' rectangleWidth);  	}  	y = editor.LineToY (segment.StartLine.LineNumber);  	var yEnd = editor.LineToY (segment.EndLine.LineNumber + 1);  	if (yEnd == 0)  		yEnd = editor.VAdjustment.Upper;  	rectangleHeight = yEnd - y;  	rectangles [i] = new Cairo.Rectangle (xPos' y - yPadding' rectangleWidth' rectangleHeight + yPadding * 2);  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = foldSegments.Count - 1; i >= 0; i--) {  	var segment = foldSegments [i];  	if (segment.IsInvalid)  		continue;  	var segmentStartLine = segment.StartLine;  	var segmentEndLine = segment.EndLine;  	int curWidth = 0;  	var endLine = segmentEndLine.NextLine;  	var y = editor.LineToY (segmentStartLine.LineNumber);  	if (y < editor.VAdjustment.Value) {  		segmentStartLine = editor.GetLine (editor.YToLine (editor.VAdjustment.Value));  		y = editor.LineToY (segmentStartLine.LineNumber);  	}  	for (var curLine = segmentStartLine; curLine != endLine && y < editor.VAdjustment.Value + editor.Allocation.Height; curLine = curLine.NextLine) {  		var curLayout = textViewMargin.CreateLinePartLayout (mode' curLine' curLine.Offset' curLine.Length' -1' -1);  		var width = (int)(curLayout.Width);  		curWidth = System.Math.Max (curWidth' width);  		y += editor.GetLineHeight (curLine);  	}  	double xPos = textViewMargin.XOffset;  	double rectangleWidth = 0' rectangleHeight = 0;  	lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentStartLine' segmentStartLine.Offset' segmentStartLine.Length' -1' -1);  	var rectangleStart = lineLayout.Layout.IndexToPos (GetFirstNonWsIdx (lineLayout.Layout.Text));  	xPos = System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleStart.X / Pango.Scale.PangoScale) - xPadding);  	lineLayout = textViewMargin.CreateLinePartLayout (mode' segmentEndLine' segmentEndLine.Offset' segmentEndLine.Length' -1' -1);  	var rectangleEnd = lineLayout.Layout.IndexToPos (GetFirstNonWsIdx (lineLayout.Layout.Text));  	xPos = System.Math.Min (xPos' System.Math.Max (textViewMargin.XOffset' (textViewMargin.XOffset + textViewMargin.TextStartPosition + rectangleEnd.X / Pango.Scale.PangoScale) - xPadding));  	rectangleWidth = textViewMargin.XOffset + textViewMargin.TextStartPosition + curWidth - xPos + xPadding * 2;  	if (i < foldSegments.Count - 1) {  		rectangleWidth = System.Math.Max ((rectangles [i + 1].X + rectangles [i + 1].Width + rightMarginPadding) - xPos' rectangleWidth);  	}  	y = editor.LineToY (segment.StartLine.LineNumber);  	var yEnd = editor.LineToY (segment.EndLine.LineNumber + 1);  	if (yEnd == 0)  		yEnd = editor.VAdjustment.Upper;  	rectangleHeight = yEnd - y;  	rectangles [i] = new Cairo.Rectangle (xPos' y - yPadding' rectangleWidth' rectangleHeight + yPadding * 2);  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: rectangleWidth = textViewMargin.XOffset + textViewMargin.TextStartPosition + curWidth - xPos + xPadding * 2;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: rectangles [i] = new Cairo.Rectangle (xPos' y - yPadding' rectangleWidth' rectangleHeight + yPadding * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < foldSegments.Count; i++) {  	var rect = rectangles [i];  	if (i == foldSegments.Count - 1) {  		/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  		var age = (DateTime.Now - startTime).TotalMilliseconds;  		var alpha = 0.1;  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  			alpha = 0.1 + (1.0 - animationState) / 5;  		}  		var bg = editor.ColorStyle.PlainText.Foreground;  		cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.Fill ();  		if (age < animationLength) {  			var animationState = age / (double)animationLength;  			curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  			DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  			cr.SetSourceColor (GetColor (i' brightness' colorCount));  			cr.Fill ();  			continue;  		}  	}  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (i == foldSegments.Count - 1) {  	/*					var radius = (int)(editor.Options.Zoom * 2); 					int w = 2 * radius; 					using (var shadow = new Blur ( 						System.Math.Min ((int)rect.Width + w * 2' editor.Allocation.Width)' 						System.Math.Min ((int)rect.Height + w * 2' editor.Allocation.Height)'  						radius)) { 						using (var gctx = shadow.GetContext ()) { 							gctx.Color = new Cairo.Color (0' 0' 0' 0); 							gctx.Fill ();  							var a = 0; 							var b = 0; 							DrawRoundRectangle (gctx' true' true' w - a' w - b' editor.LineHeight / 4' rect.Width + a * 2' rect.Height + a * 2); 							var bg = editor.ColorStyle.Default.CairoColor; 							gctx.Color = new Cairo.Color (bg.R' bg.G' bg.B' 0.6); 							gctx.Fill (); 						}  						cr.Save (); 						cr.Translate (rect.X - w - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value - w); 						shadow.Draw (cr); 						cr.Restore (); 					}*/var curPadSize = 1;  	var age = (DateTime.Now - startTime).TotalMilliseconds;  	var alpha = 0.1;  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  		alpha = 0.1 + (1.0 - animationState) / 5;  	}  	var bg = editor.ColorStyle.PlainText.Foreground;  	cr.SetSourceRGBA (bg.R' bg.G' bg.B' alpha);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.Fill ();  	if (age < animationLength) {  		var animationState = age / (double)animationLength;  		curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  		DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  		cr.SetSourceColor (GetColor (i' brightness' colorCount));  		cr.Fill ();  		continue;  	}  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  	alpha = 0.1 + (1.0 - animationState) / 5;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  	alpha = 0.1 + (1.0 - animationState) / 5;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  	alpha = 0.1 + (1.0 - animationState) / 5;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  	alpha = 0.1 + (1.0 - animationState) / 5;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: curPadSize = (int)(3 + System.Math.Sin (System.Math.PI * animationState) * 3);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: alpha = 0.1 + (1.0 - animationState) / 5;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: alpha = 0.1 + (1.0 - animationState) / 5;  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  	continue;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  	continue;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  	continue;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  	continue;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: if (age < animationLength) {  	var animationState = age / (double)animationLength;  	curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  	DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  	cr.SetSourceColor (GetColor (i' brightness' colorCount));  	cr.Fill ();  	continue;  }  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: curPadSize = (int)(2 + System.Math.Sin (System.Math.PI * animationState) * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value - curPadSize' rect.Y - editor.VAdjustment.Value - curPadSize' editor.LineHeight / 2' rect.Width + curPadSize * 2' rect.Height + curPadSize * 2);  
Magic Number,Mono.TextEditor,FoldingScreenbackgroundRenderer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldingScreenbackgroundRenderer.cs,Draw,The following statement contains a magic number: DrawRoundRectangle (cr' true' true' rect.X - editor.HAdjustment.Value' rect.Y - editor.VAdjustment.Value' editor.LineHeight / 2' rect.Width' rect.Height);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: foreach (int i in new[] {  	24'  	22'  	20'  	18'  	16'  	14  }) {  	if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  		GtkMinorVersion = i;  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: if (Gtk.Global.CheckVersion (2' (uint)i' 0) == null) {  	GtkMinorVersion = i;  	break;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: for (int i = 1; i < 20; i++) {  	if (Gtk.Global.CheckVersion (2' (uint)GtkMinorVersion' (uint)i) == null) {  		GtkMicroVersion = i;  	}  	else {  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: for (int i = 1; i < 20; i++) {  	if (Gtk.Global.CheckVersion (2' (uint)GtkMinorVersion' (uint)i) == null) {  		GtkMicroVersion = i;  	}  	else {  		break;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GtkWorkarounds,The following statement contains a magic number: if (Gtk.Global.CheckVersion (2' (uint)GtkMinorVersion' (uint)i) == null) {  	GtkMicroVersion = i;  }  else {  	break;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MacGetUsableMonitorGeometry,The following statement contains a magic number: if (IntPtr.Size == 8) {  	objc_msgSend_CGRect64 (out visible' scrn' sel_visibleFrame);  	objc_msgSend_CGRect64 (out frame' scrn' sel_frame);  }  else {  	CGRect32 visible32' frame32;  	objc_msgSend_CGRect32 (out visible32' scrn' sel_visibleFrame);  	objc_msgSend_CGRect32 (out frame32' scrn' sel_frame);  	visible = new CGRect64 (visible32);  	frame = new CGRect64 (frame32);  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MacRequestAttention,The following statement contains a magic number: if (IntPtr.Size == 8) {  	objc_msgSend_NSInt64_NSInt64 (sharedApp' sel_requestUserAttention' kind);  }  else {  	objc_msgSend_NSInt32_NSInt32 (sharedApp' sel_requestUserAttention' kind);  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,IsContextMenuButton,The following statement contains a magic number: if (evt.Button == 3 && (evt.State & (Gdk.ModifierType.Button1Mask | Gdk.ModifierType.Button2Mask)) == 0)  	return true;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (Platform.IsMac) {  	Gdk.ModifierType mtype = Gdk.ModifierType.None;  	ulong mod;  	if (IntPtr.Size == 8) {  		mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  	}  	else {  		mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  	}  	if ((mod & (1 << 17)) != 0)  		mtype |= Gdk.ModifierType.ShiftMask;  	if ((mod & (1 << 18)) != 0)  		mtype |= Gdk.ModifierType.ControlMask;  	if ((mod & (1 << 19)) != 0)  		mtype |= Gdk.ModifierType.Mod1Mask;  	// Alt key  	if ((mod & (1 << 20)) != 0)  		mtype |= Gdk.ModifierType.Mod2Mask;  	// Command key  	return mtype;  }  else {  	Gdk.ModifierType mtype;  	Gtk.Global.GetCurrentEventState (out mtype);  	return mtype;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (Platform.IsMac) {  	Gdk.ModifierType mtype = Gdk.ModifierType.None;  	ulong mod;  	if (IntPtr.Size == 8) {  		mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  	}  	else {  		mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  	}  	if ((mod & (1 << 17)) != 0)  		mtype |= Gdk.ModifierType.ShiftMask;  	if ((mod & (1 << 18)) != 0)  		mtype |= Gdk.ModifierType.ControlMask;  	if ((mod & (1 << 19)) != 0)  		mtype |= Gdk.ModifierType.Mod1Mask;  	// Alt key  	if ((mod & (1 << 20)) != 0)  		mtype |= Gdk.ModifierType.Mod2Mask;  	// Command key  	return mtype;  }  else {  	Gdk.ModifierType mtype;  	Gtk.Global.GetCurrentEventState (out mtype);  	return mtype;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (Platform.IsMac) {  	Gdk.ModifierType mtype = Gdk.ModifierType.None;  	ulong mod;  	if (IntPtr.Size == 8) {  		mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  	}  	else {  		mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  	}  	if ((mod & (1 << 17)) != 0)  		mtype |= Gdk.ModifierType.ShiftMask;  	if ((mod & (1 << 18)) != 0)  		mtype |= Gdk.ModifierType.ControlMask;  	if ((mod & (1 << 19)) != 0)  		mtype |= Gdk.ModifierType.Mod1Mask;  	// Alt key  	if ((mod & (1 << 20)) != 0)  		mtype |= Gdk.ModifierType.Mod2Mask;  	// Command key  	return mtype;  }  else {  	Gdk.ModifierType mtype;  	Gtk.Global.GetCurrentEventState (out mtype);  	return mtype;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (Platform.IsMac) {  	Gdk.ModifierType mtype = Gdk.ModifierType.None;  	ulong mod;  	if (IntPtr.Size == 8) {  		mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  	}  	else {  		mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  	}  	if ((mod & (1 << 17)) != 0)  		mtype |= Gdk.ModifierType.ShiftMask;  	if ((mod & (1 << 18)) != 0)  		mtype |= Gdk.ModifierType.ControlMask;  	if ((mod & (1 << 19)) != 0)  		mtype |= Gdk.ModifierType.Mod1Mask;  	// Alt key  	if ((mod & (1 << 20)) != 0)  		mtype |= Gdk.ModifierType.Mod2Mask;  	// Command key  	return mtype;  }  else {  	Gdk.ModifierType mtype;  	Gtk.Global.GetCurrentEventState (out mtype);  	return mtype;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (Platform.IsMac) {  	Gdk.ModifierType mtype = Gdk.ModifierType.None;  	ulong mod;  	if (IntPtr.Size == 8) {  		mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  	}  	else {  		mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  	}  	if ((mod & (1 << 17)) != 0)  		mtype |= Gdk.ModifierType.ShiftMask;  	if ((mod & (1 << 18)) != 0)  		mtype |= Gdk.ModifierType.ControlMask;  	if ((mod & (1 << 19)) != 0)  		mtype |= Gdk.ModifierType.Mod1Mask;  	// Alt key  	if ((mod & (1 << 20)) != 0)  		mtype |= Gdk.ModifierType.Mod2Mask;  	// Command key  	return mtype;  }  else {  	Gdk.ModifierType mtype;  	Gtk.Global.GetCurrentEventState (out mtype);  	return mtype;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if (IntPtr.Size == 8) {  	mod = objc_msgSend_NSUInt64 (cls_NSEvent' sel_modifierFlags);  }  else {  	mod = objc_msgSend_NSUInt32 (cls_NSEvent' sel_modifierFlags);  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if ((mod & (1 << 17)) != 0)  	mtype |= Gdk.ModifierType.ShiftMask;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if ((mod & (1 << 18)) != 0)  	mtype |= Gdk.ModifierType.ControlMask;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if ((mod & (1 << 19)) != 0)  	mtype |= Gdk.ModifierType.Mod1Mask;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetCurrentKeyModifiers,The following statement contains a magic number: if ((mod & (1 << 20)) != 0)  	mtype |= Gdk.ModifierType.Mod2Mask;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (!GetEventScrollDeltas (evt' out deltaX' out deltaY)) {  	var direction = evt.Direction;  	deltaX = deltaY = 0;  	if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  		deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  		deltaX = 0.0;  		if (direction == Gdk.ScrollDirection.Up)  			deltaY = -deltaY;  	}  	else if (pageSizeX != 0) {  		deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  		deltaY = 0.0;  		if (direction == Gdk.ScrollDirection.Left)  			deltaX = -deltaX;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (!GetEventScrollDeltas (evt' out deltaX' out deltaY)) {  	var direction = evt.Direction;  	deltaX = deltaY = 0;  	if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  		deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  		deltaX = 0.0;  		if (direction == Gdk.ScrollDirection.Up)  			deltaY = -deltaY;  	}  	else if (pageSizeX != 0) {  		deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  		deltaY = 0.0;  		if (direction == Gdk.ScrollDirection.Left)  			deltaX = -deltaX;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (!GetEventScrollDeltas (evt' out deltaX' out deltaY)) {  	var direction = evt.Direction;  	deltaX = deltaY = 0;  	if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  		deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  		deltaX = 0.0;  		if (direction == Gdk.ScrollDirection.Up)  			deltaY = -deltaY;  	}  	else if (pageSizeX != 0) {  		deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  		deltaY = 0.0;  		if (direction == Gdk.ScrollDirection.Left)  			deltaX = -deltaX;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (!GetEventScrollDeltas (evt' out deltaX' out deltaY)) {  	var direction = evt.Direction;  	deltaX = deltaY = 0;  	if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  		deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  		deltaX = 0.0;  		if (direction == Gdk.ScrollDirection.Up)  			deltaY = -deltaY;  	}  	else if (pageSizeX != 0) {  		deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  		deltaY = 0.0;  		if (direction == Gdk.ScrollDirection.Left)  			deltaX = -deltaX;  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  	deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  	deltaX = 0.0;  	if (direction == Gdk.ScrollDirection.Up)  		deltaY = -deltaY;  }  else if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  	deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  	deltaX = 0.0;  	if (direction == Gdk.ScrollDirection.Up)  		deltaY = -deltaY;  }  else if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  	deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  	deltaX = 0.0;  	if (direction == Gdk.ScrollDirection.Up)  		deltaY = -deltaY;  }  else if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeY != 0 && (direction == Gdk.ScrollDirection.Down || direction == Gdk.ScrollDirection.Up)) {  	deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  	deltaX = 0.0;  	if (direction == Gdk.ScrollDirection.Up)  		deltaY = -deltaY;  }  else if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: deltaY = System.Math.Pow (pageSizeY' 2.0 / 3.0);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: if (pageSizeX != 0) {  	deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  	deltaY = 0.0;  	if (direction == Gdk.ScrollDirection.Left)  		deltaX = -deltaX;  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,GetPageScrollPixelDeltas,The following statement contains a magic number: deltaX = System.Math.Pow (pageSizeX' 2.0 / 3.0);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The following statement contains a magic number: unchecked {  	id = (((ulong)(uint)evt.State) | (((ulong)evt.HardwareKeycode) << 32) | (((ulong)evt.Group) << 48));  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The following statement contains a magic number: unchecked {  	id = (((ulong)(uint)evt.State) | (((ulong)evt.HardwareKeycode) << 32) | (((ulong)evt.Group) << 48));  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The following statement contains a magic number: id = (((ulong)(uint)evt.State) | (((ulong)evt.HardwareKeycode) << 32) | (((ulong)evt.Group) << 48));  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The following statement contains a magic number: id = (((ulong)(uint)evt.State) | (((ulong)evt.HardwareKeycode) << 32) | (((ulong)evt.Group) << 48));  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MapKeys,The following statement contains a magic number: if (GtkMinorVersion >= 20) {  	gdk_keymap_add_virtual_modifiers (keymap.Handle' ref modifier);  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetImCursorLocation,The following statement contains a magic number: if (Platform.IsWindows && System.Environment.OSVersion.Version.Major >= 6) {  	bool enabled;  	if (DwmIsCompositionEnabled (out enabled) == 0 && enabled) {  		var hwnd = gdk_win32_drawable_get_handle (clientWindow.Toplevel.Handle);  		Win32Rect rect;  		// this module gets the WINVER=6 version of GetWindowRect' which returns the correct value  		if (GetWindowRect (hwnd' out rect)) {  			int x' y;  			clientWindow.Toplevel.GetPosition (out x' out y);  			cursor.X = cursor.X - x + rect.Left;  			cursor.Y = cursor.Y - y + rect.Top - cursor.Height;  		}  	}  }  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,CreateForallCallback,The following statement contains a magic number: il.Emit (OpCodes.Ldloca_S' 2);  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,MarkupLinks,The following statement contains a magic number: if (GtkMinorVersion < 18)  	return text;  
Magic Number,Mono.TextEditor,GtkWorkarounds,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GtkWorkarounds.cs,SetLinkHandler,The following statement contains a magic number: if (GtkMinorVersion >= 18)  	new UrlHandlerClosure (urlHandler).ConnectTo (label);  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: using (var layout = editor.LayoutCache.RequestLayout ()) {  	layout.FontDescription = gutterFont;  	layout.SetText (LineCountMax.ToString ());  	layout.Alignment = Pango.Alignment.Left;  	layout.Width = -1;  	int height;  	layout.GetPixelSize (out this.width' out height);  	this.width += 4;  	if (!editor.Options.ShowFoldMargin)  		this.width += 2;  	using (var metrics = editor.PangoContext.GetMetrics (layout.FontDescription' editor.PangoContext.Language)) {  		fontHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  	}  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: using (var layout = editor.LayoutCache.RequestLayout ()) {  	layout.FontDescription = gutterFont;  	layout.SetText (LineCountMax.ToString ());  	layout.Alignment = Pango.Alignment.Left;  	layout.Width = -1;  	int height;  	layout.GetPixelSize (out this.width' out height);  	this.width += 4;  	if (!editor.Options.ShowFoldMargin)  		this.width += 2;  	using (var metrics = editor.PangoContext.GetMetrics (layout.FontDescription' editor.PangoContext.Language)) {  		fontHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  	}  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: using (var layout = editor.LayoutCache.RequestLayout ()) {  	layout.FontDescription = gutterFont;  	layout.SetText (LineCountMax.ToString ());  	layout.Alignment = Pango.Alignment.Left;  	layout.Width = -1;  	int height;  	layout.GetPixelSize (out this.width' out height);  	this.width += 4;  	if (!editor.Options.ShowFoldMargin)  		this.width += 2;  	using (var metrics = editor.PangoContext.GetMetrics (layout.FontDescription' editor.PangoContext.Language)) {  		fontHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  	}  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: this.width += 4;  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: if (!editor.Options.ShowFoldMargin)  	this.width += 2;  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: this.width += 2;  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: using (var metrics = editor.PangoContext.GetMetrics (layout.FontDescription' editor.PangoContext.Language)) {  	fontHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,CalculateWidth,The following statement contains a magic number: fontHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The following statement contains a magic number: if (line <= editor.Document.LineCount) {  	// Due to a mac? gtk bug I need to re-create the layout here  	// otherwise I get pango exceptions.  	using (var layout = editor.LayoutCache.RequestLayout ()) {  		layout.FontDescription = gutterFont;  		layout.Width = (int)Width;  		layout.Alignment = Pango.Alignment.Right;  		layout.SetText (line.ToString ());  		cr.Save ();  		cr.Translate (x + (int)Width + (editor.Options.ShowFoldMargin ? 0 : -2)' y);  		cr.SetSourceColor (lineNumberGC);  		cr.ShowLayout (layout);  		cr.Restore ();  	}  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The following statement contains a magic number: using (var layout = editor.LayoutCache.RequestLayout ()) {  	layout.FontDescription = gutterFont;  	layout.Width = (int)Width;  	layout.Alignment = Pango.Alignment.Right;  	layout.SetText (line.ToString ());  	cr.Save ();  	cr.Translate (x + (int)Width + (editor.Options.ShowFoldMargin ? 0 : -2)' y);  	cr.SetSourceColor (lineNumberGC);  	cr.ShowLayout (layout);  	cr.Restore ();  }  
Magic Number,Mono.TextEditor,GutterMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\GutterMargin.cs,Draw,The following statement contains a magic number: cr.Translate (x + (int)Width + (editor.Options.ShowFoldMargin ? 0 : -2)' y);  
Magic Number,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The following statement contains a magic number: if (!backgroundIsDrawn) {  	ctx.Rectangle (x' y' Width' lineHeight);  	ctx.SetSourceColor (backgroundColor);  	ctx.Fill ();  	ctx.MoveTo (x + Width - 0.5' y);  	ctx.LineTo (x + Width - 0.5' y + lineHeight);  	ctx.SetSourceColor (separatorColor);  	ctx.Stroke ();  }  
Magic Number,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The following statement contains a magic number: if (!backgroundIsDrawn) {  	ctx.Rectangle (x' y' Width' lineHeight);  	ctx.SetSourceColor (backgroundColor);  	ctx.Fill ();  	ctx.MoveTo (x + Width - 0.5' y);  	ctx.LineTo (x + Width - 0.5' y + lineHeight);  	ctx.SetSourceColor (separatorColor);  	ctx.Stroke ();  }  
Magic Number,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The following statement contains a magic number: ctx.MoveTo (x + Width - 0.5' y);  
Magic Number,Mono.TextEditor,IconMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\IconMargin.cs,Draw,The following statement contains a magic number: ctx.LineTo (x + Width - 0.5' y + lineHeight);  
Magic Number,Mono.TextEditor,GapBuffer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\GapBuffer.cs,PlaceGap,The following statement contains a magic number: if (gapLength < minLength) {  	if (minLength < maxGapLength) {  		CreateBuffer (newOffset' minLength + (maxGapLength - minLength) / 2);  	}  	else {  		CreateBuffer (newOffset' minLength + minGapLength);  	}  	return;  }  
Magic Number,Mono.TextEditor,GapBuffer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\GapBuffer.cs,PlaceGap,The following statement contains a magic number: if (minLength < maxGapLength) {  	CreateBuffer (newOffset' minLength + (maxGapLength - minLength) / 2);  }  else {  	CreateBuffer (newOffset' minLength + minGapLength);  }  
Magic Number,Mono.TextEditor,GapBuffer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\GapBuffer.cs,PlaceGap,The following statement contains a magic number: CreateBuffer (newOffset' minLength + (maxGapLength - minLength) / 2);  
Magic Number,Mono.TextEditor,LineSplitter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\LineSplitter.cs,GetTreeHeight,The following statement contains a magic number: return size == 0 ? 0 : GetTreeHeight (size / 2) + 1;  
Magic Number,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,WaitForFoldUpdateFinished,The following statement contains a magic number: if (foldSegmentTask != null) {  	foldSegmentTask.Wait (5000);  	foldSegmentTask = null;  }  
Magic Number,Mono.TextEditor,TextDocument,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\TextDocument.cs,WaitForFoldUpdateFinished,The following statement contains a magic number: foldSegmentTask.Wait (5000);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (S == 0) {  	r = g = b = L;  }  else {  	double temp2 = L <= 0.5 ? L * (1.0 + S) : L + S - (L * S);  	double temp1 = 2.0 * L - temp2;  	double[] t3 = new double[] {  		H + 1.0 / 3.0'  		H'  		H - 1.0 / 3.0  	};  	double[] clr = new double[] {  		0'  		0'  		0  	};  	for (int i = 0; i < 3; i++) {  		if (t3 [i] < 0)  			t3 [i] += 1.0;  		if (t3 [i] > 1)  			t3 [i] -= 1.0;  		if (6.0 * t3 [i] < 1.0)  			clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  		else if (2.0 * t3 [i] < 1.0)  			clr [i] = temp2;  		else if (3.0 * t3 [i] < 2.0)  			clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  		else  			clr [i] = temp1;  	}  	r = clr [0];  	g = clr [1];  	b = clr [2];  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t3 [i] < 0)  		t3 [i] += 1.0;  	if (t3 [i] > 1)  		t3 [i] -= 1.0;  	if (6.0 * t3 [i] < 1.0)  		clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  	else if (2.0 * t3 [i] < 1.0)  		clr [i] = temp2;  	else if (3.0 * t3 [i] < 2.0)  		clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  	else  		clr [i] = temp1;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (6.0 * t3 [i] < 1.0)  	clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  else if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: clr [i] = temp1 + (temp2 - temp1) * t3 [i] * 6.0;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (2.0 * t3 [i] < 1.0)  	clr [i] = temp2;  else if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: if (3.0 * t3 [i] < 2.0)  	clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  else  	clr [i] = temp1;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: clr [i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3 [i]) * 6.0);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToRgb,The following statement contains a magic number: b = clr [2];  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPixel,The following statement contains a magic number: return rv << 16 | gv << 8 | bv;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPixel,The following statement contains a magic number: return rv << 16 | gv << 8 | bv;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.L = (m + v) / 2.0;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (this.S > 0.0) {  	this.S /= (this.L <= 0.5) ? (v + m) : (2.0 - v - m);  }  else {  	return;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (this.S > 0.0) {  	this.S /= (this.L <= 0.5) ? (v + m) : (2.0 - v - m);  }  else {  	return;  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.S /= (this.L <= 0.5) ? (v + m) : (2.0 - v - m);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.S /= (this.L <= 0.5) ? (v + m) : (2.0 - v - m);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (r == v) {  	this.H = (g == m ? 5.0 + b2 : 1.0 - g2);  }  else if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (r == v) {  	this.H = (g == m ? 5.0 + b2 : 1.0 - g2);  }  else if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (r == v) {  	this.H = (g == m ? 5.0 + b2 : 1.0 - g2);  }  else if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (r == v) {  	this.H = (g == m ? 5.0 + b2 : 1.0 - g2);  }  else if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.H = (g == m ? 5.0 + b2 : 1.0 - g2);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: if (g == v) {  	this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  }  else {  	this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.H = (b == m ? 1.0 + r2 : 3.0 - b2);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.H = (r == m ? 3.0 + g2 : 5.0 - r2);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,HslColor,The following statement contains a magic number: this.H /= 6.0;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,Brightness,The following statement contains a magic number: return System.Math.Sqrt (r * .241 + g * .691 + b * .068);  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double h = bgH + (i + 1.0) / (double)n;  	// for monochromatic backround the h value doesn't matter  	if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  		h = bgH + 0.5;  	if (h > 1.0)  		h -= 1.0;  	double s = 0.85;  	double l = 0.5;  	if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  		l = 0.8;  	result.Add (Mono.TextEditor.HslColor.FromHsl (h' s' l));  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double h = bgH + (i + 1.0) / (double)n;  	// for monochromatic backround the h value doesn't matter  	if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  		h = bgH + 0.5;  	if (h > 1.0)  		h -= 1.0;  	double s = 0.85;  	double l = 0.5;  	if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  		l = 0.8;  	result.Add (Mono.TextEditor.HslColor.FromHsl (h' s' l));  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double h = bgH + (i + 1.0) / (double)n;  	// for monochromatic backround the h value doesn't matter  	if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  		h = bgH + 0.5;  	if (h > 1.0)  		h -= 1.0;  	double s = 0.85;  	double l = 0.5;  	if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  		l = 0.8;  	result.Add (Mono.TextEditor.HslColor.FromHsl (h' s' l));  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double h = bgH + (i + 1.0) / (double)n;  	// for monochromatic backround the h value doesn't matter  	if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  		h = bgH + 0.5;  	if (h > 1.0)  		h -= 1.0;  	double s = 0.85;  	double l = 0.5;  	if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  		l = 0.8;  	result.Add (Mono.TextEditor.HslColor.FromHsl (h' s' l));  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double h = bgH + (i + 1.0) / (double)n;  	// for monochromatic backround the h value doesn't matter  	if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  		h = bgH + 0.5;  	if (h > 1.0)  		h -= 1.0;  	double s = 0.85;  	double l = 0.5;  	if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  		l = 0.8;  	result.Add (Mono.TextEditor.HslColor.FromHsl (h' s' l));  }  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: if (i + 1 == n && !(backGround.H == 0 && backGround.S == 0))  	h = bgH + 0.5;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: h = bgH + 0.5;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  	l = 0.8;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: if (backGround.H == 0 && backGround.S == 0 && backGround.L < 0.5)  	l = 0.8;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,GenerateHighlightColors,The following statement contains a magic number: l = 0.8;  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPangoString,The following statement contains a magic number: return string.Format ("#{0:x2}{1:x2}{2:x2}"' (int)(resultColor.R * 255)' (int)(resultColor.G * 255)' (int)(resultColor.B * 255));  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPangoString,The following statement contains a magic number: return string.Format ("#{0:x2}{1:x2}{2:x2}"' (int)(resultColor.R * 255)' (int)(resultColor.G * 255)' (int)(resultColor.B * 255));  
Magic Number,Mono.TextEditor,HslColor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\HslColor.cs,ToPangoString,The following statement contains a magic number: return string.Format ("#{0:x2}{1:x2}{2:x2}"' (int)(resultColor.R * 255)' (int)(resultColor.G * 255)' (int)(resultColor.B * 255));  
Magic Number,Mono.TextEditor,SelectionActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\SelectionActions.cs,EndLineSelection,The following statement contains a magic number: if (fromLine == toLine + 1) {  	if ((fromLine - data.MainSelection.Lead.Line) != 2) {  		var fromSegment = data.Document.GetLine (fromLine);  		data.SetSelection (fromSegment.EndOffsetIncludingDelimiter' toSegment.Offset);  	}  	else {  		data.SetSelection (toSegment.Offset' toSegment.EndOffsetIncludingDelimiter);  	}  }  
Magic Number,Mono.TextEditor,SelectionActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Actions\SelectionActions.cs,EndLineSelection,The following statement contains a magic number: if ((fromLine - data.MainSelection.Lead.Line) != 2) {  	var fromSegment = data.Document.GetLine (fromLine);  	data.SetSelection (fromSegment.EndOffsetIncludingDelimiter' toSegment.Offset);  }  else {  	data.SetSelection (toSegment.Offset' toSegment.EndOffsetIncludingDelimiter);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleVAdjustmentValueChanged,The following statement contains a magic number: foreach (DocumentLine line in layoutDict.Keys) {  	int curLine = line.LineNumber;  	if (startLine - 5 >= curLine || endLine + 5 <= curLine) {  		linesToRemove.Add (line);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleVAdjustmentValueChanged,The following statement contains a magic number: foreach (DocumentLine line in layoutDict.Keys) {  	int curLine = line.LineNumber;  	if (startLine - 5 >= curLine || endLine + 5 <= curLine) {  		linesToRemove.Add (line);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleVAdjustmentValueChanged,The following statement contains a magic number: if (startLine - 5 >= curLine || endLine + 5 <= curLine) {  	linesToRemove.Add (line);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,HandleVAdjustmentValueChanged,The following statement contains a magic number: if (startLine - 5 >= curLine || endLine + 5 <= curLine) {  	linesToRemove.Add (line);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 2;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 3;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 4;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 5;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 6;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 7;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following statement contains a magic number: return 8;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: markerFont.Size = markerFont.Size * 8 / 10;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: markerFont.Size = markerFont.Size * 8 / 10;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: using (var metrics = textEditor.PangoContext.GetMetrics (textEditor.Options.Font' textEditor.PangoContext.Language)) {  	this.textEditor.GetTextEditorData ().LineHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  	this.charWidth = metrics.ApproximateCharWidth / Pango.Scale.PangoScale;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: this.textEditor.GetTextEditorData ().LineHeight = System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: using (var metrics = textEditor.PangoContext.GetMetrics (textEditor.Options.GutterFont' textEditor.PangoContext.Language)) {  	this.textEditor.GetTextEditorData ().LineHeight = System.Math.Max (this.textEditor.GetTextEditorData ().LineHeight' System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale));  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: this.textEditor.GetTextEditorData ().LineHeight = System.Math.Max (this.textEditor.GetTextEditorData ().LineHeight' System.Math.Ceiling (0.5 + (metrics.Ascent + metrics.Descent) / Pango.Scale.PangoScale));  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: font.Size = font.Size * 3 / 4;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,OptionsChanged,The following statement contains a magic number: font.Size = font.Size * 3 / 4;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,UpdateCaret,The following statement contains a magic number: textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom' (int)(caretRectangle.Y + (textEditor.VAdjustment.Value - caretVAdjustmentValue))' caretRectangle.Width + 2 * (int)textEditor.Options.Zoom' caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (win)) {  	cr.Rectangle (XOffset' 0' textEditor.Allocation.Width - XOffset' textEditor.Allocation.Height);  	cr.Clip ();  	cr.LineWidth = System.Math.Max (1' System.Math.Floor (textEditor.Options.Zoom));  	cr.Antialias = Cairo.Antialias.None;  	var curRect = new Gdk.Rectangle ((int)caretX' (int)caretY' (int)this.charWidth' (int)LineHeight - 1);  	if (curRect != caretRectangle) {  		caretRectangle = curRect;  		//					textEditor.TextArea.QueueDrawArea (caretRectangle.X - (int)textEditor.Options.Zoom'  		//					               (int)(caretRectangle.Y + (-textEditor.VAdjustment.Value + caretVAdjustmentValue))'  		//				                    caretRectangle.Width + (int)textEditor.Options.Zoom'  		//					               caretRectangle.Height + 1);  		caretVAdjustmentValue = textEditor.VAdjustment.Value;  	}  	var fgColor = textEditor.ColorStyle.PlainText.Foreground;  	//				var bgColor = textEditor.ColorStyle.Default.CairoBackgroundColor;  	var line = Document.GetLine (Caret.Line);  	if (line != null) {  		foreach (var marker in line.Markers) {  			var style = marker as StyleTextLineMarker;  			if (style == null)  				continue;  			//					if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.BackgroundColor))  			//						bgColor = style.BackgroundColor;  			if (style.IncludedStyles.HasFlag (StyleTextLineMarker.StyleFlag.Color))  				fgColor = style.Color;  		}  	}  	/* 				var foreground = ((HslColor)fgColor).ToPixel (); 				var background = ((HslColor)color).ToPixel (); 				var caretColor = (foreground ^ background) & 0xFFFFFF; 				color = HslColor.FromPixel (caretColor);*/var color = fgColor;  	switch (Caret.Mode) {  	case CaretMode.Insert:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  		break;  	case CaretMode.Block:  		cr.SetSourceColor (color);  		cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  		cr.Fill ();  		char caretChar = GetCaretChar ();  		if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  			using (var layout = textEditor.LayoutCache.RequestLayout ()) {  				layout.FontDescription = textEditor.Options.Font;  				layout.SetText (caretChar.ToString ());  				cr.MoveTo (caretRectangle.X' caretRectangle.Y);  				cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  				cr.ShowLayout (layout);  			}  		}  		break;  	case CaretMode.Underscore:  		cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following statement contains a magic number: cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawSpaceMarker,The following statement contains a magic number: cr.Rectangle (x + (x2 - x - d) / 2' py' d' d);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The following statement contains a magic number: cr.MoveTo (0.5 + x' 0.5 + py);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The following statement contains a magic number: cr.MoveTo (0.5 + x' 0.5 + py);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The following statement contains a magic number: cr.LineTo (0.5 + x2 - charWidth / 2' 0.5 + py);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The following statement contains a magic number: cr.LineTo (0.5 + x2 - charWidth / 2' 0.5 + py);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawTabMarker,The following statement contains a magic number: cr.LineTo (0.5 + x2 - charWidth / 2' 0.5 + py);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateMatchingBracket,The following statement contains a magic number: if (offset <= highlightBracketOffset && highlightBracketOffset <= offset + length) {  	int index = highlightBracketOffset - offset;  	Pango.Rectangle rect = layout.Layout.IndexToPos ((int)TranslateToUTF8Index (layout.LineChars' (uint)index' ref curIndex' ref byteIndex));  	var bracketMatch = new Cairo.Rectangle (xPos + rect.X / Pango.Scale.PangoScale + 0.5' y + 0.5' (rect.Width / Pango.Scale.PangoScale) - 1' (rect.Height / Pango.Scale.PangoScale) - 1);  	if (BackgroundRenderer == null) {  		ctx.SetSourceColor (ColorStyle.BraceMatchingRectangle.Color);  		ctx.Rectangle (bracketMatch);  		ctx.FillPreserve ();  		ctx.SetSourceColor (ColorStyle.BraceMatchingRectangle.SecondColor);  		ctx.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DecorateMatchingBracket,The following statement contains a magic number: if (offset <= highlightBracketOffset && highlightBracketOffset <= offset + length) {  	int index = highlightBracketOffset - offset;  	Pango.Rectangle rect = layout.Layout.IndexToPos ((int)TranslateToUTF8Index (layout.LineChars' (uint)index' ref curIndex' ref byteIndex));  	var bracketMatch = new Cairo.Rectangle (xPos + rect.X / Pango.Scale.PangoScale + 0.5' y + 0.5' (rect.Width / Pango.Scale.PangoScale) - 1' (rect.Height / Pango.Scale.PangoScale) - 1);  	if (BackgroundRenderer == null) {  		ctx.SetSourceColor (ColorStyle.BraceMatchingRectangle.Color);  		ctx.Rectangle (bracketMatch);  		ctx.FillPreserve ();  		ctx.SetSourceColor (ColorStyle.BraceMatchingRectangle.SecondColor);  		ctx.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawIndent,The following statement contains a magic number: for (int i = 0; i < layout.IndentSize; i += textEditor.Options.IndentationSize) {  	var x = System.Math.Floor (xPos + i * charWidth);  	cr.MoveTo (x + 0.5' top);  	cr.LineTo (x + 0.5' bottom);  	cr.SetSourceColor (ColorStyle.IndentationGuide.Color);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawIndent,The following statement contains a magic number: for (int i = 0; i < layout.IndentSize; i += textEditor.Options.IndentationSize) {  	var x = System.Math.Floor (xPos + i * charWidth);  	cr.MoveTo (x + 0.5' top);  	cr.LineTo (x + 0.5' bottom);  	cr.SetSourceColor (ColorStyle.IndentationGuide.Color);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawIndent,The following statement contains a magic number: cr.MoveTo (x + 0.5' top);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawIndent,The following statement contains a magic number: cr.LineTo (x + 0.5' bottom);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: if (!isSelectionDrawn && (layout.StartSet || selectionStartOffset == offset + length) && BackgroundRenderer == null) {  	double startX;  	int startY;  	double endX;  	int endY;  	if (selectionStartOffset != offset + length) {  		var start = layout.Layout.IndexToPos (layout.SelectionStartIndex);  		startX = System.Math.Floor (start.X / Pango.Scale.PangoScale);  		startY = (int)(y + System.Math.Floor (start.Y / Pango.Scale.PangoScale));  		var end = layout.Layout.IndexToPos (layout.SelectionEndIndex);  		endX = System.Math.Ceiling (end.X / Pango.Scale.PangoScale);  		endY = (int)(y + System.Math.Ceiling (end.Y / Pango.Scale.PangoScale));  	}  	else {  		startY = endY = (int)y;  		startX = width;  		endX = startX;  	}  	if (textEditor.MainSelection.SelectionMode == SelectionMode.Block && startX == endX) {  		endX = startX + 2;  	}  	if (startY == endY) {  		DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (xPos + startX' startY' endX - startX' LineHeight)' this.SelectionColor.Background' true);  	}  	else {  		DrawRectangleWithRuler (cr' xPos + textEditor.HAdjustment.Value - TextStartPosition' new Cairo.Rectangle (xPos + startX' startY' textEditor.Allocation.Width - xPos - startX' LineHeight)' this.SelectionColor.Background' true);  		if (endY - startY > LineHeight) {  			DrawRectangleWithRuler (cr' xPos' new Cairo.Rectangle (xPos' startY + LineHeight' textEditor.Allocation.Width - xPos' endY - startY - LineHeight)' this.SelectionColor.Background' true);  		}  		DrawRectangleWithRuler (cr' xPos' new Cairo.Rectangle (xPos' endY' endX' LineHeight)' this.SelectionColor.Background' true);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: if (textEditor.MainSelection.SelectionMode == SelectionMode.Block && startX == endX) {  	endX = startX + 2;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: endX = startX + 2;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: if (textEditor.HighlightSearchPattern) {  	while (!(firstSearch = GetFirstSearchResult (o' offset + length)).IsInvalid) {  		double x = position;  		HandleSelection (lineOffset' logicalRulerColumn' selectionStartOffset' selectionEndOffset' System.Math.Max (lineOffset' firstSearch.Offset)' System.Math.Min (lineOffset + line.Length' firstSearch.EndOffset)' delegate (int start' int end) {  			uint startIndex = (uint)(start - offset);  			uint endIndex = (uint)(end - offset);  			if (startIndex < endIndex && endIndex <= layout.LineChars.Length) {  				uint startTranslated = TranslateToUTF8Index (layout.LineChars' startIndex' ref curIndex' ref byteIndex);  				uint endTranslated = TranslateToUTF8Index (layout.LineChars' endIndex' ref curIndex' ref byteIndex);  				int l' x1' x2;  				layout.Layout.IndexToLineX ((int)startTranslated' false' out l' out x1);  				layout.Layout.IndexToLineX ((int)endTranslated' false' out l' out x2);  				int w = (int)System.Math.Ceiling ((x2 - x1) / Pango.Scale.PangoScale);  				int s = (int)System.Math.Floor (x1 / Pango.Scale.PangoScale + x);  				double corner = System.Math.Min (4' width) * textEditor.Options.Zoom;  				cr.SetSourceColor (MainSearchResult.IsInvalid || MainSearchResult.Offset != firstSearch.Offset ? ColorStyle.SearchResult.Color : ColorStyle.SearchResultMain.Color);  				FoldingScreenbackgroundRenderer.DrawRoundRectangle (cr' true' true' s' y' corner' w + 1' LineHeight);  				cr.Fill ();  			}  		}' null);  		o = System.Math.Max (firstSearch.EndOffset' o + 1);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: while (!(firstSearch = GetFirstSearchResult (o' offset + length)).IsInvalid) {  	double x = position;  	HandleSelection (lineOffset' logicalRulerColumn' selectionStartOffset' selectionEndOffset' System.Math.Max (lineOffset' firstSearch.Offset)' System.Math.Min (lineOffset + line.Length' firstSearch.EndOffset)' delegate (int start' int end) {  		uint startIndex = (uint)(start - offset);  		uint endIndex = (uint)(end - offset);  		if (startIndex < endIndex && endIndex <= layout.LineChars.Length) {  			uint startTranslated = TranslateToUTF8Index (layout.LineChars' startIndex' ref curIndex' ref byteIndex);  			uint endTranslated = TranslateToUTF8Index (layout.LineChars' endIndex' ref curIndex' ref byteIndex);  			int l' x1' x2;  			layout.Layout.IndexToLineX ((int)startTranslated' false' out l' out x1);  			layout.Layout.IndexToLineX ((int)endTranslated' false' out l' out x2);  			int w = (int)System.Math.Ceiling ((x2 - x1) / Pango.Scale.PangoScale);  			int s = (int)System.Math.Floor (x1 / Pango.Scale.PangoScale + x);  			double corner = System.Math.Min (4' width) * textEditor.Options.Zoom;  			cr.SetSourceColor (MainSearchResult.IsInvalid || MainSearchResult.Offset != firstSearch.Offset ? ColorStyle.SearchResult.Color : ColorStyle.SearchResultMain.Color);  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (cr' true' true' s' y' corner' w + 1' LineHeight);  			cr.Fill ();  		}  	}' null);  	o = System.Math.Max (firstSearch.EndOffset' o + 1);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: HandleSelection (lineOffset' logicalRulerColumn' selectionStartOffset' selectionEndOffset' System.Math.Max (lineOffset' firstSearch.Offset)' System.Math.Min (lineOffset + line.Length' firstSearch.EndOffset)' delegate (int start' int end) {  	uint startIndex = (uint)(start - offset);  	uint endIndex = (uint)(end - offset);  	if (startIndex < endIndex && endIndex <= layout.LineChars.Length) {  		uint startTranslated = TranslateToUTF8Index (layout.LineChars' startIndex' ref curIndex' ref byteIndex);  		uint endTranslated = TranslateToUTF8Index (layout.LineChars' endIndex' ref curIndex' ref byteIndex);  		int l' x1' x2;  		layout.Layout.IndexToLineX ((int)startTranslated' false' out l' out x1);  		layout.Layout.IndexToLineX ((int)endTranslated' false' out l' out x2);  		int w = (int)System.Math.Ceiling ((x2 - x1) / Pango.Scale.PangoScale);  		int s = (int)System.Math.Floor (x1 / Pango.Scale.PangoScale + x);  		double corner = System.Math.Min (4' width) * textEditor.Options.Zoom;  		cr.SetSourceColor (MainSearchResult.IsInvalid || MainSearchResult.Offset != firstSearch.Offset ? ColorStyle.SearchResult.Color : ColorStyle.SearchResultMain.Color);  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (cr' true' true' s' y' corner' w + 1' LineHeight);  		cr.Fill ();  	}  }' null);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following statement contains a magic number: if (startIndex < endIndex && endIndex <= layout.LineChars.Length) {  	uint startTranslated = TranslateToUTF8Index (layout.LineChars' startIndex' ref curIndex' ref byteIndex);  	uint endTranslated = TranslateToUTF8Index (layout.LineChars' endIndex' ref curIndex' ref byteIndex);  	int l' x1' x2;  	layout.Layout.IndexToLineX ((int)startTranslated' false' out l' out x1);  	layout.Layout.IndexToLineX ((int)endTranslated' false' out l' out x2);  	int w = (int)System.Math.Ceiling ((x2 - x1) / Pango.Scale.PangoScale);  	int s = (int)System.Math.Floor (x1 / Pango.Scale.PangoScale + x);  	double corner = System.Math.Min (4' width) * textEditor.Options.Zoom;  	cr.SetSourceColor (MainSearchResult.IsInvalid || MainSearchResult.Offset != firstSearch.Offset ? ColorStyle.SearchResult.Color : ColorStyle.SearchResultMain.Color);  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (cr' true' true' s' y' corner' w + 1' LineHeight);  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFirstSearchResult,The following statement contains a magic number: if (startOffset < endOffset && this.selectedRegions.Count > 0) {  	var region = new TextSegment (startOffset' endOffset - startOffset);  	int min = 0;  	int max = selectedRegions.Count - 1;  	do {  		int mid = (min + max) / 2;  		TextSegment segment = selectedRegions [mid];  		if (segment.Contains (startOffset) || segment.Contains (endOffset) || region.Contains (segment)) {  			if (mid == 0)  				return segment;  			TextSegment prevSegment = selectedRegions [mid - 1];  			if (!(prevSegment.Contains (startOffset) || prevSegment.Contains (endOffset) || region.Contains (prevSegment)))  				return segment;  			max = mid - 1;  			continue;  		}  		if (segment.Offset < endOffset) {  			min = mid + 1;  		}  		else {  			max = mid - 1;  		}  	}  	while (min <= max);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFirstSearchResult,The following statement contains a magic number: do {  	int mid = (min + max) / 2;  	TextSegment segment = selectedRegions [mid];  	if (segment.Contains (startOffset) || segment.Contains (endOffset) || region.Contains (segment)) {  		if (mid == 0)  			return segment;  		TextSegment prevSegment = selectedRegions [mid - 1];  		if (!(prevSegment.Contains (startOffset) || prevSegment.Contains (endOffset) || region.Contains (prevSegment)))  			return segment;  		max = mid - 1;  		continue;  	}  	if (segment.Offset < endOffset) {  		min = mid + 1;  	}  	else {  		max = mid - 1;  	}  }  while (min <= max);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetPixel,The following statement contains a magic number: return (((ulong)color.Red) << 32) | (((ulong)color.Green) << 16) | ((ulong)color.Blue);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetPixel,The following statement contains a magic number: return (((ulong)color.Red) << 32) | (((ulong)color.Green) << 16) | ((ulong)color.Blue);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The following statement contains a magic number: if (args.Button == 1) {  	if (!CalculateClickLocation (args.X' args.Y' out clickLocation))  		return;  	DocumentLine line = Document.GetLine (clickLocation.Line);  	bool isHandled = false;  	if (line != null) {  		foreach (TextLineMarker marker in line.Markers) {  			if (marker is IActionTextLineMarker) {  				isHandled |= ((IActionTextLineMarker)marker).MousePressed (textEditor' args);  				if (isHandled)  					break;  			}  		}  		foreach (var marker in Document.GetTextSegmentMarkersAt (line).Where (m => m.IsVisible)) {  			if (marker is IActionTextLineMarker) {  				isHandled |= ((IActionTextLineMarker)marker).MousePressed (textEditor' args);  				if (isHandled)  					break;  			}  		}  	}  	if (isHandled)  		return;  	int offset = Document.LocationToOffset (clickLocation);  	if (offset < 0) {  		textEditor.RunAction (CaretMoveActions.ToDocumentEnd);  		return;  	}  	if (args.Button == 2 && !selection.IsEmpty && selection.Contains (Document.OffsetToLocation (offset))) {  		textEditor.ClearSelection ();  		return;  	}  	if (args.Type == EventType.TwoButtonPress) {  		var data = textEditor.GetTextEditorData ();  		mouseWordStart = data.FindCurrentWordStart (offset);  		mouseWordEnd = data.FindCurrentWordEnd (offset);  		Caret.Offset = mouseWordEnd;  		textEditor.MainSelection = new Selection (textEditor.Document.OffsetToLocation (mouseWordStart)' textEditor.Document.OffsetToLocation (mouseWordEnd));  		InSelectionDrag = true;  		mouseSelectionMode = MouseSelectionMode.Word;  		// folding marker  		int lineNr = args.LineNumber;  		foreach (var shownFolding in GetFoldRectangles (lineNr)) {  			if (shownFolding.Item1.Contains ((int)(args.X + this.XOffset)' (int)args.Y)) {  				shownFolding.Item2.IsFolded = false;  				return;  			}  		}  		return;  	}  	else if (args.Type == EventType.ThreeButtonPress) {  		int lineNr = Document.OffsetToLineNumber (offset);  		textEditor.SetSelectLines (lineNr' lineNr);  		var range = textEditor.SelectionRange;  		mouseWordStart = range.Offset;  		mouseWordEnd = range.EndOffset;  		InSelectionDrag = true;  		mouseSelectionMode = MouseSelectionMode.WholeLine;  		return;  	}  	mouseSelectionMode = MouseSelectionMode.SingleChar;  	if (textEditor.IsSomethingSelected && IsInsideSelection (clickLocation) && clickLocation != textEditor.Caret.Location) {  		inDrag = true;  	}  	else {  		if ((args.ModifierState & Gdk.ModifierType.ShiftMask) == ModifierType.ShiftMask) {  			InSelectionDrag = true;  			Caret.PreserveSelection = true;  			if (!textEditor.IsSomethingSelected) {  				textEditor.MainSelection = new Selection (Caret.Location' clickLocation);  				Caret.Location = clickLocation;  			}  			else {  				Caret.Location = clickLocation;  				textEditor.ExtendSelectionTo (clickLocation);  			}  			Caret.PreserveSelection = false;  		}  		else {  			textEditor.ClearSelection ();  			Caret.Location = clickLocation;  			InSelectionDrag = true;  			textEditor.SetSelection (clickLocation' clickLocation);  		}  		textEditor.RequestResetCaretBlink ();  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The following statement contains a magic number: if (args.Button == 2 && !selection.IsEmpty && selection.Contains (Document.OffsetToLocation (offset))) {  	textEditor.ClearSelection ();  	return;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MousePressed,The following statement contains a magic number: if (!Platform.IsWindows && args.Button == 2 && this.textEditor.CanEdit (docLocation.Line)) {  	TextSegment selectionRange = TextSegment.Invalid;  	int offset = Document.LocationToOffset (docLocation);  	if (!selection.IsEmpty)  		selectionRange = selection.GetSelectionRange (this.textEditor.GetTextEditorData ());  	var oldVersion = textEditor.Document.Version;  	bool autoScroll = textEditor.Caret.AutoScrollToCaret;  	textEditor.Caret.AutoScrollToCaret = false;  	if (!selection.IsEmpty && selectionRange.Contains (offset)) {  		textEditor.ClearSelection ();  		textEditor.Caret.Offset = selectionRange.EndOffset;  		return;  	}  	ClipboardActions.PasteFromPrimary (textEditor.GetTextEditorData ()' offset);  	textEditor.Caret.Offset = oldOffset;  	if (!selectionRange.IsInvalid)  		textEditor.SelectionRange = new TextSegment (oldVersion.MoveOffsetTo (Document.Version' selectionRange.Offset)' selectionRange.Length);  	if (autoScroll)  		textEditor.Caret.ActivateAutoScrollWithoutMove ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseReleased,The following statement contains a magic number: if (args.Button != 2 && !InSelectionDrag)  	textEditor.ClearSelection ();  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,ShowTooltip,The following statement contains a magic number: codeSegmentTooltipTimeoutId = GLib.Timeout.Add (650' delegate {  	previewWindow = new CodeSegmentPreviewWindow (textEditor' false' segment);  	if (previewWindow.IsEmptyText) {  		previewWindow.Destroy ();  		previewWindow = null;  		return false;  	}  	if (textEditor == null || textEditor.GdkWindow == null)  		return false;  	int ox = 0' oy = 0;  	textEditor.GdkWindow.GetOrigin (out ox' out oy);  	ox += textEditor.Allocation.X;  	oy += textEditor.Allocation.Y;  	int x = hintRectangle.Right;  	int y = hintRectangle.Bottom;  	previewWindow.CalculateSize ();  	var req = previewWindow.SizeRequest ();  	int w = req.Width;  	int h = req.Height;  	var geometry = this.textEditor.Screen.GetUsableMonitorGeometry (this.textEditor.Screen.GetMonitorAtPoint (ox + x' oy + y));  	if (x + ox + w > geometry.X + geometry.Width)  		x = hintRectangle.Left - w;  	if (y + oy + h > geometry.Y + geometry.Height)  		y = hintRectangle.Top - h;  	int destX = System.Math.Max (0' ox + x);  	int destY = System.Math.Max (0' oy + y);  	previewWindow.Move (destX' destY);  	previewWindow.ShowAll ();  	return false;  });  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DimColor,The following statement contains a magic number: return DimColor (color' 0.95);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (textEditor.Options.ShowRuler) {  	var right = left + width;  	var divider = (int)(System.Math.Max (left' System.Math.Min (x + TextStartPosition + rulerX' right)));  	if (divider < right) {  		var beforeDividerWidth = divider - left;  		if (beforeDividerWidth > 0) {  			cr.Rectangle (left' area.Y' beforeDividerWidth' area.Height);  			cr.Fill ();  		}  		cr.Rectangle (divider' area.Y' right - divider' area.Height);  		cr.SetSourceColor (color);  		cr.Fill ();  		if (beforeDividerWidth > 0) {  			cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  		}  		return;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (textEditor.Options.ShowRuler) {  	var right = left + width;  	var divider = (int)(System.Math.Max (left' System.Math.Min (x + TextStartPosition + rulerX' right)));  	if (divider < right) {  		var beforeDividerWidth = divider - left;  		if (beforeDividerWidth > 0) {  			cr.Rectangle (left' area.Y' beforeDividerWidth' area.Height);  			cr.Fill ();  		}  		cr.Rectangle (divider' area.Y' right - divider' area.Height);  		cr.SetSourceColor (color);  		cr.Fill ();  		if (beforeDividerWidth > 0) {  			cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  		}  		return;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (divider < right) {  	var beforeDividerWidth = divider - left;  	if (beforeDividerWidth > 0) {  		cr.Rectangle (left' area.Y' beforeDividerWidth' area.Height);  		cr.Fill ();  	}  	cr.Rectangle (divider' area.Y' right - divider' area.Height);  	cr.SetSourceColor (color);  	cr.Fill ();  	if (beforeDividerWidth > 0) {  		cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  	}  	return;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (divider < right) {  	var beforeDividerWidth = divider - left;  	if (beforeDividerWidth > 0) {  		cr.Rectangle (left' area.Y' beforeDividerWidth' area.Height);  		cr.Fill ();  	}  	cr.Rectangle (divider' area.Y' right - divider' area.Height);  	cr.SetSourceColor (color);  	cr.Fill ();  	if (beforeDividerWidth > 0) {  		cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  	}  	return;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (beforeDividerWidth > 0) {  	cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: if (beforeDividerWidth > 0) {  	cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawRectangleWithRuler,The following statement contains a magic number: cr.DrawLine (ColorStyle.Ruler.Color' divider + 0.5' area.Y' divider + 0.5' area.Y + area.Height);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,The following statement contains a magic number: using (var calcTextLayout = textEditor.LayoutCache.RequestLayout ())  	using (var calcFoldingLayout = textEditor.LayoutCache.RequestLayout ()) {  		calcTextLayout.FontDescription = textEditor.Options.Font;  		calcTextLayout.Tabs = this.tabArray;  		calcFoldingLayout.FontDescription = markerLayout.FontDescription;  		calcFoldingLayout.Tabs = this.tabArray;  		foreach (var folding in foldings) {  			int foldOffset = folding.StartLine.Offset + folding.Column - 1;  			if (foldOffset < offset)  				continue;  			if (folding.IsFolded) {  				var txt = Document.GetTextAt (offset' System.Math.Max (0' System.Math.Min (foldOffset - offset' Document.TextLength - offset)));  				calcTextLayout.SetText (txt);  				calcTextLayout.GetSize (out width' out height);  				xPos += width / Pango.Scale.PangoScale;  				offset = folding.EndLine.Offset + folding.EndColumn;  				calcFoldingLayout.SetText (folding.Description);  				calcFoldingLayout.GetSize (out width' out height);  				var pixelWidth = width / Pango.Scale.PangoScale + foldXMargin * 2;  				var foldingRectangle = new Rectangle ((int)xPos' y' (int)pixelWidth' (int)LineHeight - 1);  				yield return Tuple.Create (foldingRectangle' folding);  				xPos += pixelWidth;  				if (folding.EndLine != line) {  					line = folding.EndLine;  					foldings = Document.GetStartFoldings (line);  					goto restart;  				}  			}  		}  	}  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,The following statement contains a magic number: using (var calcFoldingLayout = textEditor.LayoutCache.RequestLayout ()) {  	calcTextLayout.FontDescription = textEditor.Options.Font;  	calcTextLayout.Tabs = this.tabArray;  	calcFoldingLayout.FontDescription = markerLayout.FontDescription;  	calcFoldingLayout.Tabs = this.tabArray;  	foreach (var folding in foldings) {  		int foldOffset = folding.StartLine.Offset + folding.Column - 1;  		if (foldOffset < offset)  			continue;  		if (folding.IsFolded) {  			var txt = Document.GetTextAt (offset' System.Math.Max (0' System.Math.Min (foldOffset - offset' Document.TextLength - offset)));  			calcTextLayout.SetText (txt);  			calcTextLayout.GetSize (out width' out height);  			xPos += width / Pango.Scale.PangoScale;  			offset = folding.EndLine.Offset + folding.EndColumn;  			calcFoldingLayout.SetText (folding.Description);  			calcFoldingLayout.GetSize (out width' out height);  			var pixelWidth = width / Pango.Scale.PangoScale + foldXMargin * 2;  			var foldingRectangle = new Rectangle ((int)xPos' y' (int)pixelWidth' (int)LineHeight - 1);  			yield return Tuple.Create (foldingRectangle' folding);  			xPos += pixelWidth;  			if (folding.EndLine != line) {  				line = folding.EndLine;  				foldings = Document.GetStartFoldings (line);  				goto restart;  			}  		}  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,The following statement contains a magic number: foreach (var folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		var txt = Document.GetTextAt (offset' System.Math.Max (0' System.Math.Min (foldOffset - offset' Document.TextLength - offset)));  		calcTextLayout.SetText (txt);  		calcTextLayout.GetSize (out width' out height);  		xPos += width / Pango.Scale.PangoScale;  		offset = folding.EndLine.Offset + folding.EndColumn;  		calcFoldingLayout.SetText (folding.Description);  		calcFoldingLayout.GetSize (out width' out height);  		var pixelWidth = width / Pango.Scale.PangoScale + foldXMargin * 2;  		var foldingRectangle = new Rectangle ((int)xPos' y' (int)pixelWidth' (int)LineHeight - 1);  		yield return Tuple.Create (foldingRectangle' folding);  		xPos += pixelWidth;  		if (folding.EndLine != line) {  			line = folding.EndLine;  			foldings = Document.GetStartFoldings (line);  			goto restart;  		}  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetFoldRectangles,The following statement contains a magic number: if (folding.IsFolded) {  	var txt = Document.GetTextAt (offset' System.Math.Max (0' System.Math.Min (foldOffset - offset' Document.TextLength - offset)));  	calcTextLayout.SetText (txt);  	calcTextLayout.GetSize (out width' out height);  	xPos += width / Pango.Scale.PangoScale;  	offset = folding.EndLine.Offset + folding.EndColumn;  	calcFoldingLayout.SetText (folding.Description);  	calcFoldingLayout.GetSize (out width' out height);  	var pixelWidth = width / Pango.Scale.PangoScale + foldXMargin * 2;  	var foldingRectangle = new Rectangle ((int)xPos' y' (int)pixelWidth' (int)LineHeight - 1);  	yield return Tuple.Create (foldingRectangle' folding);  	xPos += pixelWidth;  	if (folding.EndLine != line) {  		line = folding.EndLine;  		foldings = Document.GetStartFoldings (line);  		goto restart;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if (topBottomFallsThrough && corners == CairoCorners.None) {  	cr.MoveTo (x' y - r);  	cr.LineTo (x' y + h + r);  	cr.MoveTo (x + w' y - r);  	cr.LineTo (x + w' y + h + r);  	return;  }  else if (r < 0.0001 || corners == CairoCorners.None) {  	cr.Rectangle (x' y' w' h);  	return;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if (r < 0.0001 || corners == CairoCorners.None) {  	cr.Rectangle (x' y' w' h);  	return;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.TopLeft | CairoCorners.TopRight)) == 0 && topBottomFallsThrough) {  	y -= r;  	h += r;  	cr.MoveTo (x + w' y);  }  else {  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.MoveTo (x + r' y);  	}  	else {  		cr.MoveTo (x' y);  	}  	if ((corners & CairoCorners.TopRight) != 0) {  		cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  	}  	else {  		cr.LineTo (x + w' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.TopLeft | CairoCorners.TopRight)) == 0 && topBottomFallsThrough) {  	y -= r;  	h += r;  	cr.MoveTo (x + w' y);  }  else {  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.MoveTo (x + r' y);  	}  	else {  		cr.MoveTo (x' y);  	}  	if ((corners & CairoCorners.TopRight) != 0) {  		cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  	}  	else {  		cr.LineTo (x + w' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & CairoCorners.TopRight) != 0) {  	cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  }  else {  	cr.LineTo (x + w' y);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & CairoCorners.TopRight) != 0) {  	cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  }  else {  	cr.LineTo (x + w' y);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + w - r' y + r' r' System.Math.PI * 1.5' System.Math.PI * 2);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.BottomLeft | CairoCorners.BottomRight)) == 0 && topBottomFallsThrough) {  	h += r;  	cr.LineTo (x + w' y + h);  	cr.MoveTo (x' y + h);  	cr.LineTo (x' y + r);  	cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  }  else {  	if ((corners & CairoCorners.BottomRight) != 0) {  		cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  	}  	else {  		cr.LineTo (x + w' y + h);  	}  	if ((corners & CairoCorners.BottomLeft) != 0) {  		cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  	}  	else {  		cr.LineTo (x' y + h);  	}  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  	}  	else {  		cr.LineTo (x' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.BottomLeft | CairoCorners.BottomRight)) == 0 && topBottomFallsThrough) {  	h += r;  	cr.LineTo (x + w' y + h);  	cr.MoveTo (x' y + h);  	cr.LineTo (x' y + r);  	cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  }  else {  	if ((corners & CairoCorners.BottomRight) != 0) {  		cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  	}  	else {  		cr.LineTo (x + w' y + h);  	}  	if ((corners & CairoCorners.BottomLeft) != 0) {  		cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  	}  	else {  		cr.LineTo (x' y + h);  	}  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  	}  	else {  		cr.LineTo (x' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.BottomLeft | CairoCorners.BottomRight)) == 0 && topBottomFallsThrough) {  	h += r;  	cr.LineTo (x + w' y + h);  	cr.MoveTo (x' y + h);  	cr.LineTo (x' y + r);  	cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  }  else {  	if ((corners & CairoCorners.BottomRight) != 0) {  		cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  	}  	else {  		cr.LineTo (x + w' y + h);  	}  	if ((corners & CairoCorners.BottomLeft) != 0) {  		cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  	}  	else {  		cr.LineTo (x' y + h);  	}  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  	}  	else {  		cr.LineTo (x' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & (CairoCorners.BottomLeft | CairoCorners.BottomRight)) == 0 && topBottomFallsThrough) {  	h += r;  	cr.LineTo (x + w' y + h);  	cr.MoveTo (x' y + h);  	cr.LineTo (x' y + r);  	cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  }  else {  	if ((corners & CairoCorners.BottomRight) != 0) {  		cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  	}  	else {  		cr.LineTo (x + w' y + h);  	}  	if ((corners & CairoCorners.BottomLeft) != 0) {  		cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  	}  	else {  		cr.LineTo (x' y + h);  	}  	if ((corners & CairoCorners.TopLeft) != 0) {  		cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  	}  	else {  		cr.LineTo (x' y);  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & CairoCorners.BottomRight) != 0) {  	cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  }  else {  	cr.LineTo (x + w' y + h);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + w - r' y + h - r' r' 0' System.Math.PI * 0.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & CairoCorners.BottomLeft) != 0) {  	cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  }  else {  	cr.LineTo (x' y + h);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + r' y + h - r' r' System.Math.PI * 0.5' System.Math.PI);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: if ((corners & CairoCorners.TopLeft) != 0) {  	cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  }  else {  	cr.LineTo (x' y);  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,RoundedRectangle,The following statement contains a magic number: cr.Arc (x + r' y + r' r' System.Math.PI' System.Math.PI * 1.5);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: foreach (FoldSegment folding in foldings) {  	int foldOffset = folding.StartLine.Offset + folding.Column - 1;  	if (foldOffset < offset)  		continue;  	if (folding.IsFolded) {  		DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  		offset = folding.EndLine.Offset + folding.EndColumn - 1;  		markerLayout.SetText (folding.Description);  		int width' height;  		markerLayout.GetPixelSize (out width' out height);  		bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  		double pixelX = 0.5 + System.Math.Floor (position);  		double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  		double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  		var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  		if (BackgroundRenderer == null && isFoldingSelected) {  			cr.SetSourceColor (SelectionColor.Background);  			cr.Rectangle (foldingRectangle);  			cr.Fill ();  		}  		if (isFoldingSelected && SelectionColor.TransparentForeground) {  			cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  		}  		else {  			cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  		}  		var boundingRectangleHeight = foldingRectangle.Height - 1;  		var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  		RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  		cr.Stroke ();  		cr.Save ();  		cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  		cr.ShowLayout (markerLayout);  		cr.Restore ();  		if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		position += foldingRectangle.Width;  		if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  			var cx = (int)position;  			SetVisibleCaretPosition (cx' y' cx' y);  		}  		if (folding.EndLine != line) {  			line = folding.EndLine;  			lineNr = line.LineNumber;  			foldings = Document.GetStartFoldings (line);  			isEolFolded = line.Length <= folding.EndColumn;  			goto restart;  		}  		isEolFolded = line.Length <= folding.EndColumn;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (folding.IsFolded) {  	DrawLinePart (cr' line' lineNr' logicalRulerColumn' offset' foldOffset - offset' ref position' ref isSelectionDrawn' y' area.X + area.Width' _lineHeight);  	offset = folding.EndLine.Offset + folding.EndColumn - 1;  	markerLayout.SetText (folding.Description);  	int width' height;  	markerLayout.GetPixelSize (out width' out height);  	bool isFoldingSelected = !this.HideSelection && textEditor.IsSomethingSelected && textEditor.SelectionRange.Contains (folding.Segment);  	double pixelX = 0.5 + System.Math.Floor (position);  	double foldXMargin = foldMarkerXMargin * textEditor.Options.Zoom;  	double pixelWidth = System.Math.Floor (position + width - pixelX + foldXMargin * 2);  	var foldingRectangle = new Cairo.Rectangle (pixelX' y' pixelWidth' this.LineHeight);  	if (BackgroundRenderer == null && isFoldingSelected) {  		cr.SetSourceColor (SelectionColor.Background);  		cr.Rectangle (foldingRectangle);  		cr.Fill ();  	}  	if (isFoldingSelected && SelectionColor.TransparentForeground) {  		cr.SetSourceColor (ColorStyle.CollapsedText.Foreground);  	}  	else {  		cr.SetSourceColor (isFoldingSelected ? SelectionColor.Foreground : ColorStyle.CollapsedText.Foreground);  	}  	var boundingRectangleHeight = foldingRectangle.Height - 1;  	var boundingRectangleY = System.Math.Floor (foldingRectangle.Y + (foldingRectangle.Height - boundingRectangleHeight) / 2);  	RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  	cr.Stroke ();  	cr.Save ();  	cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  	cr.ShowLayout (markerLayout);  	cr.Restore ();  	if (caretOffset == foldOffset && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	position += foldingRectangle.Width;  	if (caretOffset == foldOffset + folding.Length && !string.IsNullOrEmpty (folding.Description)) {  		var cx = (int)position;  		SetVisibleCaretPosition (cx' y' cx' y);  	}  	if (folding.EndLine != line) {  		line = folding.EndLine;  		lineNr = line.LineNumber;  		foldings = Document.GetStartFoldings (line);  		isEolFolded = line.Length <= folding.EndColumn;  		goto restart;  	}  	isEolFolded = line.Length <= folding.EndColumn;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: RoundedRectangle (cr' System.Math.Floor (foldingRectangle.X) + 0.5' boundingRectangleY + 0.5' System.Math.Floor (foldingRectangle.Width - cr.LineWidth)' System.Math.Floor (boundingRectangleHeight - cr.LineWidth)' LineHeight / 8' CairoCorners.All' false);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: cr.Translate (position + foldXMargin' System.Math.Floor (boundingRectangleY + System.Math.Max (0' boundingRectangleHeight - height) / 2));  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (textEditor.Options.ShowWhitespaces != ShowWhitespaces.Never) {  	switch (textEditor.Options.ShowWhitespaces) {  	case ShowWhitespaces.Selection:  		if (!isEolFolded && isEolSelected)  			if (!(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection))  				if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  					goto case ShowWhitespaces.Always;  		break;  	case ShowWhitespaces.Always:  		if (wrapper == null)  			wrapper = GetLayout (line);  		DrawEolMarker (cr' line' isEolSelected' position' y + System.Math.Max (0' wrapper.Height - LineHeight));  		break;  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: switch (textEditor.Options.ShowWhitespaces) {  case ShowWhitespaces.Selection:  	if (!isEolFolded && isEolSelected)  		if (!(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection))  			if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  				goto case ShowWhitespaces.Always;  	break;  case ShowWhitespaces.Always:  	if (wrapper == null)  		wrapper = GetLayout (line);  	DrawEolMarker (cr' line' isEolSelected' position' y + System.Math.Max (0' wrapper.Height - LineHeight));  	break;  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (!isEolFolded && isEolSelected)  	if (!(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection))  		if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  			goto case ShowWhitespaces.Always;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (!(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection))  	if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  		goto case ShowWhitespaces.Always;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following statement contains a magic number: if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  	goto case ShowWhitespaces.Always;  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: if (textEditor.HAdjustment.Value > 0) {  	cr.LineWidth = textEditor.Options.Zoom;  	for (int i = 0; i < verticalShadowAlphaTable.Length; i++) {  		cr.SetSourceRGBA (0' 0' 0' 1 - verticalShadowAlphaTable [i]);  		cr.MoveTo (x + i * cr.LineWidth + 0.5' y);  		cr.LineTo (x + i * cr.LineWidth + 0.5' y + 1 + _lineHeight);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: if (textEditor.HAdjustment.Value > 0) {  	cr.LineWidth = textEditor.Options.Zoom;  	for (int i = 0; i < verticalShadowAlphaTable.Length; i++) {  		cr.SetSourceRGBA (0' 0' 0' 1 - verticalShadowAlphaTable [i]);  		cr.MoveTo (x + i * cr.LineWidth + 0.5' y);  		cr.LineTo (x + i * cr.LineWidth + 0.5' y + 1 + _lineHeight);  		cr.Stroke ();  	}  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: for (int i = 0; i < verticalShadowAlphaTable.Length; i++) {  	cr.SetSourceRGBA (0' 0' 0' 1 - verticalShadowAlphaTable [i]);  	cr.MoveTo (x + i * cr.LineWidth + 0.5' y);  	cr.LineTo (x + i * cr.LineWidth + 0.5' y + 1 + _lineHeight);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: for (int i = 0; i < verticalShadowAlphaTable.Length; i++) {  	cr.SetSourceRGBA (0' 0' 0' 1 - verticalShadowAlphaTable [i]);  	cr.MoveTo (x + i * cr.LineWidth + 0.5' y);  	cr.LineTo (x + i * cr.LineWidth + 0.5' y + 1 + _lineHeight);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: cr.MoveTo (x + i * cr.LineWidth + 0.5' y);  
Magic Number,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawScrollShadow,The following statement contains a magic number: cr.LineTo (x + i * cr.LineWidth + 0.5' y + 1 + _lineHeight);  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: while (result < endOffset) {  	CharacterClass next = GetCharacterClass (doc.GetCharAt (result)' subword' false);  	if (next != current) {  		// camelCase and PascalCase handling  		bool camelSkip = false;  		if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  			if (result - 2 > line.Offset) {  				CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  				if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  					result--;  				else  					camelSkip = true;  			}  		}  		if (!camelSkip)  			break;  	}  	current = next;  	result++;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: while (result < endOffset) {  	CharacterClass next = GetCharacterClass (doc.GetCharAt (result)' subword' false);  	if (next != current) {  		// camelCase and PascalCase handling  		bool camelSkip = false;  		if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  			if (result - 2 > line.Offset) {  				CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  				if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  					result--;  				else  					camelSkip = true;  			}  		}  		if (!camelSkip)  			break;  	}  	current = next;  	result++;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: while (result < endOffset) {  	CharacterClass next = GetCharacterClass (doc.GetCharAt (result)' subword' false);  	if (next != current) {  		// camelCase and PascalCase handling  		bool camelSkip = false;  		if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  			if (result - 2 > line.Offset) {  				CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  				if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  					result--;  				else  					camelSkip = true;  			}  		}  		if (!camelSkip)  			break;  	}  	current = next;  	result++;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next != current) {  	// camelCase and PascalCase handling  	bool camelSkip = false;  	if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  		if (result - 2 > line.Offset) {  			CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  			if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  				result--;  			else  				camelSkip = true;  		}  	}  	if (!camelSkip)  		break;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next != current) {  	// camelCase and PascalCase handling  	bool camelSkip = false;  	if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  		if (result - 2 > line.Offset) {  			CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  			if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  				result--;  			else  				camelSkip = true;  		}  	}  	if (!camelSkip)  		break;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next != current) {  	// camelCase and PascalCase handling  	bool camelSkip = false;  	if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  		if (result - 2 > line.Offset) {  			CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  			if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  				result--;  			else  				camelSkip = true;  		}  	}  	if (!camelSkip)  		break;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  	if (result - 2 > line.Offset) {  		CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  		if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  			result--;  		else  			camelSkip = true;  	}  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  	if (result - 2 > line.Offset) {  		CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  		if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  			result--;  		else  			camelSkip = true;  	}  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (next == CharacterClass.LowercaseLetter && current == CharacterClass.UppercaseLetter) {  	if (result - 2 > line.Offset) {  		CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  		if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  			result--;  		else  			camelSkip = true;  	}  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (result - 2 > line.Offset) {  	CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  	if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  		result--;  	else  		camelSkip = true;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (result - 2 > line.Offset) {  	CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  	if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  		result--;  	else  		camelSkip = true;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (result - 2 > line.Offset) {  	CharacterClass previous = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  	if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  		result--;  	else  		camelSkip = true;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (previous == CharacterClass.UppercaseLetter && result - 2 > offset)  	result--;  else  	camelSkip = true;  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CharacterClass.Whitespace && result - 1 > line.Offset) {  	result--;  	current = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: current = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: while (result > line.Offset) {  	CharacterClass prev = GetCharacterClass (doc.GetCharAt (result - 1)' subword' false);  	if (prev != current) {  		// camelCase and PascalCase handling  		bool camelSkip = false;  		if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  			if (result - 2 > line.Offset) {  				CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  				if (back2 == CharacterClass.UppercaseLetter)  					result--;  				else  					camelSkip = true;  			}  		}  		if (!camelSkip)  			break;  	}  	current = prev;  	result--;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: while (result > line.Offset) {  	CharacterClass prev = GetCharacterClass (doc.GetCharAt (result - 1)' subword' false);  	if (prev != current) {  		// camelCase and PascalCase handling  		bool camelSkip = false;  		if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  			if (result - 2 > line.Offset) {  				CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  				if (back2 == CharacterClass.UppercaseLetter)  					result--;  				else  					camelSkip = true;  			}  		}  		if (!camelSkip)  			break;  	}  	current = prev;  	result--;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (prev != current) {  	// camelCase and PascalCase handling  	bool camelSkip = false;  	if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  		if (result - 2 > line.Offset) {  			CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  			if (back2 == CharacterClass.UppercaseLetter)  				result--;  			else  				camelSkip = true;  		}  	}  	if (!camelSkip)  		break;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (prev != current) {  	// camelCase and PascalCase handling  	bool camelSkip = false;  	if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  		if (result - 2 > line.Offset) {  			CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  			if (back2 == CharacterClass.UppercaseLetter)  				result--;  			else  				camelSkip = true;  		}  	}  	if (!camelSkip)  		break;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  	if (result - 2 > line.Offset) {  		CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  		if (back2 == CharacterClass.UppercaseLetter)  			result--;  		else  			camelSkip = true;  	}  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (prev == CharacterClass.UppercaseLetter && current == CharacterClass.LowercaseLetter) {  	if (result - 2 > line.Offset) {  		CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  		if (back2 == CharacterClass.UppercaseLetter)  			result--;  		else  			camelSkip = true;  	}  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (result - 2 > line.Offset) {  	CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  	if (back2 == CharacterClass.UppercaseLetter)  		result--;  	else  		camelSkip = true;  }  
Magic Number,Mono.TextEditor,SharpDevelopWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\SharpDevelopWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (result - 2 > line.Offset) {  	CharacterClass back2 = GetCharacterClass (doc.GetCharAt (result - 2)' subword' false);  	if (back2 == CharacterClass.UppercaseLetter)  		result--;  	else  		camelSkip = true;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: while (result < doc.TextLength) {  	char ch = doc.GetCharAt (result);  	CC current = SW.GetCharacterClass (ch' subword' includeUnderscore);  	//camelCase / PascalCase splitting  	if (subword) {  		if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  			break;  		}  		else if (previous == CC.Digit && current != CC.Digit) {  			break;  		}  		else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  			break;  		}  		else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  			result--;  			break;  		}  	}  	//else break at end of identifiers  	if (previous != CC.Unknown && previous != CC.Whitespace) {  		inIndentifier = true;  	}  	else if (inIndentifier) {  		result--;  		break;  	}  	previous = current;  	result++;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: while (result < doc.TextLength) {  	char ch = doc.GetCharAt (result);  	CC current = SW.GetCharacterClass (ch' subword' includeUnderscore);  	//camelCase / PascalCase splitting  	if (subword) {  		if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  			break;  		}  		else if (previous == CC.Digit && current != CC.Digit) {  			break;  		}  		else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  			break;  		}  		else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  			result--;  			break;  		}  	}  	//else break at end of identifiers  	if (previous != CC.Unknown && previous != CC.Whitespace) {  		inIndentifier = true;  	}  	else if (inIndentifier) {  		result--;  		break;  	}  	previous = current;  	result++;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (subword) {  	if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  		break;  	}  	else if (previous == CC.Digit && current != CC.Digit) {  		break;  	}  	else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  		break;  	}  	else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  		result--;  		break;  	}  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (subword) {  	if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  		break;  	}  	else if (previous == CC.Digit && current != CC.Digit) {  		break;  	}  	else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  		break;  	}  	else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  		result--;  		break;  	}  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  	break;  }  else if (previous == CC.Digit && current != CC.Digit) {  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.Digit && (previous != CC.Digit || (result - 1 == offset && !Char.IsDigit (doc.GetCharAt (result - 1))))) {  	break;  }  else if (previous == CC.Digit && current != CC.Digit) {  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (previous == CC.Digit && current != CC.Digit) {  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (previous == CC.Digit && current != CC.Digit) {  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindNextWordOffset,The following statement contains a magic number: if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result - 2 > 0 && SW.GetCharacterClass (doc.GetCharAt (result - 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result--;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: while (result > 0) {  	char ch = doc.GetCharAt (result);  	CC current = SW.GetCharacterClass (ch' subword' includeUnderscore);  	//camelCase / PascalCase splitting  	if (subword) {  		if (current == CC.Digit && previous != CC.Digit) {  			result++;  			break;  		}  		else if (previous == CC.Digit && current != CC.Digit) {  			result++;  			break;  		}  		else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  			break;  		}  		else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  			result++;  			break;  		}  	}  	//else break at end of identifiers  	if (previous != CC.Unknown && previous != CC.Whitespace) {  		inIndentifier = true;  	}  	else if (inIndentifier) {  		result += 2;  		break;  	}  	previous = current;  	result--;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: while (result > 0) {  	char ch = doc.GetCharAt (result);  	CC current = SW.GetCharacterClass (ch' subword' includeUnderscore);  	//camelCase / PascalCase splitting  	if (subword) {  		if (current == CC.Digit && previous != CC.Digit) {  			result++;  			break;  		}  		else if (previous == CC.Digit && current != CC.Digit) {  			result++;  			break;  		}  		else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  			break;  		}  		else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  			result++;  			break;  		}  	}  	//else break at end of identifiers  	if (previous != CC.Unknown && previous != CC.Whitespace) {  		inIndentifier = true;  	}  	else if (inIndentifier) {  		result += 2;  		break;  	}  	previous = current;  	result--;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: while (result > 0) {  	char ch = doc.GetCharAt (result);  	CC current = SW.GetCharacterClass (ch' subword' includeUnderscore);  	//camelCase / PascalCase splitting  	if (subword) {  		if (current == CC.Digit && previous != CC.Digit) {  			result++;  			break;  		}  		else if (previous == CC.Digit && current != CC.Digit) {  			result++;  			break;  		}  		else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  			break;  		}  		else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  			result++;  			break;  		}  	}  	//else break at end of identifiers  	if (previous != CC.Unknown && previous != CC.Whitespace) {  		inIndentifier = true;  	}  	else if (inIndentifier) {  		result += 2;  		break;  	}  	previous = current;  	result--;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (subword) {  	if (current == CC.Digit && previous != CC.Digit) {  		result++;  		break;  	}  	else if (previous == CC.Digit && current != CC.Digit) {  		result++;  		break;  	}  	else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  		break;  	}  	else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  		result++;  		break;  	}  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (subword) {  	if (current == CC.Digit && previous != CC.Digit) {  		result++;  		break;  	}  	else if (previous == CC.Digit && current != CC.Digit) {  		result++;  		break;  	}  	else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  		break;  	}  	else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  		result++;  		break;  	}  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.Digit && previous != CC.Digit) {  	result++;  	break;  }  else if (previous == CC.Digit && current != CC.Digit) {  	result++;  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.Digit && previous != CC.Digit) {  	result++;  	break;  }  else if (previous == CC.Digit && current != CC.Digit) {  	result++;  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (previous == CC.Digit && current != CC.Digit) {  	result++;  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (previous == CC.Digit && current != CC.Digit) {  	result++;  	break;  }  else if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.UppercaseLetter && previous != CC.UppercaseLetter) {  	break;  }  else if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (current == CC.LowercaseLetter && previous == CC.UppercaseLetter && result + 2 < doc.TextLength && SW.GetCharacterClass (doc.GetCharAt (result + 2)' subword' includeUnderscore) != CC.LowercaseLetter) {  	result++;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (previous != CC.Unknown && previous != CC.Whitespace) {  	inIndentifier = true;  }  else if (inIndentifier) {  	result += 2;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: if (inIndentifier) {  	result += 2;  	break;  }  
Magic Number,Mono.TextEditor,EmacsWordFindStrategy,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\EmacsWordFindStrategy.cs,FindPrevWordOffset,The following statement contains a magic number: result += 2;  
Magic Number,Mono.TextEditor,TooltipProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TooltipProvider.cs,GetRequiredPosition,The following statement contains a magic number: xalign = 0.5;  
Magic Number,Mono.TextEditor,TooltipProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TooltipProvider.cs,ShowTooltipWindow,The following statement contains a magic number: w += 10;  
Magic Number,Mono.TextEditor,TooltipProvider,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TooltipProvider.cs,ShowTooltipWindow,The following statement contains a magic number: y += 10;  
Magic Number,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,InternalDraw,The following statement contains a magic number: if (Wave) {  	Pango.CairoHelper.ShowErrorUnderline (cr' @from' y + editor.LineHeight - height' to - @from' height);  }  else {  	cr.LineWidth = 1;  	cr.MoveTo (@from' y + editor.LineHeight - 1.5);  	cr.LineTo (to' y + editor.LineHeight - 1.5);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,InternalDraw,The following statement contains a magic number: if (Wave) {  	Pango.CairoHelper.ShowErrorUnderline (cr' @from' y + editor.LineHeight - height' to - @from' height);  }  else {  	cr.LineWidth = 1;  	cr.MoveTo (@from' y + editor.LineHeight - 1.5);  	cr.LineTo (to' y + editor.LineHeight - 1.5);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,InternalDraw,The following statement contains a magic number: cr.MoveTo (@from' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UnderlineTextSegmentMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextSegmentMarker.cs,InternalDraw,The following statement contains a magic number: cr.LineTo (to' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,MouseHover,The following statement contains a magic number: if (found) {  	var list = new List<FoldSegment> (editor.Document.GetFoldingContaining (lineSegment));  	list.Sort ((x' y) => x.Offset.CompareTo (y.Offset));  	foldings = list;  	if (editor.TextViewMargin.BackgroundRenderer == null) {  		timerId = GLib.Timeout.Add (150' SetBackgroundRenderer);  	}  	else {  		SetBackgroundRenderer ();  	}  }  else {  	RemoveBackgroundRenderer ();  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,MouseHover,The following statement contains a magic number: if (editor.TextViewMargin.BackgroundRenderer == null) {  	timerId = GLib.Timeout.Add (150' SetBackgroundRenderer);  }  else {  	SetBackgroundRenderer ();  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,MouseHover,The following statement contains a magic number: timerId = GLib.Timeout.Add (150' SetBackgroundRenderer);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  }  else {  	hslColor.L = hslColor.L * 0.9;  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  }  else {  	hslColor.L = hslColor.L * 0.9;  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  }  else {  	hslColor.L = hslColor.L * 0.9;  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: if (brightness < 0.5) {  	hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  }  else {  	hslColor.L = hslColor.L * 0.9;  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: hslColor.L = hslColor.L * 0.85 + hslColor.L * 0.25;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,OptionsChanged,The following statement contains a magic number: hslColor.L = hslColor.L * 0.9;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2' drawArea.X + drawArea.Width - drawArea.Width * 2 / 10' drawArea.Y + drawArea.Height / 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: if (!isOpen)  	ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,DrawFoldSegment,The following statement contains a magic number: ctx.DrawLine (isSelected ? foldLineHighlightedGC : foldToggleMarkerGC' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height * 2 / 10' drawArea.X + drawArea.Width / 2' drawArea.Y + drawArea.Height - drawArea.Height * 2 / 10);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: foldSegmentSize = marginWidth * 4 / 6;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: foldSegmentSize = marginWidth * 4 / 6;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: foldSegmentSize -= (foldSegmentSize) % 2;  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.EnableQuickDiff) {  	if (state == TextDocument.LineState.Changed) {  		cr.SetSourceColor (lineStateChangedGC);  		cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  		cr.Fill ();  	}  	else if (state == TextDocument.LineState.Dirty) {  		cr.SetSourceColor (lineStateDirtyGC);  		cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  		cr.Fill ();  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.EnableQuickDiff) {  	if (state == TextDocument.LineState.Changed) {  		cr.SetSourceColor (lineStateChangedGC);  		cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  		cr.Fill ();  	}  	else if (state == TextDocument.LineState.Dirty) {  		cr.SetSourceColor (lineStateDirtyGC);  		cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  		cr.Fill ();  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (state == TextDocument.LineState.Changed) {  	cr.SetSourceColor (lineStateChangedGC);  	cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  	cr.Fill ();  }  else if (state == TextDocument.LineState.Dirty) {  	cr.SetSourceColor (lineStateDirtyGC);  	cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (state == TextDocument.LineState.Changed) {  	cr.SetSourceColor (lineStateChangedGC);  	cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  	cr.Fill ();  }  else if (state == TextDocument.LineState.Dirty) {  	cr.SetSourceColor (lineStateDirtyGC);  	cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (state == TextDocument.LineState.Dirty) {  	cr.SetSourceColor (lineStateDirtyGC);  	cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  	cr.Fill ();  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: cr.Rectangle (x + 1' y' marginWidth / 3' lineHeight);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (editor.Options.ShowFoldMargin && line <= editor.Document.LineCount) {  	double foldSegmentYPos = y + System.Math.Floor (editor.LineHeight - foldSegmentSize) / 2;  	double xPos = x + System.Math.Floor (marginWidth / 2) + 0.5;  	if (isFoldStart) {  		bool isVisible = true;  		bool moreLinedOpenFold = false;  		foreach (FoldSegment foldSegment in startFoldings) {  			if (foldSegment.IsFolded) {  				isVisible = false;  			}  			else {  				moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  			}  		}  		bool isFoldEndFromUpperFold = false;  		foreach (FoldSegment foldSegment in endFoldings) {  			if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  				isFoldEndFromUpperFold = true;  		}  		DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  		if (isContaining || isFoldEndFromUpperFold)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  		if (isContaining || moreLinedOpenFold)  			cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  	}  	else {  		if (isFoldEnd) {  			double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  			cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  			cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  			if (isContaining)  				cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  		}  		else if (isContaining) {  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  		}  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldStart) {  	bool isVisible = true;  	bool moreLinedOpenFold = false;  	foreach (FoldSegment foldSegment in startFoldings) {  		if (foldSegment.IsFolded) {  			isVisible = false;  		}  		else {  			moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  		}  	}  	bool isFoldEndFromUpperFold = false;  	foreach (FoldSegment foldSegment in endFoldings) {  		if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  			isFoldEndFromUpperFold = true;  	}  	DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  	if (isContaining || isFoldEndFromUpperFold)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  	if (isContaining || moreLinedOpenFold)  		cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  }  else {  	if (isFoldEnd) {  		double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  		cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  		cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  		if (isContaining)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  	}  	else if (isContaining) {  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldStart) {  	bool isVisible = true;  	bool moreLinedOpenFold = false;  	foreach (FoldSegment foldSegment in startFoldings) {  		if (foldSegment.IsFolded) {  			isVisible = false;  		}  		else {  			moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  		}  	}  	bool isFoldEndFromUpperFold = false;  	foreach (FoldSegment foldSegment in endFoldings) {  		if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  			isFoldEndFromUpperFold = true;  	}  	DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  	if (isContaining || isFoldEndFromUpperFold)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  	if (isContaining || moreLinedOpenFold)  		cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  }  else {  	if (isFoldEnd) {  		double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  		cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  		cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  		if (isContaining)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  	}  	else if (isContaining) {  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldStart) {  	bool isVisible = true;  	bool moreLinedOpenFold = false;  	foreach (FoldSegment foldSegment in startFoldings) {  		if (foldSegment.IsFolded) {  			isVisible = false;  		}  		else {  			moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  		}  	}  	bool isFoldEndFromUpperFold = false;  	foreach (FoldSegment foldSegment in endFoldings) {  		if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  			isFoldEndFromUpperFold = true;  	}  	DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  	if (isContaining || isFoldEndFromUpperFold)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  	if (isContaining || moreLinedOpenFold)  		cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  }  else {  	if (isFoldEnd) {  		double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  		cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  		cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  		if (isContaining)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  	}  	else if (isContaining) {  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldStart) {  	bool isVisible = true;  	bool moreLinedOpenFold = false;  	foreach (FoldSegment foldSegment in startFoldings) {  		if (foldSegment.IsFolded) {  			isVisible = false;  		}  		else {  			moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  		}  	}  	bool isFoldEndFromUpperFold = false;  	foreach (FoldSegment foldSegment in endFoldings) {  		if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  			isFoldEndFromUpperFold = true;  	}  	DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  	if (isContaining || isFoldEndFromUpperFold)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  	if (isContaining || moreLinedOpenFold)  		cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  }  else {  	if (isFoldEnd) {  		double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  		cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  		cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  		if (isContaining)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  	}  	else if (isContaining) {  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldStart) {  	bool isVisible = true;  	bool moreLinedOpenFold = false;  	foreach (FoldSegment foldSegment in startFoldings) {  		if (foldSegment.IsFolded) {  			isVisible = false;  		}  		else {  			moreLinedOpenFold = foldSegment.EndLine.Offset > foldSegment.StartLine.Offset;  		}  	}  	bool isFoldEndFromUpperFold = false;  	foreach (FoldSegment foldSegment in endFoldings) {  		if (foldSegment.EndLine.Offset > foldSegment.StartLine.Offset && !foldSegment.IsFolded)  			isFoldEndFromUpperFold = true;  	}  	DrawFoldSegment (cr' x' y' isVisible' isStartSelected);  	if (isContaining || isFoldEndFromUpperFold)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  	if (isContaining || moreLinedOpenFold)  		cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  }  else {  	if (isFoldEnd) {  		double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  		cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  		cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  		if (isContaining)  			cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  	}  	else if (isContaining) {  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  	}  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isContaining || isFoldEndFromUpperFold)  	cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' foldSegmentYPos - 2);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isContaining || moreLinedOpenFold)  	cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: cr.DrawLine (isEndSelected || (isStartSelected && isVisible) || isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' foldSegmentYPos + foldSegmentSize + 2' xPos' drawArea.Y + drawArea.Height);  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldEnd) {  	double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  	cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  	cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  	if (isContaining)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  }  else if (isContaining) {  	cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldEnd) {  	double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  	cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  	cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  	if (isContaining)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  }  else if (isContaining) {  	cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: if (isFoldEnd) {  	double yMid = System.Math.Floor (drawArea.Y + drawArea.Height / 2) + 0.5;  	cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  	cr.DrawLine (isContainingSelected || isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' yMid);  	if (isContaining)  		cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' xPos' drawArea.Y + drawArea.Height);  }  else if (isContaining) {  	cr.DrawLine (isContainingSelected ? foldLineHighlightedGC : foldLineGC' xPos' drawArea.Y' xPos' drawArea.Y + drawArea.Height);  }  
Magic Number,Mono.TextEditor,FoldMarkerMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\FoldMarkerMargin.cs,Draw,The following statement contains a magic number: cr.DrawLine (isEndSelected ? foldLineHighlightedGC : foldLineGC' xPos' yMid' x + marginWidth - 2' yMid);  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,CreateInputMethodMenuItem,The following statement contains a magic number: if (GtkWorkarounds.GtkMinorVersion >= 16) {  	bool showMenu = (bool)GtkWorkarounds.GetProperty (Settings' "gtk-show-input-method-menu").Val;  	if (!showMenu)  		return null;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,VAdjustmentValueChanged,The following statement contains a magic number: if (System.Math.Abs (delta) >= Allocation.Height - this.LineHeight * 2 || this.TextViewMargin.InSelectionDrag) {  	this.QueueDraw ();  	OnVScroll (EventArgs.Empty);  	return;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnDragDataReceived,The following statement contains a magic number: if (selection_data.Length > 0 && selection_data.Format == 8) {  	Caret.Offset = dragOffset;  	if (CanEdit (dragCaretPos.Line)) {  		int offset = Caret.Offset;  		if (!selection.IsEmpty && selection.GetSelectionRange (textEditorData).Offset >= offset) {  			var start = Document.OffsetToLocation (selection.GetSelectionRange (textEditorData).Offset + selection_data.Text.Length);  			var end = Document.OffsetToLocation (selection.GetSelectionRange (textEditorData).Offset + selection_data.Text.Length + selection.GetSelectionRange (textEditorData).Length);  			selection = new Selection (start' end);  		}  		textEditorData.PasteText (offset' selection_data.Text' null' ref undo);  		Caret.Offset = offset + selection_data.Text.Length;  		MainSelection = new Selection (Document.OffsetToLocation (offset)' Caret.Location);  	}  	dragOver = false;  	context = null;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: try {  	// The coordinates have to be properly adjusted to the origin since  	// the event may come from a child widget  	int rx' ry;  	GdkWindow.GetOrigin (out rx' out ry);  	double x = (int)e.XRoot - rx;  	double y = (int)e.YRoot - ry;  	overChildWidget = containerChildren.Any (w => w.Child.Allocation.Contains ((int)x' (int)y));  	RemoveScrollWindowTimer ();  	Gdk.ModifierType mod = e.State;  	double startPos;  	Margin margin = GetMarginAtX (x' out startPos);  	if (textViewMargin.inDrag && margin == this.textViewMargin && Gtk.Drag.CheckThreshold (this' (int)pressPositionX' (int)pressPositionY' (int)x' (int)y)) {  		dragContents = new ClipboardActions.CopyOperation ();  		dragContents.CopyData (textEditorData);  		DragContext context = Gtk.Drag.Begin (this' ClipboardActions.CopyOperation.TargetList' DragAction.Move | DragAction.Copy' 1' e);  		if (!Platform.IsMac) {  			CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  			Gtk.Drag.SetIconWidget (context' window' 0' 0);  		}  		selection = MainSelection;  		textViewMargin.inDrag = false;  	}  	else {  		FireMotionEvent (x' y' mod);  		if (mouseButtonPressed != 0) {  			UpdateScrollWindowTimer (x' y' mod);  		}  	}  }  catch (Exception ex) {  	GLib.ExceptionManager.RaiseUnhandledException (ex' false);  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: try {  	// The coordinates have to be properly adjusted to the origin since  	// the event may come from a child widget  	int rx' ry;  	GdkWindow.GetOrigin (out rx' out ry);  	double x = (int)e.XRoot - rx;  	double y = (int)e.YRoot - ry;  	overChildWidget = containerChildren.Any (w => w.Child.Allocation.Contains ((int)x' (int)y));  	RemoveScrollWindowTimer ();  	Gdk.ModifierType mod = e.State;  	double startPos;  	Margin margin = GetMarginAtX (x' out startPos);  	if (textViewMargin.inDrag && margin == this.textViewMargin && Gtk.Drag.CheckThreshold (this' (int)pressPositionX' (int)pressPositionY' (int)x' (int)y)) {  		dragContents = new ClipboardActions.CopyOperation ();  		dragContents.CopyData (textEditorData);  		DragContext context = Gtk.Drag.Begin (this' ClipboardActions.CopyOperation.TargetList' DragAction.Move | DragAction.Copy' 1' e);  		if (!Platform.IsMac) {  			CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  			Gtk.Drag.SetIconWidget (context' window' 0' 0);  		}  		selection = MainSelection;  		textViewMargin.inDrag = false;  	}  	else {  		FireMotionEvent (x' y' mod);  		if (mouseButtonPressed != 0) {  			UpdateScrollWindowTimer (x' y' mod);  		}  	}  }  catch (Exception ex) {  	GLib.ExceptionManager.RaiseUnhandledException (ex' false);  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: if (textViewMargin.inDrag && margin == this.textViewMargin && Gtk.Drag.CheckThreshold (this' (int)pressPositionX' (int)pressPositionY' (int)x' (int)y)) {  	dragContents = new ClipboardActions.CopyOperation ();  	dragContents.CopyData (textEditorData);  	DragContext context = Gtk.Drag.Begin (this' ClipboardActions.CopyOperation.TargetList' DragAction.Move | DragAction.Copy' 1' e);  	if (!Platform.IsMac) {  		CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  		Gtk.Drag.SetIconWidget (context' window' 0' 0);  	}  	selection = MainSelection;  	textViewMargin.inDrag = false;  }  else {  	FireMotionEvent (x' y' mod);  	if (mouseButtonPressed != 0) {  		UpdateScrollWindowTimer (x' y' mod);  	}  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: if (textViewMargin.inDrag && margin == this.textViewMargin && Gtk.Drag.CheckThreshold (this' (int)pressPositionX' (int)pressPositionY' (int)x' (int)y)) {  	dragContents = new ClipboardActions.CopyOperation ();  	dragContents.CopyData (textEditorData);  	DragContext context = Gtk.Drag.Begin (this' ClipboardActions.CopyOperation.TargetList' DragAction.Move | DragAction.Copy' 1' e);  	if (!Platform.IsMac) {  		CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  		Gtk.Drag.SetIconWidget (context' window' 0' 0);  	}  	selection = MainSelection;  	textViewMargin.inDrag = false;  }  else {  	FireMotionEvent (x' y' mod);  	if (mouseButtonPressed != 0) {  		UpdateScrollWindowTimer (x' y' mod);  	}  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: if (!Platform.IsMac) {  	CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  	Gtk.Drag.SetIconWidget (context' window' 0' 0);  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnMotionNotifyEvent,The following statement contains a magic number: if (!Platform.IsMac) {  	CodeSegmentPreviewWindow window = new CodeSegmentPreviewWindow (textEditorData.Parent' true' textEditorData.SelectionRange' 300' 300);  	Gtk.Drag.SetIconWidget (context' window' 0' 0);  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,UpdateScrollWindowTimer,The following statement contains a magic number: if (scrollWindowTimer == 0) {  	scrollWindowTimer = GLib.Timeout.Add (50' delegate {  		FireMotionEvent (scrollWindowTimer_x' scrollWindowTimer_y' scrollWindowTimer_mod);  		return true;  	});  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,UpdateScrollWindowTimer,The following statement contains a magic number: scrollWindowTimer = GLib.Timeout.Add (50' delegate {  	FireMotionEvent (scrollWindowTimer_x' scrollWindowTimer_y' scrollWindowTimer_mod);  	return true;  });  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,CenterTo,The following statement contains a magic number: caretPosition -= this.textEditorData.VAdjustment.PageSize / 2;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnScrollEvent,The following statement contains a magic number: if (hasZoomModifier && lastScrollTime != 0 && (evnt.Time - lastScrollTime) < 100)  	hasZoomModifier = false;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetHAdjustment,The following statement contains a magic number: if (Options.WrapLines) {  	this.textEditorData.HAdjustment.SetBounds (0' 0' 0' 0' 0);  }  else {  	if (longestLine != null && this.textEditorData.HAdjustment != null) {  		double maxX = longestLineWidth;  		if (maxX > Allocation.Width)  			maxX += 2 * this.textViewMargin.CharWidth;  		double width = Allocation.Width - this.TextViewMargin.XOffset;  		var realMaxX = System.Math.Max (maxX' this.textEditorData.HAdjustment.Value + width);  		foreach (var containerChild in editor.containerChildren.Concat (containerChildren)) {  			if (containerChild.Child == this)  				continue;  			realMaxX = System.Math.Max (realMaxX' containerChild.X + containerChild.Child.Allocation.Width);  		}  		this.textEditorData.HAdjustment.SetBounds (0' realMaxX' this.textViewMargin.CharWidth' width' width);  		if (realMaxX < width)  			this.textEditorData.HAdjustment.Value = 0;  	}  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetHAdjustment,The following statement contains a magic number: if (longestLine != null && this.textEditorData.HAdjustment != null) {  	double maxX = longestLineWidth;  	if (maxX > Allocation.Width)  		maxX += 2 * this.textViewMargin.CharWidth;  	double width = Allocation.Width - this.TextViewMargin.XOffset;  	var realMaxX = System.Math.Max (maxX' this.textEditorData.HAdjustment.Value + width);  	foreach (var containerChild in editor.containerChildren.Concat (containerChildren)) {  		if (containerChild.Child == this)  			continue;  		realMaxX = System.Math.Max (realMaxX' containerChild.X + containerChild.Child.Allocation.Width);  	}  	this.textEditorData.HAdjustment.SetBounds (0' realMaxX' this.textViewMargin.CharWidth' width' width);  	if (realMaxX < width)  		this.textEditorData.HAdjustment.Value = 0;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetHAdjustment,The following statement contains a magic number: if (maxX > Allocation.Width)  	maxX += 2 * this.textViewMargin.CharWidth;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetHAdjustment,The following statement contains a magic number: maxX += 2 * this.textViewMargin.CharWidth;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetAdjustments,The following statement contains a magic number: if (this.textEditorData.VAdjustment != null) {  	double maxY = textEditorData.HeightTree.TotalHeight;  	//				if (maxY > allocation.Height)  	maxY += allocation.Height / 2 - LineHeight;  	foreach (var containerChild in editor.containerChildren.Concat (containerChildren)) {  		maxY = System.Math.Max (maxY' containerChild.Y + containerChild.Child.SizeRequest ().Height);  	}  	if (VAdjustment.Value > maxY - allocation.Height) {  		VAdjustment.Value = System.Math.Max (0' maxY - allocation.Height);  		QueueDraw ();  	}  	this.textEditorData.VAdjustment.SetBounds (0' System.Math.Max (allocation.Height' maxY)' LineHeight' allocation.Height' allocation.Height);  	if (maxY < allocation.Height)  		this.textEditorData.VAdjustment.Value = 0;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,SetAdjustments,The following statement contains a magic number: maxY += allocation.Height / 2 - LineHeight;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (e.Window))  	using (Cairo.Context textViewCr = Gdk.CairoHelper.Create (e.Window)) {  		UpdateMarginXOffsets ();  		cr.LineWidth = Options.Zoom;  		textViewCr.LineWidth = Options.Zoom;  		textViewCr.Rectangle (textViewMargin.XOffset' 0' Allocation.Width - textViewMargin.XOffset' Allocation.Height);  		textViewCr.Clip ();  		RenderMargins (cr' textViewCr' cairoArea);  		#if DEBUG_EXPOSE  						Console.WriteLine ("{0} expose {1}'{2} {3}x{4}"' (long)(DateTime.Now - started).TotalMilliseconds' 					e.Area.X' e.Area.Y' e.Area.Width' e.Area.Height); #endif  		if (requestResetCaretBlink && HasFocus) {  			textViewMargin.ResetCaretBlink (200);  			requestResetCaretBlink = false;  		}  		foreach (Animation animation in actors) {  			animation.Drawer.Draw (cr);  		}  		OnPainted (new PaintEventArgs (cr' cairoArea));  	}  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context textViewCr = Gdk.CairoHelper.Create (e.Window)) {  	UpdateMarginXOffsets ();  	cr.LineWidth = Options.Zoom;  	textViewCr.LineWidth = Options.Zoom;  	textViewCr.Rectangle (textViewMargin.XOffset' 0' Allocation.Width - textViewMargin.XOffset' Allocation.Height);  	textViewCr.Clip ();  	RenderMargins (cr' textViewCr' cairoArea);  	#if DEBUG_EXPOSE  					Console.WriteLine ("{0} expose {1}'{2} {3}x{4}"' (long)(DateTime.Now - started).TotalMilliseconds' 					e.Area.X' e.Area.Y' e.Area.Width' e.Area.Height); #endif  	if (requestResetCaretBlink && HasFocus) {  		textViewMargin.ResetCaretBlink (200);  		requestResetCaretBlink = false;  	}  	foreach (Animation animation in actors) {  		animation.Drawer.Draw (cr);  	}  	OnPainted (new PaintEventArgs (cr' cairoArea));  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnExposeEvent,The following statement contains a magic number: if (requestResetCaretBlink && HasFocus) {  	textViewMargin.ResetCaretBlink (200);  	requestResetCaretBlink = false;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnExposeEvent,The following statement contains a magic number: textViewMargin.ResetCaretBlink (200);  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ShowTooltip,The following statement contains a magic number: if (tipWindow != null && currentTooltipProvider != null && currentTooltipProvider.IsInteractive (editor' tipWindow)) {  	int wx' ww' wh;  	tipWindow.GetSize (out ww' out wh);  	wx = tipX - ww / 2;  	if (xloc >= wx && xloc < wx + ww && yloc >= tipY && yloc < tipY + 20 + wh)  		return;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ShowTooltip,The following statement contains a magic number: if (tipWindow != null && currentTooltipProvider != null && currentTooltipProvider.IsInteractive (editor' tipWindow)) {  	int wx' ww' wh;  	tipWindow.GetSize (out ww' out wh);  	wx = tipX - ww / 2;  	if (xloc >= wx && xloc < wx + ww && yloc >= tipY && yloc < tipY + 20 + wh)  		return;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ShowTooltip,The following statement contains a magic number: wx = tipX - ww / 2;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,ShowTooltip,The following statement contains a magic number: if (xloc >= wx && xloc < wx + ww && yloc >= tipY && yloc < tipY + 20 + wh)  	return;  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,TooltipTimer,The following statement contains a magic number: if (remainingMs > 50) {  	// Still some significant time left. Re-schedule the timer  	tipShowTimeoutId = GLib.Timeout.Add ((uint)remainingMs' TooltipTimer);  	return false;  }  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,DelayedHideTooltip,The following statement contains a magic number: tipHideTimeoutId = GLib.Timeout.Add (300' delegate {  	HideTooltip ();  	tipHideTimeoutId = 0;  	return false;  });  
Magic Number,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,StartAnimation,The following statement contains a magic number: return StartAnimation (drawer' 300);  
Magic Number,Mono.TextEditor,UnderlineMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UnderlineMarker.cs,InternalDraw,The following statement contains a magic number: if (Wave) {  	Pango.CairoHelper.ShowErrorUnderline (cr' @from' y + editor.LineHeight - height' to - @from' height);  }  else {  	cr.LineWidth = 1;  	cr.MoveTo (@from' y + editor.LineHeight - 1.5);  	cr.LineTo (to' y + editor.LineHeight - 1.5);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,UnderlineMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UnderlineMarker.cs,InternalDraw,The following statement contains a magic number: if (Wave) {  	Pango.CairoHelper.ShowErrorUnderline (cr' @from' y + editor.LineHeight - height' to - @from' height);  }  else {  	cr.LineWidth = 1;  	cr.MoveTo (@from' y + editor.LineHeight - 1.5);  	cr.LineTo (to' y + editor.LineHeight - 1.5);  	cr.Stroke ();  }  
Magic Number,Mono.TextEditor,UnderlineMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UnderlineMarker.cs,InternalDraw,The following statement contains a magic number: cr.MoveTo (@from' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UnderlineMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UnderlineMarker.cs,InternalDraw,The following statement contains a magic number: cr.LineTo (to' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: if (@from < to) {  	cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  }  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: if (@from < to) {  	cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  }  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: if (@from < to) {  	cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  }  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: if (@from < to) {  	cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  }  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,UrlMarker,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\UrlMarker.cs,Draw,The following statement contains a magic number: cr.DrawLine (editor.ColorStyle.GetForeground (editor.ColorStyle.GetChunkStyle (style))' @from + 0.5' y + editor.LineHeight - 1.5' to + 0.5' y + editor.LineHeight - 1.5);  
Magic Number,Mono.TextEditor,ActionMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\ActionMargin.cs,ActionMargin,The following statement contains a magic number: marginWidth = 20;  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		}  		else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			RunAction (CaretMoveActions.ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	break;  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		}  		else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			RunAction (CaretMoveActions.ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	break;  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		}  		else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			RunAction (CaretMoveActions.ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	break;  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (2 > command.Length)  	break;  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		RunAction (CaretMoveActions.ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		RunAction (CaretMoveActions.ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (2 == command.Length) {  	if (null == lastPattern || null == lastReplacement)  		return "No stored pattern.";  	// Perform replacement with stored stuff  	command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following statement contains a magic number: if (command.Length == 2) {  	RunAction (CaretMoveActions.ToDocumentEnd);  	return "Jumped to end of document.";  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret ();  			return;  		}  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action == null)  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	if (action != null)  		RunAction (action);  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'd')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  		else  			RunActions (action' ClipboardActions.Cut);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'y')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		RunAction (action);  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	}  	else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	//copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' ViActions.NewLineAbove);  		else  			RunActions (action' ClipboardActions.Cut);  		Status = "-- INSERT --";  		CurState = State.Insert;  		motion = Motion.None;  		Caret.Mode = CaretMode.Insert;  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = GetInsertAction (key' modifier);  	if (action != null)  		RunAction (action);  	else if (unicodeKey != 0)  		InsertCharacter (unicodeKey);  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	}  	else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		RunAction (MiscActions.IndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.IndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		RunAction (MiscActions.RemoveIndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.RemoveIndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	}  	else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  			HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  			// FIXME stop on errors? essential with multipliers and nowrapscan  		}  		/* Once all the keys have been played back' quickly exit. */return;  	}  	else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		RunAction (marks [k].LoadMark);  		Reset ("");  	}  	else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		case 'z':  		case '.':  			editor.CenterToCaret ();  			Reset ("");  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret ();  			return;  		}  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action == null)  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	if (action != null)  		RunAction (action);  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'd')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  		else  			RunActions (action' ClipboardActions.Cut);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'y')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		RunAction (action);  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	}  	else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	//copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' ViActions.NewLineAbove);  		else  			RunActions (action' ClipboardActions.Cut);  		Status = "-- INSERT --";  		CurState = State.Insert;  		motion = Motion.None;  		Caret.Mode = CaretMode.Insert;  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = GetInsertAction (key' modifier);  	if (action != null)  		RunAction (action);  	else if (unicodeKey != 0)  		InsertCharacter (unicodeKey);  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	}  	else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		RunAction (MiscActions.IndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.IndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		RunAction (MiscActions.RemoveIndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.RemoveIndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	}  	else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  			HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  			// FIXME stop on errors? essential with multipliers and nowrapscan  		}  		/* Once all the keys have been played back' quickly exit. */return;  	}  	else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		RunAction (marks [k].LoadMark);  		Reset ("");  	}  	else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		case 'z':  		case '.':  			editor.CenterToCaret ();  			Reset ("");  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch (CurState) {  case State.Unknown:  	Reset (string.Empty);  	goto case State.Normal;  case State.Normal:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		if (key == Gdk.Key.Delete)  			unicodeKey = 'x';  		switch ((char)unicodeKey) {  		case '?':  		case '/':  		case ':':  			CurState = State.Command;  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  			return;  		case 'A':  			RunAction (CaretMoveActions.LineEnd);  			goto case 'i';  		case 'I':  			RunAction (CaretMoveActions.LineFirstNonWhitespace);  			goto case 'i';  		case 'a':  			//use CaretMoveActions so that we can move past last character on line end  			RunAction (CaretMoveActions.Right);  			goto case 'i';  		case 'i':  			Caret.Mode = CaretMode.Insert;  			Status = "-- INSERT --";  			CurState = State.Insert;  			return;  		case 'R':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.Replace;  			return;  		case 'V':  			Status = "-- VISUAL LINE --";  			Data.SetSelectLines (Caret.Line' Caret.Line);  			CurState = State.VisualLine;  			return;  		case 'v':  			Status = "-- VISUAL --";  			CurState = State.Visual;  			RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  			return;  		case 'd':  			Status = "d";  			CurState = State.Delete;  			return;  		case 'y':  			Status = "y";  			CurState = State.Yank;  			return;  		case 'Y':  			CurState = State.Yank;  			HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  			return;  		case 'O':  			RunAction (ViActions.NewLineAbove);  			goto case 'i';  		case 'o':  			RunAction (ViActions.NewLineBelow);  			goto case 'i';  		case 'r':  			Caret.Mode = CaretMode.Underscore;  			Status = "-- REPLACE --";  			CurState = State.WriteChar;  			return;  		case 'c':  			Caret.Mode = CaretMode.Insert;  			Status = "c";  			CurState = State.Change;  			return;  		case 'x':  			if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			ViActions.RetreatFromLineEnd (Data);  			return;  		case 'X':  			if (Data.Caret.Column == DocumentLocation.MinColumn)  				return;  			Status = string.Empty;  			if (!Data.IsSomethingSelected && 0 < Caret.Offset)  				RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  			else  				RunAction (ClipboardActions.Cut);  			return;  		case 'D':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			return;  		case 'C':  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  			goto case 'i';  		case '>':  			Status = ">";  			CurState = State.Indent;  			return;  		case '<':  			Status = "<";  			CurState = State.Unindent;  			return;  		case 'n':  			Search ();  			return;  		case 'N':  			searchBackward = !searchBackward;  			Search ();  			searchBackward = !searchBackward;  			return;  		case 'p':  			PasteAfter (false);  			return;  		case 'P':  			PasteBefore (false);  			return;  		case 's':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'S':  			if (!Data.IsSomethingSelected)  				RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  			else  				Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  			RunAction (ClipboardActions.Cut);  			goto case 'i';  		case 'g':  			Status = "g";  			CurState = State.G;  			return;  		case 'H':  			Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  			return;  		case 'J':  			RunAction (ViActions.Join);  			return;  		case 'L':  			int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case 'M':  			line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  			if (line < DocumentLocation.MinLine)  				line = Document.LineCount;  			Caret.Line = line;  			return;  		case '~':  			RunAction (ViActions.ToggleCase);  			return;  		case 'z':  			Status = "z";  			CurState = State.Fold;  			return;  		case 'm':  			Status = "m";  			CurState = State.Mark;  			return;  		case '`':  			Status = "`";  			CurState = State.GoToMark;  			return;  		case '@':  			Status = "@";  			CurState = State.PlayMacro;  			return;  		case 'q':  			if (currentMacro == null) {  				Status = "q";  				CurState = State.NameMacro;  				return;  			}  			currentMacro = null;  			Reset ("Macro Recorded");  			return;  		case '*':  			SearchWordAtCaret ();  			return;  		}  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action == null)  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	if (action != null)  		RunAction (action);  	//undo/redo may leave MD with a selection mode without activating visual mode  	CheckVisualMode ();  	return;  case State.Delete:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'd')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' CaretMoveActions.LineFirstNonWhitespace);  		else  			RunActions (action' ClipboardActions.Cut);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Yank:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	int offset = Caret.Offset;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'y')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		RunAction (action);  		if (Data.IsSomethingSelected && !lineAction)  			offset = Data.SelectionRange.Offset;  		RunAction (ClipboardActions.Copy);  		Reset (string.Empty);  	}  	else {  		Reset ("Unrecognised motion");  	}  	Caret.Offset = offset;  	return;  case State.Change:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  	}  	//copied from delete action  	else if (((modifier & (Gdk.ModifierType.ShiftMask | Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == 'c')) {  		action = SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd);  		lineAction = true;  	}  	else {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey);  		if (action == null)  			action = ViActionMaps.GetDirectionKeyAction (key' modifier);  		if (action != null)  			action = SelectionActions.FromMoveAction (action);  	}  	if (action != null) {  		if (lineAction)  			RunActions (action' ClipboardActions.Cut' ViActions.NewLineAbove);  		else  			RunActions (action' ClipboardActions.Cut);  		Status = "-- INSERT --";  		CurState = State.Insert;  		motion = Motion.None;  		Caret.Mode = CaretMode.Insert;  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Insert:  case State.Replace:  	action = GetInsertAction (key' modifier);  	if (action != null)  		RunAction (action);  	else if (unicodeKey != 0)  		InsertCharacter (unicodeKey);  	return;  case State.VisualLine:  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (true);  		return;  	case 'P':  		PasteBefore (true);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (SelectionActions.LineActionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Visual:  	if (IsInnerOrOuterMotionKey (unicodeKey' ref motion))  		return;  	if (motion != Motion.None) {  		action = ViActionMaps.GetEditObjectCharAction ((char)unicodeKey' motion);  		if (action != null) {  			RunAction (action);  			return;  		}  	}  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null) {  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	}  	if (action == null) {  		action = ViActionMaps.GetCommandCharAction ((char)unicodeKey);  	}  	if (action != null) {  		RunAction (ViActions.VisualSelectionFromMoveAction (action));  		return;  	}  	ApplyActionToSelection (modifier' unicodeKey);  	return;  case State.Command:  	switch (key) {  	case Gdk.Key.Return:  	case Gdk.Key.KP_Enter:  		Status = RunExCommand (commandBuffer.ToString ());  		commandBuffer.Length = 0;  		CurState = State.Normal;  		break;  	case Gdk.Key.BackSpace:  	case Gdk.Key.Delete:  	case Gdk.Key.KP_Delete:  		if (0 < commandBuffer.Length) {  			commandBuffer.Remove (commandBuffer.Length - 1' 1);  			Status = commandBuffer.ToString ();  			if (0 == commandBuffer.Length)  				Reset (Status);  		}  		break;  	default:  		if (unicodeKey != 0) {  			commandBuffer.Append ((char)unicodeKey);  			Status = commandBuffer.ToString ();  		}  		break;  	}  	return;  case State.WriteChar:  	if (unicodeKey != 0) {  		RunAction (SelectionActions.StartSelection);  		int roffset = Data.SelectionRange.Offset;  		InsertCharacter ((char)unicodeKey);  		Reset (string.Empty);  		Caret.Offset = roffset;  	}  	else {  		Reset ("Keystroke was not a character");  	}  	return;  case State.Indent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && unicodeKey == '>')) {  		RunAction (MiscActions.IndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.IndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.Unindent:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0 && ((char)unicodeKey) == '<')) {  		RunAction (MiscActions.RemoveIndentSelection);  		Reset ("");  		return;  	}  	action = ViActionMaps.GetNavCharAction ((char)unicodeKey);  	if (action == null)  		action = ViActionMaps.GetDirectionKeyAction (key' modifier);  	if (action != null) {  		RunActions (SelectionActions.FromMoveAction (action)' MiscActions.RemoveIndentSelection);  		Reset ("");  	}  	else {  		Reset ("Unrecognised motion");  	}  	return;  case State.G:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'g':  			Caret.Offset = 0;  			Reset ("");  			return;  		}  	}  	Reset ("Unknown command");  	return;  case State.Mark: {  	char k = (char)unicodeKey;  	ViMark mark = null;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Mark");  		return;  	}  	if (marks.ContainsKey (k)) {  		mark = marks [k];  	}  	else {  		mark = new ViMark (k);  		marks [k] = mark;  	}  	RunAction (mark.SaveMark);  	Reset ("");  	return;  }  case State.NameMacro: {  	char k = (char)unicodeKey;  	if (!char.IsLetterOrDigit (k)) {  		Reset ("Invalid Macro Name");  		return;  	}  	currentMacro = new ViMacro (k);  	currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();  	macros [k] = currentMacro;  	Reset ("");  	return;  }  case State.PlayMacro: {  	char k = (char)unicodeKey;  	if (k == '@')  		k = macros_lastplayed;  	if (macros.ContainsKey (k)) {  		Reset ("");  		macros_lastplayed = k;  		// FIXME play nice when playing macros from inside macros?  		ViMacro macroToPlay = macros [k];  		foreach (ViMacro.KeySet keySet in macroToPlay.KeysPressed) {  			HandleKeypress (keySet.Key' keySet.UnicodeKey' keySet.Modifiers);  			// FIXME stop on errors? essential with multipliers and nowrapscan  		}  		/* Once all the keys have been played back' quickly exit. */return;  	}  	else {  		Reset ("Invalid Macro Name '" + k + "'");  		return;  	}  }  case State.GoToMark: {  	char k = (char)unicodeKey;  	if (marks.ContainsKey (k)) {  		RunAction (marks [k].LoadMark);  		Reset ("");  	}  	else {  		Reset ("Unknown Mark");  	}  	return;  }  case State.Fold:  	if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  		switch ((char)unicodeKey) {  		case 'A':  			// Recursive fold toggle  			action = FoldActions.ToggleFoldRecursive;  			break;  		case 'C':  			// Recursive fold close  			action = FoldActions.CloseFoldRecursive;  			break;  		case 'M':  			// Close all folds  			action = FoldActions.CloseAllFolds;  			break;  		case 'O':  			// Recursive fold open  			action = FoldActions.OpenFoldRecursive;  			break;  		case 'R':  			// Expand all folds  			action = FoldActions.OpenAllFolds;  			break;  		case 'a':  			// Fold toggle  			action = FoldActions.ToggleFold;  			break;  		case 'c':  			// Fold close  			action = FoldActions.CloseFold;  			break;  		case 'o':  			// Fold open  			action = FoldActions.OpenFold;  			break;  		case 'z':  		case '.':  			editor.CenterToCaret ();  			Reset ("");  			break;  		default:  			Reset ("Unknown command");  			break;  		}  		if (null != action) {  			RunAction (action);  			Reset (string.Empty);  		}  	}  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret ();  		return;  	}  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret ();  		return;  	}  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {  	if (key == Gdk.Key.Delete)  		unicodeKey = 'x';  	switch ((char)unicodeKey) {  	case '?':  	case '/':  	case ':':  		CurState = State.Command;  		commandBuffer.Append ((char)unicodeKey);  		Status = commandBuffer.ToString ();  		return;  	case 'A':  		RunAction (CaretMoveActions.LineEnd);  		goto case 'i';  	case 'I':  		RunAction (CaretMoveActions.LineFirstNonWhitespace);  		goto case 'i';  	case 'a':  		//use CaretMoveActions so that we can move past last character on line end  		RunAction (CaretMoveActions.Right);  		goto case 'i';  	case 'i':  		Caret.Mode = CaretMode.Insert;  		Status = "-- INSERT --";  		CurState = State.Insert;  		return;  	case 'R':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.Replace;  		return;  	case 'V':  		Status = "-- VISUAL LINE --";  		Data.SetSelectLines (Caret.Line' Caret.Line);  		CurState = State.VisualLine;  		return;  	case 'v':  		Status = "-- VISUAL --";  		CurState = State.Visual;  		RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  		return;  	case 'd':  		Status = "d";  		CurState = State.Delete;  		return;  	case 'y':  		Status = "y";  		CurState = State.Yank;  		return;  	case 'Y':  		CurState = State.Yank;  		HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  		return;  	case 'O':  		RunAction (ViActions.NewLineAbove);  		goto case 'i';  	case 'o':  		RunAction (ViActions.NewLineBelow);  		goto case 'i';  	case 'r':  		Caret.Mode = CaretMode.Underscore;  		Status = "-- REPLACE --";  		CurState = State.WriteChar;  		return;  	case 'c':  		Caret.Mode = CaretMode.Insert;  		Status = "c";  		CurState = State.Change;  		return;  	case 'x':  		if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		ViActions.RetreatFromLineEnd (Data);  		return;  	case 'X':  		if (Data.Caret.Column == DocumentLocation.MinColumn)  			return;  		Status = string.Empty;  		if (!Data.IsSomethingSelected && 0 < Caret.Offset)  			RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  		else  			RunAction (ClipboardActions.Cut);  		return;  	case 'D':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		return;  	case 'C':  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  		goto case 'i';  	case '>':  		Status = ">";  		CurState = State.Indent;  		return;  	case '<':  		Status = "<";  		CurState = State.Unindent;  		return;  	case 'n':  		Search ();  		return;  	case 'N':  		searchBackward = !searchBackward;  		Search ();  		searchBackward = !searchBackward;  		return;  	case 'p':  		PasteAfter (false);  		return;  	case 'P':  		PasteBefore (false);  		return;  	case 's':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'S':  		if (!Data.IsSomethingSelected)  			RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  		else  			Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  		RunAction (ClipboardActions.Cut);  		goto case 'i';  	case 'g':  		Status = "g";  		CurState = State.G;  		return;  	case 'H':  		Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  		return;  	case 'J':  		RunAction (ViActions.Join);  		return;  	case 'L':  		int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case 'M':  		line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  		if (line < DocumentLocation.MinLine)  			line = Document.LineCount;  		Caret.Line = line;  		return;  	case '~':  		RunAction (ViActions.ToggleCase);  		return;  	case 'z':  		Status = "z";  		CurState = State.Fold;  		return;  	case 'm':  		Status = "m";  		CurState = State.Mark;  		return;  	case '`':  		Status = "`";  		CurState = State.GoToMark;  		return;  	case '@':  		Status = "@";  		CurState = State.PlayMacro;  		return;  	case 'q':  		if (currentMacro == null) {  			Status = "q";  			CurState = State.NameMacro;  			return;  		}  		currentMacro = null;  		Reset ("Macro Recorded");  		return;  	case '*':  		SearchWordAtCaret ();  		return;  	}  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret ();  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret ();  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret ();  	return;  }  
Magic Number,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following statement contains a magic number: line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: return data =>  {  	int beginOffset' length;  	if (TryFindInnerQuote (data' c' out beginOffset' out length)) {  		beginOffset--;  		length += 2;  		data.SelectionRange = new TextSegment (beginOffset' length);  	}  };  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: if (TryFindInnerQuote (data' c' out beginOffset' out length)) {  	beginOffset--;  	length += 2;  	data.SelectionRange = new TextSegment (beginOffset' length);  }  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,OuterQuote,The following statement contains a magic number: length += 2;  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: for (int i = start; forward && i < text.Length || !forward && i >= 0; i += increment) {  	if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  		return i;  }  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: for (int i = start; forward && i < text.Length || !forward && i >= 0; i += increment) {  	if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  		return i;  }  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  	return i;  
Magic Number,Mono.TextEditor.Vi,ViActions,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActions.cs,ParseForQuote,The following statement contains a magic number: if (text [i] == charToFind && (i < 1 || text [i - 1] != '\\') && (i < 2 || text [i - 2] != '\\'))  	return i;  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: for (int i = 0; i < command.Length; i++) {  	if (command [i] == '<') {  		int j = command.IndexOf ('>'' i);  		if (j < i + 2)  			throw new FormatException ("Could not find matching > at index " + i.ToString ());  		string seq = command.Substring (i + 1' j - i - 1);  		list.Add (ParseKeySequence (seq));  		i = j;  	}  	else {  		list.Add (command [i]);  	}  }  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: if (command [i] == '<') {  	int j = command.IndexOf ('>'' i);  	if (j < i + 2)  		throw new FormatException ("Could not find matching > at index " + i.ToString ());  	string seq = command.Substring (i + 1' j - i - 1);  	list.Add (ParseKeySequence (seq));  	i = j;  }  else {  	list.Add (command [i]);  }  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,Parse,The following statement contains a magic number: if (j < i + 2)  	throw new FormatException ("Could not find matching > at index " + i.ToString ());  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: while (seq.Length > 2 && seq [1] == '-') {  	switch (seq [0]) {  	case 'S':  		modifiers |= ModifierType.ShiftMask;  		break;  	case 'C':  		modifiers |= ModifierType.ControlMask;  		break;  	case 'M':  	case 'A':  		modifiers |= ModifierType.Mod1Mask;  		break;  	case 'D':  		modifiers |= ModifierType.MetaMask;  		//HACK: Mac command key  		break;  	default:  		throw new FormatException ("Unknown modifier " + seq [0].ToString ());  	}  	seq = seq.Substring (2);  }  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: while (seq.Length > 2 && seq [1] == '-') {  	switch (seq [0]) {  	case 'S':  		modifiers |= ModifierType.ShiftMask;  		break;  	case 'C':  		modifiers |= ModifierType.ControlMask;  		break;  	case 'M':  	case 'A':  		modifiers |= ModifierType.Mod1Mask;  		break;  	case 'D':  		modifiers |= ModifierType.MetaMask;  		//HACK: Mac command key  		break;  	default:  		throw new FormatException ("Unknown modifier " + seq [0].ToString ());  	}  	seq = seq.Substring (2);  }  
Magic Number,Mono.TextEditor.Vi,ViKeyNotation,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViKeyNotation.cs,ParseKeySequence,The following statement contains a magic number: seq = seq.Substring (2);  
Magic Number,Mono.TextEditor.Vi,ViBuilderContext,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilderContext.cs,RunAction,The following statement contains a magic number: if (Multiplier > 1) {  	for (int i = 0; i < System.Math.Min (100' Multiplier); i++)  		action (editor);  }  else {  	action (editor);  }  
Magic Number,Mono.TextEditor.Vi,ViBuilderContext,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilderContext.cs,RunAction,The following statement contains a magic number: for (int i = 0; i < System.Math.Min (100' Multiplier); i++)  	action (editor);  
Magic Number,Mono.TextEditor.Vi,ViBuilders,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: ctx.Builder = (ViBuilderContext x) =>  {  	int c = (int)x.LastKey.Char;  	if (c >= (int)'0' && c <= (int)'9') {  		//don't eat '0' if not preceded by non-zero digit  		//pass on to interpret as goto line start  		if (c == (int)'0' && factor == 1) {  			ctx.Multiplier *= multiplier;  			ctx.Builder = nextBuilder;  			return ctx.Builder (ctx);  		}  		int d = c - (int)'0';  		multiplier = multiplier * factor + d;  		factor *= 10;  		return true;  	}  	else {  		ctx.Multiplier *= multiplier;  		ctx.Builder = nextBuilder;  		return ctx.Builder (ctx);  	}  };  
Magic Number,Mono.TextEditor.Vi,ViBuilders,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: if (c >= (int)'0' && c <= (int)'9') {  	//don't eat '0' if not preceded by non-zero digit  	//pass on to interpret as goto line start  	if (c == (int)'0' && factor == 1) {  		ctx.Multiplier *= multiplier;  		ctx.Builder = nextBuilder;  		return ctx.Builder (ctx);  	}  	int d = c - (int)'0';  	multiplier = multiplier * factor + d;  	factor *= 10;  	return true;  }  else {  	ctx.Multiplier *= multiplier;  	ctx.Builder = nextBuilder;  	return ctx.Builder (ctx);  }  
Magic Number,Mono.TextEditor.Vi,ViBuilders,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViBuilders.cs,StartMultiplierBuilder,The following statement contains a magic number: factor *= 10;  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (evnt.Window)) {  	cr.Rectangle (evnt.Region.Clipbox.X' evnt.Region.Clipbox.Y' evnt.Region.Clipbox.Width' evnt.Region.Clipbox.Height);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Background);  	cr.Fill ();  	using (var layout = PangoUtil.CreateLayout (editor)) {  		layout.FontDescription = editor.Options.Font;  		layout.SetText ("000'00-00");  		int minstatusw' minstatush;  		layout.GetPixelSize (out minstatusw' out minstatush);  		var line = editor.GetLine (editor.Caret.Line);  		var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  		if (visColumn != editor.Caret.Column) {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  		}  		else {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  		}  		int statusw' statush;  		layout.GetPixelSize (out statusw' out statush);  		statusw = System.Math.Max (statusw' minstatusw);  		statusw += 8;  		cr.MoveTo (Allocation.Width - statusw' 0);  		statusw += 8;  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		layout.SetText (statusText ?? "");  		int w' h;  		layout.GetPixelSize (out w' out h);  		var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  		cr.MoveTo (x' 0);  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		if (ShowCaret) {  			if (editor.TextViewMargin.caretBlink) {  				cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight);  				cr.Fill ();  			}  		}  	}  }  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (Cairo.Context cr = Gdk.CairoHelper.Create (evnt.Window)) {  	cr.Rectangle (evnt.Region.Clipbox.X' evnt.Region.Clipbox.Y' evnt.Region.Clipbox.Width' evnt.Region.Clipbox.Height);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Background);  	cr.Fill ();  	using (var layout = PangoUtil.CreateLayout (editor)) {  		layout.FontDescription = editor.Options.Font;  		layout.SetText ("000'00-00");  		int minstatusw' minstatush;  		layout.GetPixelSize (out minstatusw' out minstatush);  		var line = editor.GetLine (editor.Caret.Line);  		var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  		if (visColumn != editor.Caret.Column) {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  		}  		else {  			layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  		}  		int statusw' statush;  		layout.GetPixelSize (out statusw' out statush);  		statusw = System.Math.Max (statusw' minstatusw);  		statusw += 8;  		cr.MoveTo (Allocation.Width - statusw' 0);  		statusw += 8;  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		layout.SetText (statusText ?? "");  		int w' h;  		layout.GetPixelSize (out w' out h);  		var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  		cr.MoveTo (x' 0);  		cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  		cr.ShowLayout (layout);  		if (ShowCaret) {  			if (editor.TextViewMargin.caretBlink) {  				cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight);  				cr.Fill ();  			}  		}  	}  }  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (var layout = PangoUtil.CreateLayout (editor)) {  	layout.FontDescription = editor.Options.Font;  	layout.SetText ("000'00-00");  	int minstatusw' minstatush;  	layout.GetPixelSize (out minstatusw' out minstatush);  	var line = editor.GetLine (editor.Caret.Line);  	var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  	if (visColumn != editor.Caret.Column) {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  	}  	else {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  	}  	int statusw' statush;  	layout.GetPixelSize (out statusw' out statush);  	statusw = System.Math.Max (statusw' minstatusw);  	statusw += 8;  	cr.MoveTo (Allocation.Width - statusw' 0);  	statusw += 8;  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	layout.SetText (statusText ?? "");  	int w' h;  	layout.GetPixelSize (out w' out h);  	var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  	cr.MoveTo (x' 0);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	if (ShowCaret) {  		if (editor.TextViewMargin.caretBlink) {  			cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight);  			cr.Fill ();  		}  	}  }  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: using (var layout = PangoUtil.CreateLayout (editor)) {  	layout.FontDescription = editor.Options.Font;  	layout.SetText ("000'00-00");  	int minstatusw' minstatush;  	layout.GetPixelSize (out minstatusw' out minstatush);  	var line = editor.GetLine (editor.Caret.Line);  	var visColumn = line.GetVisualColumn (editor.GetTextEditorData ()' editor.Caret.Column);  	if (visColumn != editor.Caret.Column) {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column + "-" + visColumn);  	}  	else {  		layout.SetText (editor.Caret.Line + "'" + editor.Caret.Column);  	}  	int statusw' statush;  	layout.GetPixelSize (out statusw' out statush);  	statusw = System.Math.Max (statusw' minstatusw);  	statusw += 8;  	cr.MoveTo (Allocation.Width - statusw' 0);  	statusw += 8;  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	layout.SetText (statusText ?? "");  	int w' h;  	layout.GetPixelSize (out w' out h);  	var x = System.Math.Min (0' -w + Allocation.Width - editor.TextViewMargin.CharWidth - statusw);  	cr.MoveTo (x' 0);  	cr.SetSourceColor (editor.ColorStyle.PlainText.Foreground);  	cr.ShowLayout (layout);  	if (ShowCaret) {  		if (editor.TextViewMargin.caretBlink) {  			cr.Rectangle (w + x' 0' (int)editor.TextViewMargin.CharWidth' (int)editor.LineHeight);  			cr.Fill ();  		}  	}  }  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: statusw += 8;  
Magic Number,Mono.TextEditor.Vi,ViStatusArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViStatusArea.cs,OnExposeEvent,The following statement contains a magic number: statusw += 8;  
Magic Number,Mono.TextEditor.PopupWindow,TooltipWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\TooltipWindow.cs,TooltipWindow,The following statement contains a magic number: this.BorderWidth = 2;  
Magic Number,Mono.TextEditor.PopupWindow,TooltipWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\TooltipWindow.cs,TooltipWindow,The following statement contains a magic number: this.BorderWidth = 3;  
Magic Number,Mono.TextEditor.PopupWindow,TooltipWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\TooltipWindow.cs,OnSizeAllocated,The following statement contains a magic number: if (NudgeHorizontal || NudgeVertical) {  	int x' y;  	this.GetPosition (out x' out y);  	int oldY = y' oldX = x;  	const int edgeGap = 2;  	//				int w = allocation.Width;  	//				  	//				if (fitWidthToScreen && (x + w >= screenW - edgeGap)) {  	//					int fittedWidth = screenW - x - edgeGap;  	//					if (fittedWidth < minFittedWidth) {  	//						x -= (minFittedWidth - fittedWidth);  	//						fittedWidth = minFittedWidth;  	//					}  	//					LimitWidth (fittedWidth);  	//				}  	Gdk.Rectangle geometry = Screen.GetUsableMonitorGeometry (Screen.GetMonitorAtPoint (x' y));  	if (NudgeHorizontal) {  		if (allocation.Width <= geometry.Width && x + allocation.Width >= geometry.Left + geometry.Width - edgeGap)  			x = geometry.Left + (geometry.Width - allocation.Width - edgeGap);  		if (x <= geometry.Left + edgeGap)  			x = geometry.Left + edgeGap;  	}  	if (NudgeVertical) {  		if (allocation.Height <= geometry.Height && y + allocation.Height >= geometry.Top + geometry.Height - edgeGap)  			y = geometry.Top + (geometry.Height - allocation.Height - edgeGap);  		if (y <= geometry.Top + edgeGap)  			y = geometry.Top + edgeGap;  	}  	if (y != oldY || x != oldX)  		Move (x' y);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: using (var cr = this.CreateXwtContext ()) {  	//avoid recreating the GC objects that we use multiple times  	var textColor = this.Style.Text (StateType.Normal).ToXwtColor ();  	int n = 0;  	n = (int)(vadj.Value / rowHeight);  	while (ypos < winHeight - margin && n < win.DataProvider.Count) {  		bool hasMarkup = false;  		IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  		if (markupListDataProvider != null) {  			if (markupListDataProvider.HasMarkup (n)) {  				layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  				hasMarkup = true;  			}  		}  		if (!hasMarkup)  			layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  		Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  		int iconHeight' iconWidth;  		if (icon != null) {  			iconWidth = (int)icon.Width;  			iconHeight = (int)icon.Height;  		}  		else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  			iconHeight = iconWidth = 24;  		}  		var s = layout.GetSize ();  		int typos' iypos;  		int he = (int)s.Height;  		typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  		iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  		if (n == selection) {  			if (!disableSelection) {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Fill ();  				cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  			else {  				cr.Rectangle (margin' ypos' lineWidth' he + padding);  				cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  				cr.Stroke ();  				cr.SetColor (textColor);  				cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  			}  		}  		else {  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		if (icon != null)  			cr.DrawImage (icon' xpos' iypos);  		ypos += rowHeight;  		n++;  		//reset the markup or it carries over to the next SetText  		if (hasMarkup)  			layout.Markup = string.Empty;  	}  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: while (ypos < winHeight - margin && n < win.DataProvider.Count) {  	bool hasMarkup = false;  	IMarkupListDataProvider<T> markupListDataProvider = win.DataProvider as IMarkupListDataProvider<T>;  	if (markupListDataProvider != null) {  		if (markupListDataProvider.HasMarkup (n)) {  			layout.Markup = (markupListDataProvider.GetMarkup (n) ?? "&lt;null&gt;");  			hasMarkup = true;  		}  	}  	if (!hasMarkup)  		layout.Text = (win.DataProvider.GetText (n) ?? "<null>");  	Xwt.Drawing.Image icon = win.DataProvider.GetIcon (n);  	int iconHeight' iconWidth;  	if (icon != null) {  		iconWidth = (int)icon.Width;  		iconHeight = (int)icon.Height;  	}  	else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  		iconHeight = iconWidth = 24;  	}  	var s = layout.GetSize ();  	int typos' iypos;  	int he = (int)s.Height;  	typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  	iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  	if (n == selection) {  		if (!disableSelection) {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Fill ();  			cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  		else {  			cr.Rectangle (margin' ypos' lineWidth' he + padding);  			cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  			cr.Stroke ();  			cr.SetColor (textColor);  			cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  		}  	}  	else {  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	if (icon != null)  		cr.DrawImage (icon' xpos' iypos);  	ypos += rowHeight;  	n++;  	//reset the markup or it carries over to the next SetText  	if (hasMarkup)  		layout.Markup = string.Empty;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (icon != null) {  	iconWidth = (int)icon.Width;  	iconHeight = (int)icon.Height;  }  else if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  	iconHeight = iconWidth = 24;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (!Gtk.Icon.SizeLookup (Gtk.IconSize.Menu' out iconWidth' out iconHeight)) {  	iconHeight = iconWidth = 24;  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: iconHeight = iconWidth = 24;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: typos = he < rowHeight ? ypos + (rowHeight - he) / 2 : ypos;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: iypos = iconHeight < rowHeight ? ypos + (rowHeight - iconHeight) / 2 : ypos;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (n == selection) {  	if (!disableSelection) {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Fill ();  		cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	else {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Stroke ();  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  }  else {  	cr.SetColor (textColor);  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (n == selection) {  	if (!disableSelection) {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Fill ();  		cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	else {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Stroke ();  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  }  else {  	cr.SetColor (textColor);  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (n == selection) {  	if (!disableSelection) {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Fill ();  		cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  	else {  		cr.Rectangle (margin' ypos' lineWidth' he + padding);  		cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  		cr.Stroke ();  		cr.SetColor (textColor);  		cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  	}  }  else {  	cr.SetColor (textColor);  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (!disableSelection) {  	cr.Rectangle (margin' ypos' lineWidth' he + padding);  	cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  	cr.Fill ();  	cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  else {  	cr.Rectangle (margin' ypos' lineWidth' he + padding);  	cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  	cr.Stroke ();  	cr.SetColor (textColor);  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: if (!disableSelection) {  	cr.Rectangle (margin' ypos' lineWidth' he + padding);  	cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  	cr.Fill ();  	cr.SetColor (this.Style.Text (StateType.Selected).ToXwtColor ());  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  else {  	cr.Rectangle (margin' ypos' lineWidth' he + padding);  	cr.SetColor (this.Style.Base (StateType.Selected).ToXwtColor ());  	cr.Stroke ();  	cr.SetColor (textColor);  	cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  }  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,DrawList,The following statement contains a magic number: cr.DrawTextLayout (layout' xpos + iconWidth + 2' typos);  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,CalcVisibleRows,The following statement contains a magic number: visibleRows = 7;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,CalcVisibleRows,The following statement contains a magic number: if (this.win.DataProvider.Count > this.visibleRows)  	newHeight = (rowHeight * visibleRows) + margin * 2;  else  	newHeight = (rowHeight * this.win.DataProvider.Count) + margin * 2;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,CalcVisibleRows,The following statement contains a magic number: if (this.win.DataProvider.Count > this.visibleRows)  	newHeight = (rowHeight * visibleRows) + margin * 2;  else  	newHeight = (rowHeight * this.win.DataProvider.Count) + margin * 2;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,CalcVisibleRows,The following statement contains a magic number: newHeight = (rowHeight * visibleRows) + margin * 2;  
Magic Number,Mono.TextEditor.PopupWindow,ListWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWidget.cs,CalcVisibleRows,The following statement contains a magic number: newHeight = (rowHeight * this.win.DataProvider.Count) + margin * 2;  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnSizeRequested,The following statement contains a magic number: xSpacer += xBorder * 2 + 1;  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnSizeRequested,The following statement contains a magic number: requisition.Width = descriptionWidth + xSpacer + xBorder * 2 + 1;  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1;  	Gdk.GC gc = new Gdk.GC (args.Window);  	layout.SetMarkup (TitleText);  	int width' height;  	layout.GetPixelSize (out width' out height);  	width += xBorder * 2;  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' yBorder);  	g.ShowLayout (layout);  	g.Restore ();  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  	g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  	int y = height + yBorder * 2;  	for (int i = 0; i < Items.Count; i++) {  		KeyValuePair<string' string> pair = Items [i];  		layout.SetMarkup (pair.Key);  		layout.GetPixelSize (out width' out height);  		if (i == 0) {  			FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  			g.SetSourceColor (categoryBgColor);  			g.FillPreserve ();  			g.SetSourceColor (borderColor);  			g.Stroke ();  			g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  			g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xBorder' y);  		g.ShowLayout (layout);  		g.Restore ();  		g.Save ();  		g.SetSourceColor (textColor);  		g.Translate (xSpacer + xBorder' y);  		layout.SetMarkup (pair.Value);  		g.ShowLayout (layout);  		g.Restore ();  		// draw top line  		if (i > 0) {  			g.MoveTo (1' y + 0.5);  			g.LineTo (Allocation.Width - 1' y + 0.5);  			g.SetSourceColor (gridColor);  			g.Stroke ();  		}  		y += height;  	}  	gc.Dispose ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: width += xBorder * 2;  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' 0.5' 0.5' height + yBorder * 2 + 1.5' width' height + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' 0.5' height * 2 + yBorder * 2 + 0.5' height' Allocation.Width - 1' Allocation.Height - height * 2 - yBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (xSpacer + 0.5' height * 2 + yBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (xSpacer + 0.5' Allocation.Height - 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: for (int i = 0; i < Items.Count; i++) {  	KeyValuePair<string' string> pair = Items [i];  	layout.SetMarkup (pair.Key);  	layout.GetPixelSize (out width' out height);  	if (i == 0) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  		g.SetSourceColor (categoryBgColor);  		g.FillPreserve ();  		g.SetSourceColor (borderColor);  		g.Stroke ();  		g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  		g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	gc.RgbFgColor = (HslColor)(i == 0 ? bgColor : textColor);  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xBorder' y);  	g.ShowLayout (layout);  	g.Restore ();  	g.Save ();  	g.SetSourceColor (textColor);  	g.Translate (xSpacer + xBorder' y);  	layout.SetMarkup (pair.Value);  	g.ShowLayout (layout);  	g.Restore ();  	// draw top line  	if (i > 0) {  		g.MoveTo (1' y + 0.5);  		g.LineTo (Allocation.Width - 1' y + 0.5);  		g.SetSourceColor (gridColor);  		g.Stroke ();  	}  	y += height;  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i == 0) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  	g.SetSourceColor (categoryBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  	g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' false' false' 0' y + 0.5' height + 1.5' Allocation.Width' height);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (xSpacer + 0.5' height + yBorder * 2 + 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (xSpacer + 0.5' height * 2 + yBorder * 2 + 1);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i > 0) {  	g.MoveTo (1' y + 0.5);  	g.LineTo (Allocation.Width - 1' y + 0.5);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (i > 0) {  	g.MoveTo (1' y + 0.5);  	g.LineTo (Allocation.Width - 1' y + 0.5);  	g.SetSourceColor (gridColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (1' y + 0.5);  
Magic Number,Mono.TextEditor.PopupWindow,TableLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (Allocation.Width - 1' y + 0.5);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnSizeRequested,The following statement contains a magic number: xSpacer += xDescriptionBorder * 2 + 1;  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: using (var g = Gdk.CairoHelper.Create (args.Window)) {  	g.Translate (Allocation.X' Allocation.Y);  	g.LineWidth = 1.5;  	titleLayout.SetMarkup (TitleText);  	int width' height;  	titleLayout.GetPixelSize (out width' out height);  	var tw = SupportsAlpha ? triangleWidth : 0;  	var th = SupportsAlpha ? triangleHeight : 0;  	width += xDescriptionBorder * 2;  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  	}  	else {  		g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  	}  	g.SetSourceColor (titleBgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	g.MoveTo (tw + xDescriptionBorder' yTitleBorder);  	g.SetSourceColor (titleTextColor);  	g.ShowLayout (titleLayout);  	if (SupportsAlpha) {  		FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  	}  	else {  		g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  	}  	g.SetSourceColor (bgColor);  	g.FillPreserve ();  	g.SetSourceColor (borderColor);  	g.Stroke ();  	if (SupportsAlpha) {  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  		g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  		g.ClosePath ();  		g.SetSourceColor (bgColor);  		g.Fill ();  		g.MoveTo (tw' Allocation.Height / 2 - th / 2);  		g.LineTo (0' Allocation.Height / 2);  		g.LineTo (tw' Allocation.Height / 2 + th / 2);  		g.SetSourceColor (borderColor);  		g.Stroke ();  	}  	int y = height + yTitleBorder * 2 + yDescriptionBorder;  	g.MoveTo (tw + xDescriptionBorder' y);  	g.SetSourceColor (textColor);  	g.ShowLayout (descriptionLayout);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineWidth = 1.5;  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: width += xDescriptionBorder * 2;  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  }  else {  	g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' true' false' tw + 0.5' 0.5' height + yTitleBorder * 2 + 1.5' Allocation.Width - 1 - tw' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.Rectangle (0' 0' Allocation.Width' height + yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  }  else {  	g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: FoldingScreenbackgroundRenderer.DrawRoundRectangle (g' false' true' tw + 0.5' height + yTitleBorder * 2 + 0.5' height' Allocation.Width - 1 - tw' Allocation.Height - height - yTitleBorder * 2 - 1);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.Rectangle (0' height + yTitleBorder * 2' Allocation.Width' Allocation.Height - height - yTitleBorder * 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: if (SupportsAlpha) {  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  	g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  	g.ClosePath ();  	g.SetSourceColor (bgColor);  	g.Fill ();  	g.MoveTo (tw' Allocation.Height / 2 - th / 2);  	g.LineTo (0' Allocation.Height / 2);  	g.LineTo (tw' Allocation.Height / 2 + th / 2);  	g.SetSourceColor (borderColor);  	g.Stroke ();  }  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (tw' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (tw' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (0' Allocation.Height / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw + 5' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (tw' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.MoveTo (tw' Allocation.Height / 2 - th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (0' Allocation.Height / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.PopupWindow,InsertionCursorLayoutModeHelpWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ModeHelpWindow.cs,OnExposeEvent,The following statement contains a magic number: g.LineTo (tw' Allocation.Height / 2 + th / 2);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: switch (easing) {  case Easing.QuadraticIn:  	return percent * percent;  case Easing.QuadraticOut:  	return -1.0 * percent * (percent - 2.0);  case Easing.QuadraticInOut:  	percent *= 2.0;  	return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  case Easing.ExponentialIn:  	return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  case Easing.ExponentialOut:  	return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  case Easing.ExponentialInOut:  	percent *= 2.0;  	return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  case Easing.Sine:  	return System.Math.Sin (percent * System.Math.PI);  case Easing.Linear:  default:  	return percent;  }  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return -1.0 * percent * (percent - 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: percent *= 2.0;  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? percent * percent * 0.5 : -0.5 * (--percent * (percent - 2.0) - 1.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return System.Math.Pow (2.0' 10.0 * (percent - 1.0));  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return -System.Math.Pow (2.0' -10.0 * percent) + 1.0;  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: percent *= 2.0;  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,Choreographer,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\Choreographer.cs,Compose,The following statement contains a magic number: return percent < 1.0 ? 0.5 * System.Math.Pow (2.0' 10.0 * (percent - 1.0)) : 0.5 * (-System.Math.Pow (2.0' -10.0 * --percent) + 2.0);  
Magic Number,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnSizeAllocated,The following statement contains a magic number: if (horizontal) {  	allocation.X += start_border;  	allocation.Y += (int)BorderWidth;  	allocation.Height -= (int)BorderWidth * 2;  }  else {  	allocation.X += (int)BorderWidth;  	allocation.Y += start_border;  	allocation.Width -= (int)BorderWidth * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnSizeAllocated,The following statement contains a magic number: if (horizontal) {  	allocation.X += start_border;  	allocation.Y += (int)BorderWidth;  	allocation.Height -= (int)BorderWidth * 2;  }  else {  	allocation.X += (int)BorderWidth;  	allocation.Y += start_border;  	allocation.Width -= (int)BorderWidth * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnSizeAllocated,The following statement contains a magic number: allocation.Height -= (int)BorderWidth * 2;  
Magic Number,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnSizeAllocated,The following statement contains a magic number: allocation.Width -= (int)BorderWidth * 2;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWindow,The following statement contains a magic number: Duration = 500;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWindow,The following statement contains a magic number: ExpandWidth = 12;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWindow,The following statement contains a magic number: ExpandHeight = 2;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWindow,The following statement contains a magic number: stage.UpdateFrequency = 10;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,Popup,The following statement contains a magic number: x = x + bounds.X - (int)(ExpandWidth / 2);  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,Popup,The following statement contains a magic number: y = y + bounds.Y - (int)(ExpandHeight / 2);  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 2.0 - actor.Percent * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 2.0 - actor.Percent * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 2.0 - actor.Percent * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 2.0 - actor.Percent * 2;  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: opacity = 2.0 - actor.Percent * 2;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: opacity = 2.0 - actor.Percent * 2;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWidget,The following statement contains a magic number: Duration = 500;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWidget,The following statement contains a magic number: ExpandWidth = 12;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWidget,The following statement contains a magic number: ExpandHeight = 2;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,BounceFadePopupWidget,The following statement contains a magic number: stage.UpdateFrequency = 10;  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 1 - 2 * (actor.Percent - 0.5);  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 1 - 2 * (actor.Percent - 0.5);  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 1 - 2 * (actor.Percent - 0.5);  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: if (actor.Percent < 0.5) {  	scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  	opacity = 1.0;  }  //for the second half' vary opacity linearly from 1 to 0.  else {  	scale = Choreographer.Compose (1.0' BounceEasing);  	opacity = 1 - 2 * (actor.Percent - 0.5);  }  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: scale = Choreographer.Compose (actor.Percent * 2' BounceEasing);  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: opacity = 1 - 2 * (actor.Percent - 0.5);  
Magic Number,Mono.TextEditor.Theatrics,BounceFadePopupWidget,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\BounceFadePopupWindow.cs,OnAnimationActorStep,The following statement contains a magic number: opacity = 1 - 2 * (actor.Percent - 0.5);  
Magic Number,Mono.TextEditor.Utils,Hunk,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,Hunk,The following statement contains a magic number: this.Context = 3;  
Magic Number,Mono.TextEditor.Utils,Hunk,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,Overlaps,The following statement contains a magic number: return DistanceTo (other) < this.Context * 2;  
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: for (int D = 0; D <= MaxD; D++) {  	// Extend the forward path.  	for (int k = downK - D; k <= downK + D; k += 2) {  		// Debug.Write(0' "SMS"' "extend forward path " + k.ToString());  		// find the only or better starting point  		int x' y;  		if (k == downK - D) {  			x = downVector [downOffset + k + 1];  			// down  		}  		else {  			x = downVector [downOffset + k - 1] + 1;  			// a step to the right  			if (k < downK + D && downVector [downOffset + k + 1] >= x)  				x = downVector [downOffset + k + 1];  			// down  		}  		y = x - k;  		// find the end of the furthest reaching forward D-path in diagonal k.  		while (x < upperA && y < upperB && dataA.Data [x].Equals (dataB.Data [y])) {  			x++;  			y++;  		}  		downVector [downOffset + k] = x;  		// overlap ?  		if (oddDelta && upK - D < k && k < upK + D) {  			if (upVector [upOffset + k] <= downVector [downOffset + k]) {  				ret.x = downVector [downOffset + k];  				ret.y = downVector [downOffset + k] - k;  				// ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points  				// ret.v = UpVector[UpOffset + k] - k;  				return (ret);  			}  			// if  		}  		// if  	}  	// for k  	// Extend the reverse path.  	for (int k = upK - D; k <= upK + D; k += 2) {  		// Debug.Write(0' "SMS"' "extend reverse path " + k.ToString());  		// find the only or better starting point  		int x' y;  		if (k == upK + D) {  			x = upVector [upOffset + k - 1];  			// up  		}  		else {  			x = upVector [upOffset + k + 1] - 1;  			// left  			if (k > upK - D && upVector [upOffset + k - 1] < x)  				x = upVector [upOffset + k - 1];  			// up  		}  		// if  		y = x - k;  		while (x > lowerA && y > lowerB && dataA.Data [x - 1].Equals (dataB.Data [y - 1])) {  			x--;  			y--;  			// diagonal  		}  		upVector [upOffset + k] = x;  		// overlap ?  		if (!oddDelta && downK - D <= k && k <= downK + D) {  			if (upVector [upOffset + k] <= downVector [downOffset + k]) {  				ret.x = downVector [downOffset + k];  				ret.y = downVector [downOffset + k] - k;  				// ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points  				// ret.v = UpVector[UpOffset + k] - k;  				return (ret);  			}  			// if  		}  		// if  	}  	// for k  }  
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: for (int D = 0; D <= MaxD; D++) {  	// Extend the forward path.  	for (int k = downK - D; k <= downK + D; k += 2) {  		// Debug.Write(0' "SMS"' "extend forward path " + k.ToString());  		// find the only or better starting point  		int x' y;  		if (k == downK - D) {  			x = downVector [downOffset + k + 1];  			// down  		}  		else {  			x = downVector [downOffset + k - 1] + 1;  			// a step to the right  			if (k < downK + D && downVector [downOffset + k + 1] >= x)  				x = downVector [downOffset + k + 1];  			// down  		}  		y = x - k;  		// find the end of the furthest reaching forward D-path in diagonal k.  		while (x < upperA && y < upperB && dataA.Data [x].Equals (dataB.Data [y])) {  			x++;  			y++;  		}  		downVector [downOffset + k] = x;  		// overlap ?  		if (oddDelta && upK - D < k && k < upK + D) {  			if (upVector [upOffset + k] <= downVector [downOffset + k]) {  				ret.x = downVector [downOffset + k];  				ret.y = downVector [downOffset + k] - k;  				// ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points  				// ret.v = UpVector[UpOffset + k] - k;  				return (ret);  			}  			// if  		}  		// if  	}  	// for k  	// Extend the reverse path.  	for (int k = upK - D; k <= upK + D; k += 2) {  		// Debug.Write(0' "SMS"' "extend reverse path " + k.ToString());  		// find the only or better starting point  		int x' y;  		if (k == upK + D) {  			x = upVector [upOffset + k - 1];  			// up  		}  		else {  			x = upVector [upOffset + k + 1] - 1;  			// left  			if (k > upK - D && upVector [upOffset + k - 1] < x)  				x = upVector [upOffset + k - 1];  			// up  		}  		// if  		y = x - k;  		while (x > lowerA && y > lowerB && dataA.Data [x - 1].Equals (dataB.Data [y - 1])) {  			x--;  			y--;  			// diagonal  		}  		upVector [upOffset + k] = x;  		// overlap ?  		if (!oddDelta && downK - D <= k && k <= downK + D) {  			if (upVector [upOffset + k] <= downVector [downOffset + k]) {  				ret.x = downVector [downOffset + k];  				ret.y = downVector [downOffset + k] - k;  				// ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points  				// ret.v = UpVector[UpOffset + k] - k;  				return (ret);  			}  			// if  		}  		// if  	}  	// for k  }  
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: for (int k = downK - D; k <= downK + D; k += 2) {  	// Debug.Write(0' "SMS"' "extend forward path " + k.ToString());  	// find the only or better starting point  	int x' y;  	if (k == downK - D) {  		x = downVector [downOffset + k + 1];  		// down  	}  	else {  		x = downVector [downOffset + k - 1] + 1;  		// a step to the right  		if (k < downK + D && downVector [downOffset + k + 1] >= x)  			x = downVector [downOffset + k + 1];  		// down  	}  	y = x - k;  	// find the end of the furthest reaching forward D-path in diagonal k.  	while (x < upperA && y < upperB && dataA.Data [x].Equals (dataB.Data [y])) {  		x++;  		y++;  	}  	downVector [downOffset + k] = x;  	// overlap ?  	if (oddDelta && upK - D < k && k < upK + D) {  		if (upVector [upOffset + k] <= downVector [downOffset + k]) {  			ret.x = downVector [downOffset + k];  			ret.y = downVector [downOffset + k] - k;  			// ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points  			// ret.v = UpVector[UpOffset + k] - k;  			return (ret);  		}  		// if  	}  	// if  }  
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: k += 2
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: for (int k = upK - D; k <= upK + D; k += 2) {  	// Debug.Write(0' "SMS"' "extend reverse path " + k.ToString());  	// find the only or better starting point  	int x' y;  	if (k == upK + D) {  		x = upVector [upOffset + k - 1];  		// up  	}  	else {  		x = upVector [upOffset + k + 1] - 1;  		// left  		if (k > upK - D && upVector [upOffset + k - 1] < x)  			x = upVector [upOffset + k - 1];  		// up  	}  	// if  	y = x - k;  	while (x > lowerA && y > lowerB && dataA.Data [x - 1].Equals (dataB.Data [y - 1])) {  		x--;  		y--;  		// diagonal  	}  	upVector [upOffset + k] = x;  	// overlap ?  	if (!oddDelta && downK - D <= k && k <= downK + D) {  		if (upVector [upOffset + k] <= downVector [downOffset + k]) {  			ret.x = downVector [downOffset + k];  			ret.y = downVector [downOffset + k] - k;  			// ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points  			// ret.v = UpVector[UpOffset + k] - k;  			return (ret);  		}  		// if  	}  	// if  }  
Magic Number,Mono.TextEditor.Utils,Diff,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,SMS,The following statement contains a magic number: k += 2
Magic Number,Mono.TextEditor.Utils,DiffData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\Diff.cs,DiffData,The following statement contains a magic number: Modified = new bool[Length + 2];  
Magic Number,Mono.TextEditor.Utils,TextFileUtility,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\TextFileUtility.cs,AutoDetectEncoding,The following statement contains a magic number: try {  	int max = (int)System.Math.Min (stream.Length' 50 * 1024);  	byte[] readBuf = new byte[max];  	int readLength = stream.Read (readBuf' 0' max);  	stream.Position = 0;  	// Store the dfa data from the verifiers in local variables.  	byte[] states = new byte[verifiers.Length];  	int verifiersRunning = verifiers.Length;  	for (int i = 0; i < verifiers.Length; i++)  		states [i] = verifiers [i].InitalState;  	// run the verifiers  	fixed (byte* bBeginPtr = readBuf' stateBeginPtr = states) {  		byte* bPtr = bBeginPtr;  		byte* bEndPtr = bBeginPtr + readLength;  		byte* sEndPtr = stateBeginPtr + states.Length;  		while (bPtr != bEndPtr) {  			byte* sPtr = stateBeginPtr;  			int i = 0;  			while (sPtr != sEndPtr) {  				byte curState = *sPtr;  				if (curState != 0) {  					curState = stateTables [i] [curState] [*bPtr];  					if (curState == 0) {  						verifiersRunning--;  						if (verifiersRunning == 0)  							goto finishVerify;  					}  					*sPtr = curState;  				}  				sPtr++;  				i++;  			}  			bPtr++;  		}  		finishVerify:  		if (verifiersRunning > 0) {  			//						Console.WriteLine ("valid encodings:");  			//						for (int i = 0; i < verifiers.Length; i++) {  			//							if (verifiers [i].IsEncodingValid (states [i]))  			//								Console.WriteLine (verifiers [i].Encoding.EncodingName);  			//						}  			//						Console.WriteLine ("---------------");  			for (int i = 0; i < verifiers.Length; i++) {  				if (verifiers [i].IsEncodingValid (states [i]))  					return verifiers [i].Encoding;  			}  		}  	}  }  catch (Exception e) {  	Console.WriteLine (e);  }  
Magic Number,Mono.TextEditor.Utils,TextFileUtility,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\TextFileUtility.cs,AutoDetectEncoding,The following statement contains a magic number: try {  	int max = (int)System.Math.Min (stream.Length' 50 * 1024);  	byte[] readBuf = new byte[max];  	int readLength = stream.Read (readBuf' 0' max);  	stream.Position = 0;  	// Store the dfa data from the verifiers in local variables.  	byte[] states = new byte[verifiers.Length];  	int verifiersRunning = verifiers.Length;  	for (int i = 0; i < verifiers.Length; i++)  		states [i] = verifiers [i].InitalState;  	// run the verifiers  	fixed (byte* bBeginPtr = readBuf' stateBeginPtr = states) {  		byte* bPtr = bBeginPtr;  		byte* bEndPtr = bBeginPtr + readLength;  		byte* sEndPtr = stateBeginPtr + states.Length;  		while (bPtr != bEndPtr) {  			byte* sPtr = stateBeginPtr;  			int i = 0;  			while (sPtr != sEndPtr) {  				byte curState = *sPtr;  				if (curState != 0) {  					curState = stateTables [i] [curState] [*bPtr];  					if (curState == 0) {  						verifiersRunning--;  						if (verifiersRunning == 0)  							goto finishVerify;  					}  					*sPtr = curState;  				}  				sPtr++;  				i++;  			}  			bPtr++;  		}  		finishVerify:  		if (verifiersRunning > 0) {  			//						Console.WriteLine ("valid encodings:");  			//						for (int i = 0; i < verifiers.Length; i++) {  			//							if (verifiers [i].IsEncodingValid (states [i]))  			//								Console.WriteLine (verifiers [i].Encoding.EncodingName);  			//						}  			//						Console.WriteLine ("---------------");  			for (int i = 0; i < verifiers.Length; i++) {  				if (verifiers [i].IsEncodingValid (states [i]))  					return verifiers [i].Encoding;  			}  		}  	}  }  catch (Exception e) {  	Console.WriteLine (e);  }  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: for (int i = 0; i < colorList.Count; i++) {  	var color = colorList [i];  	colorTable.Append (@"\red");  	colorTable.Append ((int)(255 * color.R));  	colorTable.Append (@"\green");  	colorTable.Append ((int)(255 * color.G));  	colorTable.Append (@"\blue");  	colorTable.Append ((int)(255 * color.B));  	colorTable.Append (";");  }  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: for (int i = 0; i < colorList.Count; i++) {  	var color = colorList [i];  	colorTable.Append (@"\red");  	colorTable.Append ((int)(255 * color.R));  	colorTable.Append (@"\green");  	colorTable.Append ((int)(255 * color.G));  	colorTable.Append (@"\blue");  	colorTable.Append ((int)(255 * color.B));  	colorTable.Append (";");  }  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: for (int i = 0; i < colorList.Count; i++) {  	var color = colorList [i];  	colorTable.Append (@"\red");  	colorTable.Append ((int)(255 * color.R));  	colorTable.Append (@"\green");  	colorTable.Append ((int)(255 * color.G));  	colorTable.Append (@"\blue");  	colorTable.Append ((int)(255 * color.B));  	colorTable.Append (";");  }  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: colorTable.Append ((int)(255 * color.R));  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: colorTable.Append ((int)(255 * color.G));  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,CreateColorTable,The following statement contains a magic number: colorTable.Append ((int)(255 * color.B));  
Magic Number,Mono.TextEditor.Utils,RtfWriter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\RtfWriter.cs,GenerateRtf,The following statement contains a magic number: try {  	string fontName = options.Font.ToString ();  	double fontSize = Double.Parse (fontName.Substring (fontName.LastIndexOf (' ') + 1)' System.Globalization.CultureInfo.InvariantCulture) * 2;  	rtf.Append (@"\fs");  	rtf.Append (fontSize);  }  catch (Exception) {  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,InsertBalanceTree,The following statement contains a magic number: while (node != null) {  	node.Balance += balance;  	balance = node.Balance;  	if (balance == 0)  		return;  	if (balance == -2) {  		if (node.Left.Balance < 1) {  			RotateRight (node);  		}  		else {  			RotateLeftRight (node);  		}  		return;  	}  	if (balance == 2) {  		if (node.Right.Balance > -1) {  			RotateLeft (node);  		}  		else {  			RotateRightLeft (node);  		}  		return;  	}  	var parent = node.Parent;  	if (parent != null)  		balance = parent.Left == node ? (sbyte)-1 : (sbyte)1;  	node = parent;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,InsertBalanceTree,The following statement contains a magic number: while (node != null) {  	node.Balance += balance;  	balance = node.Balance;  	if (balance == 0)  		return;  	if (balance == -2) {  		if (node.Left.Balance < 1) {  			RotateRight (node);  		}  		else {  			RotateLeftRight (node);  		}  		return;  	}  	if (balance == 2) {  		if (node.Right.Balance > -1) {  			RotateLeft (node);  		}  		else {  			RotateRightLeft (node);  		}  		return;  	}  	var parent = node.Parent;  	if (parent != null)  		balance = parent.Left == node ? (sbyte)-1 : (sbyte)1;  	node = parent;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,InsertBalanceTree,The following statement contains a magic number: if (balance == -2) {  	if (node.Left.Balance < 1) {  		RotateRight (node);  	}  	else {  		RotateLeftRight (node);  	}  	return;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,InsertBalanceTree,The following statement contains a magic number: if (balance == 2) {  	if (node.Right.Balance > -1) {  		RotateLeft (node);  	}  	else {  		RotateRightLeft (node);  	}  	return;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,The following statement contains a magic number: while (node != null) {  	node.Balance += balance;  	balance = node.Balance;  	if (balance == -2) {  		if (node.Left.Balance < 1) {  			RotateRight (node);  			if (node.Balance == 0) {  				node = node.Parent;  			}  			else if (node.Balance == -1)  				return;  		}  		else {  			RotateLeftRight (node);  			node = node.Parent;  		}  	}  	else if (balance == 2) {  		if (node.Right.Balance > -1) {  			RotateLeft (node);  			if (node.Balance == 0) {  				node = node.Parent;  			}  			else if (node.Balance == 1)  				return;  		}  		else {  			RotateRightLeft (node);  			node = node.Parent;  		}  	}  	else if (node.Balance != 0) {  		return;  	}  	var parent = node.Parent;  	if (parent != null)  		balance = parent.Left == node ? (sbyte)1 : (sbyte)-1;  	node = parent;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,The following statement contains a magic number: while (node != null) {  	node.Balance += balance;  	balance = node.Balance;  	if (balance == -2) {  		if (node.Left.Balance < 1) {  			RotateRight (node);  			if (node.Balance == 0) {  				node = node.Parent;  			}  			else if (node.Balance == -1)  				return;  		}  		else {  			RotateLeftRight (node);  			node = node.Parent;  		}  	}  	else if (balance == 2) {  		if (node.Right.Balance > -1) {  			RotateLeft (node);  			if (node.Balance == 0) {  				node = node.Parent;  			}  			else if (node.Balance == 1)  				return;  		}  		else {  			RotateRightLeft (node);  			node = node.Parent;  		}  	}  	else if (node.Balance != 0) {  		return;  	}  	var parent = node.Parent;  	if (parent != null)  		balance = parent.Left == node ? (sbyte)1 : (sbyte)-1;  	node = parent;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,The following statement contains a magic number: if (balance == -2) {  	if (node.Left.Balance < 1) {  		RotateRight (node);  		if (node.Balance == 0) {  			node = node.Parent;  		}  		else if (node.Balance == -1)  			return;  	}  	else {  		RotateLeftRight (node);  		node = node.Parent;  	}  }  else if (balance == 2) {  	if (node.Right.Balance > -1) {  		RotateLeft (node);  		if (node.Balance == 0) {  			node = node.Parent;  		}  		else if (node.Balance == 1)  			return;  	}  	else {  		RotateRightLeft (node);  		node = node.Parent;  	}  }  else if (node.Balance != 0) {  	return;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,The following statement contains a magic number: if (balance == -2) {  	if (node.Left.Balance < 1) {  		RotateRight (node);  		if (node.Balance == 0) {  			node = node.Parent;  		}  		else if (node.Balance == -1)  			return;  	}  	else {  		RotateLeftRight (node);  		node = node.Parent;  	}  }  else if (balance == 2) {  	if (node.Right.Balance > -1) {  		RotateLeft (node);  		if (node.Balance == 0) {  			node = node.Parent;  		}  		else if (node.Balance == 1)  			return;  	}  	else {  		RotateRightLeft (node);  		node = node.Parent;  	}  }  else if (node.Balance != 0) {  	return;  }  
Magic Number,Mono.TextEditor.Utils,AvlTree,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Utils\AvlTree.cs,DeleteBalanceTree,The following statement contains a magic number: if (balance == 2) {  	if (node.Right.Balance > -1) {  		RotateLeft (node);  		if (node.Balance == 0) {  			node = node.Parent;  		}  		else if (node.Balance == 1)  			return;  	}  	else {  		RotateRightLeft (node);  		node = node.Parent;  	}  }  else if (node.Balance != 0) {  	return;  }  
Missing Default,Mono.TextEditor.Highlighting,Rule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Rule.cs,ReadNode,The following switch statement is missing a default case: switch (reader.LocalName) {  case "Delimiters":  	this.SetDelimiter (reader.ReadElementString ());  	return true;  case "Property":  	string name = reader.GetAttribute ("name");  	string value = reader.ReadElementString ();  	if (!properties.ContainsKey (name))  		properties [name] = new List<string> ();  	properties [name].Add (value);  	return true;  case Match.Node:  	matchList.Add (Match.Read (reader));  	return true;  case Span.Node:  case Span.AltNode:  	spanList.Add (Span.Read (reader));  	return true;  case Mono.TextEditor.Highlighting.Keywords.Node:  	Keywords keywords = Mono.TextEditor.Highlighting.Keywords.Read (reader' IgnoreCase);  	this.keywords.Add (keywords);  	UpdateKeywordTable (keywords);  	return true;  case Marker.PrevMarker:  	prevMarkerList.Add (Marker.Read (reader));  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,Rule,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Rule.cs,Read,The following switch statement is missing a default case: switch (reader.LocalName) {  case Node:  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,Keywords,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Keywords.cs,Read,The following switch statement is missing a default case: switch (reader.LocalName) {  case "Word":  	result.words.Add (reader.ReadElementString ());  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,Match,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Match.cs,Read,The following switch statement is missing a default case: switch (reader.LocalName) {  case "Group":  	result.Groups.Add (reader.GetAttribute ("color"));  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,Span,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\Span.cs,Read,The following switch statement is missing a default case: switch (reader.LocalName) {  case "Begin":  	string beginFlags = reader.GetAttribute ("flags");  	if (!string.IsNullOrEmpty (beginFlags))  		result.BeginFlags = (SpanBeginFlags)Enum.Parse (typeof(SpanBeginFlags)' beginFlags);  	result.BeginTagColor = reader.GetAttribute ("color");  	result.Begin = new Regex (reader.ReadElementString ());  	return true;  case "End":  	string endFlags = reader.GetAttribute ("flags");  	if (!string.IsNullOrEmpty (endFlags))  		result.EndFlags = (SpanEndFlags)Enum.Parse (typeof(SpanEndFlags)' endFlags);  	result.EndTagColor = reader.GetAttribute ("color");  	result.End = new Regex (reader.ReadElementString ());  	return true;  case "Exit":  	string exitFlags = reader.GetAttribute ("flags");  	if (!string.IsNullOrEmpty (exitFlags))  		result.ExitFlags = (SpanExitFlags)Enum.Parse (typeof(SpanExitFlags)' exitFlags);  	result.Exit = new Regex (reader.ReadElementString ());  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,SyntaxMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\SyntaxMode.cs,Read,The following switch statement is missing a default case: switch (reader.LocalName) {  case Node:  	string extends = reader.GetAttribute ("extends");  	if (!String.IsNullOrEmpty (extends)) {  		result = (SyntaxMode)SyntaxModeService.GetSyntaxMode (null' extends).MemberwiseClone ();  	}  	result.Name = reader.GetAttribute ("name");  	result.MimeType = reader.GetAttribute (MimeTypesAttribute);  	if (!String.IsNullOrEmpty (reader.GetAttribute ("ignorecase")))  		result.IgnoreCase = Boolean.Parse (reader.GetAttribute ("ignorecase"));  	return true;  case Rule.Node:  	result.rules.Add (Rule.Read (result' reader' result.IgnoreCase));  	return true;  }  
Missing Default,Mono.TextEditor.Highlighting,XmlReadHelper,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Highlighting\XmlReadHelper.cs,ReadList,The following switch statement is missing a default case: switch (reader.NodeType) {  case XmlNodeType.EndElement:  	if (endNodes.Contains (reader.LocalName))  		return;  	Console.WriteLine ("Unknown end node: " + reader.LocalName + " valid end nodes are: " + ConcatString (endNodes));  	break;  case XmlNodeType.Element:  	if (!didReadStartNode && endNodes.Contains (reader.LocalName)) {  		didReadStartNode = true;  		//						break;  	}  	bool validNode = callback (data);  	if (!validNode)  		Console.WriteLine ("Unknown node: " + reader.LocalName);  	if (data.SkipNextRead)  		goto skip;  	break;  }  
Missing Default,Mono.TextEditor,TextEditorData,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\TextEditorData.cs,DeleteSelection,The following switch statement is missing a default case: switch (selection.SelectionMode) {  case SelectionMode.Normal:  	var segment = selection.GetSelectionRange (this);  	int len = System.Math.Min (segment.Length' Document.TextLength - segment.Offset);  	var loc = selection.Anchor < selection.Lead ? selection.Anchor : selection.Lead;  	caret.Location = loc;  	EnsureCaretIsNotVirtual ();  	if (len > 0)  		Remove (segment.Offset' len);  	caret.Location = loc;  	break;  case SelectionMode.Block:  	DocumentLocation visStart = LogicalToVisualLocation (selection.Anchor);  	DocumentLocation visEnd = LogicalToVisualLocation (selection.Lead);  	int startCol = System.Math.Min (visStart.Column' visEnd.Column);  	int endCol = System.Math.Max (visStart.Column' visEnd.Column);  	bool preserve = Caret.PreserveSelection;  	Caret.PreserveSelection = true;  	for (int lineNr = selection.MinLine; lineNr <= selection.MaxLine; lineNr++) {  		DocumentLine curLine = Document.GetLine (lineNr);  		int col1 = curLine.GetLogicalColumn (this' startCol) - 1;  		int col2 = System.Math.Min (curLine.GetLogicalColumn (this' endCol) - 1' curLine.Length);  		if (col1 >= col2)  			continue;  		Remove (curLine.Offset + col1' col2 - col1);  		if (Caret.Line == lineNr && Caret.Column >= col1)  			Caret.Column = col1 + 1;  	}  	int column = System.Math.Min (selection.Anchor.Column' selection.Lead.Column);  	MainSelection = selection.WithRange (new DocumentLocation (selection.Anchor.Line' column)' new DocumentLocation (selection.Lead.Line' column));  	Caret.PreserveSelection = preserve;  	break;  }  
Missing Default,Mono.TextEditor,InsertionCursorEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\InsertionCursorEditMode.cs,HandleKeypress,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Up:  	if (CurIndex > 0)  		CurIndex--;  	DocumentLocation loc = insertionPoints [CurIndex].Location;  	editor.CenterTo (loc.Line - 1' DocumentLocation.MinColumn);  	editor.QueueDraw ();  	SetHelpWindowPosition ();  	break;  case Gdk.Key.Down:  	if (CurIndex < insertionPoints.Count - 1)  		CurIndex++;  	loc = insertionPoints [CurIndex].Location;  	editor.CenterTo (loc.Line + 1' DocumentLocation.MinColumn);  	editor.QueueDraw ();  	SetHelpWindowPosition ();  	break;  case Gdk.Key.KP_Enter:  case Gdk.Key.Return:  	OnExited (new InsertionCursorEventArgs (true' insertionPoints [CurIndex]));  	break;  case Gdk.Key.Escape:  	OnExited (new InsertionCursorEventArgs (false' null));  	break;  }  
Missing Default,Mono.TextEditor,LineSplitter,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Document\LineSplitter.cs,NextDelimiter,The following switch statement is missing a default case: switch (*p) {  case NewLine.CR:  	char* nextp = p + 1;  	if (nextp < endPtr && *nextp == NewLine.LF)  		return new Delimiter ((int)(p - start)' UnicodeNewline.CRLF);  	return new Delimiter ((int)(p - start)' UnicodeNewline.CR);  case NewLine.LF:  	return new Delimiter ((int)(p - start)' UnicodeNewline.LF);  case NewLine.NEL:  	return new Delimiter ((int)(p - start)' UnicodeNewline.NEL);  case NewLine.VT:  	return new Delimiter ((int)(p - start)' UnicodeNewline.VT);  case NewLine.FF:  	return new Delimiter ((int)(p - start)' UnicodeNewline.FF);  case NewLine.LS:  	return new Delimiter ((int)(p - start)' UnicodeNewline.LS);  case NewLine.PS:  	return new Delimiter ((int)(p - start)' UnicodeNewline.PS);  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetEolMarkerIndex,The following switch statement is missing a default case: switch (ch) {  case UnicodeNewline.Unknown:  	return 0;  case UnicodeNewline.LF:  	return 1;  case UnicodeNewline.CRLF:  	return 2;  case UnicodeNewline.CR:  	return 3;  case UnicodeNewline.NEL:  	return 4;  case UnicodeNewline.VT:  	return 5;  case UnicodeNewline.FF:  	return 6;  case UnicodeNewline.LS:  	return 7;  case UnicodeNewline.PS:  	return 8;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,GetCaretChar,The following switch statement is missing a default case: switch (caretChar) {  case ' ':  	break;  case '\t':  	break;  case '\n':  case '\r':  	break;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawCaret,The following switch statement is missing a default case: switch (Caret.Mode) {  case CaretMode.Insert:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height);  	break;  case CaretMode.Block:  	cr.SetSourceColor (color);  	cr.Rectangle (caretRectangle.X + 0.5' caretRectangle.Y + 0.5' caretRectangle.Width' caretRectangle.Height);  	cr.Fill ();  	char caretChar = GetCaretChar ();  	if (!char.IsWhiteSpace (caretChar) && caretChar != '\0') {  		using (var layout = textEditor.LayoutCache.RequestLayout ()) {  			layout.FontDescription = textEditor.Options.Font;  			layout.SetText (caretChar.ToString ());  			cr.MoveTo (caretRectangle.X' caretRectangle.Y);  			cr.SetSourceColor (textEditor.ColorStyle.PlainText.Background);  			cr.ShowLayout (layout);  		}  	}  	break;  case CaretMode.Underscore:  	cr.DrawLine (color' caretRectangle.X + 0.5' caretRectangle.Y + caretRectangle.Height + 0.5' caretRectangle.X + caretRectangle.Width' caretRectangle.Y + caretRectangle.Height + 0.5);  	break;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following switch statement is missing a default case: switch (textEditor.Options.ShowWhitespaces) {  case ShowWhitespaces.Selection:  	if (textEditor.IsSomethingSelected && (selectionStartOffset < offset || selectionStartOffset == selectionEndOffset) && BackgroundRenderer == null)  		DecorateTabsAndSpaces (cr' wrapper' offset' length' xPos' y' selectionStartOffset' selectionEndOffset + wrapper.LineChars.Length);  	break;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,DrawLinePart,The following switch statement is missing a default case: switch (textEditor.Options.ShowWhitespaces) {  case ShowWhitespaces.Always:  	DecorateTabsAndSpaces (cr' wrapper' offset' length' xPos' y' selectionStartOffset' selectionEndOffset + wrapper.LineChars.Length);  	break;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,MouseHover,The following switch statement is missing a default case: switch (this.mouseSelectionMode) {  case MouseSelectionMode.SingleChar:  	if (loc.Line != Caret.Line || !textEditor.GetTextEditorData ().IsCaretInVirtualLocation) {  		if (!InSelectionDrag) {  			textEditor.SetSelection (loc' loc);  		}  		else {  			textEditor.ExtendSelectionTo (loc);  		}  		Caret.Location = loc;  	}  	break;  case MouseSelectionMode.Word:  	if (loc.Line != Caret.Line || !textEditor.GetTextEditorData ().IsCaretInVirtualLocation) {  		int offset = textEditor.Document.LocationToOffset (loc);  		int start;  		int end;  		//					var data = textEditor.GetTextEditorData ();  		if (offset < textEditor.SelectionAnchor) {  			start = ScanWord (Document' offset' false);  			end = ScanWord (Document' textEditor.SelectionAnchor' true);  			Caret.Offset = start;  		}  		else {  			start = ScanWord (Document' textEditor.SelectionAnchor' false);  			end = ScanWord (Document' offset' true);  			Caret.Offset = end;  		}  		if (!textEditor.MainSelection.IsEmpty) {  			if (Caret.Offset < mouseWordStart) {  				textEditor.MainSelection = new Selection (Document.OffsetToLocation (mouseWordEnd)' Caret.Location' textEditor.MainSelection.SelectionMode);  			}  			else {  				textEditor.MainSelection = new Selection (Document.OffsetToLocation (mouseWordStart)' Caret.Location' textEditor.MainSelection.SelectionMode);  			}  		}  	}  	break;  case MouseSelectionMode.WholeLine:  	//textEditor.SetSelectLines (loc.Line' textEditor.MainSelection.Anchor.Line);  	DocumentLine line1 = textEditor.Document.GetLine (loc.Line);  	DocumentLine line2 = textEditor.Document.GetLineByOffset (textEditor.SelectionAnchor);  	var o2 = line1.Offset < line2.Offset ? line1.Offset : line1.EndOffsetIncludingDelimiter;  	Caret.Offset = o2;  	if (!textEditor.MainSelection.IsEmpty) {  		if (mouseWordStart < o2) {  			textEditor.MainSelection = new Selection (textEditor.OffsetToLocation (mouseWordStart)' Caret.Location' textEditor.MainSelection.SelectionMode);  		}  		else {  			textEditor.MainSelection = new Selection (textEditor.OffsetToLocation (mouseWordEnd)' Caret.Location' textEditor.MainSelection.SelectionMode);  		}  	}  	break;  }  
Missing Default,Mono.TextEditor,TextViewMargin,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextViewMargin.cs,Draw,The following switch statement is missing a default case: switch (textEditor.Options.ShowWhitespaces) {  case ShowWhitespaces.Selection:  	if (!isEolFolded && isEolSelected)  		if (!(BackgroundRenderer != null && textEditor.Options.ShowWhitespaces == ShowWhitespaces.Selection))  			if (textEditor.MainSelection.Contains (lineNr' 2 + line.Length) && !(lineNr == Caret.Line && Caret.Column > 1 && textEditor.MainSelection.Anchor.Line < textEditor.MainSelection.Lead.Line) && textEditor.MainSelection.Anchor.Line != textEditor.MainSelection.Lead.Line)  				goto case ShowWhitespaces.Always;  	break;  case ShowWhitespaces.Always:  	if (wrapper == null)  		wrapper = GetLayout (line);  	DrawEolMarker (cr' line' isEolSelected' position' y + System.Math.Max (0' wrapper.Height - LineHeight));  	break;  }  
Missing Default,Mono.TextEditor,TextArea,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextArea.cs,OnAnimationActorStep,The following switch statement is missing a default case: switch (actor.Target.AnimationState) {  case AnimationState.Coming:  	actor.Target.Drawer.Percent = actor.Percent;  	if (actor.Expired) {  		actor.Target.AnimationState = AnimationState.Going;  		actor.Reset ();  		return true;  	}  	break;  case AnimationState.Going:  	if (actor.Expired) {  		RemoveAnimation (actor.Target);  		return false;  	}  	actor.Target.Drawer.Percent = 1.0 - actor.Percent;  	break;  }  
Missing Default,Mono.TextEditor,TextEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor\Gui\TextEditor.cs,OnActorStep,The following switch statement is missing a default case: switch (actor.Target.AnimationState) {  case AnimationState.Coming:  	actor.Target.QueueDraw ();  	actor.Target.Percent = actor.Percent;  	if (actor.Expired) {  		actor.Target.AnimationState = AnimationState.Idle;  		return false;  	}  	break;  case AnimationState.IntendingToGo:  	actor.Target.AnimationState = AnimationState.Going;  	actor.Target.Bias = actor.Percent;  	actor.Reset ((uint)(actor.Target.Duration * actor.Percent));  	break;  case AnimationState.Going:  	if (actor.Expired) {  		this.Remove (actor.Target);  		return false;  	}  	actor.Target.Percent = 1.0 - actor.Percent;  	break;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following switch statement is missing a default case: switch (command [0]) {  case ':':  	if (2 > command.Length)  		break;  	int line;  	if (int.TryParse (command.Substring (1)' out line)) {  		if (line < DocumentLocation.MinLine || line > Data.Document.LineCount) {  			return "Invalid line number.";  		}  		else if (line == 0) {  			RunAction (CaretMoveActions.ToDocumentStart);  			return "Jumped to beginning of document.";  		}  		Data.Caret.Line = line;  		Editor.ScrollToCaret ();  		return string.Format ("Jumped to line {0}."' line);  	}  	switch (command [1]) {  	case 's':  		if (2 == command.Length) {  			if (null == lastPattern || null == lastReplacement)  				return "No stored pattern.";  			// Perform replacement with stored stuff  			command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  		}  		var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  		if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  			break;  		return RegexReplace (match);  	case '$':  		if (command.Length == 2) {  			RunAction (CaretMoveActions.ToDocumentEnd);  			return "Jumped to end of document.";  		}  		break;  	}  	break;  case '?':  case '/':  	searchBackward = ('?' == command [0]);  	if (1 < command.Length) {  		Editor.HighlightSearchPattern = true;  		Editor.SearchEngine = new RegexSearchEngine ();  		var pattern = command.Substring (1);  		Editor.SearchPattern = pattern;  		var caseSensitive = pattern.ToCharArray ().Any (c => char.IsUpper (c));  		Editor.SearchEngine.SearchRequest.CaseSensitive = caseSensitive;  	}  	return Search ();  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,RunExCommand,The following switch statement is missing a default case: switch (command [1]) {  case 's':  	if (2 == command.Length) {  		if (null == lastPattern || null == lastReplacement)  			return "No stored pattern.";  		// Perform replacement with stored stuff  		command = string.Format (":s/{0}/{1}/"' lastPattern' lastReplacement);  	}  	var match = Regex.Match (command' substMatch' RegexOptions.Compiled);  	if (!(match.Success && match.Groups ["pattern"].Success && match.Groups ["replacement"].Success))  		break;  	return RegexReplace (match);  case '$':  	if (command.Length == 2) {  		RunAction (CaretMoveActions.ToDocumentEnd);  		return "Jumped to end of document.";  	}  	break;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case '?':  case '/':  case ':':  	CurState = State.Command;  	commandBuffer.Append ((char)unicodeKey);  	Status = commandBuffer.ToString ();  	return;  case 'A':  	RunAction (CaretMoveActions.LineEnd);  	goto case 'i';  case 'I':  	RunAction (CaretMoveActions.LineFirstNonWhitespace);  	goto case 'i';  case 'a':  	//use CaretMoveActions so that we can move past last character on line end  	RunAction (CaretMoveActions.Right);  	goto case 'i';  case 'i':  	Caret.Mode = CaretMode.Insert;  	Status = "-- INSERT --";  	CurState = State.Insert;  	return;  case 'R':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.Replace;  	return;  case 'V':  	Status = "-- VISUAL LINE --";  	Data.SetSelectLines (Caret.Line' Caret.Line);  	CurState = State.VisualLine;  	return;  case 'v':  	Status = "-- VISUAL --";  	CurState = State.Visual;  	RunAction (ViActions.VisualSelectionFromMoveAction (ViActions.Right));  	return;  case 'd':  	Status = "d";  	CurState = State.Delete;  	return;  case 'y':  	Status = "y";  	CurState = State.Yank;  	return;  case 'Y':  	CurState = State.Yank;  	HandleKeypress (Gdk.Key.y' (int)'y'' Gdk.ModifierType.None);  	return;  case 'O':  	RunAction (ViActions.NewLineAbove);  	goto case 'i';  case 'o':  	RunAction (ViActions.NewLineBelow);  	goto case 'i';  case 'r':  	Caret.Mode = CaretMode.Underscore;  	Status = "-- REPLACE --";  	CurState = State.WriteChar;  	return;  case 'c':  	Caret.Mode = CaretMode.Insert;  	Status = "c";  	CurState = State.Change;  	return;  case 'x':  	if (Data.Caret.Column == Data.Document.GetLine (Data.Caret.Line).Length + 1)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Right)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	ViActions.RetreatFromLineEnd (Data);  	return;  case 'X':  	if (Data.Caret.Column == DocumentLocation.MinColumn)  		return;  	Status = string.Empty;  	if (!Data.IsSomethingSelected && 0 < Caret.Offset)  		RunActions (SelectionActions.FromMoveAction (CaretMoveActions.Left)' ClipboardActions.Cut);  	else  		RunAction (ClipboardActions.Cut);  	return;  case 'D':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	return;  case 'C':  	RunActions (SelectionActions.FromMoveAction (CaretMoveActions.LineEnd)' ClipboardActions.Cut);  	goto case 'i';  case '>':  	Status = ">";  	CurState = State.Indent;  	return;  case '<':  	Status = "<";  	CurState = State.Unindent;  	return;  case 'n':  	Search ();  	return;  case 'N':  	searchBackward = !searchBackward;  	Search ();  	searchBackward = !searchBackward;  	return;  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  case 's':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.FromMoveAction (CaretMoveActions.Right));  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'S':  	if (!Data.IsSomethingSelected)  		RunAction (SelectionActions.LineActionFromMoveAction (CaretMoveActions.LineEnd));  	else  		Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	RunAction (ClipboardActions.Cut);  	goto case 'i';  case 'g':  	Status = "g";  	CurState = State.G;  	return;  case 'H':  	Caret.Line = System.Math.Max (DocumentLocation.MinLine' Editor.PointToLocation (0' Editor.LineHeight - 1).Line);  	return;  case 'J':  	RunAction (ViActions.Join);  	return;  case 'L':  	int line = Editor.PointToLocation (0' Editor.Allocation.Height - Editor.LineHeight * 2 - 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case 'M':  	line = Editor.PointToLocation (0' Editor.Allocation.Height / 2).Line;  	if (line < DocumentLocation.MinLine)  		line = Document.LineCount;  	Caret.Line = line;  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	return;  case 'z':  	Status = "z";  	CurState = State.Fold;  	return;  case 'm':  	Status = "m";  	CurState = State.Mark;  	return;  case '`':  	Status = "`";  	CurState = State.GoToMark;  	return;  case '@':  	Status = "@";  	CurState = State.PlayMacro;  	return;  case 'q':  	if (currentMacro == null) {  		Status = "q";  		CurState = State.NameMacro;  		return;  	}  	currentMacro = null;  	Reset ("Macro Recorded");  	return;  case '*':  	SearchWordAtCaret ();  	return;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'p':  	PasteAfter (true);  	return;  case 'P':  	PasteBefore (true);  	return;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'p':  	PasteAfter (false);  	return;  case 'P':  	PasteBefore (false);  	return;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,HandleKeypress,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'g':  	Caret.Offset = 0;  	Reset ("");  	return;  }  
Missing Default,Mono.TextEditor.Vi,ViEditMode,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViMode.cs,ApplyActionToSelection,The following switch statement is missing a default case: switch ((char)unicodeKey) {  case 'x':  case 'd':  	RunAction (ClipboardActions.Cut);  	Reset ("Deleted selection");  	return;  case 'y':  	int offset = Data.SelectionRange.Offset;  	RunAction (ClipboardActions.Copy);  	Reset ("Yanked selection");  	Caret.Offset = offset;  	return;  case 's':  case 'c':  	RunAction (ClipboardActions.Cut);  	Caret.Mode = CaretMode.Insert;  	CurState = State.Insert;  	Status = "-- INSERT --";  	return;  case 'S':  	Data.SetSelectLines (Data.MainSelection.Anchor.Line' Data.Caret.Line);  	goto case 'c';  case '>':  	RunAction (MiscActions.IndentSelection);  	Reset ("");  	return;  case '<':  	RunAction (MiscActions.RemoveIndentSelection);  	Reset ("");  	return;  case ':':  	commandBuffer.Append (":");  	Status = commandBuffer.ToString ();  	CurState = State.Command;  	break;  case 'J':  	RunAction (ViActions.Join);  	Reset ("");  	return;  case '~':  	RunAction (ViActions.ToggleCase);  	Reset ("");  	return;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetEditObjectCharAction,The following switch statement is missing a default case: switch (c) {  case 'W':  case 'w':  	return ViActions.WordEnd;  case 'B':  case 'b':  	return ViActions.WordStart;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetNavCharAction,The following switch statement is missing a default case: switch (c) {  case 'h':  	return ViActions.Left;  case 'b':  	return CaretMoveActions.PreviousSubword;  case 'B':  	return CaretMoveActions.PreviousWord;  case 'l':  	return ViActions.Right;  case 'e':  	return ViActions.NextSubwordEnd;  case 'E':  	return ViActions.NextWordEnd;  case 'w':  	return CaretMoveActions.NextSubword;  case 'W':  	return CaretMoveActions.NextWord;  case 'k':  	return ViActions.Up;  case 'j':  	return ViActions.Down;  case '%':  	return MiscActions.GotoMatchingBracket;  case '0':  	return CaretMoveActions.LineStart;  case '^':  case '_':  	return CaretMoveActions.LineFirstNonWhitespace;  case '$':  	return ViActions.LineEnd;  case 'G':  	return CaretMoveActions.ToDocumentEnd;  case '{':  	return ViActions.MoveToPreviousEmptyLine;  case '}':  	return ViActions.MoveToNextEmptyLine;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Left:  case Gdk.Key.KP_Left:  	return ViActions.Left;  case Gdk.Key.Right:  case Gdk.Key.KP_Right:  	return ViActions.Right;  case Gdk.Key.Up:  case Gdk.Key.KP_Up:  	return ViActions.Up;  case Gdk.Key.Down:  case Gdk.Key.KP_Down:  	return ViActions.Down;  //not strictly vi' but more useful IMO  case Gdk.Key.KP_Home:  case Gdk.Key.Home:  	return CaretMoveActions.LineHome;  case Gdk.Key.KP_End:  case Gdk.Key.End:  	return ViActions.LineEnd;  case Gdk.Key.Page_Up:  case Gdk.Key.KP_Page_Up:  	return CaretMoveActions.PageUp;  case Gdk.Key.Page_Down:  case Gdk.Key.KP_Page_Down:  	return CaretMoveActions.PageDown;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetDirectionKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Left:  case Gdk.Key.KP_Left:  	return CaretMoveActions.PreviousWord;  case Gdk.Key.Right:  case Gdk.Key.KP_Right:  	return CaretMoveActions.NextWord;  case Gdk.Key.Up:  case Gdk.Key.KP_Up:  	return ScrollActions.Up;  // usually bound at IDE level  case Gdk.Key.u:  	return CaretMoveActions.PageUp;  case Gdk.Key.Down:  case Gdk.Key.KP_Down:  	return ScrollActions.Down;  case Gdk.Key.d:  	return CaretMoveActions.PageDown;  case Gdk.Key.KP_Home:  case Gdk.Key.Home:  	return CaretMoveActions.ToDocumentStart;  case Gdk.Key.KP_End:  case Gdk.Key.End:  	return CaretMoveActions.ToDocumentEnd;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Tab:  	return MiscActions.InsertTab;  case Gdk.Key.Return:  case Gdk.Key.KP_Enter:  	return MiscActions.InsertNewLine;  case Gdk.Key.BackSpace:  	return DeleteActions.Backspace;  case Gdk.Key.Delete:  case Gdk.Key.KP_Delete:  	return DeleteActions.Delete;  case Gdk.Key.Insert:  	return MiscActions.SwitchCaretMode;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.BackSpace:  	return DeleteActions.PreviousWord;  case Gdk.Key.Delete:  case Gdk.Key.KP_Delete:  	return DeleteActions.NextWord;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetInsertKeyAction,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Tab:  	return MiscActions.RemoveTab;  case Gdk.Key.BackSpace:  	return DeleteActions.Backspace;  case Gdk.Key.Return:  case Gdk.Key.KP_Enter:  	return MiscActions.InsertNewLine;  }  
Missing Default,Mono.TextEditor.Vi,ViActionMaps,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViActionMaps.cs,GetCommandCharAction,The following switch statement is missing a default case: switch (c) {  case 'u':  	return MiscActions.Undo;  }  
Missing Default,Mono.TextEditor.Vi,ViEditor,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Vi\ViEditor.cs,SetMode,The following switch statement is missing a default case: switch (mode) {  case ViEditorMode.Insert:  	Message = "-- INSERT --";  	editMode.SetCaretMode (CaretMode.Insert);  	break;  case ViEditorMode.Normal:  	editMode.SetCaretMode (CaretMode.Block);  	break;  case ViEditorMode.Replace:  	Message = "-- REPLACE --";  	editMode.SetCaretMode (CaretMode.Underscore);  	break;  }  
Missing Default,Mono.TextEditor.PopupWindow,ListWindow,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.PopupWindow\ListWindow.cs,ProcessKey,The following switch statement is missing a default case: switch (key) {  case Gdk.Key.Up:  	if (list.SelectionDisabled)  		list.SelectionDisabled = false;  	else  		list.Selection--;  	return ListWindowKeyAction.Ignore;  case Gdk.Key.Down:  	if (list.SelectionDisabled)  		list.SelectionDisabled = false;  	else  		list.Selection++;  	return ListWindowKeyAction.Ignore;  case Gdk.Key.Page_Up:  	list.Selection -= list.VisibleRows - 1;  	return ListWindowKeyAction.Ignore;  case Gdk.Key.Page_Down:  	list.Selection += list.VisibleRows - 1;  	return ListWindowKeyAction.Ignore;  case Gdk.Key.Left:  	//if (curPos == 0) return KeyAction.CloseWindow | KeyAction.Process;  	//curPos--;  	return ListWindowKeyAction.Process;  case Gdk.Key.BackSpace:  	if (curPos == 0 || (modifier & Gdk.ModifierType.ControlMask) != 0)  		return ListWindowKeyAction.CloseWindow | ListWindowKeyAction.Process;  	curPos--;  	word.Remove (curPos' 1);  	UpdateWordSelection ();  	return ListWindowKeyAction.Process;  case Gdk.Key.Right:  	//if (curPos == word.Length) return KeyAction.CloseWindow | KeyAction.Process;  	//curPos++;  	return ListWindowKeyAction.Process;  case Gdk.Key.Caps_Lock:  case Gdk.Key.Num_Lock:  case Gdk.Key.Scroll_Lock:  	return ListWindowKeyAction.Ignore;  case Gdk.Key.Return:  case Gdk.Key.ISO_Enter:  case Gdk.Key.Key_3270_Enter:  case Gdk.Key.KP_Enter:  	return (list.SelectionDisabled ? ListWindowKeyAction.Process : (ListWindowKeyAction.Complete | ListWindowKeyAction.Ignore)) | ListWindowKeyAction.CloseWindow;  case Gdk.Key.Escape:  	return ListWindowKeyAction.CloseWindow | ListWindowKeyAction.Ignore;  case Gdk.Key.Home:  case Gdk.Key.End:  	return ListWindowKeyAction.CloseWindow | ListWindowKeyAction.Process;  case Gdk.Key.Control_L:  case Gdk.Key.Control_R:  case Gdk.Key.Alt_L:  case Gdk.Key.Alt_R:  case Gdk.Key.Shift_L:  case Gdk.Key.Shift_R:  case Gdk.Key.ISO_Level3_Shift:  	// AltGr  	return ListWindowKeyAction.Process;  }  
Missing Default,Mono.TextEditor.Theatrics,AnimatedBox,C:\repos\SamiDidier_NClass\lib\Mono.Texteditor\Mono.TextEditor.Theatrics\AnimatedBox.cs,OnActorStep,The following switch statement is missing a default case: switch (actor.Target.AnimationState) {  case AnimationState.Coming:  	actor.Target.Percent = actor.Percent;  	if (actor.Expired) {  		actor.Target.AnimationState = AnimationState.Idle;  		return false;  	}  	break;  case AnimationState.IntendingToGo:  	actor.Target.AnimationState = AnimationState.Going;  	actor.Target.Bias = actor.Percent;  	actor.Reset ((uint)(actor.Target.Duration * actor.Percent));  	break;  case AnimationState.Going:  	if (actor.Expired) {  		actor.Target.Unparent ();  		children.Remove (actor.Target.Node);  		return false;  	}  	else {  		actor.Target.Percent = 1.0 - actor.Percent;  	}  	break;  }  
