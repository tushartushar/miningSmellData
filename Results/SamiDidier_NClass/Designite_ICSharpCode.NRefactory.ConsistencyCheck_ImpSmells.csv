Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,FindReferencesConsistencyCheck,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\FindReferencesConsistencyCheck.cs,TestFindReferences,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,PatternMatchingTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\PatternMatchingTest.cs,RunTest,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,TypeSystemTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\TypeSystemTests.cs,ResolvedUnresolvedMembers,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,RunTest,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,RoundtripTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RoundtripTest.cs,Roundtrip,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,Solution,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Solution.cs,Solution,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,CompareResults,Cyclomatic complexity of the method is 24
Long Parameter List,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,Run,The method has 17 parameters.
Long Parameter List,ICSharpCode.NRefactory.ConsistencyCheck.Xml,XmlReaderTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\XmlReaderTest.cs,Run,The method has 9 parameters.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,FindReferencesConsistencyCheck,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\FindReferencesConsistencyCheck.cs,TestFindReferences,The length of the statement  "			fr.FindReferencesInFile (searchScopes' file.UnresolvedTypeSystemForFile' file.SyntaxTree' project.Compilation' delegate (AstNode node' ResolveResult result) { " is 158.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,FindReferencesConsistencyCheck,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\FindReferencesConsistencyCheck.cs,PrintTimingsPerEntityType,The length of the statement  "		Console.WriteLine ("{0} - avg. {1} per entity"' pair.Key' TimeSpan.FromSeconds (timings [pair.Key].TotalSeconds / pair.Value)); " is 127.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,PatternMatchingTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\PatternMatchingTest.cs,RunTest,The length of the statement  "			throw new InvalidOperationException ("Mutation in " + id.StartLocation + " did not prevent the match; in " + file.FileName); " is 124.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,PatternMatchingTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\PatternMatchingTest.cs,RunTest,The length of the statement  "			throw new InvalidOperationException ("Mutation in " + pe.StartLocation + " did not prevent the match; in " + file.FileName); " is 124.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,Program,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Program.cs,Main,The length of the statement  "	Console.WriteLine ("Loaded {0} lines of code ({1:f1} MB) in {2} files in {3} projects."' solution.AllFiles.Sum (f => 1 + f.OriginalText.Count (c => c == '\n'))' solution.AllFiles.Sum (f => f.OriginalText.Length) / 1024.0 / 1024.0' solution.AllFiles.Count ()' solution.Projects.Count); " is 284.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,RunTest,The length of the statement  "	test.resolveAllResolver = new CSharpAstResolver (file.Project.Compilation' file.SyntaxTree' file.UnresolvedTypeSystemForFile); " is 126.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,CheckResult,The length of the statement  "	Console.WriteLine ("Different resolve results for '{0}' at {1} in {2}:"' node' node.StartLocation' node.GetRegion ().FileName); " is 127.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,CheckStateBefore,The length of the statement  "	Console.WriteLine ("Different resolver states before '{0}' at {1} in {2}."' node' node.StartLocation' node.GetRegion ().FileName); " is 130.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,CheckStateAfter,The length of the statement  "	Console.WriteLine ("Different resolver states after '{0}' at {1} in {2}."' node' node.StartLocation' node.GetRegion ().FileName); " is 129.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,CheckConversion,The length of the statement  "	Console.WriteLine ("Different conversions for '{0}' at {1} in {2}:"' node' node.StartLocation' node.GetRegion ().FileName); " is 123.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,CheckExpectedType,The length of the statement  "	Console.WriteLine ("Different expected types for '{0}' at {1} in {2}:"' node' node.StartLocation' node.GetRegion ().FileName); " is 126.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,Compare,The length of the statement  "	else if (type.IsArray || type.IsGenericType && (type.GetGenericTypeDefinition () == typeof(List<>) || type.GetGenericTypeDefinition () == typeof(ReadOnlyCollection<>) || type.GetGenericTypeDefinition () == typeof(IList<>) || type.GetGenericTypeDefinition () == typeof(ICollection<>) || type.GetGenericTypeDefinition () == typeof(IEnumerable<>))) { " is 347.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,Compare,The length of the statement  "		else if (val1 is Conversion && val2 is Conversion && ((Conversion)val1).IsAnonymousFunctionConversion && ((Conversion)val2).IsAnonymousFunctionConversion) " is 154.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,IsEqualVariable,The length of the statement  "	return object.Equals (v1.ConstantValue' v2.ConstantValue) && v1.IsConst == v2.IsConst && v1.Name == v2.Name && v1.Region == v2.Region && object.Equals (v1.Type' v2.Type); " is 170.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,ResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\ResolverTest.cs,RunTest,The length of the statement  "	CSharpAstResolver resolver = new CSharpAstResolver (file.Project.Compilation' file.SyntaxTree' file.UnresolvedTypeSystemForFile); " is 129.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,ResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\ResolverTest.cs,RunTestWithoutUnresolvedFile,The length of the statement  "	CSharpAstResolver originalResolver = new CSharpAstResolver (file.Project.Compilation' file.SyntaxTree' file.UnresolvedTypeSystemForFile); " is 137.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RoundtripTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RoundtripTest.cs,RunTest,The length of the statement  "	if (code.Contains ("enum VarianceModifier") || file.FileName.EndsWith ("ecore.cs") || file.FileName.EndsWith ("method.cs")) " is 123.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RoundtripTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RoundtripTest.cs,RunTest,The length of the statement  "	if (file.FileName.EndsWith ("KnownTypeReference.cs") || file.FileName.EndsWith ("typemanager.cs") || file.FileName.EndsWith ("GetAllBaseTypesTest.cs") || file.FileName.EndsWith ("Tokens.cs") || file.FileName.EndsWith ("OpCode.cs") || file.FileName.EndsWith ("MainWindow.cs")) " is 275.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,RoundtripTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RoundtripTest.cs,RunTest,The length of the statement  "	if (file.FileName.Contains ("FormattingTests") || file.FileName.Contains ("ContextAction") || file.FileName.Contains ("CodeCompletion")) " is 136.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,Run,The length of the statement  "	RunTest ("DepthFirstAstVisitor<object>"' files' (syntaxTree' list) => syntaxTree.AcceptVisitor (new DepthFirst<object> (list))); " is 128.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,Run,The length of the statement  "	RunTest ("DepthFirstAstVisitor<object' object>"' files' (syntaxTree' list) => syntaxTree.AcceptVisitor (new DepthFirst<object' object> (list)' null)); " is 150.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The length of the statement  "	Console.WriteLine ("Incremental parse time:     " + incrementalParseTime + " for " + totalCharactersChanged + " characters changed"); " is 133.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The length of the statement  "	Console.WriteLine ("Non-Incremental parse time: " + nonIncrementalParseTime + " for " + totalCharactersParsed + " characters"); " is 127.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck.Xml,XmlReaderTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\XmlReaderTest.cs,Run,The length of the statement  "	using (StreamWriter output = File.CreateText (Path.Combine (Program.TempPath' reader.GetType ().Name + "-output.csv"))) { " is 121.
Long Statement,ICSharpCode.NRefactory.ConsistencyCheck.Xml,XmlReaderTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\XmlReaderTest.cs,Run,The length of the statement  "		var properties = typeof(XmlReader).GetProperties (BindingFlags.Public | BindingFlags.Instance).Where (p => p.GetIndexParameters ().Length == 0 && !ignoredProperties.Contains (p.Name)).ToArray (); " is 195.
Complex Conditional,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,Compare,The conditional expression  "type.IsArray || type.IsGenericType && (type.GetGenericTypeDefinition () == typeof(List<>) || type.GetGenericTypeDefinition () == typeof(ReadOnlyCollection<>) || type.GetGenericTypeDefinition () == typeof(IList<>) || type.GetGenericTypeDefinition () == typeof(ICollection<>) || type.GetGenericTypeDefinition () == typeof(IEnumerable<>))"  is complex.
Complex Conditional,ICSharpCode.NRefactory.ConsistencyCheck,RandomizedOrderResolverTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RandomizedOrderResolverTest.cs,Compare,The conditional expression  "val1 is Conversion && val2 is Conversion && ((Conversion)val1).IsAnonymousFunctionConversion && ((Conversion)val2).IsAnonymousFunctionConversion"  is complex.
Complex Conditional,ICSharpCode.NRefactory.ConsistencyCheck,RoundtripTest,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\RoundtripTest.cs,RunTest,The conditional expression  "file.FileName.EndsWith ("KnownTypeReference.cs") || file.FileName.EndsWith ("typemanager.cs") || file.FileName.EndsWith ("GetAllBaseTypesTest.cs") || file.FileName.EndsWith ("Tokens.cs") || file.FileName.EndsWith ("OpCode.cs") || file.FileName.EndsWith ("MainWindow.cs")"  is complex.
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,Program,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Program.cs,Main,The following statement contains a magic number: Console.WriteLine ("Loaded {0} lines of code ({1:f1} MB) in {2} files in {3} projects."' solution.AllFiles.Sum (f => 1 + f.OriginalText.Count (c => c == '\n'))' solution.AllFiles.Sum (f => f.OriginalText.Length) / 1024.0 / 1024.0' solution.AllFiles.Count ()' solution.Projects.Count);  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,Program,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Program.cs,Main,The following statement contains a magic number: Console.WriteLine ("Loaded {0} lines of code ({1:f1} MB) in {2} files in {3} projects."' solution.AllFiles.Sum (f => 1 + f.OriginalText.Count (c => c == '\n'))' solution.AllFiles.Sum (f => f.OriginalText.Length) / 1024.0 / 1024.0' solution.AllFiles.Count ()' solution.Projects.Count);  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,RunTest,The following statement contains a magic number: foreach (var file in files) {  	for (int i = 0; i < 20; i++) {  		list.Clear ();  		action (file' list);  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,RunTest,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	list.Clear ();  	action (file' list);  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,VisitorBenchmark,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\VisitorBenchmark.cs,RunTest,The following statement contains a magic number: Console.WriteLine (text.PadRight (40) + ": " + w.Elapsed);  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int iteration = 0; iteration < 100; iteration++) {  	totalCharactersParsed += b.Length;  	var textSource = new StringTextSource (b.ToString ()' versionProvider.CurrentVersion);  	w.Restart ();  	var incrementalResult = parser.ParseIncremental (parserState' textSource' out parserState);  	w.Stop ();  	incrementalParseTime += w.Elapsed;  	w.Restart ();  	var nonIncrementalResult = parser.Parse (textSource);  	w.Stop ();  	nonIncrementalParseTime += w.Elapsed;  	CompareResults (incrementalResult' nonIncrementalResult);  	incrementalResult.AcceptVisitor (new ValidationVisitor (textSource));  	// Randomly mutate the file:  	//				List<TextChangeEventArgs> changes = new List<TextChangeEventArgs>();  	int modifications = rnd.Next (0' 25);  	int offset = 0;  	for (int i = 0; i < modifications; i++) {  		if (i == 0 || rnd.Next (0' 10) == 0)  			offset = rnd.Next (0' b.Length);  		else  			offset += rnd.Next (0' Math.Min (10' b.Length - offset));  		int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  		int insertionLength;  		int removalLength;  		switch (rnd.Next (0' 21) / 10) {  		case 0:  			removalLength = 0;  			insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  			break;  		case 1:  			removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  			insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  			break;  		default:  			removalLength = rnd.Next (0' b.Length - offset);  			insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  			break;  		}  		string removedText = b.ToString (offset' removalLength);  		b.Remove (offset' removalLength);  		string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  		b.Insert (offset' insertedText);  		versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  		totalCharactersChanged += insertionLength;  	}  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: for (int i = 0; i < modifications; i++) {  	if (i == 0 || rnd.Next (0' 10) == 0)  		offset = rnd.Next (0' b.Length);  	else  		offset += rnd.Next (0' Math.Min (10' b.Length - offset));  	int originalOffset = rnd.Next (0' originalXmlFile.TextLength);  	int insertionLength;  	int removalLength;  	switch (rnd.Next (0' 21) / 10) {  	case 0:  		removalLength = 0;  		insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  		break;  	case 1:  		removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  		insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  		break;  	default:  		removalLength = rnd.Next (0' b.Length - offset);  		insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  		break;  	}  	string removedText = b.ToString (offset' removalLength);  	b.Remove (offset' removalLength);  	string insertedText = originalXmlFile.GetText (originalOffset' insertionLength);  	b.Insert (offset' insertedText);  	versionProvider.AppendChange (new TextChangeEventArgs (offset' removedText' insertedText));  	totalCharactersChanged += insertionLength;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: if (i == 0 || rnd.Next (0' 10) == 0)  	offset = rnd.Next (0' b.Length);  else  	offset += rnd.Next (0' Math.Min (10' b.Length - offset));  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: if (i == 0 || rnd.Next (0' 10) == 0)  	offset = rnd.Next (0' b.Length);  else  	offset += rnd.Next (0' Math.Min (10' b.Length - offset));  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: offset += rnd.Next (0' Math.Min (10' b.Length - offset));  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: switch (rnd.Next (0' 21) / 10) {  case 0:  	removalLength = 0;  	insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  	break;  case 1:  	removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  	insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  	break;  default:  	removalLength = rnd.Next (0' b.Length - offset);  	insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  	break;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: switch (rnd.Next (0' 21) / 10) {  case 0:  	removalLength = 0;  	insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  	break;  case 1:  	removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  	insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  	break;  default:  	removalLength = rnd.Next (0' b.Length - offset);  	insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  	break;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: switch (rnd.Next (0' 21) / 10) {  case 0:  	removalLength = 0;  	insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  	break;  case 1:  	removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  	insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  	break;  default:  	removalLength = rnd.Next (0' b.Length - offset);  	insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  	break;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: switch (rnd.Next (0' 21) / 10) {  case 0:  	removalLength = 0;  	insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  	break;  case 1:  	removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  	insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  	break;  default:  	removalLength = rnd.Next (0' b.Length - offset);  	insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  	break;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: switch (rnd.Next (0' 21) / 10) {  case 0:  	removalLength = 0;  	insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  	break;  case 1:  	removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  	insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  	break;  default:  	removalLength = rnd.Next (0' b.Length - offset);  	insertionLength = rnd.Next (0' originalXmlFile.TextLength - originalOffset);  	break;  }  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: insertionLength = rnd.Next (0' Math.Min (50' originalXmlFile.TextLength - originalOffset));  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: removalLength = rnd.Next (0' Math.Min (20' b.Length - offset));  
Magic Number,ICSharpCode.NRefactory.ConsistencyCheck,IncrementalXmlParserTests,C:\repos\SamiDidier_NClass\lib\NRefactory\ICSharpCode.NRefactory.ConsistencyCheck\Xml\IncrementalXmlParserTests.cs,Run,The following statement contains a magic number: insertionLength = rnd.Next (0' Math.Min (20' originalXmlFile.TextLength - originalOffset));  
