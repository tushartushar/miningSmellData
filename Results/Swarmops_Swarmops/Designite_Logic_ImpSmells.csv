Implementation smell,Namespace,Class,File,Method,Description
Long Method,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestUnspents,The method has 153 lines of code.
Long Method,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,CheckColdStorageRecurse,The method has 177 lines of code.
Long Method,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The method has 214 lines of code.
Long Method,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateFromProtoIdentity,The method has 214 lines of code.
Long Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The method has 272 lines of code.
Long Method,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,The method has 145 lines of code.
Long Method,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The method has 115 lines of code.
Complex Method,Swarmops.Logic.Communications,MailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\MailTemplate.cs,NormalizeHtmlExtracted,Cyclomatic complexity of the method is 11
Complex Method,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,PreparePlaceholders,Cyclomatic complexity of the method is 13
Complex Method,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,CheckColdStorageRecurse,Cyclomatic complexity of the method is 23
Complex Method,Swarmops.Logic.Financial,VatReport,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReport.cs,AddVatReportItemsFromAccountRows,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,Cyclomatic complexity of the method is 30
Complex Method,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Financial,OutboundInvoices,C:\repos\Swarmops_Swarmops\Logic\Financial\OutboundInvoices.cs,AutomatchAgainstUnbalancedTransactions,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,BindToTransactionAndClose,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidExpenseClaims,Cyclomatic complexity of the method is 12
Complex Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidCashAdvances,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidSalaries,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,Cyclomatic complexity of the method is 10
Complex Method,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,Cyclomatic complexity of the method is 19
Complex Method,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,Create,Cyclomatic complexity of the method is 12
Complex Method,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,GetBudgetAttestationSpaceAdjustments,Cyclomatic complexity of the method is 14
Complex Method,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,GetFinancialDependencyType,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,RecalculateTransaction,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,Authenticate,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,RequestActivistSignoffProcess,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,HasAccess,Cyclomatic complexity of the method is 11
Complex Method,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,FilterPeople,Cyclomatic complexity of the method is 16
Complex Method,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,CanSeePerson,Cyclomatic complexity of the method is 10
Complex Method,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,RerasterizeAll,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,Cyclomatic complexity of the method is 12
Complex Method,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,GetDatabase,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,PrimeCountry,Cyclomatic complexity of the method is 11
Complex Method,Swarmops.Logic.Structure,Geographies,C:\repos\Swarmops_Swarmops\Logic\Structure\Geographies.cs,RemoveRedundant,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,Cyclomatic complexity of the method is 16
Complex Method,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,RemoveRedundant,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,GetMostLocalOrganization,Cyclomatic complexity of the method is 9
Complex Method,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddExpenseClaimAttestations,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddCashAdvanceAttestations,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddPayouts,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,LogicalOr,Cyclomatic complexity of the method is 8
Complex Method,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,HasAccess,Cyclomatic complexity of the method is 8
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,Create,The method has 8 parameters. Parameters: sender' from' organization' resolver' recipientDataXml' transmitterClass' payloadXml' priority
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,Create,The method has 8 parameters. Parameters: sender' from' organization' resolverDataXml' recipientDataXml' transmitterClassString' payloadXml' priority
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateNotification,The method has 5 parameters. Parameters: organization' notification' strings' customStrings' recipients
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateParticipantMail,The method has 6 parameters. Parameters: customSubject' customBody' sender' from' organization' geography
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateNotification,The method has 5 parameters. Parameters: organization' notificationResourceString' strings' customStrings' recipients
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateNotificationAttestationNeeded,The method has 6 parameters. Parameters: budget' concernedPerson' supplier' amountRequested' purpose' notification
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateNotificationOfFinancialValidation,The method has 6 parameters. Parameters: budget' concernedPerson' amountRequested' purpose' notification' reasonGiven
Long Parameter List,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateSecurityNotification,The method has 5 parameters. Parameters: concernedPerson' actingPerson' organization' ticket' notification
Long Parameter List,Swarmops.Logic.Communications,AutoMail,C:\repos\Swarmops_Swarmops\Logic\Communications\AutoMail.cs,Create,The method has 6 parameters. Parameters: type' org' geo' author' title' body
Long Parameter List,Swarmops.Logic.Communications,MailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\MailTemplate.cs,Create,The method has 5 parameters. Parameters: templateName' languageCode' countryCode' organizationId' templateBody
Long Parameter List,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,Create,The method has 7 parameters. Parameters: author' title' body' mailPriority' mailType' organization' geography
Long Parameter List,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,Create,The method has 8 parameters. Parameters: author' title' body' mailPriority' mailType' organization' geography' releaseDateTime
Long Parameter List,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,CreateFake,The method has 7 parameters. Parameters: author' title' body' ignoredPriority' mailType' organization' geography
Long Parameter List,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,CreateFake,The method has 6 parameters. Parameters: author' title' body' mailType' organization' geography
Long Parameter List,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,CreateFunctional,The method has 8 parameters. Parameters: authorType' title' body' mailPriority' mailType' organizationId' geographyId' releaseDateTime
Long Parameter List,Swarmops.Logic.Communications,PaperLetter,C:\repos\Swarmops_Swarmops\Logic\Communications\PaperLetter.cs,Create,The method has 8 parameters. Parameters: creator' organization' fromName' replyAddressLines' receivedDate' recipient' recipientRole' personal
Long Parameter List,Swarmops.Logic.Communications,PaperLetter,C:\repos\Swarmops_Swarmops\Logic\Communications\PaperLetter.cs,Create,The method has 8 parameters. Parameters: creatingPersonId' organizationId' fromName' replyAddressLines' receivedDate' toPersonId' toPersonInRole' personal
Long Parameter List,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,CreateOutboundMail,The method has 5 parameters. Parameters: author' mailPriority' organization' geography' releaseDateTime
Long Parameter List,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,CreateFunctionalOutboundMail,The method has 5 parameters. Parameters: authorType' mailPriority' organization' geography' releaseDateTime
Long Parameter List,Swarmops.Logic.Communications,PlaceHolder,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,PlaceHolder,The method has 5 parameters. Parameters: name' label' tagOrId' dataType' formatString
Long Parameter List,Swarmops.Logic.Financial,VatReportItem,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReportItem.cs,Create,The method has 5 parameters. Parameters: report' transaction' turnoverCents' vatInboundCents' vatOutboundCents
Long Parameter List,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Create,The method has 6 parameters. Parameters: organization' forPerson' createdByPerson' amountCents' budget' description
Long Parameter List,Swarmops.Logic.Financial,InboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\InboundInvoice.cs,Create,The method has 11 parameters. Parameters: organization' dueDate' amountCents' vatCents' budget' supplier' description' payToAccount' ocr' invoiceReference' creatingPerson
Long Parameter List,Swarmops.Logic.Financial,OutboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\OutboundInvoice.cs,Create,The method has 10 parameters. Parameters: organization' dueDate' budget' customerName' invoiceAddressMail' invoiceAddressPaper' currency' domestic' theirReference' createdByPerson
Long Parameter List,Swarmops.Logic.Financial,Payment,C:\repos\Swarmops_Swarmops\Logic\Financial\Payment.cs,Create,The method has 6 parameters. Parameters: group' amount' reference' fromAccount' key' hasImage
Long Parameter List,Swarmops.Logic.Financial,Payment,C:\repos\Swarmops_Swarmops\Logic\Financial\Payment.cs,CreateSingle,The method has 6 parameters. Parameters: organization' dateTime' currency' amountCents' invoice' createdByPerson
Long Parameter List,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,CreatePayment,The method has 5 parameters. Parameters: amount' reference' fromAccount' key' hasImage
Long Parameter List,Swarmops.Logic.Financial,PayrollItem,C:\repos\Swarmops_Swarmops\Logic\Financial\PayrollItem.cs,Create,The method has 10 parameters. Parameters: person' organization' employedDate' reportsToPerson' country' baseSalaryCents' budget' additiveTaxLevel' subtractiveTaxLevelId' isContractor
Long Parameter List,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,Create,The method has 5 parameters. Parameters: payrollItem' payoutDate' netSalaryCents' subtractiveTaxCents' additiveTaxCents
Long Parameter List,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The method has 7 parameters. Parameters: claimer' organization' budget' expenseDate' description' amountCents' vatCents
Long Parameter List,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,ImportWithStub,The method has 7 parameters. Parameters: organizationId' dateTime' financialAccountId' amountCents' description' importHash' personId
Long Parameter List,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,AddDocument,The method has 5 parameters. Parameters: serverFileName' originalFileName' fileSize' description' uploader
Long Parameter List,Swarmops.Logic.Cache,OrganizationCache,C:\repos\Swarmops_Swarmops\Logic\Cache\OrganizationCache.cs,CreateOrganization,The method has 10 parameters. Parameters: ParentOrganizationId' NameInternational' Name' NameShort' Domain' MailPrefix' AnchorGeographyId' AcceptsMembers' AutoAssignNewMembers' DefaultCountryId
Long Parameter List,Swarmops.Logic.Cache,OrganizationCache,C:\repos\Swarmops_Swarmops\Logic\Cache\OrganizationCache.cs,UpdateOrganization,The method has 11 parameters. Parameters: ParentOrganizationId' NameInternational' Name' NameShort' Domain' MailPrefix' AnchorGeographyId' AcceptsMembers' AutoAssignNewMembers' DefaultCountryId' OrganizationId
Long Parameter List,Swarmops.Logic.Support,ActivistEvents,C:\repos\Swarmops_Swarmops\Logic\Support\ActivistEvents.cs,CreateActivistWithLogging,The method has 7 parameters. Parameters: geo' newActivist' logMessage' evtSrc' isPublic' isConfirmed' orgId
Long Parameter List,Swarmops.Logic.Support,Document,C:\repos\Swarmops_Swarmops\Logic\Support\Document.cs,Create,The method has 6 parameters. Parameters: serverFileName' clientFileName' fileSize' description' identifiableObject' uploader
Long Parameter List,Swarmops.Logic.Support,Documents,C:\repos\Swarmops_Swarmops\Logic\Support\Documents.cs,Add,The method has 5 parameters. Parameters: serverFileName' clientFileName' fileSize' description' uploader
Long Parameter List,Swarmops.Logic.Support,PWEvents,C:\repos\Swarmops_Swarmops\Logic\Support\PWEvents.cs,CreateEvent,The method has 8 parameters. Parameters: eventSource' eventType' actingPersonId' organizationId' geographyId' affectedPersonId' parameterInt' parameterText
Long Parameter List,Swarmops.Logic.Support.LogEntries,CashAdvanceRequestedLogEntry,C:\repos\Swarmops_Swarmops\Logic\Support\LogEntries\CashAdvanceRequestedLogEntry.cs,CashAdvanceRequestedLogEntry,The method has 5 parameters. Parameters: actingPerson' beneficiaryPerson' amount' budget' reason
Long Parameter List,Swarmops.Logic.Support.LogEntries,InboundInvoiceCreatedLogEntry,C:\repos\Swarmops_Swarmops\Logic\Support\LogEntries\InboundInvoiceCreatedLogEntry.cs,InboundInvoiceCreatedLogEntry,The method has 5 parameters. Parameters: creatingPerson' supplier' description' amount' budget
Long Parameter List,Swarmops.Logic.Support.LogEntries,ExpenseClaimFiledLogEntry,C:\repos\Swarmops_Swarmops\Logic\Support\LogEntries\ExpenseClaimFiledLogEntry.cs,ExpenseClaimFiledLogEntry,The method has 6 parameters. Parameters: filingPerson' beneficiaryPerson' amount' vat' budget' reason
Long Parameter List,Swarmops.Logic.Support.LogEntries,PayoutCreatedLogEntry,C:\repos\Swarmops_Swarmops\Logic\Support\LogEntries\PayoutCreatedLogEntry.cs,PayoutCreatedLogEntry,The method has 6 parameters. Parameters: payingPerson' beneficiaryPerson' organization' currency' amount' reason
Long Parameter List,Swarmops.Logic.Governance,Ballot,C:\repos\Swarmops_Swarmops\Logic\Governance\Ballot.cs,Create,The method has 6 parameters. Parameters: election' organization' geography' name' ballotCount' deliveryAddress
Long Parameter List,Swarmops.Logic.Governance,MeetingElection,C:\repos\Swarmops_Swarmops\Logic\Governance\MeetingElection.cs,Create,The method has 10 parameters. Parameters: creator' org' geo' name' resultsType' maxVoteLength' runningOpens' runningCloses' votingOpens' votingCloses
Long Parameter List,Swarmops.Logic.Governance,Motion,C:\repos\Swarmops_Swarmops\Logic\Governance\Motion.cs,Create,The method has 6 parameters. Parameters: meeting' submittingPerson' creatingPerson' title' text' decisionPoints
Long Parameter List,Swarmops.Logic.Governance,Motion,C:\repos\Swarmops_Swarmops\Logic\Governance\Motion.cs,AddAmendment,The method has 5 parameters. Parameters: title' text' decisionPoint' submittingPerson' createdByPerson
Long Parameter List,Swarmops.Logic.Governance,MotionAmendment,C:\repos\Swarmops_Swarmops\Logic\Governance\MotionAmendment.cs,Create,The method has 6 parameters. Parameters: motion' title' text' decisionPoint' submittingPerson' creatingPerson
Long Parameter List,Swarmops.Logic.Media,MediaEntry,C:\repos\Swarmops_Swarmops\Logic\Media\MediaEntry.cs,CreateFromKeyword,The method has 6 parameters. Parameters: keyword' mediaName' isBlog' url' title' dateTime
Long Parameter List,Swarmops.Logic.Special.Sweden,SupportCaseDelta,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportCaseDelta.cs,SupportCaseDelta,The method has 6 parameters. Parameters: supportCaseDeltaId' supportCaseId' supportPersonId' dateTime' verb' changes
Long Parameter List,Swarmops.Logic.Special.Sweden,IForumDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The method has 5 parameters. Parameters: forumId' poster' title' description' post
Long Parameter List,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The method has 5 parameters. Parameters: forumId' poster' title' description' post
Long Parameter List,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseVBulletin,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The method has 5 parameters. Parameters: forumId' poster' title' description' post
Long Parameter List,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,Create,The method has 6 parameters. Parameters: updateType' updateSource' guid' countryCode' changeDataXml' effectiveDateTime
Long Parameter List,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,InitDatabaseThreadCreateGeographyChildren,The method has 5 parameters. Parameters: children' parentGeographyId' geographyIdTranslation' count' total
Long Parameter List,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,Create,The method has 10 parameters. Parameters: parentOrganizationId' nameInternational' name' nameShort' domain' mailPrefix' anchorGeographyId' acceptsMembers' autoAssignNewMembers' defaultCountryId
Long Parameter List,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,UpdateOrganization,The method has 11 parameters. Parameters: ParentOrganizationId' NameInternational' Name' NameShort' Domain' MailPrefix' AnchorGeographyId' AcceptsMembers' AutoAssignNewMembers' DefaultCountryId' OrganizationId
Long Parameter List,Swarmops.Logic.Swarm,ExternalActivity,C:\repos\Swarmops_Swarmops\Logic\Swarm\ExternalActivity.cs,Create,The method has 6 parameters. Parameters: organization' geograpy' type' date' description' createdByPerson
Long Parameter List,Swarmops.Logic.Swarm,ExternalIdentity,C:\repos\Swarmops_Swarmops\Logic\Swarm\ExternalIdentity.cs,SetExternalIdentity,The method has 5 parameters. Parameters: ExternalSystem' UserID' Password' AttachedToPerson' TypeOfAccount
Long Parameter List,Swarmops.Logic.Swarm,ExternalIdentity,C:\repos\Swarmops_Swarmops\Logic\Swarm\ExternalIdentity.cs,CreateExternalIdentity,The method has 5 parameters. Parameters: ExternalSystem' UserID' Password' AttachedToPerson' TypeOfAccount
Long Parameter List,Swarmops.Logic.Swarm,MembershipEvent,C:\repos\Swarmops_Swarmops\Logic\Swarm\MembershipEvent.cs,MembershipEvent,The method has 7 parameters. Parameters: dateTime' personId' organizationId' geographyId' birthYear' gender' deltaCount
Long Parameter List,Swarmops.Logic.Swarm,Parley,C:\repos\Swarmops_Swarmops\Logic\Swarm\Parley.cs,Create,The method has 12 parameters. Parameters: organization' person' budgetInitial' name' geography' description' informationUrl' startDate' endDate' budgetCents' guaranteeCents' attendanceFeeCents
Long Parameter List,Swarmops.Logic.Swarm,Person,C:\repos\Swarmops_Swarmops\Logic\Swarm\Person.cs,Create,The method has 10 parameters. Parameters: name' email' password' phone' street' postal' city' countryCode' dateOfBirth' gender
Long Parameter List,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,Create,The method has 11 parameters. Parameters: level' createdByPerson' createdByPosition' positionType' positionTitle' volunteerable' overridable' reportsTo' dotReportsTo' minCount' maxCount
Long Parameter List,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,Create,The method has 12 parameters. Parameters: organization' level' createdByPerson' createdByPosition' positionType' positionTitle' volunteerable' overridable' reportsTo' dotReportsTo' minCount' maxCount
Long Parameter List,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,Assign,The method has 6 parameters. Parameters: person' geography' assignedByPerson' assignedByPosition' assignmentNotes' expiresUtc
Long Parameter List,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,Assign,The method has 5 parameters. Parameters: person' assignedByPerson' assignedByPosition' assignmentNotes' expiresUtc
Long Parameter List,Swarmops.Logic.Swarm,PositionAssignment,C:\repos\Swarmops_Swarmops\Logic\Swarm\PositionAssignment.cs,Create,The method has 7 parameters. Parameters: position' geography' person' createdByPerson' createdByPosition' expiresDateTimeUtc' assignmentNotes
Long Identifier,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The length of the parameter satoshisMaximumAnticipatedFees is 30.
Long Identifier,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,,The length of the parameter BitcoinAccountsReceivableIndex is 30.
Long Identifier,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the parameter satoshisMaximumAnticipatedFees is 30.
Long Identifier,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,CheckForexProfitLoss,The length of the parameter currentNativeValueOfForeignCents is 32.
Long Identifier,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,,The length of the parameter _organizationBudgetAttestationSpaceLookup is 41.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetCountriesOperationCompleted is 30.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetCountriesInUseOperationCompleted is 35.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetCitiesForCountryOperationCompleted is 37.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetPostalCodesForCountryOperationCompleted is 42.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetGeographyOperationCompleted is 30.
Long Identifier,Swarmops.Logic.Automation,GetGeographyData,C:\repos\Swarmops_Swarmops\Logic\Automation\GetGeographyData.cs,,The length of the parameter GetGeographyForCountryOperationCompleted is 40.
Long Identifier,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,IsOrInherits,The length of the parameter prospectiveParentOrganizationId is 31.
Long Identifier,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,Inherits,The length of the parameter prospectiveParentOrganizationId is 31.
Long Statement,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateNotification,The length of the statement  "            return CreateNotification(organization' notification' new NotificationStrings()' new NotificationCustomStrings()' recipients); " is 126.
Long Statement,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateSandboxMail,The length of the statement  "                new PayloadEnvelope(new ParticipantMailPayload(customSubject + "|" + sandboxMailAddress' customBody' recipients[0].GetParticipations()[0]' recipients[0])).ToXml()' " is 163.
Long Statement,Swarmops.Logic.Communications,OutboundComm,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundComm.cs,CreateParticipantNotification,The length of the statement  "            payload.Strings[NotificationString.RegularTitle] = organization.RegularLabel.ToString();  // may need fudging later because localization " is 136.
Long Statement,Swarmops.Logic.Communications,OutboundCommRecipients,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundCommRecipients.cs,ForOutboundCommLimited,The length of the statement  "            return FromArray(SwarmDb.GetDatabaseForReading().GetOutboundCommRecipients(comm' DatabaseCondition.OpenTrue' new RecordLimit(limit))); " is 134.
Long Statement,Swarmops.Logic.Communications,RegisterActivistHandler,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageReceiver.cs,Handle,The length of the statement  "                        ActivistEvents.CreateActivistWithLogging(person.Geography' person' "Registered by SMS"' EventSource.SMS' true' true' partyOrgId); " is 129.
Long Statement,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,InsertAllPlaceHoldersToTemplate,The length of the statement  "            // sort the placeholders according to the order they were defined in to guarantee that substitutions are in expected order. " is 123.
Long Statement,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,InsertAllPlaceHoldersToTemplate,The length of the statement  "            // "Inside" substitutions are done if the placeholder containing the substitution is defined before the substitutet one. " is 120.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetSpendableCoin,The length of the statement  "                        new WebClient().DownloadString("https://bitcoincash.blockexplorer.com/api/addr/" + secretKey.PubKey.GetAddress(Network.Main) + "/utxo")); " is 137.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,CheckColdStorageRecurse,The length of the statement  "                                    row.AmountForeignCents = new Money(row.AmountCents' organization.Currency' ourTx.DateTime).ToCurrency (Currency.BitcoinCore); " is 125.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetAddressAccountLookupRecurse,The length of the statement  "            if (!string.IsNullOrEmpty(account.BitcoinAddress) || IsValidBitcoinAddress (account.Name)) // TODO: Add a special property for the address instead of using name " is 160.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The length of the statement  "                                new WebClient().DownloadString("https://blockexplorer.com/api/utils/estimatefee?nbBlocks=" + blocksWait.ToString(CultureInfo.InvariantCulture))); " is 145.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The length of the statement  "                    double feeWholeCoins = Double.Parse((string)feeData[blocksWait.ToString(CultureInfo.InvariantCulture)]' NumberStyles.AllowDecimalPoint); " is 136.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The length of the statement  "            throw new InvalidOperationException("This function is only for testing purposes. It pays real money. Don't use except for dev/test."); " is 134.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The length of the statement  "            Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(BitcoinChain.Cash) * 20; // assume max 20k transaction size " is 155.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The length of the statement  "            // If we arrive at this point' the previous function didn't throw' and we have enough money. Add the inputs to the transaction. " is 127.
Long Statement,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The length of the statement  "                        + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0); " is 143.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddress,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddress.cs,FromIdentityAggressive,The length of the statement  "            return FromBasic(SwarmDb.GetDatabaseForWriting().GetHotBitcoinAddress(hotBitcoinAddressId)); // "Writing" is intentional " is 120.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddress,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddress.cs,Create,The length of the statement  "            string bitcoinAddress = extPubKey.PubKey.GetAddress(Network.Main).ToString();    // TODO: CHANGE NETWORK.MAIN TO NEW LOOKUP " is 123.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddress,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddress.cs,Create,The length of the statement  "            string bitcoinAddressFallback = extPubKey.PubKey.GetAddress(Network.Main).ToString(); // The fallback address would be the main address " is 135.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddresses,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddresses.cs,FindAmount,The length of the statement  "            throw new NotEnoughFundsException("Insufficient funds"' "Group argument"' new Satoshis (satoshisRequired)); // Serving as a placeholder for now' also testing the notification " is 174.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddressUnspent,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddressUnspent.cs,Delete,The length of the statement  "            SwarmDb.GetDatabaseForWriting().SetHotBitcoinAddressBalance (base.HotBitcoinAddressId' this.Address.Unspents.AmountSatoshisTotal); // re-fetches from db " is 152.
Long Statement,Swarmops.Logic.Financial,HotBitcoinAddressUnspents,C:\repos\Swarmops_Swarmops\Logic\Financial\HotBitcoinAddressUnspents.cs,ForAddress,The length of the statement  "            return FromArray (SwarmDb.GetDatabaseForWriting().GetHotBitcoinAddressUnspents (address)); // "ForWriting" is intentional here " is 126.
Long Statement,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The length of the statement  "                    new DateTime(organization.FirstFiscalYear' 1' 1).AddMonths(reportMonthInterval).AddDays(1); // add one day for some safety margin; we're constructing the VAT report on the 2nd of the month " is 188.
Long Statement,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The length of the statement  "                DateTime nextReportGenerationTime = nextReport.AddMonths(reportMonthInterval).AddDays(3); // Make the report on the 4yh after the period has ended " is 146.
Long Statement,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The length of the statement  "                // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll " is 124.
Long Statement,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The length of the statement  "                    btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places) " is 137.
Long Statement,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The length of the statement  "                BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw); " is 122.
Long Statement,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The length of the statement  "            // This function attempts to find a transaction that matches the payment group' a transaction that is currently unbalanced. " is 123.
Long Statement,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateBitcoinPayoutFromPrototype,The length of the statement  "            // This function is made for complex bitcoin payouts and will typically take many different types of payouts to many people at once. " is 132.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidSalaries,The length of the statement  "                BasicPayout basicPayout = new BasicPayout (0' organization.Identity' "[Loc]Financial_TheTaxMan"' "SEBG 5050-1055"' // HACK: Get tax account from something " is 154.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The length of the statement  "                // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal); " is 152.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The length of the statement  "                        // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime); " is 161.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The length of the statement  "                // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description); " is 123.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The length of the statement  "                        // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate); " is 138.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                    else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4) " is 127.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                        // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day. " is 132.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                        OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson)); " is 158.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still). " is 158.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size " is 143.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                        NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1))); " is 127.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN! " is 127.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                        throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress); " is 148.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                            + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0); " is 143.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                        spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode); " is 161.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString()); " is 130.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                    ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null); " is 132.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                    // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger " is 133.
Long Statement,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The length of the statement  "                    ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore); " is 202.
Long Statement,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The length of the statement  "                        monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit " is 121.
Long Statement,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The length of the statement  "                        if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0) " is 125.
Long Statement,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,DenyAttestation,The length of the statement  "            OutboundComm.CreateNotificationOfFinancialValidation(Budget' this.PayrollItem.Person' NetSalaryCents / 100.0' this.PayoutDate.ToString("MMMM yyyy")' " is 148.
Long Statement,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,CheckForexProfitLoss,The length of the statement  "            // Compare current balance in native currency with the current balance in foreign currency. If off by more than 100 cents' " is 122.
Long Statement,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,FromBlockchainHash,The length of the statement  "            // There may be multiple transactions in this Swarmops installation referring to this transaction on the blockchain' but only " is 125.
Long Statement,Swarmops.Logic.Cache,OrganizationCache,C:\repos\Swarmops_Swarmops\Logic\Cache\OrganizationCache.cs,Reload,The length of the statement  "            // Let this be for the moment' new and old parents need to be loaded as well. Better right now to reload the whole cache. " is 121.
Long Statement,Swarmops.Logic.Cache,OrganizationCache,C:\repos\Swarmops_Swarmops\Logic\Cache\OrganizationCache.cs,Reload,The length of the statement  "            //    __organizationCache[objectId][0] = Organization.FromBasic(SwarmDb.GetDatabaseForReading().GetOrganization(objectId)); " is 123.
Long Statement,Swarmops.Logic.Cache,OrganizationCache,C:\repos\Swarmops_Swarmops\Logic\Cache\OrganizationCache.cs,GetOrganizationTree,The length of the statement  "                    // new Organization(organization.OrganizationId' organization.ParentOrganizationId' organization.Name' generation + 1)); " is 120.
Long Statement,Swarmops.Logic.Communications.Payload,NotificationPayload,C:\repos\Swarmops_Swarmops\Logic\Communications\Payload\NotificationPayload.cs,GetSubject,The length of the statement  "                    Logic_Communications_Transmission_NotificationPayload.ResourceManager.GetString (SubjectResource' CultureInfo.CreateSpecificCulture (cultureId))); " is 146.
Long Statement,Swarmops.Logic.Communications.Payload,NotificationPayload,C:\repos\Swarmops_Swarmops\Logic\Communications\Payload\NotificationPayload.cs,RenderComm,The length of the statement  "            if (string.IsNullOrEmpty (culture) || culture == "af-ZA") // the af-ZA is the virtual in-place translator code' which is gibberish " is 130.
Long Statement,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The length of the statement  "                // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception. " is 139.
Long Statement,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,InitializeSymmetricFileSystemKey,The length of the statement  "            if (Debugger.IsAttached && Path.DirectorySeparatorChar == '\\') // check if we're debugging - double check to overdo security " is 125.
Long Statement,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,HasAccess,The length of the statement  "                throw new ArgumentNullException("access"' @"Access cannot be null' but must always be explicitly specified. Specify AccessAspect.Null if null access is desired."); " is 163.
Long Statement,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,HasAccess,The length of the statement  "                    // This organization has decided to open its financial reports to all participants. Reselect the access request to "participant" level. " is 135.
Long Statement,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,CanAccess,The length of the statement  "            throw new NotImplementedException("Authority.CanAccess is not implemented for type " + identifiableObject.GetType().FullName); " is 126.
Long Statement,Swarmops.Logic.Support,BackendServiceOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServiceOrder.cs,Execute,The length of the statement  "                SwarmDb.GetDatabaseForWriting().SetBackendServiceOrderException(this.Identity' new ArgumentNullException("ClassName"' "Class failed to instantiate -- service engine is null: " + className)); " is 190.
Long Statement,Swarmops.Logic.Support,BackendServiceOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServiceOrder.cs,Execute,The length of the statement  "            MethodInfo methodFromXml = serviceClassType.GetMethod("FromXml"' BindingFlags.FlattenHierarchy | BindingFlags.Static | BindingFlags.Public); " is 140.
Long Statement,Swarmops.Logic.Support,BackendServiceOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServiceOrder.cs,Execute,The length of the statement  "                SwarmDb.GetDatabaseForWriting().SetBackendServiceOrderException(this.Identity' new ArgumentNullException("MethodName"' "Class failed to instantiate -- method search returned null")); " is 182.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,FirstInitialization,The length of the statement  "            // in the file' the commands are split by a single # sign. (Semicolons are an integral part of storedprocs' so they can't be used.) " is 131.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The length of the statement  "                Console.WriteLine("Swarmops: Current DB version is {0}' but expected is {1}. A schema upgrade will take place."' currentDbVersion' expectedDbVersion); " is 150.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The length of the statement  "                    // Because Mono installs with an insufficient certificate store' we must disable certificate checking before accessing github " is 125.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The length of the statement  "                    fileName = String.Format("https://raw.githubusercontent.com/Swarmops/Swarmops/master/Database/Schemata/upgrade-{0:D4}.sql"' " is 123.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The length of the statement  "                // in the file' the commands are split by a single # sign. (Semicolons are an integral part of storedprocs' so they can't be used.) " is 131.
Long Statement,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The length of the statement  "                        string trimmedCommand = sqlCommand.Trim().TrimEnd(';').Trim(); // removes whitespace first' then any ; at the end (if left in by mistake) " is 137.
Long Statement,Swarmops.Logic.Support,SupportFunctions,C:\repos\Swarmops_Swarmops\Logic\Support\General.cs,DisableSslCertificateChecks,The length of the statement  "            // TODO: Does this install a new handler every time it's been called? How do you verify that this short-circuit is in place? " is 124.
Long Statement,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,TemplateToPdf,The length of the statement  "                    "-c \"inkscape --without-gui --export-to-pdf=" + tempFileName + " " + svgFileName + "\"");  // inkscape is a package-level dependency " is 133.
Long Statement,Swarmops.Logic.Support,PWEvents,C:\repos\Swarmops_Swarmops\Logic\Support\PWEvents.cs,CreateEvent,The length of the statement  "            //TODO: organizationId comes in hardcoded as 1 from a lot of places' should probably be changed based on affected person " is 120.
Long Statement,Swarmops.Logic.Support,SingularFactory,C:\repos\Swarmops_Swarmops\Logic\Support\SingularFactory.cs,FromBasic,The length of the statement  "                            "Unable to find higher-order class for base type " + basicType.ToString() + "; if it's in a plugin' was the higher-order assembly registered with SingularFactory?"); " is 165.
Long Statement,Swarmops.Logic.Support,SingularFactory,C:\repos\Swarmops_Swarmops\Logic\Support\SingularFactory.cs,FromBasic,The length of the statement  "                        "Unable to find a public static method named \"" + logicType.ToString() + ".FromBasic (" +basicType.ToString()+ ")\" in a loaded assembly"); " is 140.
Long Statement,Swarmops.Logic.Support,SwarmopsLog,C:\repos\Swarmops_Swarmops\Logic\Support\SwarmopsLog.cs,DebugLog,The length of the statement  "                File.AppendAllLines("/tmp/swarmops-debug.log"' new string[] { DateTime.UtcNow.ToString("yyyy-MM-dd/HH:mm:ss.fff | ") + logEntry }); " is 131.
Long Statement,Swarmops.Logic.Support.BackendServices,RasterizeDocumentHiresOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServices\RasterizeDocumentHiresOrder.cs,LongRun,The length of the statement  "                PdfProcessor.Rerasterize((Document)document' PdfProcessor.PdfProcessorOptions.HighQuality | PdfProcessor.PdfProcessorOptions.ForceOrphans); " is 139.
Long Statement,Swarmops.Logic.Support.BackendServices,ReturnBitcoinEchoUtxoOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServices\ReturnBitcoinEchoUtxoOrder.cs,Run,The length of the statement  "            // TODO: Verify that the utxoAddress is an EchoTest address' i.e. has second path component == BitcoinUtility.BitcoinEchoTestIndex " is 130.
Long Statement,Swarmops.Logic.Support.BackendServices,ReturnBitcoinEchoUtxoOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServices\ReturnBitcoinEchoUtxoOrder.cs,Run,The length of the statement  "            string returnAddress = BitcoinUtility.GetInputAddressesForTransaction(BitcoinChain.Cash' utxoToReturn.TransactionHash)[0]; // assumes at least one input address -- not coinbase " is 176.
Long Statement,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,GetUndeliverableCases,The length of the statement  "                        "SELECT ixBug'sTitle FROM Bug WHERE (sTitle LIKE 'Undeliver%' OR sTitle = 'failure notice' OR sTitle LIKE 'Mail delivery failed: returning message to sender' OR sTitle LIKE 'Delivery Status Notification%' OR sTitle LIKE 'Olevererbart:%' OR sTitle LIKE 'Returned mail:%') AND fOpen=1 and ixBug > " + " is 298.
Long Statement,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,GetDelayWarnings,The length of the statement  "                        "SELECT ixBug'sTitle FROM Bug WHERE (sTitle = 'Delivery Status Notification (Delay)' OR sTitle LIKE 'Warning: could not send message for %' OR sTitle LIKE 'AUTO:%' OR sTitle LIKE 'Out of Office%') AND fOpen=1"' " is 210.
Long Statement,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,GetRecentOutgoingEmails,The length of the statement  "                        "SELECT BugEvent.ixBugEvent AS BugEventId'BugEvent.ixBug AS BugId' Bug.sTitle as BugTitle' Bug.sCustomerEmail AS Recipient' BugEvent.s AS Body'Person.sFullName AS Sender FROM BugEvent'Bug'Person WHERE BugEvent.sVerb='Replied' AND BugEvent.fEmail=1 AND Person.ixPerson=BugEvent.ixPerson AND Bug.ixBug = BugEvent.ixBug AND BugEvent.ixBugEvent > " + " is 346.
Long Statement,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The length of the statement  "            //  BugEvent.ixBugEvent AS BugEventId'BugEvent.ixBug AS BugId' Bug.sTitle as BugTitle' Bug.sCustomerEmail AS Recipient' BugEvent.s AS Body'Person.sFullName AS Sender " is 165.
Long Statement,Swarmops.Logic.Special.Sweden,SwedishForumHandleProvider,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumHandleProvider.cs,SetPersonHandle,The length of the statement  "                int[] members = SwarmDb.GetDatabaseForReading().GetObjectsByOptionalData(ObjectType.Person' ObjectOptionalDataType.ForumAccountId' "" + newHandleAccountId); " is 156.
Long Statement,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,Create,The length of the statement  "            return FromBasic (SwarmDb.GetDatabaseForWriting().GetGeographyUpdate (identity));  // "ForWriting" intentional to avoid db replication race conditions " is 150.
Long Statement,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,FromOptionalDataString,The length of the statement  "            int[] organizationIds = SwarmDb.GetDatabaseForReading().GetObjectsByOptionalData(ObjectType.Organization' dataType' data.Trim()); " is 129.
Long Statement,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,EnableEconomy,The length of the statement  "            FinancialAccount lodging = FinancialAccount.Create(this' "[LOC]Cost_TravelLodging"' FinancialAccountType.Cost' travelMaster); " is 125.
Long Statement,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,Delete,The length of the statement  "            // OrganizationCache.DeleteOrganization(this.Identity);  -- commented out because OrganizationCache.Delete is also marked obsolete " is 130.
Long Statement,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddBitcoinChecks,The length of the statement  "                if (authority.Organization.FinancialAccounts.AssetsBitcoinHot != null && authority.Organization.Identity != Organization.SandboxIdentity && ! PilotInstallationIds.IsPilot(PilotInstallationIds.DevelopmentSandbox)) " is 212.
Long Statement,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddBitcoinChecks,The length of the statement  "                                        "SwarmopsJS.ajaxCall('/Automation/FinancialFunctions.aspx/SetBitcoinPayoutAddress'' { bitcoinAddress: enteredData }' function (result) { " + " is 140.
Long Statement,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddBitcoinChecks,The length of the statement  "                                          "if (result.Success) { alertify.log('Payout address set.'); $('div#divDashboardTodo').fadeOut(); } else { alertify.alert('Could not set payout address: ' + result.DisplayMessage); } " + " is 185.
Long Statement,Swarmops.Logic.Swarm,Participation,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participation.cs,Terminate,The length of the statement  "                PWEvents.CreateEvent (EventSource.PirateWeb' EventType.LostMember' actingPerson.Identity' OrganizationId' Person.GeographyId' " is 125.
Long Statement,Swarmops.Logic.Swarm,Participation,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participation.cs,Terminate,The length of the statement  "                // Remove all newsletter subscriptions once the membership is terminated (to make sure default is now off and only turn off explicitly turned-on subscriptions) " is 159.
Long Statement,Swarmops.Logic.Swarm,Participation,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participation.cs,Terminate,The length of the statement  "                // HACK HACK HACK: uses feed IDs in an extremely ugly way to loop 1-9. Should use NewsletterFeeds.ForOrganization() once support for newsletters in different orgs are established. " is 179.
Long Statement,Swarmops.Logic.Swarm,MembershipEvents,C:\repos\Swarmops_Swarmops\Logic\Swarm\MembershipEvents.cs,LoadAll,The length of the statement  "                    // A few records in the database have had their memberships terminated at the exact time of creation. This means that sorting will " is 130.
Long Statement,Swarmops.Logic.Swarm,Parley,C:\repos\Swarmops_Swarmops\Logic\Swarm\Parley.cs,CancelBudget,The length of the statement  "            // Adjust budgets. (NB: Cost budgets are negative' but the bookkeeping cost funds are positive. Some sign reversal is necessary.) " is 129.
Long Statement,Swarmops.Logic.Swarm,PersonQuarantine,C:\repos\Swarmops_Swarmops\Logic\Swarm\PersonQuarantine.cs,QuarantineFor,The length of the statement  "            ObjectOptionalData.ForObject(this._person).SetOptionalDataString(this._quarantineType' quarantineUntil.ToString("yyyy-MM-dd hh:mm:ss"' CultureInfo.InvariantCulture)); " is 166.
Long Statement,Swarmops.Logic.Swarm,Position,C:\repos\Swarmops_Swarmops\Logic\Swarm\Position.cs,HasAccess,The length of the statement  "                throw new ArgumentNullException ("access"' @"Access requested must always be specified. Use AccessAspect.Null if null access is desired (and access should always be true)."); " is 174.
Long Statement,Swarmops.Logic.Swarm,PositionAssignment,C:\repos\Swarmops_Swarmops\Logic\Swarm\PositionAssignment.cs,FromIdentityAggressive,The length of the statement  "            return FromBasic(SwarmDb.GetDatabaseForWriting().GetPositionAssignment(positionAssignmentId)); // "ForWriting" is intentional - avoids race conditions in Create() " is 162.
Long Statement,Swarmops.Logic.Swarm,PositionAssignment,C:\repos\Swarmops_Swarmops\Logic\Swarm\PositionAssignment.cs,Create,The length of the statement  "                    expiresDateTimeUtc == null ? Constants.DateTimeHigh : (DateTime) expiresDateTimeUtc' assignmentNotes);  // DateTime.MaxValue kills MySql layer " is 142.
Long Statement,Swarmops.Logic.Swarm,PositionAssignment,C:\repos\Swarmops_Swarmops\Logic\Swarm\PositionAssignment.cs,Terminate,The length of the statement  "            base.TerminatedDateTimeUtc = DateTime.UtcNow; // may differ by milliseconds from actual value set' but shouldn't matter for practical purposes " is 142.
Long Statement,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,ForOrganizationGeographyRecurse,The length of the statement  "                TreeNode<Position> newPositionNode = positionNode.AddChild (Position.FromBasic(positionTemplate)); // "FromBasic" creates a deep copy " is 133.
Long Statement,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,CreateSysadminPositions,The length of the statement  "            Position sysadminPrincipal = Position.Create (PositionLevel.SystemWide' null /* createdByPerson*/' null /*createdByPosition*/' PositionType.System_SysadminMain' " is 160.
Long Statement,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,CreateSysadminPositions,The length of the statement  "                PositionTitle.Default' false /*volunteerable*/' false /*overridable*/' null /*reportsTo*/' null /*dotReportsTo*/' 1 /*minCount*/' 1 /*maxCount*/); " is 146.
Long Statement,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,CreateSysadminPositions,The length of the statement  "            Position.Create(PositionLevel.SystemWide' null /* createdByPerson*/' null /*createdByPosition*/' PositionType.System_SysadminReadWrite' PositionTitle.Default' " is 158.
Long Statement,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,CreateSysadminPositions,The length of the statement  "            Position.Create(PositionLevel.SystemWide' null /* createdByPerson*/' null /*createdByPosition*/' PositionType.System_SysadminAssistantReadOnly' PositionTitle.Default' " is 166.
Complex Conditional,Swarmops.Logic.Communications,UnregisterActivistHandler,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageReceiver.cs,Filter,The conditional expression  "(smsParts[0] == "stopp" || smsParts[0] == "stop") &&                  (smsParts[1] == "aktivist" || smsParts[1] == "activist")"  is complex.
Complex Conditional,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The conditional expression  "dateTime.Year < 2014 && organization.Identity == 1 &&                      fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId) &&                      PilotInstallationIds.IsPilot (PilotInstallationIds.PiratePartySE)"  is complex.
Complex Conditional,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidExpenseClaims,The conditional expression  "claim.Attested && claim.Validated && !claim.Repaid && !claim.KeepSeparate"  is complex.
Complex Conditional,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The conditional expression  "possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity"  is complex.
Complex Conditional,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,HasAccess,The conditional expression  "(access.Aspect == AccessAspect.Bookkeeping || access.Aspect == AccessAspect.Financials) &&                  access.Type == AccessType.Read && this.Person.Identity == Swarm.Person.OpenLedgersIdentity"  is complex.
Complex Conditional,Swarmops.Logic.DashboardTasks,Tasks,C:\repos\Swarmops_Swarmops\Logic\DashboardTasks\Tasks.cs,AddAdvanceDebts,The conditional expression  "claim.Open && claim.Attested && claim.Validated && claim.Claimed"  is complex.
Empty Catch Block,Swarmops.Logic.Communications,PhoneMessageReceiver,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageReceiver.cs,Handle,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Communications,PhoneMessageReceiver,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageReceiver.cs,GetPeopleFromPhoneNumbers,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,PreparePlaceholders,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,IsValidBitcoinAddress,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,IsValidBitcoinAddress,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,GetPeopleByLoginToken,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Security,PermissionSet,C:\repos\Swarmops_Swarmops\Logic\Security\PermissionSet.cs,PermissionSet,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Security,PermissionSet,C:\repos\Swarmops_Swarmops\Logic\Security\PermissionSet.cs,PermissionSet,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Support,BackendServiceOrder,C:\repos\Swarmops_Swarmops\Logic\Support\BackendServiceOrder.cs,Execute,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,FirstInitialization,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Support,DatabaseMaintenance,C:\repos\Swarmops_Swarmops\Logic\Support\DatabaseMaintenance.cs,UpgradeSchemata,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.DataObjects,OrganizationsDataObject,C:\repos\Swarmops_Swarmops\Logic\DataObjects\OrganizationDataObject.cs,UpdateOrgUptake,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetUptakeGeographies,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,LoadFunctionalMailAddress,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Swarm,Activists,C:\repos\Swarmops_Swarmops\Logic\Swarm\Activists.cs,SendPhoneMessage,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Swarm,Participation,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participation.cs,Terminate,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Swarm,PaymentCode,C:\repos\Swarmops_Swarmops\Logic\Swarm\PaymentCode.cs,Create,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Swarm,Person,C:\repos\Swarmops_Swarmops\Logic\Swarm\Person.cs,ResolveGeography,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.Swarm,Volunteer,C:\repos\Swarmops_Swarmops\Logic\Swarm\Volunteer.cs,AutoAssign,The method has an empty catch block.
Empty Catch Block,Swarmops.Logic.DashboardTasks,Tasks,C:\repos\Swarmops_Swarmops\Logic\DashboardTasks\Tasks.cs,AddExpenseClaims,The method has an empty catch block.
Magic Number,Swarmops.Logic.Communications,AutoMail,C:\repos\Swarmops_Swarmops\Logic\Communications\AutoMail.cs,FromTypeOrganizationAndGeography,The following statement contains a magic number: if (basic.Body.Trim().Length < 3)              {                  return null; // If there is no body' there is no mail              }
Magic Number,Swarmops.Logic.Communications,MailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\MailTemplate.cs,FromNameCountryAndOrg,The following statement contains a magic number: string lang = country.Culture.Substring (0' 2);
Magic Number,Swarmops.Logic.Communications,MailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\MailTemplate.cs,FromNameAndOrg,The following statement contains a magic number: string lang = country.Culture.Substring (0' 2);
Magic Number,Swarmops.Logic.Communications,NewsletterFeeds,C:\repos\Swarmops_Swarmops\Logic\Communications\NewsletterFeeds.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,NewsletterFeeds,C:\repos\Swarmops_Swarmops\Logic\Communications\NewsletterFeeds.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,CreateFake,The following statement contains a magic number: return FromBasic (new BasicOutboundMail (0' MailAuthorType.Person' author.PersonId' title'                  body' 99' mailType' organization.Identity'                  geography.Identity' DateTime.Now'                  DateTime.Now' false' false' false' Constants.DateTimeLow'                  Constants.DateTimeLow' Constants.DateTimeLow' 0' 0' 0));
Magic Number,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,PrepareTemplate,The following statement contains a magic number: if (renderText)              {                  if (this.templatePlain == null)                  {                      this.templatePlain =                          TypedMailTemplate.FromName (TypedMailTemplate.GetNameFromMailType (MailType) + "Plain");                      this.templatePlain.Initialize (culture.Substring (3)' Organization.Identity' this'                          (renderText ? "Plain" : ""));                      this.templatePlain.PreparePlaceholders();                  }                  else                  {                      //reuse the template' just reset the html to the saved version before replacements                      this.templatePlain.Template.ResetContent();                  }                  template = this.templatePlain;              }              else              {                  if (this.templateHtml == null)                  {                      this.templateHtml = TypedMailTemplate.FromName (TypedMailTemplate.GetNameFromMailType (MailType));                      this.templateHtml.Initialize (culture.Substring (3)' Organization.Identity' this'                          (renderText ? "Plain" : ""));                      this.templateHtml.PreparePlaceholders();                  }                  else                  {                      //reuse the template' just reset the html to the saved version before replacements                      this.templateHtml.Template.ResetContent();                  }                  template = this.templateHtml;              }
Magic Number,Swarmops.Logic.Communications,OutboundMail,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMail.cs,PrepareTemplate,The following statement contains a magic number: if (renderText)              {                  if (this.templatePlain == null)                  {                      this.templatePlain =                          TypedMailTemplate.FromName (TypedMailTemplate.GetNameFromMailType (MailType) + "Plain");                      this.templatePlain.Initialize (culture.Substring (3)' Organization.Identity' this'                          (renderText ? "Plain" : ""));                      this.templatePlain.PreparePlaceholders();                  }                  else                  {                      //reuse the template' just reset the html to the saved version before replacements                      this.templatePlain.Template.ResetContent();                  }                  template = this.templatePlain;              }              else              {                  if (this.templateHtml == null)                  {                      this.templateHtml = TypedMailTemplate.FromName (TypedMailTemplate.GetNameFromMailType (MailType));                      this.templateHtml.Initialize (culture.Substring (3)' Organization.Identity' this'                          (renderText ? "Plain" : ""));                      this.templateHtml.PreparePlaceholders();                  }                  else                  {                      //reuse the template' just reset the html to the saved version before replacements                      this.templateHtml.Template.ResetContent();                  }                  template = this.templateHtml;              }
Magic Number,Swarmops.Logic.Communications,OutboundMailRecipients,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMailRecipients.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,OutboundMailRecipients,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMailRecipients.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,OutboundMails,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMails.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,OutboundMails,C:\repos\Swarmops_Swarmops\Logic\Communications\OutboundMails.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Communications,PaperLetters,C:\repos\Swarmops_Swarmops\Logic\Communications\PaperLetters.cs,FromArray,The following statement contains a magic number: PaperLetters result = new PaperLetters {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Communications,PaperLetters,C:\repos\Swarmops_Swarmops\Logic\Communications\PaperLetters.cs,FromArray,The following statement contains a magic number: PaperLetters result = new PaperLetters {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Communications,PhoneMessageReceiver,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageReceiver.cs,SendMail,The following statement contains a magic number: SmtpClient mailserver = new SmtpClient ("mail.piratpartiet.se"' 587);
Magic Number,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,TypeFromName,The following statement contains a magic number: if (className.ToLower().EndsWith ("plain"))                  className = className.Substring (0' className.Length - 5);
Magic Number,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,FromName,The following statement contains a magic number: try              {                  if (className.EndsWith ("Plain"))                      className = className.Substring (0' className.Length - 5);                  //Get the current assembly object                  Assembly assembly = Assembly.GetExecutingAssembly();                  //Get the name of the assembly (this will include the public token and version number                  AssemblyName assemblyName = assembly.GetName();                  //Use just the name concat to the class chosen to get the type of the object                  Type t = assembly.GetType (assemblyName.Name + ".Communications." + className' false' true);                  if (t == null)                  {                      //Fail' no such class                      throw new ArgumentException ("There is no defined class for a TypedMailTemplate named:" + className);                  }                  //Create the object' cast it and return it to the caller                  return (TypedMailTemplate) Activator.CreateInstance (t);              }              catch (Exception e)              {                  throw new Exception ("Failed to create TypedMailTemplate " + className' e);              }
Magic Number,Swarmops.Logic.Communications,TypedMailTemplate,C:\repos\Swarmops_Swarmops\Logic\Communications\TypedMailTemplate.cs,Initialize,The following statement contains a magic number: try              {                  this.template = MailTemplate.FromNameCountryAndOrg (BaseName + variant' countryCode' orgId);              }              catch              {                  string name = BaseName + variant;                  if (name.EndsWith ("Plain"))                  {                      try                      {                          name = name.Substring (0' name.Length - 5);                          this.template = MailTemplate.FromNameCountryAndOrg (name' countryCode' orgId);                      }                      catch (Exception e)                      {                          throw new Exception (                              "Failed to create MailTemplate.FromNameCountryAndOrg(" + name + "'" + countryCode + "'" +                              orgId + ")"' e);                      }                  }                  else                  {                      try                      {                          this.template = MailTemplate.FromNameCountryAndOrg (name + "Plain"' countryCode' orgId);                      }                      catch (Exception e)                      {                          throw new Exception (                              "Failed to create (plain) MailTemplate.FromNameCountryAndOrg(" + name + "'" + countryCode +                              "'" + orgId + ")"' e);                      }                  }              }
Magic Number,Swarmops.Logic.Communications,PhoneMessageTransmitter,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,CheckServiceStatus,The following statement contains a magic number: switch (Credential.ServiceName)              {                  case "SwedishSms":                      return true; //cant test this                    case "SwedishKannel":                  {                      String username = Credential.Login;                      String password = Credential.Password;                      Encoding enc = Credential.Encoding;                      String url = "https://nurse.sanitarium.se/kannel/status";                      String result;                        HttpWebResponse responseOut = null;                      try                      {                          result = HTTPSender.Send (url' enc' 1500' out responseOut);                          if (((int) responseOut.StatusCode).ToString().StartsWith ("2"))                              return true;                          return false;                      }                      catch (Exception)                      {                          return false;                      }                  }                  default:                      throw new Exception ("Error on SMS transmit. Unknown SMS service: " + Credential.ServiceName);              }
Magic Number,Swarmops.Logic.Communications,PhoneMessageTransmitter,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,NormalizePhoneNumber,The following statement contains a magic number: if (phoneNumber.Length > 4 && !phoneNumber.StartsWith ("+"))              {                  if (phoneNumber.StartsWith ("00"))                  {                      phoneNumber = "+" + phoneNumber.Substring (2);                  }                  else if (phoneNumber.StartsWith ("0"))                  {                      phoneNumber = "+46" + phoneNumber.Substring (1);                  }                  else                  {                      phoneNumber = "+" + phoneNumber;                  }              }
Magic Number,Swarmops.Logic.Communications,PhoneMessageTransmitter,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,NormalizePhoneNumber,The following statement contains a magic number: if (phoneNumber.Length > 4 && !phoneNumber.StartsWith ("+"))              {                  if (phoneNumber.StartsWith ("00"))                  {                      phoneNumber = "+" + phoneNumber.Substring (2);                  }                  else if (phoneNumber.StartsWith ("0"))                  {                      phoneNumber = "+46" + phoneNumber.Substring (1);                  }                  else                  {                      phoneNumber = "+" + phoneNumber;                  }              }
Magic Number,Swarmops.Logic.Communications,PhoneMessageTransmitter,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,DeNormalizedPhoneNumber,The following statement contains a magic number: string[] phoneNumbers = new string[3];
Magic Number,Swarmops.Logic.Communications,PhoneMessageTransmitter,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,DeNormalizedPhoneNumber,The following statement contains a magic number: if (match.Success)              {                  GroupCollection groups = match.Groups;                  int i = groups.Count - 1;                  phoneNumbers[0] = "0" + groups[i];                  phoneNumbers[1] = "0046" + groups[i];                  phoneNumbers[2] = "46" + groups[i]; // PW Doesn't save the + so don't search for it              }              else                  phoneNumbers[0] = phoneNumber;
Magic Number,Swarmops.Logic.Communications,HTTPSender,C:\repos\Swarmops_Swarmops\Logic\Communications\PhoneMessageTransmitter.cs,Send,The following statement contains a magic number: byte[] buf = new byte[8092];
Magic Number,Swarmops.Logic.Financial,BitcoinBlockchainUpgrade,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinBlockchainUpgrade.cs,Upgrade,The following statement contains a magic number: fromVersion -= fromVersion%2;
Magic Number,Swarmops.Logic.Financial,BitcoinBlockchainUpgrade,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinBlockchainUpgrade.cs,Upgrade,The following statement contains a magic number: while (fromVersion < toVersion)              {                  SystemSettings.BlockchainCodeVersion = fromVersion + 1;  // Indicates upgrade in progress                    switch (fromVersion)                  {                      case 0:                          SplitCashFromCore();                          break;                      default:                          throw new NotImplementedException("Unimplemented upgrade path");                  }                      fromVersion += 2;              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,VerifyBitcoinHotWallet,The following statement contains a magic number: if (!File.Exists (SystemSettings.EtcFolder + Path.DirectorySeparatorChar + "hotwallet"))              {                  ExtKey privateRoot = new ExtKey();                  File.WriteAllText (SystemSettings.EtcFolder + Path.DirectorySeparatorChar + "hotwallet"'                      privateRoot.GetWif (Network.Main).ToWif()' Encoding.ASCII);                  File.WriteAllText (                      SystemSettings.EtcFolder + Path.DirectorySeparatorChar + "hotwallet-created-" +                      DateTime.UtcNow.ToString ("yyyy-MM-dd--HH-mm-ss--fff.backup")'                      privateRoot.GetWif (Network.Main).ToWif()' Encoding.ASCII); // an extra backup                    if (String.IsNullOrEmpty (Persistence.Key["BitcoinHotPublicRoot"]))                  {                      Persistence.Key["BitcoinHotPublicRoot"] = privateRoot.Neuter().GetWif (Network.Main).ToWif();                  }              }              else              {                  // The file exists. Does the database have the hotwallet public root?                    if (Persistence.Key["BitcoinHotPublicRoot"].Length < 3)                  {                      // No' it has disappeared' which can happen for a few bad reasons                        Persistence.Key["BitcoinHotPublicRoot"] =                          BitcoinHotPrivateRoot.Neuter().GetWif (Network.Main).ToWif();                      if (!PilotInstallationIds.IsPilot (PilotInstallationIds.DevelopmentSandbox))                      {                          // TODO: Log some sort of exception (the sandbox db is reset every night' so it's ok to lose the public key from there)                      }                  }                    // Is the hotwallet public root equal to the private root' while in production environment?                    // ReSharper disable once RedundantCheckBeforeAssignment                  if (Persistence.Key["BitcoinHotPublicRoot"] !=                      BitcoinHotPrivateRoot.Neuter().GetWif (Network.Main).ToWif() && !Debugger.IsAttached)                  {                      // SERIOUS CONDITION - the public root key did not match the private root key. This needs to be logged somewhere.                      OutboundComm.CreateNotification (NotificationResource.System_PublicRootReset);                        // Reset it                      Persistence.Key["BitcoinHotPublicRoot"] =                          BitcoinHotPrivateRoot.Neuter().GetWif (Network.Main).ToWif();                  }              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestUnspents,The following statement contains a magic number: switch (chain)              {                  case BitcoinChain.Core:                        addressInfoResult =                          JObject.Parse(                              new WebClient().DownloadString(                                  "https://blockchain.info/address/" + address + "?format=json&api_key=" +                                  SystemSettings.BlockchainSwarmopsApiKey));                        if ((int)addressInfoResult["final_balance"] == 0)                      {                          return false; // no funds on address at all at this time                      }                        try                      {                          unspentJsonResult = JObject.Parse(                              new WebClient().DownloadString("https://blockchain.info/unspent?active=" + address + "&api_key=" +                                                              SystemSettings.BlockchainSwarmopsApiKey));                        }                      catch (WebException webException)                      {                          // A 500 on the above _may_ mean that there's no unspent outpoints. It can also mean a data                          // retrieval or network error' in which case the exception must absolutely not be interpreted                          // as valid data of zero unspent outpoints.                            try                          {                              if (webException.Response == null)                              {                                  throw; // if there's no response at all' we can't do shit                              }                                string errorResponseContent =                                  new StreamReader(webException.Response.GetResponseStream()).ReadToEnd();                                if (errorResponseContent.Trim().StartsWith("No free outputs to spend"))                              {                                  // all is okay network-wise' there just aren't any UTXOs so we're getting an error code for that                                    return false; // no further processing and there are no fresh transactions                              }                                throw; // otherwise throw upward                          }                          catch (WebException)                          {                              // Ok' we tried' but there's apparently a network error so we need to abort this whole thing                              throw;                          }                        }                        foreach (var unspentJson in unspentJsonResult["unspent_outputs"])                      {                          BitcoinUnspentTransactionOutput txUnspent = new BitcoinUnspentTransactionOutput()                          {                              BitcoinAddress = address'                              ConfirmationCount = (UInt32)unspentJson["confirmations"]'                              Satoshis = (UInt64)unspentJson["value"]'                              TransactionHash = (string)unspentJson["tx_hash_big_endian"]'                              TransactionOutputIndex = (UInt32)unspentJson["tx_output_n"]                          };                            if (txUnspent.ConfirmationCount < 2)                          {                              // Fresh transactions' return true                              result = true;                          }                            // Add unspent to database                            if (hotAddress == null)                          {                              hotAddress = HotBitcoinAddress.FromAddress(chain' address);                          }                            SwarmDb.GetDatabaseForWriting()                              .CreateHotBitcoinAddressUnspentConditional(hotAddress.Identity' txUnspent.TransactionHash'                                  (int)txUnspent.TransactionOutputIndex' (Int64)txUnspent.Satoshis'                                  (int)txUnspent.ConfirmationCount);                      }                        // Update hotaddress totals                        HotBitcoinAddresses.UpdateAllUnspentTotals();                        return result;                        case BitcoinChain.Cash:                        // TODO: SELECTION OF BLOCK EXPLORER' ADDRESS STRING FORMAT TO GO WITH IT                        addressInfoResult =                          JObject.Parse(                              new WebClient().DownloadString(                                  "https://bitcoincash.blockexplorer.com/api/addr/" + address));                        JArray unspentArray;                        if ((int)addressInfoResult["balanceSat"] == 0 && (int)addressInfoResult["unconfirmedBalanceSat"] == 0)                      {                          return false; // no funds on address at all at this time                      }                        try                      {                          unspentArray = JArray.Parse(                              new WebClient().DownloadString("https://bitcoincash.blockexplorer.com/api/addr/" + address + "/utxo"));                        }                      catch (WebException webException)                      {                          // A 500 on the above _may_ mean that there's no unspent outpoints. It can also mean a data                          // retrieval or network error' in which case the exception must absolutely not be interpreted                          // as valid data of zero unspent outpoints.                            try                          {                              if (webException.Response == null)                              {                                  throw; // if there's no response at all' we can't do shit                              }                                string errorResponseContent =                                  new StreamReader(webException.Response.GetResponseStream()).ReadToEnd();                                if (errorResponseContent.Trim().StartsWith("No free outputs to spend"))                              {                                  // all is okay network-wise' there just aren't any UTXOs so we're getting an error code for that                                    return false; // no further processing and there are no fresh transactions                              }                                throw; // otherwise throw upward                          }                          catch (WebException)                          {                              // Ok' we tried' but there's apparently a network error so we need to abort this whole thing                              throw;                          }                        }                        foreach (JObject unspentJson in unspentArray.Children())                      {                          BitcoinUnspentTransactionOutput txUnspent = new BitcoinUnspentTransactionOutput()                          {                              BitcoinAddress = address'                              ConfirmationCount = (UInt32)unspentJson["confirmations"]'                              Satoshis = (UInt64)unspentJson["satoshis"]'                              TransactionHash = (string)unspentJson["txid"]'                              TransactionOutputIndex = (UInt32)unspentJson["vout"]                          };                            if (txUnspent.ConfirmationCount < 2)                          {                              // Fresh transactions' return true                              result = true;                          }                            // Add unspent to database                            if (hotAddress == null)                          {                              hotAddress = HotBitcoinAddress.GetAddressOrForkCore(chain' address);                          }                            SwarmDb.GetDatabaseForWriting()                              .CreateHotBitcoinAddressUnspentConditional(hotAddress.Identity' txUnspent.TransactionHash'                                  (int)txUnspent.TransactionOutputIndex' (Int64)txUnspent.Satoshis'                                  (int)txUnspent.ConfirmationCount);                      }                        // Update hotaddress totals                        HotBitcoinAddresses.UpdateAllUnspentTotals();                        return result;                    default:                      throw new NotImplementedException("Unimplemented bitcoin chain: " + chain);              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestUnspents,The following statement contains a magic number: switch (chain)              {                  case BitcoinChain.Core:                        addressInfoResult =                          JObject.Parse(                              new WebClient().DownloadString(                                  "https://blockchain.info/address/" + address + "?format=json&api_key=" +                                  SystemSettings.BlockchainSwarmopsApiKey));                        if ((int)addressInfoResult["final_balance"] == 0)                      {                          return false; // no funds on address at all at this time                      }                        try                      {                          unspentJsonResult = JObject.Parse(                              new WebClient().DownloadString("https://blockchain.info/unspent?active=" + address + "&api_key=" +                                                              SystemSettings.BlockchainSwarmopsApiKey));                        }                      catch (WebException webException)                      {                          // A 500 on the above _may_ mean that there's no unspent outpoints. It can also mean a data                          // retrieval or network error' in which case the exception must absolutely not be interpreted                          // as valid data of zero unspent outpoints.                            try                          {                              if (webException.Response == null)                              {                                  throw; // if there's no response at all' we can't do shit                              }                                string errorResponseContent =                                  new StreamReader(webException.Response.GetResponseStream()).ReadToEnd();                                if (errorResponseContent.Trim().StartsWith("No free outputs to spend"))                              {                                  // all is okay network-wise' there just aren't any UTXOs so we're getting an error code for that                                    return false; // no further processing and there are no fresh transactions                              }                                throw; // otherwise throw upward                          }                          catch (WebException)                          {                              // Ok' we tried' but there's apparently a network error so we need to abort this whole thing                              throw;                          }                        }                        foreach (var unspentJson in unspentJsonResult["unspent_outputs"])                      {                          BitcoinUnspentTransactionOutput txUnspent = new BitcoinUnspentTransactionOutput()                          {                              BitcoinAddress = address'                              ConfirmationCount = (UInt32)unspentJson["confirmations"]'                              Satoshis = (UInt64)unspentJson["value"]'                              TransactionHash = (string)unspentJson["tx_hash_big_endian"]'                              TransactionOutputIndex = (UInt32)unspentJson["tx_output_n"]                          };                            if (txUnspent.ConfirmationCount < 2)                          {                              // Fresh transactions' return true                              result = true;                          }                            // Add unspent to database                            if (hotAddress == null)                          {                              hotAddress = HotBitcoinAddress.FromAddress(chain' address);                          }                            SwarmDb.GetDatabaseForWriting()                              .CreateHotBitcoinAddressUnspentConditional(hotAddress.Identity' txUnspent.TransactionHash'                                  (int)txUnspent.TransactionOutputIndex' (Int64)txUnspent.Satoshis'                                  (int)txUnspent.ConfirmationCount);                      }                        // Update hotaddress totals                        HotBitcoinAddresses.UpdateAllUnspentTotals();                        return result;                        case BitcoinChain.Cash:                        // TODO: SELECTION OF BLOCK EXPLORER' ADDRESS STRING FORMAT TO GO WITH IT                        addressInfoResult =                          JObject.Parse(                              new WebClient().DownloadString(                                  "https://bitcoincash.blockexplorer.com/api/addr/" + address));                        JArray unspentArray;                        if ((int)addressInfoResult["balanceSat"] == 0 && (int)addressInfoResult["unconfirmedBalanceSat"] == 0)                      {                          return false; // no funds on address at all at this time                      }                        try                      {                          unspentArray = JArray.Parse(                              new WebClient().DownloadString("https://bitcoincash.blockexplorer.com/api/addr/" + address + "/utxo"));                        }                      catch (WebException webException)                      {                          // A 500 on the above _may_ mean that there's no unspent outpoints. It can also mean a data                          // retrieval or network error' in which case the exception must absolutely not be interpreted                          // as valid data of zero unspent outpoints.                            try                          {                              if (webException.Response == null)                              {                                  throw; // if there's no response at all' we can't do shit                              }                                string errorResponseContent =                                  new StreamReader(webException.Response.GetResponseStream()).ReadToEnd();                                if (errorResponseContent.Trim().StartsWith("No free outputs to spend"))                              {                                  // all is okay network-wise' there just aren't any UTXOs so we're getting an error code for that                                    return false; // no further processing and there are no fresh transactions                              }                                throw; // otherwise throw upward                          }                          catch (WebException)                          {                              // Ok' we tried' but there's apparently a network error so we need to abort this whole thing                              throw;                          }                        }                        foreach (JObject unspentJson in unspentArray.Children())                      {                          BitcoinUnspentTransactionOutput txUnspent = new BitcoinUnspentTransactionOutput()                          {                              BitcoinAddress = address'                              ConfirmationCount = (UInt32)unspentJson["confirmations"]'                              Satoshis = (UInt64)unspentJson["satoshis"]'                              TransactionHash = (string)unspentJson["txid"]'                              TransactionOutputIndex = (UInt32)unspentJson["vout"]                          };                            if (txUnspent.ConfirmationCount < 2)                          {                              // Fresh transactions' return true                              result = true;                          }                            // Add unspent to database                            if (hotAddress == null)                          {                              hotAddress = HotBitcoinAddress.GetAddressOrForkCore(chain' address);                          }                            SwarmDb.GetDatabaseForWriting()                              .CreateHotBitcoinAddressUnspentConditional(hotAddress.Identity' txUnspent.TransactionHash'                                  (int)txUnspent.TransactionOutputIndex' (Int64)txUnspent.Satoshis'                                  (int)txUnspent.ConfirmationCount);                      }                        // Update hotaddress totals                        HotBitcoinAddresses.UpdateAllUnspentTotals();                        return result;                    default:                      throw new NotImplementedException("Unimplemented bitcoin chain: " + chain);              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The following statement contains a magic number: if (_lastFeeRefreshLookup.ContainsKey(chain) && utcNow < _lastFeeRefreshLookup[chain].AddHours (3))              {                  return _lastFeeSatoshisLookup[chain]; // cache fee estimate for three hours              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The following statement contains a magic number: try              {                  Int64 satoshisPerThousandBytes = 1010; // default for Bitcoin Cash                    if (chain == BitcoinChain.Core)                  {                      // But Core has way way WAAAAAAY higher fees                        JObject feeData = JObject.Parse(                                  new WebClient().DownloadString("https://blockexplorer.com/api/utils/estimatefee?nbBlocks=" + blocksWait.ToString(CultureInfo.InvariantCulture)));                      double feeWholeCoins = Double.Parse((string)feeData[blocksWait.ToString(CultureInfo.InvariantCulture)]' NumberStyles.AllowDecimalPoint);                      satoshisPerThousandBytes = (Int64)(feeWholeCoins * _satoshisPerBitcoin);                  }                    _lastFeeSatoshisLookup[chain] = satoshisPerThousandBytes;                  _lastFeeRefreshLookup[chain] = utcNow;                  return satoshisPerThousandBytes;              }              catch (Exception)              {                  // TODO: Check if _lastFeeRefresh is older than a day                    if (_lastFeeSatoshisLookup.ContainsKey(chain))                  {                      return _lastFeeSatoshisLookup[chain];                  }                    if (chain == BitcoinChain.Cash)                  {                      return 1012; // a low standard: one sat per byte' plus some random extra                  }                    return 1000*200; // a not so particularly low standard: 200 sat per byte              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The following statement contains a magic number: try              {                  Int64 satoshisPerThousandBytes = 1010; // default for Bitcoin Cash                    if (chain == BitcoinChain.Core)                  {                      // But Core has way way WAAAAAAY higher fees                        JObject feeData = JObject.Parse(                                  new WebClient().DownloadString("https://blockexplorer.com/api/utils/estimatefee?nbBlocks=" + blocksWait.ToString(CultureInfo.InvariantCulture)));                      double feeWholeCoins = Double.Parse((string)feeData[blocksWait.ToString(CultureInfo.InvariantCulture)]' NumberStyles.AllowDecimalPoint);                      satoshisPerThousandBytes = (Int64)(feeWholeCoins * _satoshisPerBitcoin);                  }                    _lastFeeSatoshisLookup[chain] = satoshisPerThousandBytes;                  _lastFeeRefreshLookup[chain] = utcNow;                  return satoshisPerThousandBytes;              }              catch (Exception)              {                  // TODO: Check if _lastFeeRefresh is older than a day                    if (_lastFeeSatoshisLookup.ContainsKey(chain))                  {                      return _lastFeeSatoshisLookup[chain];                  }                    if (chain == BitcoinChain.Cash)                  {                      return 1012; // a low standard: one sat per byte' plus some random extra                  }                    return 1000*200; // a not so particularly low standard: 200 sat per byte              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The following statement contains a magic number: try              {                  Int64 satoshisPerThousandBytes = 1010; // default for Bitcoin Cash                    if (chain == BitcoinChain.Core)                  {                      // But Core has way way WAAAAAAY higher fees                        JObject feeData = JObject.Parse(                                  new WebClient().DownloadString("https://blockexplorer.com/api/utils/estimatefee?nbBlocks=" + blocksWait.ToString(CultureInfo.InvariantCulture)));                      double feeWholeCoins = Double.Parse((string)feeData[blocksWait.ToString(CultureInfo.InvariantCulture)]' NumberStyles.AllowDecimalPoint);                      satoshisPerThousandBytes = (Int64)(feeWholeCoins * _satoshisPerBitcoin);                  }                    _lastFeeSatoshisLookup[chain] = satoshisPerThousandBytes;                  _lastFeeRefreshLookup[chain] = utcNow;                  return satoshisPerThousandBytes;              }              catch (Exception)              {                  // TODO: Check if _lastFeeRefresh is older than a day                    if (_lastFeeSatoshisLookup.ContainsKey(chain))                  {                      return _lastFeeSatoshisLookup[chain];                  }                    if (chain == BitcoinChain.Cash)                  {                      return 1012; // a low standard: one sat per byte' plus some random extra                  }                    return 1000*200; // a not so particularly low standard: 200 sat per byte              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,GetRecommendedFeePerThousandBytesSatoshis,The following statement contains a magic number: try              {                  Int64 satoshisPerThousandBytes = 1010; // default for Bitcoin Cash                    if (chain == BitcoinChain.Core)                  {                      // But Core has way way WAAAAAAY higher fees                        JObject feeData = JObject.Parse(                                  new WebClient().DownloadString("https://blockexplorer.com/api/utils/estimatefee?nbBlocks=" + blocksWait.ToString(CultureInfo.InvariantCulture)));                      double feeWholeCoins = Double.Parse((string)feeData[blocksWait.ToString(CultureInfo.InvariantCulture)]' NumberStyles.AllowDecimalPoint);                      satoshisPerThousandBytes = (Int64)(feeWholeCoins * _satoshisPerBitcoin);                  }                    _lastFeeSatoshisLookup[chain] = satoshisPerThousandBytes;                  _lastFeeRefreshLookup[chain] = utcNow;                  return satoshisPerThousandBytes;              }              catch (Exception)              {                  // TODO: Check if _lastFeeRefresh is older than a day                    if (_lastFeeSatoshisLookup.ContainsKey(chain))                  {                      return _lastFeeSatoshisLookup[chain];                  }                    if (chain == BitcoinChain.Cash)                  {                      return 1012; // a low standard: one sat per byte' plus some random extra                  }                    return 1000*200; // a not so particularly low standard: 200 sat per byte              }
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The following statement contains a magic number: Int64 satoshis = new Money(100' Currency.FromCode ("SEK")).ToCurrency (Currency.BitcoinCore).Cents;
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The following statement contains a magic number: Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(BitcoinChain.Cash) * 20;
Magic Number,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestMultisigPayout,The following statement contains a magic number: Int64 feeSatoshis = (transactionSizeBytes/1000 + 1)*                                  BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(BitcoinChain.Cash);
Magic Number,Swarmops.Logic.Financial,VatReport,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReport.cs,CreateDbRecord,The following statement contains a magic number: int vatReportId = SwarmDb.GetDatabaseForWriting()                  .CreateVatReport(organization.Identity' guid.ToString()' year*100 + startMonth' monthCount);
Magic Number,Swarmops.Logic.Financial,VatReport,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReport.cs,Create,The following statement contains a magic number: if (differenceCents != 0 && newReport.VatInboundCents > 0)              {                  // if there's anything to report                    FinancialTransaction vatReportTransaction = FinancialTransaction.Create(organization' endDate.AddDays(4).AddHours(9)'                      newReport.Description);                    if (newReport.VatInboundCents > 0)                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.AssetsVatInboundUnreported'                          -newReport.VatInboundCents' null);                  }                  if (newReport.VatOutboundCents > 0)                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.DebtsVatOutboundUnreported'                          newReport.VatOutboundCents' null);                          // not negative' because our number is sign-different from the bookkeeping's                  }                    if (differenceCents < 0) // outbound > inbound                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.DebtsVatOutboundReported'                          differenceCents' null); // debt' so negative as in our variable                  }                  else // inbound > outbound                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.AssetsVatInboundReported'                          differenceCents' null); // asset' so positive as in our variable                  }                    vatReportTransaction.Dependency = newReport;                  newReport.OpenTransaction = vatReportTransaction;              }              else              {                  newReport.Open = false; // nothing to close' no tx created              }
Magic Number,Swarmops.Logic.Financial,VatReport,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReport.cs,Create,The following statement contains a magic number: if (differenceCents != 0 && newReport.VatInboundCents > 0)              {                  // if there's anything to report                    FinancialTransaction vatReportTransaction = FinancialTransaction.Create(organization' endDate.AddDays(4).AddHours(9)'                      newReport.Description);                    if (newReport.VatInboundCents > 0)                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.AssetsVatInboundUnreported'                          -newReport.VatInboundCents' null);                  }                  if (newReport.VatOutboundCents > 0)                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.DebtsVatOutboundUnreported'                          newReport.VatOutboundCents' null);                          // not negative' because our number is sign-different from the bookkeeping's                  }                    if (differenceCents < 0) // outbound > inbound                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.DebtsVatOutboundReported'                          differenceCents' null); // debt' so negative as in our variable                  }                  else // inbound > outbound                  {                      vatReportTransaction.AddRow(organization.FinancialAccounts.AssetsVatInboundReported'                          differenceCents' null); // asset' so positive as in our variable                  }                    vatReportTransaction.Dependency = newReport;                  newReport.OpenTransaction = vatReportTransaction;              }              else              {                  newReport.Open = false; // nothing to close' no tx created              }
Magic Number,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The following statement contains a magic number: Organization organization = Organization.FromIdentity(8);
Magic Number,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The following statement contains a magic number: if (reports.Count == 0)              {                  DateTime firstReportGenerationTime =                      new DateTime(organization.FirstFiscalYear' 1' 1).AddMonths(reportMonthInterval).AddDays(1); // add one day for some safety margin; we're constructing the VAT report on the 2nd of the month                    if (nowUtc > firstReportGenerationTime)                  {                      VatReport.Create(organization' organization.FirstFiscalYear' 1' reportMonthInterval);                  }              }              else              {                  reports.Sort(VatReportSorterByDate);                    DateTime lastReport = new DateTime(reports.Last().YearMonthStart/100' reports.Last().YearMonthStart%100'                      1);                  DateTime nextReport = lastReport.AddMonths(reportMonthInterval);                    DateTime nextReportGenerationTime = nextReport.AddMonths(reportMonthInterval).AddDays(3); // Make the report on the 4yh after the period has ended                  if (nowUtc > nextReportGenerationTime)                  {                      // Create a new report                        VatReport.Create(organization' nextReport.Year' nextReport.Month' reportMonthInterval);                  }              }
Magic Number,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The following statement contains a magic number: if (reports.Count == 0)              {                  DateTime firstReportGenerationTime =                      new DateTime(organization.FirstFiscalYear' 1' 1).AddMonths(reportMonthInterval).AddDays(1); // add one day for some safety margin; we're constructing the VAT report on the 2nd of the month                    if (nowUtc > firstReportGenerationTime)                  {                      VatReport.Create(organization' organization.FirstFiscalYear' 1' reportMonthInterval);                  }              }              else              {                  reports.Sort(VatReportSorterByDate);                    DateTime lastReport = new DateTime(reports.Last().YearMonthStart/100' reports.Last().YearMonthStart%100'                      1);                  DateTime nextReport = lastReport.AddMonths(reportMonthInterval);                    DateTime nextReportGenerationTime = nextReport.AddMonths(reportMonthInterval).AddDays(3); // Make the report on the 4yh after the period has ended                  if (nowUtc > nextReportGenerationTime)                  {                      // Create a new report                        VatReport.Create(organization' nextReport.Year' nextReport.Month' reportMonthInterval);                  }              }
Magic Number,Swarmops.Logic.Financial,VatReports,C:\repos\Swarmops_Swarmops\Logic\Financial\VatReports.cs,CreateNewReports,The following statement contains a magic number: if (reports.Count == 0)              {                  DateTime firstReportGenerationTime =                      new DateTime(organization.FirstFiscalYear' 1' 1).AddMonths(reportMonthInterval).AddDays(1); // add one day for some safety margin; we're constructing the VAT report on the 2nd of the month                    if (nowUtc > firstReportGenerationTime)                  {                      VatReport.Create(organization' organization.FirstFiscalYear' 1' reportMonthInterval);                  }              }              else              {                  reports.Sort(VatReportSorterByDate);                    DateTime lastReport = new DateTime(reports.Last().YearMonthStart/100' reports.Last().YearMonthStart%100'                      1);                  DateTime nextReport = lastReport.AddMonths(reportMonthInterval);                    DateTime nextReportGenerationTime = nextReport.AddMonths(reportMonthInterval).AddDays(3); // Make the report on the 4yh after the period has ended                  if (nowUtc > nextReportGenerationTime)                  {                      // Create a new report                        VatReport.Create(organization' nextReport.Year' nextReport.Month' reportMonthInterval);                  }              }
Magic Number,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The following statement contains a magic number: using (WebClient client = new WebClient())              {                  client.Encoding = Encoding.UTF8;                  string fiatRateDataRaw = client.DownloadString("https://bitpay.com/api/rates");                    // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll                  // have to use Regex matching instead.                    string regexPattern = @"\{\""code\"":\""([A-Z]+)\""'\""name\"":\""([^\""]+)\""'\""rate\"":([0-9\.]+)\}";                  Regex regex = new Regex (regexPattern);                  Match match = regex.Match (fiatRateDataRaw);                    int bitcoinId = GetOrCreateCryptocurrency("BTC");                    if (match.Success)                  {                      // We have at least one match' so prepare a new ExchangeRate snapshot                        exchangeRateSnapshotId = SwarmDb.GetDatabaseForWriting().CreateExchangeRateSnapshot();                  }                    while (match.Success)                  {                      string currencyCode = match.Groups[1].Value;                      string currencyName = match.Groups[2].Value;                      double btcRate = Double.Parse (match.Groups[3].Value' NumberStyles.AllowDecimalPoint'                          CultureInfo.InvariantCulture);                        btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places)                        int currencyId = GetOrCreateFiatCurrency (currencyCode' currencyName);                        SwarmDb.GetDatabaseForWriting()                          .CreateExchangeRateDatapoint (exchangeRateSnapshotId' currencyId' bitcoinId' btcRate);                        match = match.NextMatch();                  }                    JavaScriptSerializer serializer = new JavaScriptSerializer();                  BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw);                    // Download Shapeshift data                    string cryptoRateDataRaw = client.DownloadString("https://shapeshift.io/marketinfo");                    ShapeshiftRateDatapoint[] cryptoRates =                      (ShapeshiftRateDatapoint[]) serializer.Deserialize<ShapeshiftRateDatapoint[]>(cryptoRateDataRaw);                    if (exchangeRateSnapshotId > 0) // test that we're making a snapshot first                  {                      foreach (ShapeshiftRateDatapoint shapeshiftRate in cryptoRates)                      {                          if (shapeshiftRate.pair.StartsWith("BTC_"))                          {                              string coinCode = shapeshiftRate.pair.Substring(4);                              double btcRate = shapeshiftRate.rate;                                if (coinCode != "BCH")                              {                                  btcRate /= 1000000.0;                                      // We're operating in microbitcoin' so adjust the stored exchange rate right six decimal places                                      // EXCEPT for Bitcoin Cash which ALSO operates in microbitcoin                              }                                int coinId = GetOrCreateCryptocurrency(coinCode);                              SwarmDb.GetDatabaseForWriting().                                  CreateExchangeRateDatapoint(exchangeRateSnapshotId' coinId' bitcoinId' btcRate);                          }                      }                  }                    Console.WriteLine(cryptoRateDataRaw);              }
Magic Number,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The following statement contains a magic number: using (WebClient client = new WebClient())              {                  client.Encoding = Encoding.UTF8;                  string fiatRateDataRaw = client.DownloadString("https://bitpay.com/api/rates");                    // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll                  // have to use Regex matching instead.                    string regexPattern = @"\{\""code\"":\""([A-Z]+)\""'\""name\"":\""([^\""]+)\""'\""rate\"":([0-9\.]+)\}";                  Regex regex = new Regex (regexPattern);                  Match match = regex.Match (fiatRateDataRaw);                    int bitcoinId = GetOrCreateCryptocurrency("BTC");                    if (match.Success)                  {                      // We have at least one match' so prepare a new ExchangeRate snapshot                        exchangeRateSnapshotId = SwarmDb.GetDatabaseForWriting().CreateExchangeRateSnapshot();                  }                    while (match.Success)                  {                      string currencyCode = match.Groups[1].Value;                      string currencyName = match.Groups[2].Value;                      double btcRate = Double.Parse (match.Groups[3].Value' NumberStyles.AllowDecimalPoint'                          CultureInfo.InvariantCulture);                        btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places)                        int currencyId = GetOrCreateFiatCurrency (currencyCode' currencyName);                        SwarmDb.GetDatabaseForWriting()                          .CreateExchangeRateDatapoint (exchangeRateSnapshotId' currencyId' bitcoinId' btcRate);                        match = match.NextMatch();                  }                    JavaScriptSerializer serializer = new JavaScriptSerializer();                  BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw);                    // Download Shapeshift data                    string cryptoRateDataRaw = client.DownloadString("https://shapeshift.io/marketinfo");                    ShapeshiftRateDatapoint[] cryptoRates =                      (ShapeshiftRateDatapoint[]) serializer.Deserialize<ShapeshiftRateDatapoint[]>(cryptoRateDataRaw);                    if (exchangeRateSnapshotId > 0) // test that we're making a snapshot first                  {                      foreach (ShapeshiftRateDatapoint shapeshiftRate in cryptoRates)                      {                          if (shapeshiftRate.pair.StartsWith("BTC_"))                          {                              string coinCode = shapeshiftRate.pair.Substring(4);                              double btcRate = shapeshiftRate.rate;                                if (coinCode != "BCH")                              {                                  btcRate /= 1000000.0;                                      // We're operating in microbitcoin' so adjust the stored exchange rate right six decimal places                                      // EXCEPT for Bitcoin Cash which ALSO operates in microbitcoin                              }                                int coinId = GetOrCreateCryptocurrency(coinCode);                              SwarmDb.GetDatabaseForWriting().                                  CreateExchangeRateDatapoint(exchangeRateSnapshotId' coinId' bitcoinId' btcRate);                          }                      }                  }                    Console.WriteLine(cryptoRateDataRaw);              }
Magic Number,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The following statement contains a magic number: using (WebClient client = new WebClient())              {                  client.Encoding = Encoding.UTF8;                  string fiatRateDataRaw = client.DownloadString("https://bitpay.com/api/rates");                    // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll                  // have to use Regex matching instead.                    string regexPattern = @"\{\""code\"":\""([A-Z]+)\""'\""name\"":\""([^\""]+)\""'\""rate\"":([0-9\.]+)\}";                  Regex regex = new Regex (regexPattern);                  Match match = regex.Match (fiatRateDataRaw);                    int bitcoinId = GetOrCreateCryptocurrency("BTC");                    if (match.Success)                  {                      // We have at least one match' so prepare a new ExchangeRate snapshot                        exchangeRateSnapshotId = SwarmDb.GetDatabaseForWriting().CreateExchangeRateSnapshot();                  }                    while (match.Success)                  {                      string currencyCode = match.Groups[1].Value;                      string currencyName = match.Groups[2].Value;                      double btcRate = Double.Parse (match.Groups[3].Value' NumberStyles.AllowDecimalPoint'                          CultureInfo.InvariantCulture);                        btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places)                        int currencyId = GetOrCreateFiatCurrency (currencyCode' currencyName);                        SwarmDb.GetDatabaseForWriting()                          .CreateExchangeRateDatapoint (exchangeRateSnapshotId' currencyId' bitcoinId' btcRate);                        match = match.NextMatch();                  }                    JavaScriptSerializer serializer = new JavaScriptSerializer();                  BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw);                    // Download Shapeshift data                    string cryptoRateDataRaw = client.DownloadString("https://shapeshift.io/marketinfo");                    ShapeshiftRateDatapoint[] cryptoRates =                      (ShapeshiftRateDatapoint[]) serializer.Deserialize<ShapeshiftRateDatapoint[]>(cryptoRateDataRaw);                    if (exchangeRateSnapshotId > 0) // test that we're making a snapshot first                  {                      foreach (ShapeshiftRateDatapoint shapeshiftRate in cryptoRates)                      {                          if (shapeshiftRate.pair.StartsWith("BTC_"))                          {                              string coinCode = shapeshiftRate.pair.Substring(4);                              double btcRate = shapeshiftRate.rate;                                if (coinCode != "BCH")                              {                                  btcRate /= 1000000.0;                                      // We're operating in microbitcoin' so adjust the stored exchange rate right six decimal places                                      // EXCEPT for Bitcoin Cash which ALSO operates in microbitcoin                              }                                int coinId = GetOrCreateCryptocurrency(coinCode);                              SwarmDb.GetDatabaseForWriting().                                  CreateExchangeRateDatapoint(exchangeRateSnapshotId' coinId' bitcoinId' btcRate);                          }                      }                  }                    Console.WriteLine(cryptoRateDataRaw);              }
Magic Number,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The following statement contains a magic number: using (WebClient client = new WebClient())              {                  client.Encoding = Encoding.UTF8;                  string fiatRateDataRaw = client.DownloadString("https://bitpay.com/api/rates");                    // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll                  // have to use Regex matching instead.                    string regexPattern = @"\{\""code\"":\""([A-Z]+)\""'\""name\"":\""([^\""]+)\""'\""rate\"":([0-9\.]+)\}";                  Regex regex = new Regex (regexPattern);                  Match match = regex.Match (fiatRateDataRaw);                    int bitcoinId = GetOrCreateCryptocurrency("BTC");                    if (match.Success)                  {                      // We have at least one match' so prepare a new ExchangeRate snapshot                        exchangeRateSnapshotId = SwarmDb.GetDatabaseForWriting().CreateExchangeRateSnapshot();                  }                    while (match.Success)                  {                      string currencyCode = match.Groups[1].Value;                      string currencyName = match.Groups[2].Value;                      double btcRate = Double.Parse (match.Groups[3].Value' NumberStyles.AllowDecimalPoint'                          CultureInfo.InvariantCulture);                        btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places)                        int currencyId = GetOrCreateFiatCurrency (currencyCode' currencyName);                        SwarmDb.GetDatabaseForWriting()                          .CreateExchangeRateDatapoint (exchangeRateSnapshotId' currencyId' bitcoinId' btcRate);                        match = match.NextMatch();                  }                    JavaScriptSerializer serializer = new JavaScriptSerializer();                  BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw);                    // Download Shapeshift data                    string cryptoRateDataRaw = client.DownloadString("https://shapeshift.io/marketinfo");                    ShapeshiftRateDatapoint[] cryptoRates =                      (ShapeshiftRateDatapoint[]) serializer.Deserialize<ShapeshiftRateDatapoint[]>(cryptoRateDataRaw);                    if (exchangeRateSnapshotId > 0) // test that we're making a snapshot first                  {                      foreach (ShapeshiftRateDatapoint shapeshiftRate in cryptoRates)                      {                          if (shapeshiftRate.pair.StartsWith("BTC_"))                          {                              string coinCode = shapeshiftRate.pair.Substring(4);                              double btcRate = shapeshiftRate.rate;                                if (coinCode != "BCH")                              {                                  btcRate /= 1000000.0;                                      // We're operating in microbitcoin' so adjust the stored exchange rate right six decimal places                                      // EXCEPT for Bitcoin Cash which ALSO operates in microbitcoin                              }                                int coinId = GetOrCreateCryptocurrency(coinCode);                              SwarmDb.GetDatabaseForWriting().                                  CreateExchangeRateDatapoint(exchangeRateSnapshotId' coinId' bitcoinId' btcRate);                          }                      }                  }                    Console.WriteLine(cryptoRateDataRaw);              }
Magic Number,Swarmops.Logic.Financial,ExchangeRateSnapshot,C:\repos\Swarmops_Swarmops\Logic\Financial\ExchangeRateSnapshot.cs,Create,The following statement contains a magic number: using (WebClient client = new WebClient())              {                  client.Encoding = Encoding.UTF8;                  string fiatRateDataRaw = client.DownloadString("https://bitpay.com/api/rates");                    // BitPay doesn't provide valid JSON - the rate field isn't enclosed in quotes - so we can't use JSON Deserialization; we'll                  // have to use Regex matching instead.                    string regexPattern = @"\{\""code\"":\""([A-Z]+)\""'\""name\"":\""([^\""]+)\""'\""rate\"":([0-9\.]+)\}";                  Regex regex = new Regex (regexPattern);                  Match match = regex.Match (fiatRateDataRaw);                    int bitcoinId = GetOrCreateCryptocurrency("BTC");                    if (match.Success)                  {                      // We have at least one match' so prepare a new ExchangeRate snapshot                        exchangeRateSnapshotId = SwarmDb.GetDatabaseForWriting().CreateExchangeRateSnapshot();                  }                    while (match.Success)                  {                      string currencyCode = match.Groups[1].Value;                      string currencyName = match.Groups[2].Value;                      double btcRate = Double.Parse (match.Groups[3].Value' NumberStyles.AllowDecimalPoint'                          CultureInfo.InvariantCulture);                        btcRate /= 1000000.0; // We're operating in microbitcoin' so adjust the stored exchange rate accordingly (right-shift six decimal places)                        int currencyId = GetOrCreateFiatCurrency (currencyCode' currencyName);                        SwarmDb.GetDatabaseForWriting()                          .CreateExchangeRateDatapoint (exchangeRateSnapshotId' currencyId' bitcoinId' btcRate);                        match = match.NextMatch();                  }                    JavaScriptSerializer serializer = new JavaScriptSerializer();                  BitpayRateDatapoint[] fiatRates = (BitpayRateDatapoint[]) serializer.Deserialize<BitpayRateDatapoint[]> (fiatRateDataRaw);                    // Download Shapeshift data                    string cryptoRateDataRaw = client.DownloadString("https://shapeshift.io/marketinfo");                    ShapeshiftRateDatapoint[] cryptoRates =                      (ShapeshiftRateDatapoint[]) serializer.Deserialize<ShapeshiftRateDatapoint[]>(cryptoRateDataRaw);                    if (exchangeRateSnapshotId > 0) // test that we're making a snapshot first                  {                      foreach (ShapeshiftRateDatapoint shapeshiftRate in cryptoRates)                      {                          if (shapeshiftRate.pair.StartsWith("BTC_"))                          {                              string coinCode = shapeshiftRate.pair.Substring(4);                              double btcRate = shapeshiftRate.rate;                                if (coinCode != "BCH")                              {                                  btcRate /= 1000000.0;                                      // We're operating in microbitcoin' so adjust the stored exchange rate right six decimal places                                      // EXCEPT for Bitcoin Cash which ALSO operates in microbitcoin                              }                                int coinId = GetOrCreateCryptocurrency(coinCode);                              SwarmDb.GetDatabaseForWriting().                                  CreateExchangeRateDatapoint(exchangeRateSnapshotId' coinId' bitcoinId' btcRate);                          }                      }                  }                    Console.WriteLine(cryptoRateDataRaw);              }
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Create,The following statement contains a magic number: OutboundComm.CreateNotificationAttestationNeeded (budget' forPerson' string.Empty' amountCents/100.0'                  description' NotificationResource.CashAdvance_Requested);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Create,The following statement contains a magic number: SwarmopsLogEntry.Create (forPerson'                  new CashAdvanceRequestedLogEntry (createdByPerson' forPerson' amountCents/100.0' budget' description)'                  newAdvance);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Attest,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().CreateFinancialValidation (FinancialValidationType.Attestation'                  FinancialDependencyType.CashAdvance' Identity' DateTime.UtcNow' attester.Identity' AmountCents/100.0);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Attest,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Person' AmountCents/100.0' Description'                  NotificationResource.CashAdvance_Attested);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Deattest,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().CreateFinancialValidation (FinancialValidationType.Deattestation'                  FinancialDependencyType.CashAdvance' Identity' DateTime.UtcNow' deattester.Identity' AmountCents/100.0);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,Deattest,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Person' AmountCents/100.0' Description'                  NotificationResource.CashAdvance_Deattested);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,DenyAttestation,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().CreateFinancialValidation(FinancialValidationType.Kill'                  FinancialDependencyType.CashAdvance' Identity' DateTime.UtcNow' denyingPerson.Identity' AmountCents / 100.0);
Magic Number,Swarmops.Logic.Financial,CashAdvance,C:\repos\Swarmops_Swarmops\Logic\Financial\CashAdvance.cs,DenyAttestation,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation(Budget' Person' AmountCents / 100.0' Description'                  NotificationResource.CashAdvance_Denied' reason);
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: for (int loop = 0; loop < replacements.Length/2; loop++)              {                  data = data.Replace(replacements[loop*2]' replacements[loop*2 + 1]);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: for (int loop = 0; loop < replacements.Length/2; loop++)              {                  data = data.Replace(replacements[loop*2]' replacements[loop*2 + 1]);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: for (int loop = 0; loop < replacements.Length/2; loop++)              {                  data = data.Replace(replacements[loop*2]' replacements[loop*2 + 1]);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: foreach (string lineData in lines)              {                  string line = lineData.Trim();                    if (line.Length < 1)                  {                      continue; // empty lines may exist due to split on either CR or LF                  }                    string[] lineFields = line.Split ('\t');                    // If wrong currency' ignore                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Currency))                  {                      string currency = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Currency]]);                        if (currency != organizationCurrencyCode)                      {                          continue; // ignore this record                      }                  }                    ExternalBankDataRecord newRecord = new ExternalBankDataRecord();                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DescriptionPrimary))                  {                      newRecord.Description =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionPrimary]]);                  }                    // If primary description is empty' try to apply a secondary description                    if (String.IsNullOrEmpty(newRecord.Description))                  {                      if (fieldNameLookup.ContainsKey(ExternalBankDataFieldName.DescriptionSecondary))                      {                          newRecord.Description =                          StripQuotes(lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionSecondary]]);                      }                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.AccountBalance))                  {                      // Dividing up to step-by-step statements instead of one long statement assists debugging                      // of culture and other error sources                        string balanceString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.AccountBalance]]);                      try                      {                          newRecord.AccountBalanceCents = ParseAmountString (balanceString);                      }                      catch (Exception innerException)                      {                          throw new FormatException ("Couldn't parse account balance string - \"" + balanceString + "\""'                              innerException);                      }                  }                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date) &&                      !fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DateTime))                  {                      throw new InvalidOperationException ("Cannot parse transactions file without at least a date field");                  }                    DateTime dateTime = Constants.DateTimeLow;                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date))                  {                      string dateString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Date]]);                      dateTime = DateTime.Parse (dateString' new CultureInfo (Profile.Culture));                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Time))                      {                          string timeString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Time]]);                          TimeSpan timeOfDay = TimeSpan.Parse (timeString);                            dateTime += timeOfDay;                      }                      else                      {                          // move transaction to like mid-day of the organization's time zone. For now' all orgs are in Europe' so add 12 hours                          // this is a HACK HACK HACK                            dateTime = dateTime.AddHours (12);                      }                  }                  else // no Date field' so by earlier logic' must have a DateTime field                  {                      dateTime =                          DateTime.Parse (StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DateTime]])'                              new CultureInfo (Profile.Culture));                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TimeZone))                  {                      // Valid time zone formats are "XXX+hh:mm". The XXX are ignored.                        // Throws exception if this doesn't parse' which is what we want                        string timeZoneString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TimeZone]]);                      timeZoneString = timeZoneString.Substring (timeZoneString.Length - 6);                      TimeSpan timeZone = TimeSpan.Parse (timeZoneString);                        dateTime -= timeZone;                      // minus' to bring the time to UTC. If time 13:00 is in tz +01:00' the UTC time is 12:00                        // Then move from UTC to local time' to match various bookkeeping laws. TODO: local time per organization' perhaps?                        dateTime = dateTime.ToLocalTime();                  }                    // PILOT SPECIAL CASE: if Paypal and PPSE Pilot program' ignore everything before 2014                    if (dateTime.Year < 2014 && organization.Identity == 1 &&                      fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId) &&                      PilotInstallationIds.IsPilot (PilotInstallationIds.PiratePartySE))                  {                      continue; // Do not import PayPal records from before 2013                  }                    newRecord.DateTime = dateTime;                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionNet))                  {                      throw new ArgumentException ("There must be a transaction amount field in the bank data profile");                  }                    string amountNetString =                      StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionNet]]);                    newRecord.TransactionNetCents = ParseAmountString (amountNetString);                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionGross))                  {                      string amountGrossString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionGross]]);                      newRecord.TransactionGrossCents = ParseAmountString (amountGrossString);                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionFee))                      {                          string amountFeeString =                              StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionFee]]);                          newRecord.FeeCents = ParseAmountString (amountFeeString);                            if (Profile.FeeSignage == FeeSignage.Positive)                          {                              newRecord.FeeCents = -newRecord.FeeCents;                          }                      }                  }                  else                  {                      newRecord.TransactionGrossCents = newRecord.TransactionNetCents;                      // if no "Gross" field' copy from net                  }                    // Check for consistency of gross/net/fee:                    if (newRecord.TransactionNetCents != newRecord.TransactionGrossCents + newRecord.FeeCents)                  {                      throw new InvalidDataException (                          "For a record' the net transaction amount does not match the gross less the fee.");                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId))                  {                      newRecord.UniqueId = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.UniqueId]]);                  }                  else if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.NotUniqueId))                  {                      newRecord.NotUniqueId =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.NotUniqueId]]);                  }                    recordList.Add (newRecord);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: foreach (string lineData in lines)              {                  string line = lineData.Trim();                    if (line.Length < 1)                  {                      continue; // empty lines may exist due to split on either CR or LF                  }                    string[] lineFields = line.Split ('\t');                    // If wrong currency' ignore                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Currency))                  {                      string currency = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Currency]]);                        if (currency != organizationCurrencyCode)                      {                          continue; // ignore this record                      }                  }                    ExternalBankDataRecord newRecord = new ExternalBankDataRecord();                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DescriptionPrimary))                  {                      newRecord.Description =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionPrimary]]);                  }                    // If primary description is empty' try to apply a secondary description                    if (String.IsNullOrEmpty(newRecord.Description))                  {                      if (fieldNameLookup.ContainsKey(ExternalBankDataFieldName.DescriptionSecondary))                      {                          newRecord.Description =                          StripQuotes(lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionSecondary]]);                      }                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.AccountBalance))                  {                      // Dividing up to step-by-step statements instead of one long statement assists debugging                      // of culture and other error sources                        string balanceString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.AccountBalance]]);                      try                      {                          newRecord.AccountBalanceCents = ParseAmountString (balanceString);                      }                      catch (Exception innerException)                      {                          throw new FormatException ("Couldn't parse account balance string - \"" + balanceString + "\""'                              innerException);                      }                  }                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date) &&                      !fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DateTime))                  {                      throw new InvalidOperationException ("Cannot parse transactions file without at least a date field");                  }                    DateTime dateTime = Constants.DateTimeLow;                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date))                  {                      string dateString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Date]]);                      dateTime = DateTime.Parse (dateString' new CultureInfo (Profile.Culture));                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Time))                      {                          string timeString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Time]]);                          TimeSpan timeOfDay = TimeSpan.Parse (timeString);                            dateTime += timeOfDay;                      }                      else                      {                          // move transaction to like mid-day of the organization's time zone. For now' all orgs are in Europe' so add 12 hours                          // this is a HACK HACK HACK                            dateTime = dateTime.AddHours (12);                      }                  }                  else // no Date field' so by earlier logic' must have a DateTime field                  {                      dateTime =                          DateTime.Parse (StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DateTime]])'                              new CultureInfo (Profile.Culture));                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TimeZone))                  {                      // Valid time zone formats are "XXX+hh:mm". The XXX are ignored.                        // Throws exception if this doesn't parse' which is what we want                        string timeZoneString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TimeZone]]);                      timeZoneString = timeZoneString.Substring (timeZoneString.Length - 6);                      TimeSpan timeZone = TimeSpan.Parse (timeZoneString);                        dateTime -= timeZone;                      // minus' to bring the time to UTC. If time 13:00 is in tz +01:00' the UTC time is 12:00                        // Then move from UTC to local time' to match various bookkeeping laws. TODO: local time per organization' perhaps?                        dateTime = dateTime.ToLocalTime();                  }                    // PILOT SPECIAL CASE: if Paypal and PPSE Pilot program' ignore everything before 2014                    if (dateTime.Year < 2014 && organization.Identity == 1 &&                      fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId) &&                      PilotInstallationIds.IsPilot (PilotInstallationIds.PiratePartySE))                  {                      continue; // Do not import PayPal records from before 2013                  }                    newRecord.DateTime = dateTime;                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionNet))                  {                      throw new ArgumentException ("There must be a transaction amount field in the bank data profile");                  }                    string amountNetString =                      StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionNet]]);                    newRecord.TransactionNetCents = ParseAmountString (amountNetString);                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionGross))                  {                      string amountGrossString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionGross]]);                      newRecord.TransactionGrossCents = ParseAmountString (amountGrossString);                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionFee))                      {                          string amountFeeString =                              StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionFee]]);                          newRecord.FeeCents = ParseAmountString (amountFeeString);                            if (Profile.FeeSignage == FeeSignage.Positive)                          {                              newRecord.FeeCents = -newRecord.FeeCents;                          }                      }                  }                  else                  {                      newRecord.TransactionGrossCents = newRecord.TransactionNetCents;                      // if no "Gross" field' copy from net                  }                    // Check for consistency of gross/net/fee:                    if (newRecord.TransactionNetCents != newRecord.TransactionGrossCents + newRecord.FeeCents)                  {                      throw new InvalidDataException (                          "For a record' the net transaction amount does not match the gross less the fee.");                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId))                  {                      newRecord.UniqueId = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.UniqueId]]);                  }                  else if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.NotUniqueId))                  {                      newRecord.NotUniqueId =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.NotUniqueId]]);                  }                    recordList.Add (newRecord);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,LoadData,The following statement contains a magic number: foreach (string lineData in lines)              {                  string line = lineData.Trim();                    if (line.Length < 1)                  {                      continue; // empty lines may exist due to split on either CR or LF                  }                    string[] lineFields = line.Split ('\t');                    // If wrong currency' ignore                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Currency))                  {                      string currency = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Currency]]);                        if (currency != organizationCurrencyCode)                      {                          continue; // ignore this record                      }                  }                    ExternalBankDataRecord newRecord = new ExternalBankDataRecord();                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DescriptionPrimary))                  {                      newRecord.Description =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionPrimary]]);                  }                    // If primary description is empty' try to apply a secondary description                    if (String.IsNullOrEmpty(newRecord.Description))                  {                      if (fieldNameLookup.ContainsKey(ExternalBankDataFieldName.DescriptionSecondary))                      {                          newRecord.Description =                          StripQuotes(lineFields[fieldNameLookup[ExternalBankDataFieldName.DescriptionSecondary]]);                      }                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.AccountBalance))                  {                      // Dividing up to step-by-step statements instead of one long statement assists debugging                      // of culture and other error sources                        string balanceString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.AccountBalance]]);                      try                      {                          newRecord.AccountBalanceCents = ParseAmountString (balanceString);                      }                      catch (Exception innerException)                      {                          throw new FormatException ("Couldn't parse account balance string - \"" + balanceString + "\""'                              innerException);                      }                  }                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date) &&                      !fieldNameLookup.ContainsKey (ExternalBankDataFieldName.DateTime))                  {                      throw new InvalidOperationException ("Cannot parse transactions file without at least a date field");                  }                    DateTime dateTime = Constants.DateTimeLow;                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Date))                  {                      string dateString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Date]]);                      dateTime = DateTime.Parse (dateString' new CultureInfo (Profile.Culture));                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.Time))                      {                          string timeString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.Time]]);                          TimeSpan timeOfDay = TimeSpan.Parse (timeString);                            dateTime += timeOfDay;                      }                      else                      {                          // move transaction to like mid-day of the organization's time zone. For now' all orgs are in Europe' so add 12 hours                          // this is a HACK HACK HACK                            dateTime = dateTime.AddHours (12);                      }                  }                  else // no Date field' so by earlier logic' must have a DateTime field                  {                      dateTime =                          DateTime.Parse (StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.DateTime]])'                              new CultureInfo (Profile.Culture));                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TimeZone))                  {                      // Valid time zone formats are "XXX+hh:mm". The XXX are ignored.                        // Throws exception if this doesn't parse' which is what we want                        string timeZoneString = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TimeZone]]);                      timeZoneString = timeZoneString.Substring (timeZoneString.Length - 6);                      TimeSpan timeZone = TimeSpan.Parse (timeZoneString);                        dateTime -= timeZone;                      // minus' to bring the time to UTC. If time 13:00 is in tz +01:00' the UTC time is 12:00                        // Then move from UTC to local time' to match various bookkeeping laws. TODO: local time per organization' perhaps?                        dateTime = dateTime.ToLocalTime();                  }                    // PILOT SPECIAL CASE: if Paypal and PPSE Pilot program' ignore everything before 2014                    if (dateTime.Year < 2014 && organization.Identity == 1 &&                      fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId) &&                      PilotInstallationIds.IsPilot (PilotInstallationIds.PiratePartySE))                  {                      continue; // Do not import PayPal records from before 2013                  }                    newRecord.DateTime = dateTime;                    if (!fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionNet))                  {                      throw new ArgumentException ("There must be a transaction amount field in the bank data profile");                  }                    string amountNetString =                      StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionNet]]);                    newRecord.TransactionNetCents = ParseAmountString (amountNetString);                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionGross))                  {                      string amountGrossString =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionGross]]);                      newRecord.TransactionGrossCents = ParseAmountString (amountGrossString);                        if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.TransactionFee))                      {                          string amountFeeString =                              StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.TransactionFee]]);                          newRecord.FeeCents = ParseAmountString (amountFeeString);                            if (Profile.FeeSignage == FeeSignage.Positive)                          {                              newRecord.FeeCents = -newRecord.FeeCents;                          }                      }                  }                  else                  {                      newRecord.TransactionGrossCents = newRecord.TransactionNetCents;                      // if no "Gross" field' copy from net                  }                    // Check for consistency of gross/net/fee:                    if (newRecord.TransactionNetCents != newRecord.TransactionGrossCents + newRecord.FeeCents)                  {                      throw new InvalidDataException (                          "For a record' the net transaction amount does not match the gross less the fee.");                  }                    if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.UniqueId))                  {                      newRecord.UniqueId = StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.UniqueId]]);                  }                  else if (fieldNameLookup.ContainsKey (ExternalBankDataFieldName.NotUniqueId))                  {                      newRecord.NotUniqueId =                          StripQuotes (lineFields[fieldNameLookup[ExternalBankDataFieldName.NotUniqueId]]);                  }                    recordList.Add (newRecord);              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,ParseAmountString,The following statement contains a magic number: if (input.Length > 3)              {                  testDecimalSeparator = input[input.Length - 3];              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,ParseAmountString,The following statement contains a magic number: if (input.Length > 3)              {                  testDecimalSeparator = input[input.Length - 3];              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,ParseAmountString,The following statement contains a magic number: if (testDecimalSeparator != '.' && testDecimalSeparator != ''')              {                  // No known decimal separator where one is expected for monetary amounts'                   // so multiply amount by 100 by adding two zeroes to string' as we're supposed                  // to be returning cents                    bool weirdCaseTriggered = false;                    if (input.Length > 2)                  {                      testDecimalSeparator = input[input.Length - 2];                        if (testDecimalSeparator == '.' || testDecimalSeparator == ''')                      {                          // Fucking SEB doesn't even have the manners to only have whole units or cents'                          // but can present a half-crown as "'5". Damn them...                            input += "0";                          weirdCaseTriggered = true;                      }                  }                    if (!weirdCaseTriggered)                  {                      input += "00";                  }              }
Magic Number,Swarmops.Logic.Financial,ExternalBankData,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankData.cs,ParseAmountString,The following statement contains a magic number: if (testDecimalSeparator != '.' && testDecimalSeparator != ''')              {                  // No known decimal separator where one is expected for monetary amounts'                   // so multiply amount by 100 by adding two zeroes to string' as we're supposed                  // to be returning cents                    bool weirdCaseTriggered = false;                    if (input.Length > 2)                  {                      testDecimalSeparator = input[input.Length - 2];                        if (testDecimalSeparator == '.' || testDecimalSeparator == ''')                      {                          // Fucking SEB doesn't even have the manners to only have whole units or cents'                          // but can present a half-crown as "'5". Damn them...                            input += "0";                          weirdCaseTriggered = true;                      }                  }                    if (!weirdCaseTriggered)                  {                      input += "00";                  }              }
Magic Number,Swarmops.Logic.Financial,ExternalBankDataProfile,C:\repos\Swarmops_Swarmops\Logic\Financial\ExternalBankDataProfile.cs,FromIdentity,The following statement contains a magic number: if (externalBankDataProfileId == DEPostbankId)              {                  result.Name = "DE Postbank";                  result.Country = Country.FromCode("DE");                  result.Culture = "de-DE";                  result.IgnoreInitialLines = 7;                  result.InitialReplacements = ";|\t| €|";                    result.FieldNames[ExternalBankDataFieldName.Date] = "Buchungstag";                  result.FieldNames[ExternalBankDataFieldName.DescriptionPrimary] = "Buchungsdetails";                  result.FieldNames[ExternalBankDataFieldName.DescriptionSecondary] = "Umsatzart";                  result.FieldNames[ExternalBankDataFieldName.TransactionNet] = "Betrag (€)";                  result.FieldNames[ExternalBankDataFieldName.AccountBalance] = "Saldo (€)";                    result.LatestTransactionLocation = LatestTransactionLocation.Top;                  result.FeeSignage = FeeSignage.Unknown; // no inline fees                  result.Precision = ExternalBankDateTimePrecision.Day;                    result.BankDataAccountReader = StockBankDataReaders.TabSeparatedValuesAccountReader;                  result.BankDataPaymentsReader = null; // No aggregated payments with Paypal                    return result;              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,Create,The following statement contains a magic number: if (report._treeMap[0].Count > 3)              {                  // regroup list                    report.AggregateAccounts();              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AggregateAccounts,The following statement contains a magic number: const int assetIdentity = 1000000001;
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AggregateAccounts,The following statement contains a magic number: const int debtIdentity = 1000000002;
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AggregateAccounts,The following statement contains a magic number: const int incomeIdentity = 1000000003;
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AggregateAccounts,The following statement contains a magic number: const int costIdentity = 1000000004;
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AggregateAccounts,The following statement contains a magic number: foreach (AnnualReportLine reportLine in this.ReportLines)              {                  if (reportLine.AccountId == equityIdentity)                  {                      newRootLevel.Add (reportLine);                  }                  else                  {                      AnnualReportLine aggregateLine = remapLookup[reportLine.AccountType];                      if (aggregateLine.Children == null)                      {                          aggregateLine.Children = new List<AnnualReportLine>();                      }                        aggregateLine.Children.Add (reportLine);                        aggregateLine.AccountTreeValues.PreviousYear += reportLine.AccountTreeValues.PreviousYear;                      for (int quarter = 0; quarter < 4; quarter++)                      {                          aggregateLine.AccountTreeValues.Quarters[quarter] +=                              reportLine.AccountTreeValues.Quarters[quarter];                      }                        aggregateLine.AccountTreeValues.ThisYear += reportLine.AccountTreeValues.ThisYear;                      aggregateLine.AccountTreeValues.ThisYearBudget += reportLine.AccountTreeValues.ThisYearBudget;                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateTotals,The following statement contains a magic number: this.Totals.ThisYear = PopulateOneTotal(this._singleLookups[5]);
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateTotals,The following statement contains a magic number: this.Totals.ThisYearBudget = PopulateOneTotal(this._singleLookups[6]);
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateTotals,The following statement contains a magic number: for (int quarter = 0; quarter < 4; quarter++)              {                  this.Totals.Quarters[quarter] = PopulateOneTotal (this._singleLookups[quarter + 1]);              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,CreateAnnualReportNode,The following statement contains a magic number: for (int quarter = 1; quarter <= 4; quarter++)              {                  node.Quarters[quarter - 1] = lookup[quarter][accountId];              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,CreateAnnualReportNode,The following statement contains a magic number: node.ThisYear = lookup[5][accountId];
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,CreateAnnualReportNode,The following statement contains a magic number: node.ThisYearBudget = lookup[6][accountId];
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: this._singleLookups = new Dictionary<int' Int64>[7];
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: this._treeLookups = new Dictionary<int' Int64>[7];
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: for (int index = 0; index < 7; index++)              {                  this._treeLookups[index] = new Dictionary<int' Int64>();                  this._singleLookups[index] = new Dictionary<int' Int64>();              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: DateTime[] quarterBoundaries =              {                  new DateTime (this.Year' 1' 1)' new DateTime (this.Year' 4' 1)' new DateTime (this.Year' 7' 1)'                  new DateTime (this.Year' 10' 1)' new DateTime (this.Year + 1' 1' 1)              };
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: DateTime[] quarterBoundaries =              {                  new DateTime (this.Year' 1' 1)' new DateTime (this.Year' 4' 1)' new DateTime (this.Year' 7' 1)'                  new DateTime (this.Year' 10' 1)' new DateTime (this.Year + 1' 1' 1)              };
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: DateTime[] quarterBoundaries =              {                  new DateTime (this.Year' 1' 1)' new DateTime (this.Year' 4' 1)' new DateTime (this.Year' 7' 1)'                  new DateTime (this.Year' 10' 1)' new DateTime (this.Year + 1' 1' 1)              };
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: foreach (FinancialAccount account in accounts)              {                  // If result account' find budget                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[6][account.Identity] = account.GetBudgetCents (this.Year);                  }                  else                  {                      this._singleLookups[6][account.Identity] = 0; // if balance account' this is zero                  }                    // Find this year's inbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (                          new DateTime (this.Year - 1' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[0][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // Find quarter diffs                    for (int quarter = 0; quarter < 4; quarter++)                  {                      this._singleLookups[quarter + 1][account.Identity] =                          account.GetDeltaCents (quarterBoundaries[quarter]'                              quarterBoundaries[quarter + 1]);                  }                    // Find outbound                    if (this._accountType == FinancialAccountType.Result)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (this.Year' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else if (this._accountType == FinancialAccountType.Balance)                  {                      this._singleLookups[5][account.Identity] = account.GetDeltaCents (new DateTime (1900' 1' 1)'                          new DateTime (this.Year + 1' 1' 1));                  }                  else                  {                      throw new InvalidOperationException (                          "Can only calculate yearly reports for balance or P&L statements");                  }                    // copy to treeLookups                    for (int index = 0; index < 7; index++)                  {                      this._treeLookups[index][account.Identity] = this._singleLookups[index][account.Identity];                  }              }
Magic Number,Swarmops.Logic.Financial,AnnualReport,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,PopulateLookups,The following statement contains a magic number: for (int index = 0; index < 7; index++)              {                  AddChildrenValuesToParents (this._treeLookups[index]' accounts);              }
Magic Number,Swarmops.Logic.Financial,AnnualReportNode,C:\repos\Swarmops_Swarmops\Logic\Financial\AnnualReport.cs,AnnualReportNode,The following statement contains a magic number: this.Quarters = new Int64[4];
Magic Number,Swarmops.Logic.Financial,FinancialAccountRows,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccountRows.cs,FromArray,The following statement contains a magic number: FinancialAccountRows result = new FinancialAccountRows {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Financial,FinancialAccountRows,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccountRows.cs,FromArray,The following statement contains a magic number: FinancialAccountRows result = new FinancialAccountRows {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Financial,FinancialAccounts,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccounts.cs,GetBudgetSumCents,The following statement contains a magic number: return (Int64) (SwarmDb.GetDatabaseForReading().GetFinancialAccountsBudget (Identities' year)*100);
Magic Number,Swarmops.Logic.Financial,FinancialTransactionRows,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransactionRows.cs,FromArray,The following statement contains a magic number: FinancialTransactionRows result = new FinancialTransactionRows {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Financial,FinancialTransactionRows,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransactionRows.cs,FromArray,The following statement contains a magic number: FinancialTransactionRows result = new FinancialTransactionRows {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Financial,FinancialTransactions,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransactions.cs,GetIncomplete,The following statement contains a magic number: foreach (FinancialTransaction transaction in allIncomplete)              {                  if (transaction.DateTime.Year > 2009)                  {                      result.Add (transaction);                  }              }
Magic Number,Swarmops.Logic.Financial,InboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\InboundInvoice.cs,Create,The following statement contains a magic number: OutboundComm.CreateNotificationAttestationNeeded (budget' creatingPerson' supplier' (amountCents-vatCents)/100.0'                  description' NotificationResource.InboundInvoice_Created);
Magic Number,Swarmops.Logic.Financial,InboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\InboundInvoice.cs,Create,The following statement contains a magic number: SwarmopsLogEntry.Create (creatingPerson'                  new InboundInvoiceCreatedLogEntry (creatingPerson' supplier' description' amountCents/100.0' budget)'                  newInvoice);
Magic Number,Swarmops.Logic.Financial,OutboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\OutboundInvoice.cs,FromReference,The following statement contains a magic number: string identityString = reference.Substring (12' reference.Length - 13);
Magic Number,Swarmops.Logic.Financial,OutboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\OutboundInvoice.cs,FromReference,The following statement contains a magic number: string identityString = reference.Substring (12' reference.Length - 13);
Magic Number,Swarmops.Logic.Financial,OutboundInvoice,C:\repos\Swarmops_Swarmops\Logic\Financial\OutboundInvoice.cs,Create,The following statement contains a magic number: OutboundInvoice invoice =                  FromIdentity (SwarmDb.GetDatabaseForWriting()                      .CreateOutboundInvoice (organization.Identity'                          createdByPerson != null ? createdByPerson.Identity : 0'                          dueDate'                          budget.Identity' customerName' invoiceAddressPaper'                          invoiceAddressMail' currency.Identity' string.Empty' domestic'                          Authentication.CreateWeakSecret (6)' theirReference));
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: int namespaceLength = 4;
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: switch (Char.ToLowerInvariant (Tag[5]))              {                  case 'm':                      namespaceLength = 6; // unique per year and month                      break;                  case 'd':                      namespaceLength = 8; // unique per year' month' day                      break;                  default:                      // do nothing -- assume year' namespace length 4 as declared on init                      break;              }
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: switch (Char.ToLowerInvariant (Tag[5]))              {                  case 'm':                      namespaceLength = 6; // unique per year and month                      break;                  case 'd':                      namespaceLength = 8; // unique per year' month' day                      break;                  default:                      // do nothing -- assume year' namespace length 4 as declared on init                      break;              }
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: switch (Char.ToLowerInvariant (Tag[5]))              {                  case 'm':                      namespaceLength = 6; // unique per year and month                      break;                  case 'd':                      namespaceLength = 8; // unique per year' month' day                      break;                  default:                      // do nothing -- assume year' namespace length 4 as declared on init                      break;              }
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: string lookfor = Tag.Substring (5 + namespaceLength).ToLowerInvariant().Trim();
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: int year = Int32.Parse (Tag.Substring (5' 4));
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: int year = Int32.Parse (Tag.Substring (5' 4));
Magic Number,Swarmops.Logic.Financial,PaymentGroup,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentGroup.cs,MapTransaction,The following statement contains a magic number: if (Char.IsDigit (Tag[0]))              {                  lookfor = Tag.Substring (namespaceLength); // temp - remove after PPSE books closed for 2011                  year = Int32.Parse (Tag.Substring (0' 4));              }
Magic Number,Swarmops.Logic.Financial,PaymentInformationList,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentInformation.cs,FromArray,The following statement contains a magic number: PaymentInformationList result = new PaymentInformationList {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Financial,PaymentInformationList,C:\repos\Swarmops_Swarmops\Logic\Financial\PaymentInformation.cs,FromArray,The following statement contains a magic number: PaymentInformationList result = new PaymentInformationList {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,LoadDependencies,The following statement contains a magic number: foreach (BasicFinancialDependency dependency in dependencies)              {                  switch (dependency.DependencyType)                  {                      case FinancialDependencyType.ExpenseClaim:                          this.DependentExpenseClaims.Add(ExpenseClaim.FromIdentity(dependency.ForeignId));                          break;                      case FinancialDependencyType.InboundInvoice:                          this.DependentInvoices.Add(InboundInvoice.FromIdentity(dependency.ForeignId));                          break;                      case FinancialDependencyType.Salary:                          Salary salary = Salary.FromIdentity(dependency.ForeignId);                          if (salary.NetSalaryCents == AmountCents || this.CreatedDateTime > new DateTime(2015' 11' 1))                          {                              this.DependentSalariesNet.Add(salary);                          }                          else // LEGACY                          {                              this.DependentSalariesTax.Add(salary);                          }                          break;                        case FinancialDependencyType.SalaryTax:                          Salary salaryTax = Salary.FromIdentity(dependency.ForeignId);                          this.DependentSalariesTax.Add(salaryTax);                          break;                        case FinancialDependencyType.CashAdvance:                          this.DependentCashAdvancesPayout.Add(CashAdvance.FromIdentity(dependency.ForeignId));                          break;                        case FinancialDependencyType.CashAdvancePayback:                          this.DependentCashAdvancesPayback.Add(CashAdvance.FromIdentity(dependency.ForeignId));                          break;                        default:                          throw new NotImplementedException(                              "Unknown financial dependency type in Payout.LoadDependencies(): " + dependency);                  }              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,LoadDependencies,The following statement contains a magic number: foreach (BasicFinancialDependency dependency in dependencies)              {                  switch (dependency.DependencyType)                  {                      case FinancialDependencyType.ExpenseClaim:                          this.DependentExpenseClaims.Add(ExpenseClaim.FromIdentity(dependency.ForeignId));                          break;                      case FinancialDependencyType.InboundInvoice:                          this.DependentInvoices.Add(InboundInvoice.FromIdentity(dependency.ForeignId));                          break;                      case FinancialDependencyType.Salary:                          Salary salary = Salary.FromIdentity(dependency.ForeignId);                          if (salary.NetSalaryCents == AmountCents || this.CreatedDateTime > new DateTime(2015' 11' 1))                          {                              this.DependentSalariesNet.Add(salary);                          }                          else // LEGACY                          {                              this.DependentSalariesTax.Add(salary);                          }                          break;                        case FinancialDependencyType.SalaryTax:                          Salary salaryTax = Salary.FromIdentity(dependency.ForeignId);                          this.DependentSalariesTax.Add(salaryTax);                          break;                        case FinancialDependencyType.CashAdvance:                          this.DependentCashAdvancesPayout.Add(CashAdvance.FromIdentity(dependency.ForeignId));                          break;                        case FinancialDependencyType.CashAdvancePayback:                          this.DependentCashAdvancesPayback.Add(CashAdvance.FromIdentity(dependency.ForeignId));                          break;                        default:                          throw new NotImplementedException(                              "Unknown financial dependency type in Payout.LoadDependencies(): " + dependency);                  }              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateBitcoinPayoutFromPrototype,The following statement contains a magic number: foreach (string component in components)              {                  int foreignId = Int32.Parse(component.Substring(1));                    switch (component[0])                  {                      case 'A':                          // Cash advance                          CashAdvance advance = CashAdvance.FromIdentity (foreignId);                          advance.PaidOut = true;                            SwarmopsLogEntry.Create (null'                              new PayoutCreatedLogEntry (null' advance.Person' organization'                                  organization.Currency' advance.AmountCents/100.0'                                  "Cash Advance Paid Out")'                              advance.Person' advance);                            OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                              advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                                  foreignId);                          break;                        case 'a':                          // This is a negative record - payback of cash advance                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePayback.Open = false;                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.CashAdvancePayback'                                  foreignId);                            break;                        case 'C':                          // Expense claim                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.ExpenseClaim'                                  foreignId);                            break;                        case 'I':                          // Invoice                          InboundInvoice invoice = InboundInvoice.FromIdentity (foreignId);                          DateTime expectedPayment = invoice.DueDate;                            if (expectedPayment < DateTime.Today)                          {                              expectedPayment = DateTime.Today;                          }                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                                  invoice.Identity);                            // TODO: NOTIFY PAID?                            invoice.Open = false;                          break;                        case 'S':                          // Salary net                            Salary salaryNet = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                              salaryNet.Identity);                          salaryNet.NetPaid = true;                          break;                        case 'T':                          // Tax payout' typically for multiple salaries                            Salary salaryTax = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                              salaryTax.Identity);                          salaryTax.TaxPaid = true;                            break;                      default:                          throw new NotImplementedException();                    }              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateBitcoinPayoutFromPrototype,The following statement contains a magic number: foreach (string component in components)              {                  int foreignId = Int32.Parse(component.Substring(1));                    switch (component[0])                  {                      case 'A':                          // Cash advance                          CashAdvance advance = CashAdvance.FromIdentity (foreignId);                          advance.PaidOut = true;                            SwarmopsLogEntry.Create (null'                              new PayoutCreatedLogEntry (null' advance.Person' organization'                                  organization.Currency' advance.AmountCents/100.0'                                  "Cash Advance Paid Out")'                              advance.Person' advance);                            OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                              advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                                  foreignId);                          break;                        case 'a':                          // This is a negative record - payback of cash advance                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePayback.Open = false;                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.CashAdvancePayback'                                  foreignId);                            break;                        case 'C':                          // Expense claim                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.ExpenseClaim'                                  foreignId);                            break;                        case 'I':                          // Invoice                          InboundInvoice invoice = InboundInvoice.FromIdentity (foreignId);                          DateTime expectedPayment = invoice.DueDate;                            if (expectedPayment < DateTime.Today)                          {                              expectedPayment = DateTime.Today;                          }                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                                  invoice.Identity);                            // TODO: NOTIFY PAID?                            invoice.Open = false;                          break;                        case 'S':                          // Salary net                            Salary salaryNet = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                              salaryNet.Identity);                          salaryNet.NetPaid = true;                          break;                        case 'T':                          // Tax payout' typically for multiple salaries                            Salary salaryTax = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                              salaryTax.Identity);                          salaryTax.TaxPaid = true;                            break;                      default:                          throw new NotImplementedException();                    }              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateBitcoinPayoutFromPrototype,The following statement contains a magic number: foreach (string component in components)              {                  int foreignId = Int32.Parse(component.Substring(1));                    switch (component[0])                  {                      case 'A':                          // Cash advance                          CashAdvance advance = CashAdvance.FromIdentity (foreignId);                          advance.PaidOut = true;                            SwarmopsLogEntry.Create (null'                              new PayoutCreatedLogEntry (null' advance.Person' organization'                                  organization.Currency' advance.AmountCents/100.0'                                  "Cash Advance Paid Out")'                              advance.Person' advance);                            OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                              advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                                  foreignId);                          break;                        case 'a':                          // This is a negative record - payback of cash advance                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePayback.Open = false;                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.CashAdvancePayback'                                  foreignId);                            break;                        case 'C':                          // Expense claim                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                          SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency(payoutId' FinancialDependencyType.ExpenseClaim'                                  foreignId);                            break;                        case 'I':                          // Invoice                          InboundInvoice invoice = InboundInvoice.FromIdentity (foreignId);                          DateTime expectedPayment = invoice.DueDate;                            if (expectedPayment < DateTime.Today)                          {                              expectedPayment = DateTime.Today;                          }                            SwarmDb.GetDatabaseForWriting()                              .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                                  invoice.Identity);                            // TODO: NOTIFY PAID?                            invoice.Open = false;                          break;                        case 'S':                          // Salary net                            Salary salaryNet = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                              salaryNet.Identity);                          salaryNet.NetPaid = true;                          break;                        case 'T':                          // Tax payout' typically for multiple salaries                            Salary salaryTax = Salary.FromIdentity (foreignId);                          SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                              salaryTax.Identity);                          salaryTax.TaxPaid = true;                            break;                      default:                          throw new NotImplementedException();                    }              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateFromProtoIdentity,The following statement contains a magic number: if (components[0][0] == 'A')              {                  // Cash advance(s) to be paid out.                    string bank = string.Empty;                  string account = string.Empty;                  List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int advanceId = Int32.Parse (component.Substring (1));                      CashAdvance advance = CashAdvance.FromIdentity (advanceId);                      identityList.Add (advanceId);                      organizationId = advance.OrganizationId;                      Organization organization = Organization.FromIdentity (advance.OrganizationId);                        if (bank.Length < 1)                      {                          Person asker = advance.Person;                          bank = asker.BankName;                          account = asker.BankAccount;                      }                        amountCents += advance.AmountCents;                        advance.PaidOut = true;                      // advance.Open remains true until the advance is repaid                        SwarmopsLogEntry.Create (creator'                          new PayoutCreatedLogEntry (creator' advance.Person' organization'                              organization.Currency' amountCents/100.0'                              "Cash Advance Paid Out")'                          advance.Person' advance);                          OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                          advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                  }                    string referenceString = string.Empty;                    if (identityList.Count == 1)                  {                      referenceString = "Cash Advance #" + identityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      identityList.Sort();                      referenceString = "Cash Advances " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int advanceId in identityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                              advanceId);                  }              }              else if (components[0][0] == 'C')              {                  // Expense claims' possibly followed up by cash advance paybacks                    Person beneficiaryPerson = null;                  Organization organization = null;                  string bank = string.Empty;                  string account = string.Empty;                  List<int> claimIdentityList = new List<int>();                  List<int> advancePaybackIdentityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int foreignId = Int32.Parse (component.Substring (1));                        if (component[0] == 'C')                      {                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claimIdentityList.Add (foreignId);                            if (bank.Length < 1)                          {                              Person claimer = claim.Claimer;                              bank = claimer.BankName;                              account = claimer.BankAccount;                              organizationId = claim.OrganizationId;                          }                            beneficiaryPerson = claim.Claimer;                          organization = claim.Organization;                          amountCents += claim.AmountCents;                            claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                      }                      else if (component[0] == 'a')                      {                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePaybackIdentityList.Add (foreignId);                            amountCents -= advancePayback.AmountCents;                          advancePayback.Open = false;                      }                  }                    string referenceString = string.Empty;                    if (claimIdentityList.Count == 1)                  {                      referenceString = "Expense Claim #" + claimIdentityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      claimIdentityList.Sort();                      referenceString = "Expense Claims " + Formatting.GenerateRangeString (claimIdentityList);                  }                    SwarmopsLogEntry.Create (creator'                      new PayoutCreatedLogEntry (creator' beneficiaryPerson' organization'                          organization.Currency' amountCents/100.0'                          referenceString)'                      beneficiaryPerson);                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int claimId in claimIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.ExpenseClaim'                              claimId);                  }                    foreach (int advancePaybackId in advancePaybackIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvancePayback'                              advancePaybackId);                  }              }              else if (components[0][0] == 'I')              {                  // There is just one invoice per payout                    InboundInvoice invoice = InboundInvoice.FromIdentity (Int32.Parse (components[0].Substring (1)));                    DateTime expectedPayment = invoice.DueDate;                    if (expectedPayment < DateTime.Today)                  {                      expectedPayment = DateTime.Today;                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (invoice.OrganizationId' string.Empty' invoice.PayToAccount'                          invoice.Ocr.Length > 0 ? "OCR " + invoice.Ocr : "Ref# " + invoice.InvoiceReference'                          invoice.AmountCents' expectedPayment'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting()                      .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                          invoice.Identity);                    invoice.Open = false;              }              else if (components[0][0] == 'S')              {                  // Salary' net payment                    Salary salary = Salary.FromIdentity (Int32.Parse (components[0].Substring (1)));                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (salary.PayrollItem.OrganizationId' salary.PayrollItem.Person.BankName'                          salary.PayrollItem.Person.BankAccount'                          "Salary " + salary.PayoutDate.ToString ("yyyy-MMM")'                          salary.NetSalaryCents' salary.PayoutDate'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                      salary.Identity);                    salary.NetPaid = true;              }              else if (components[0][0] == 'T')              {                  // Tax payment for multiple salaries.                    List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                  DateTime payDay = DateTime.Today.AddDays (1);                    foreach (string component in components)                  {                      int salaryId = Int32.Parse (component.Substring (1));                      Salary salary = Salary.FromIdentity (salaryId);                      identityList.Add (salaryId);                        if (organizationId == 0)                      {                          organizationId = salary.PayrollItem.OrganizationId;                          payDay = salary.PayoutDate;                      }                        amountCents += salary.TaxTotalCents;                        salary.TaxPaid = true;                  }                    string referenceString = string.Empty;                  Organization organization = Organization.FromIdentity (organizationId);                    if (identityList.Count == 1)                  {                      referenceString = "Tax for salary #" + identityList[0];                  }                  else                  {                      identityList.Sort();                      referenceString = "Tax for salaries " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (organization.Identity' "The Tax Man"' organization.Parameters.TaxAccount'                          organization.Parameters.TaxOcr'                          amountCents' payDay' creator.Identity);                    foreach (int salaryId in identityList)                  {                      SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                          salaryId);                  }              }              else              {                  throw new NotImplementedException();              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateFromProtoIdentity,The following statement contains a magic number: if (components[0][0] == 'A')              {                  // Cash advance(s) to be paid out.                    string bank = string.Empty;                  string account = string.Empty;                  List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int advanceId = Int32.Parse (component.Substring (1));                      CashAdvance advance = CashAdvance.FromIdentity (advanceId);                      identityList.Add (advanceId);                      organizationId = advance.OrganizationId;                      Organization organization = Organization.FromIdentity (advance.OrganizationId);                        if (bank.Length < 1)                      {                          Person asker = advance.Person;                          bank = asker.BankName;                          account = asker.BankAccount;                      }                        amountCents += advance.AmountCents;                        advance.PaidOut = true;                      // advance.Open remains true until the advance is repaid                        SwarmopsLogEntry.Create (creator'                          new PayoutCreatedLogEntry (creator' advance.Person' organization'                              organization.Currency' amountCents/100.0'                              "Cash Advance Paid Out")'                          advance.Person' advance);                          OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                          advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                  }                    string referenceString = string.Empty;                    if (identityList.Count == 1)                  {                      referenceString = "Cash Advance #" + identityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      identityList.Sort();                      referenceString = "Cash Advances " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int advanceId in identityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                              advanceId);                  }              }              else if (components[0][0] == 'C')              {                  // Expense claims' possibly followed up by cash advance paybacks                    Person beneficiaryPerson = null;                  Organization organization = null;                  string bank = string.Empty;                  string account = string.Empty;                  List<int> claimIdentityList = new List<int>();                  List<int> advancePaybackIdentityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int foreignId = Int32.Parse (component.Substring (1));                        if (component[0] == 'C')                      {                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claimIdentityList.Add (foreignId);                            if (bank.Length < 1)                          {                              Person claimer = claim.Claimer;                              bank = claimer.BankName;                              account = claimer.BankAccount;                              organizationId = claim.OrganizationId;                          }                            beneficiaryPerson = claim.Claimer;                          organization = claim.Organization;                          amountCents += claim.AmountCents;                            claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                      }                      else if (component[0] == 'a')                      {                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePaybackIdentityList.Add (foreignId);                            amountCents -= advancePayback.AmountCents;                          advancePayback.Open = false;                      }                  }                    string referenceString = string.Empty;                    if (claimIdentityList.Count == 1)                  {                      referenceString = "Expense Claim #" + claimIdentityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      claimIdentityList.Sort();                      referenceString = "Expense Claims " + Formatting.GenerateRangeString (claimIdentityList);                  }                    SwarmopsLogEntry.Create (creator'                      new PayoutCreatedLogEntry (creator' beneficiaryPerson' organization'                          organization.Currency' amountCents/100.0'                          referenceString)'                      beneficiaryPerson);                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int claimId in claimIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.ExpenseClaim'                              claimId);                  }                    foreach (int advancePaybackId in advancePaybackIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvancePayback'                              advancePaybackId);                  }              }              else if (components[0][0] == 'I')              {                  // There is just one invoice per payout                    InboundInvoice invoice = InboundInvoice.FromIdentity (Int32.Parse (components[0].Substring (1)));                    DateTime expectedPayment = invoice.DueDate;                    if (expectedPayment < DateTime.Today)                  {                      expectedPayment = DateTime.Today;                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (invoice.OrganizationId' string.Empty' invoice.PayToAccount'                          invoice.Ocr.Length > 0 ? "OCR " + invoice.Ocr : "Ref# " + invoice.InvoiceReference'                          invoice.AmountCents' expectedPayment'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting()                      .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                          invoice.Identity);                    invoice.Open = false;              }              else if (components[0][0] == 'S')              {                  // Salary' net payment                    Salary salary = Salary.FromIdentity (Int32.Parse (components[0].Substring (1)));                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (salary.PayrollItem.OrganizationId' salary.PayrollItem.Person.BankName'                          salary.PayrollItem.Person.BankAccount'                          "Salary " + salary.PayoutDate.ToString ("yyyy-MMM")'                          salary.NetSalaryCents' salary.PayoutDate'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                      salary.Identity);                    salary.NetPaid = true;              }              else if (components[0][0] == 'T')              {                  // Tax payment for multiple salaries.                    List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                  DateTime payDay = DateTime.Today.AddDays (1);                    foreach (string component in components)                  {                      int salaryId = Int32.Parse (component.Substring (1));                      Salary salary = Salary.FromIdentity (salaryId);                      identityList.Add (salaryId);                        if (organizationId == 0)                      {                          organizationId = salary.PayrollItem.OrganizationId;                          payDay = salary.PayoutDate;                      }                        amountCents += salary.TaxTotalCents;                        salary.TaxPaid = true;                  }                    string referenceString = string.Empty;                  Organization organization = Organization.FromIdentity (organizationId);                    if (identityList.Count == 1)                  {                      referenceString = "Tax for salary #" + identityList[0];                  }                  else                  {                      identityList.Sort();                      referenceString = "Tax for salaries " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (organization.Identity' "The Tax Man"' organization.Parameters.TaxAccount'                          organization.Parameters.TaxOcr'                          amountCents' payDay' creator.Identity);                    foreach (int salaryId in identityList)                  {                      SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                          salaryId);                  }              }              else              {                  throw new NotImplementedException();              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateFromProtoIdentity,The following statement contains a magic number: if (components[0][0] == 'A')              {                  // Cash advance(s) to be paid out.                    string bank = string.Empty;                  string account = string.Empty;                  List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int advanceId = Int32.Parse (component.Substring (1));                      CashAdvance advance = CashAdvance.FromIdentity (advanceId);                      identityList.Add (advanceId);                      organizationId = advance.OrganizationId;                      Organization organization = Organization.FromIdentity (advance.OrganizationId);                        if (bank.Length < 1)                      {                          Person asker = advance.Person;                          bank = asker.BankName;                          account = asker.BankAccount;                      }                        amountCents += advance.AmountCents;                        advance.PaidOut = true;                      // advance.Open remains true until the advance is repaid                        SwarmopsLogEntry.Create (creator'                          new PayoutCreatedLogEntry (creator' advance.Person' organization'                              organization.Currency' amountCents/100.0'                              "Cash Advance Paid Out")'                          advance.Person' advance);                          OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                          advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                  }                    string referenceString = string.Empty;                    if (identityList.Count == 1)                  {                      referenceString = "Cash Advance #" + identityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      identityList.Sort();                      referenceString = "Cash Advances " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int advanceId in identityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                              advanceId);                  }              }              else if (components[0][0] == 'C')              {                  // Expense claims' possibly followed up by cash advance paybacks                    Person beneficiaryPerson = null;                  Organization organization = null;                  string bank = string.Empty;                  string account = string.Empty;                  List<int> claimIdentityList = new List<int>();                  List<int> advancePaybackIdentityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int foreignId = Int32.Parse (component.Substring (1));                        if (component[0] == 'C')                      {                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claimIdentityList.Add (foreignId);                            if (bank.Length < 1)                          {                              Person claimer = claim.Claimer;                              bank = claimer.BankName;                              account = claimer.BankAccount;                              organizationId = claim.OrganizationId;                          }                            beneficiaryPerson = claim.Claimer;                          organization = claim.Organization;                          amountCents += claim.AmountCents;                            claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                      }                      else if (component[0] == 'a')                      {                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePaybackIdentityList.Add (foreignId);                            amountCents -= advancePayback.AmountCents;                          advancePayback.Open = false;                      }                  }                    string referenceString = string.Empty;                    if (claimIdentityList.Count == 1)                  {                      referenceString = "Expense Claim #" + claimIdentityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      claimIdentityList.Sort();                      referenceString = "Expense Claims " + Formatting.GenerateRangeString (claimIdentityList);                  }                    SwarmopsLogEntry.Create (creator'                      new PayoutCreatedLogEntry (creator' beneficiaryPerson' organization'                          organization.Currency' amountCents/100.0'                          referenceString)'                      beneficiaryPerson);                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int claimId in claimIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.ExpenseClaim'                              claimId);                  }                    foreach (int advancePaybackId in advancePaybackIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvancePayback'                              advancePaybackId);                  }              }              else if (components[0][0] == 'I')              {                  // There is just one invoice per payout                    InboundInvoice invoice = InboundInvoice.FromIdentity (Int32.Parse (components[0].Substring (1)));                    DateTime expectedPayment = invoice.DueDate;                    if (expectedPayment < DateTime.Today)                  {                      expectedPayment = DateTime.Today;                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (invoice.OrganizationId' string.Empty' invoice.PayToAccount'                          invoice.Ocr.Length > 0 ? "OCR " + invoice.Ocr : "Ref# " + invoice.InvoiceReference'                          invoice.AmountCents' expectedPayment'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting()                      .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                          invoice.Identity);                    invoice.Open = false;              }              else if (components[0][0] == 'S')              {                  // Salary' net payment                    Salary salary = Salary.FromIdentity (Int32.Parse (components[0].Substring (1)));                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (salary.PayrollItem.OrganizationId' salary.PayrollItem.Person.BankName'                          salary.PayrollItem.Person.BankAccount'                          "Salary " + salary.PayoutDate.ToString ("yyyy-MMM")'                          salary.NetSalaryCents' salary.PayoutDate'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                      salary.Identity);                    salary.NetPaid = true;              }              else if (components[0][0] == 'T')              {                  // Tax payment for multiple salaries.                    List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                  DateTime payDay = DateTime.Today.AddDays (1);                    foreach (string component in components)                  {                      int salaryId = Int32.Parse (component.Substring (1));                      Salary salary = Salary.FromIdentity (salaryId);                      identityList.Add (salaryId);                        if (organizationId == 0)                      {                          organizationId = salary.PayrollItem.OrganizationId;                          payDay = salary.PayoutDate;                      }                        amountCents += salary.TaxTotalCents;                        salary.TaxPaid = true;                  }                    string referenceString = string.Empty;                  Organization organization = Organization.FromIdentity (organizationId);                    if (identityList.Count == 1)                  {                      referenceString = "Tax for salary #" + identityList[0];                  }                  else                  {                      identityList.Sort();                      referenceString = "Tax for salaries " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (organization.Identity' "The Tax Man"' organization.Parameters.TaxAccount'                          organization.Parameters.TaxOcr'                          amountCents' payDay' creator.Identity);                    foreach (int salaryId in identityList)                  {                      SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                          salaryId);                  }              }              else              {                  throw new NotImplementedException();              }
Magic Number,Swarmops.Logic.Financial,Payout,C:\repos\Swarmops_Swarmops\Logic\Financial\Payout.cs,CreateFromProtoIdentity,The following statement contains a magic number: if (components[0][0] == 'A')              {                  // Cash advance(s) to be paid out.                    string bank = string.Empty;                  string account = string.Empty;                  List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int advanceId = Int32.Parse (component.Substring (1));                      CashAdvance advance = CashAdvance.FromIdentity (advanceId);                      identityList.Add (advanceId);                      organizationId = advance.OrganizationId;                      Organization organization = Organization.FromIdentity (advance.OrganizationId);                        if (bank.Length < 1)                      {                          Person asker = advance.Person;                          bank = asker.BankName;                          account = asker.BankAccount;                      }                        amountCents += advance.AmountCents;                        advance.PaidOut = true;                      // advance.Open remains true until the advance is repaid                        SwarmopsLogEntry.Create (creator'                          new PayoutCreatedLogEntry (creator' advance.Person' organization'                              organization.Currency' amountCents/100.0'                              "Cash Advance Paid Out")'                          advance.Person' advance);                          OutboundComm.CreateNotificationOfFinancialValidation (advance.Budget' advance.Person'                          advance.AmountCents/100.0' advance.Description' NotificationResource.CashAdvance_PaidOut);                  }                    string referenceString = string.Empty;                    if (identityList.Count == 1)                  {                      referenceString = "Cash Advance #" + identityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      identityList.Sort();                      referenceString = "Cash Advances " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int advanceId in identityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvance'                              advanceId);                  }              }              else if (components[0][0] == 'C')              {                  // Expense claims' possibly followed up by cash advance paybacks                    Person beneficiaryPerson = null;                  Organization organization = null;                  string bank = string.Empty;                  string account = string.Empty;                  List<int> claimIdentityList = new List<int>();                  List<int> advancePaybackIdentityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                    foreach (string component in components)                  {                      int foreignId = Int32.Parse (component.Substring (1));                        if (component[0] == 'C')                      {                          ExpenseClaim claim = ExpenseClaim.FromIdentity (foreignId);                          claimIdentityList.Add (foreignId);                            if (bank.Length < 1)                          {                              Person claimer = claim.Claimer;                              bank = claimer.BankName;                              account = claimer.BankAccount;                              organizationId = claim.OrganizationId;                          }                            beneficiaryPerson = claim.Claimer;                          organization = claim.Organization;                          amountCents += claim.AmountCents;                            claim.Repaid = true;                          claim.Close();                            OutboundComm.CreateNotificationOfFinancialValidation (claim.Budget' claim.Claimer'                              claim.AmountCents/100.0' claim.Description' NotificationResource.ExpenseClaim_PaidOut);                      }                      else if (component[0] == 'a')                      {                          CashAdvance advancePayback = CashAdvance.FromIdentity (foreignId);                          advancePaybackIdentityList.Add (foreignId);                            amountCents -= advancePayback.AmountCents;                          advancePayback.Open = false;                      }                  }                    string referenceString = string.Empty;                    if (claimIdentityList.Count == 1)                  {                      referenceString = "Expense Claim #" + claimIdentityList[0].ToString (CultureInfo.InvariantCulture);                  }                  else                  {                      claimIdentityList.Sort();                      referenceString = "Expense Claims " + Formatting.GenerateRangeString (claimIdentityList);                  }                    SwarmopsLogEntry.Create (creator'                      new PayoutCreatedLogEntry (creator' beneficiaryPerson' organization'                          organization.Currency' amountCents/100.0'                          referenceString)'                      beneficiaryPerson);                    payoutId = SwarmDb.GetDatabaseForWriting().CreatePayout (organizationId' bank' account'                      referenceString' amountCents' DateTime.Today.AddDays (1)'                      creator.Identity);                    foreach (int claimId in claimIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.ExpenseClaim'                              claimId);                  }                    foreach (int advancePaybackId in advancePaybackIdentityList)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreatePayoutDependency (payoutId' FinancialDependencyType.CashAdvancePayback'                              advancePaybackId);                  }              }              else if (components[0][0] == 'I')              {                  // There is just one invoice per payout                    InboundInvoice invoice = InboundInvoice.FromIdentity (Int32.Parse (components[0].Substring (1)));                    DateTime expectedPayment = invoice.DueDate;                    if (expectedPayment < DateTime.Today)                  {                      expectedPayment = DateTime.Today;                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (invoice.OrganizationId' string.Empty' invoice.PayToAccount'                          invoice.Ocr.Length > 0 ? "OCR " + invoice.Ocr : "Ref# " + invoice.InvoiceReference'                          invoice.AmountCents' expectedPayment'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting()                      .CreatePayoutDependency (payoutId' FinancialDependencyType.InboundInvoice'                          invoice.Identity);                    invoice.Open = false;              }              else if (components[0][0] == 'S')              {                  // Salary' net payment                    Salary salary = Salary.FromIdentity (Int32.Parse (components[0].Substring (1)));                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (salary.PayrollItem.OrganizationId' salary.PayrollItem.Person.BankName'                          salary.PayrollItem.Person.BankAccount'                          "Salary " + salary.PayoutDate.ToString ("yyyy-MMM")'                          salary.NetSalaryCents' salary.PayoutDate'                          creator.Identity);                    SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.Salary'                      salary.Identity);                    salary.NetPaid = true;              }              else if (components[0][0] == 'T')              {                  // Tax payment for multiple salaries.                    List<int> identityList = new List<int>();                  Int64 amountCents = 0;                  int organizationId = 0;                  DateTime payDay = DateTime.Today.AddDays (1);                    foreach (string component in components)                  {                      int salaryId = Int32.Parse (component.Substring (1));                      Salary salary = Salary.FromIdentity (salaryId);                      identityList.Add (salaryId);                        if (organizationId == 0)                      {                          organizationId = salary.PayrollItem.OrganizationId;                          payDay = salary.PayoutDate;                      }                        amountCents += salary.TaxTotalCents;                        salary.TaxPaid = true;                  }                    string referenceString = string.Empty;                  Organization organization = Organization.FromIdentity (organizationId);                    if (identityList.Count == 1)                  {                      referenceString = "Tax for salary #" + identityList[0];                  }                  else                  {                      identityList.Sort();                      referenceString = "Tax for salaries " + Formatting.GenerateRangeString (identityList);                  }                    payoutId = SwarmDb.GetDatabaseForWriting()                      .CreatePayout (organization.Identity' "The Tax Man"' organization.Parameters.TaxAccount'                          organization.Parameters.TaxOcr'                          amountCents' payDay' creator.Identity);                    foreach (int salaryId in identityList)                  {                      SwarmDb.GetDatabaseForWriting().CreatePayoutDependency (payoutId' FinancialDependencyType.SalaryTax'                          salaryId);                  }              }              else              {                  throw new NotImplementedException();              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AddUnpaidInboundInvoices,The following statement contains a magic number: foreach (InboundInvoice invoice in invoices)              {                  if (invoice.Attested)                  {                      BasicPayout basicPayout = new BasicPayout (0' organization.Identity' string.Empty'                          invoice.PayToAccount'                          invoice.Ocr.Length > 0 ? invoice.Ocr : invoice.InvoiceReference' // prefer OCR (automatic) over Reference (manual)                          (Int64) (invoice.Amount*100)'                          invoice.DueDate' false' DateTime.Now' 0);                      Payout payout = Payout.FromBasic (basicPayout);                        payout.DependentInvoices.Add (invoice);                        payoutList.Add (payout);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,AutomatchAgainstUnbalancedTransactions,The following statement contains a magic number: foreach (FinancialTransaction transaction in transactions)              {                  // Console.WriteLine("Looking at transaction #{0} ({1:yyyy-MM-dd}' {2:N2})."' transaction.Identity' transaction.DateTime' transaction.Rows.AmountTotal);                    // First' establish that there are no similar transactions within 7 days. N^2 search.                    DateTime timeLow = transaction.DateTime.AddDays (-7);                  DateTime timeHigh = transaction.DateTime.AddDays (7);                    bool foundCompeting = false;                    foreach (FinancialTransaction possiblyCompetingTransaction in transactions)                  {                      if (possiblyCompetingTransaction.Rows.AmountCentsTotal == transaction.Rows.AmountCentsTotal &&                          possiblyCompetingTransaction.DateTime >= timeLow &&                          possiblyCompetingTransaction.DateTime <= timeHigh &&                          possiblyCompetingTransaction.Identity != transaction.Identity)                      {                          foundCompeting = true;                          // Console.WriteLine(" - Transaction #{0} ({1:yyyy-MM-dd} is competing' aborting"' possiblyCompetingTransaction.Identity' possiblyCompetingTransaction.DateTime);                      }                  }                    if (foundCompeting)                  {                      continue;                  }                    // Console.WriteLine(" - no competing transactions...\r\n - transaction description is \"{0}\"."' transaction.Description);                    // Console.WriteLine(" - looking for matching payouts");                    int foundCount = 0;                  int payoutIdFound = 0;                    // As the amount of payouts grow' this becomes less efficient exponentially.                    foreach (Payout payout in payouts)                  {                      // Ugly hack to fix cash advance payouts                        DateTime payoutLowerTimeLimit = timeLow;                      DateTime payoutUpperTimeLimit = timeHigh;                        if (payout.AmountCents == -transaction.Rows.AmountCentsTotal &&                          (payout.DependentCashAdvancesPayout.Count > 0 || payout.DependentCashAdvancesPayback.Count > 0))                      {                          // HACK: While PW5 doesn't have a manual-debug interface' special case for cash advances                            payoutLowerTimeLimit = transaction.DateTime.AddDays (-60);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (60);                      }                        // HACK: Allow for up to 20 days beyond scheduled payment to catch tax payments                        if (payout.DependentSalariesTax.Count > 0)                      {                          payoutLowerTimeLimit = transaction.DateTime.AddDays (-25);                          payoutUpperTimeLimit = transaction.DateTime.AddDays (3); // nobody pays taxes early...                      }                        if (payout.ExpectedTransactionDate >= payoutLowerTimeLimit &&                          payout.ExpectedTransactionDate <= payoutUpperTimeLimit &&                          payout.AmountCents == -transaction.Rows.AmountCentsTotal)                      {                          // Console.WriteLine(" - - payout #{0} matches ({1}' {2:yyyy-MM-dd})"' payout.Identity' payout.Recipient' payout.ExpectedTransactionDate);                            try                          {                              FinancialTransaction tiedTransaction = FinancialTransaction.FromDependency (payout);                                // Console.WriteLine(" - - - but is tied to transaction #{0} already"' tiedTransaction.Identity);                              break;                          }                          catch (Exception)                          {                              // There isn't such a transaction' which is what we want                          }                            foundCount++;                          payoutIdFound = payout.Identity;                      }                  }                    if (foundCount == 0)                  {                      // Console.WriteLine(" - none found");                  }                  else if (foundCount > 1)                  {                      // Console.WriteLine(" - multiple found' not autoprocessing");                  }                  else                  {                      Payout payout = Payout.FromIdentity (payoutIdFound);                      payout.BindToTransactionAndClose (transaction' null);                  }              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payouts,C:\repos\Swarmops_Swarmops\Logic\Financial\Payouts.cs,PerformAutomated,The following statement contains a magic number: foreach (Organization organization in Organizations.GetAll())              {                  // If this org doesn't do hotwallet' continue                  if (organization.FinancialAccounts.AssetsBitcoinHot == null)                  {                      continue;                  }                    Payouts orgPayouts = Payouts.Construct (organization);                  Payouts bitcoinPayouts = new Payouts();                  Dictionary<string' Int64> satoshiPayoutLookup = new Dictionary<string' long>();                  Dictionary<string' Int64> nativeCentsPayoutLookup = new Dictionary<string' long>();                  Dictionary<int' Int64> satoshiPersonLookup = new Dictionary<int' long>();                  Dictionary <int' Int64> nativeCentsPersonLookup = new Dictionary<int' long>();                  Int64 satoshisTotal = 0;                    string currencyCode = organization.Currency.Code;                    // For each ready payout that can automate' add an output to a constructed transaction                    TransactionBuilder txBuilder = null; // TODO TODO TODO TODO new TransactionBuilder();                  foreach (Payout payout in orgPayouts)                  {                      if (payout.ExpectedTransactionDate > utcNow)                      {                          continue; // payout is not due yet                      }                        if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length > 2 &&                          payout.Account.Length < 4)                      {                          // If the payout address is still in quarantine' don't pay out yet                            string addressSetTime = payout.RecipientPerson.BitcoinPayoutAddressTimeSet;                          if (addressSetTime.Length > 4 && DateTime.Parse (addressSetTime' CultureInfo.InvariantCulture).AddHours (48) > utcNow)                          {                              continue; // still in quarantine                          }                            // Test the payout address - is it valid and can we handle it?                            if (!BitcoinUtility.IsValidBitcoinAddress(payout.RecipientPerson.BitcoinPayoutAddress))                          {                              // Notify person that address is invalid' then clear it                                NotificationStrings primaryStrings = new NotificationStrings();                              NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                              primaryStrings[NotificationString.OrganizationName] = organization.Name;                              secondaryStrings["BitcoinAddress"] = payout.RecipientPerson.BitcoinPayoutAddress;                                OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_Bad'                                  primaryStrings' secondaryStrings'                                  People.FromSingle(payout.RecipientPerson));                                payout.RecipientPerson.BitcoinPayoutAddress = string.Empty;                                continue; // do not add this payout                          }                            // Ok' so it seems we're making this payout at this time.                            bitcoinPayouts.Add (payout);                            int recipientPersonId = payout.RecipientPerson.Identity;                            if (!satoshiPersonLookup.ContainsKey (recipientPersonId))                          {                              satoshiPersonLookup[recipientPersonId] = 0;                              nativeCentsPersonLookup[recipientPersonId] = 0;                          }                            nativeCentsPersonLookup[recipientPersonId] += payout.AmountCents;                            // Find the amount of satoshis for this payout                            if (organization.Currency.IsBitcoinCore)                          {                              satoshiPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += payout.AmountCents;                              satoshiPersonLookup[recipientPersonId] += payout.AmountCents;                          }                          else                          {                              // Convert currency                              Money payoutAmount = new Money(payout.AmountCents' organization.Currency);                              Int64 satoshis = payoutAmount.ToCurrency(Currency.BitcoinCore).Cents;                              satoshiPayoutLookup[payout.ProtoIdentity] = satoshis;                              nativeCentsPayoutLookup[payout.ProtoIdentity] = payout.AmountCents;                              satoshisTotal += satoshis;                              satoshiPersonLookup[recipientPersonId] += satoshis;                          }                      }                      else if (payout.RecipientPerson != null && payout.RecipientPerson.BitcoinPayoutAddress.Length < 3 && payout.Account.Length < 4)                      {                          // There is a payout for this person' but they don't have a bitcoin payout address set. Send notification to this effect once a day.                            if (utcNow.Minute != 0)                          {                              continue;                          }                          if (utcNow.Hour != 12)                          {                              continue;                          }                            NotificationStrings primaryStrings = new NotificationStrings();                          primaryStrings[NotificationString.OrganizationName] = organization.Name;                          OutboundComm.CreateNotification(organization' NotificationResource.BitcoinPayoutAddress_PleaseSet' primaryStrings' People.FromSingle(payout.RecipientPerson));                      }                      else if (payout.Account.StartsWith ("bitcoin:"))                      {                                                }                  }                    if (bitcoinPayouts.Count == 0)                  {                      // no automated payments pending for this organization' nothing more to do                      continue;                  }                    // We now have our desired payments. The next step is to find enough inputs to reach the required amount (plus fees; we're working a little blind here still).                    BitcoinTransactionInputs inputs = null;                  Int64 satoshisMaximumAnticipatedFees = BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain) * 20; // assume max 20k transaction size                    try                  {                      inputs = BitcoinUtility.GetInputsForAmount(organization' satoshisTotal + satoshisMaximumAnticipatedFees);                   }                  catch (NotEnoughFundsException)                  {                      // If we're at the whole hour' send a notification to people responsible for refilling the hotwallet                        if (utcNow.Minute != 0)                      {                          continue; // we're not at the whole hour' so continue with next org instead                      }                        // Send urgent notification to top up the damn wallet so we can make payments                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.Code;                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                      Int64 satoshisAvailable = HotBitcoinAddresses.ForOrganization (organization).BalanceSatoshisTotal;                        secondaryStrings["AmountMissingMicrocoinsFloat"] =                          ((satoshisTotal - satoshisAvailable + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                        if (organization.Currency.IsBitcoinCore)                      {                          secondaryStrings["AmountNeededFloat"] = ((satoshisTotal + satoshisMaximumAnticipatedFees) / 100.0).ToString("N2");                          secondaryStrings["AmountWalletFloat"] = (satoshisAvailable/100.0).ToString ("N2");                      }                      else                      {                          // convert to org native currency                            secondaryStrings["AmountNeededFloat"] =                              (new Money (satoshisTotal' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                          secondaryStrings["AmountWalletFloat"] =                              (new Money (satoshisAvailable' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents/100.0).ToString ("N2");                      }                        OutboundComm.CreateNotification (organization'                          NotificationResource.Bitcoin_Shortage_Critical' primaryStrings' secondaryStrings' People.FromSingle (Person.FromIdentity (1)));                        continue; // with next organization                  }                    // If we arrive at this point' the previous function didn't throw' and we have enough money.                   // Ensure the existence of a cost account for bitcoin miner fees.                    organization.EnsureMinerFeeAccountExists();                    // Add the inputs to the transaction.                    txBuilder = txBuilder.AddCoins (inputs.Coins);                  txBuilder = txBuilder.AddKeys (inputs.PrivateKeys);                  Int64 satoshisInput = inputs.AmountSatoshisTotal;                    // Add outputs and prepare notifications                    Int64 satoshisUsed = 0;                  Dictionary<int' List<string>> notificationSpecLookup = new Dictionary<int' List<string>>();                  Dictionary<int' List<Int64>> notificationAmountLookup = new Dictionary<int' List<Int64>>();                  Payout masterPayoutPrototype = Payout.Empty;                  HotBitcoinAddress changeAddress = HotBitcoinAddress.OrganizationWalletZero (organization' BitcoinChain.Core);   // TODO: CHAIN!                    foreach (Payout payout in bitcoinPayouts)                  {                      int recipientPersonId = payout.RecipientPerson.Identity;                      if (!notificationSpecLookup.ContainsKey (recipientPersonId))                      {                          notificationSpecLookup[recipientPersonId] = new List<string>();                          notificationAmountLookup[recipientPersonId] = new List<Int64>();                      }                      notificationSpecLookup[recipientPersonId].Add (payout.Specification);                      notificationAmountLookup[recipientPersonId].Add (payout.AmountCents);                        if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("1")) // regular address                      {                          txBuilder = txBuilder.Send (new BitcoinPubKeyAddress (payout.RecipientPerson.BitcoinPayoutAddress)'                              new Satoshis (satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else if (payout.RecipientPerson.BitcoinPayoutAddress.StartsWith ("3")) // multisig                      {                          txBuilder = txBuilder.Send(new BitcoinScriptAddress(payout.RecipientPerson.BitcoinPayoutAddress' Network.Main)'                              new Satoshis(satoshiPayoutLookup[payout.ProtoIdentity]));                      }                      else                      {                          throw new InvalidOperationException("Unhandled bitcoin address type in Payouts.PerformAutomated(): " + payout.RecipientPerson.BitcoinPayoutAddress);                      }                        satoshisUsed += satoshiPayoutLookup[payout.ProtoIdentity];                        payout.MigrateDependenciesTo (masterPayoutPrototype);                  }                    // Set change address to wallet slush                    txBuilder.SetChange (new BitcoinPubKeyAddress (changeAddress.Address));                    // Add fee                    int transactionSizeBytes = txBuilder.EstimateSize (txBuilder.BuildTransaction (false)) + inputs.Count;                   // +inputs.Count for size variability                    Int64 feeSatoshis = (transactionSizeBytes/1000 + 1) * BitcoinUtility.GetRecommendedFeePerThousandBytesSatoshis(chain);                                    txBuilder = txBuilder.SendFees (new Satoshis (feeSatoshis));                  satoshisUsed += feeSatoshis;                    // Sign transaction - ready to execute                    Transaction txReady = txBuilder.BuildTransaction (true);                    // Verify that transaction is ready                    if (!txBuilder.Verify (txReady))                  {                      // Transaction was not signed with the correct keys. This is a serious condition.                        NotificationStrings primaryStrings = new NotificationStrings();                      primaryStrings[NotificationString.OrganizationName] = organization.Name;                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PrivateKeyError'                          primaryStrings);                        throw new InvalidOperationException("Transaction is not signed enough");                  }                    // Broadcast transaction                    BitcoinUtility.BroadcastTransaction (txReady' BitcoinChain.Cash);                    // Note the transaction hash                    string transactionHash = txReady.GetHash().ToString();                    // Delete all old inputs' adjust balance for addresses (re-register unused inputs)                    inputs.AsUnspents.DeleteAll();                    // Log the new unspent created by change (if there is any)                    if (satoshisInput - satoshisUsed > 0)                  {                      SwarmDb.GetDatabaseForWriting()                          .CreateHotBitcoinAddressUnspentConditional(changeAddress.Identity' transactionHash'                              + /* the change address seems to always get index 0? is this a safe assumption? */ 0' satoshisInput - satoshisUsed' /* confirmation count*/ 0);                  }                    // Register new balance of change address' should have increased by (satoshisInput-satoshisUsed)                    // TODO                    // Send notifications                    foreach (int personId in notificationSpecLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                        string spec = string.Empty;                      for (int index = 0; index < notificationSpecLookup[personId].Count; index++)                      {                          spec += String.Format(" * {0'-40} {1'14:N2} {2'-4}\r\n"' notificationSpecLookup[personId][index]' notificationAmountLookup[personId][index]/100.0' currencyCode);                      }                        spec = spec.TrimEnd();                        NotificationStrings primaryStrings = new NotificationStrings();                      NotificationCustomStrings secondaryStrings = new NotificationCustomStrings();                        primaryStrings[NotificationString.OrganizationName] = organization.Name;                      primaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      primaryStrings[NotificationString.EmbeddedPreformattedText] = spec;                      secondaryStrings["AmountFloat"] = (nativeCentsPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAmountFloat"] = (satoshiPersonLookup[personId]/100.0).ToString ("N2");                      secondaryStrings["BitcoinAddress"] = person.BitcoinPayoutAddress; // warn: potential rare race condition here                        OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_PaidOut' primaryStrings'                          secondaryStrings' People.FromSingle(person));                  }                    // Create the master payout from its prototype                    Payout masterPayout = Payout.CreateBitcoinPayoutFromPrototype (organization' masterPayoutPrototype' txReady.GetHash().ToString());                    // Finally' create ledger entries and notify                    NotificationStrings masterPrimaryStrings = new NotificationStrings();                  NotificationCustomStrings masterSecondaryStrings = new NotificationCustomStrings();                    masterPrimaryStrings[NotificationString.OrganizationName] = organization.Name;                  masterPrimaryStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                  masterSecondaryStrings["AmountFloat"] =                      (new Swarmops.Logic.Financial.Money (satoshisUsed' Currency.BitcoinCore).ToCurrency (                          organization.Currency).Cents/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["BitcoinAmountFloat"] = (satoshisUsed/100.0).ToString ("N2"' CultureInfo.InvariantCulture);                  masterSecondaryStrings["PaymentCount"] = bitcoinPayouts.Count.ToString("N0"' CultureInfo.InvariantCulture);                    OutboundComm.CreateNotification (organization' NotificationResource.Bitcoin_Hotwallet_Outflow'                      masterPrimaryStrings' masterSecondaryStrings);                    // TODO: special case for native-bitcoin organizations vs. fiat-currency organizations                    FinancialTransaction ledgerTransaction = FinancialTransaction.Create (organization' utcNow'                      "Bitcoin automated payout");                    if (organization.Currency.IsBitcoinCore)                  {                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeSatoshis)' null);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeSatoshis' null);                  }                  else                  {                      // If the ledger isn't using bitcoin natively' we need to translate the miner fee paid to ledger cents before entering it into ledger                        Int64 feeCentsLedger = new Money (feeSatoshis' Currency.BitcoinCore).ToCurrency (organization.Currency).Cents;                      ledgerTransaction.AddRow(organization.FinancialAccounts.AssetsBitcoinHot' -(masterPayoutPrototype.AmountCents + feeCentsLedger)' null).AmountForeignCents = new Money(satoshisUsed' Currency.BitcoinCore);                      ledgerTransaction.AddRow (organization.FinancialAccounts.CostsBitcoinFees' feeCentsLedger' null);                  }                    ledgerTransaction.BlockchainHash = transactionHash;                    masterPayout.BindToTransactionAndClose (ledgerTransaction' null);              }
Magic Number,Swarmops.Logic.Financial,Payroll,C:\repos\Swarmops_Swarmops\Logic\Financial\Payroll.cs,ProcessMonthly,The following statement contains a magic number: DateTime payday = new DateTime (today.Year' today.Month' 25);
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salaries,C:\repos\Swarmops_Swarmops\Logic\Financial\Salaries.cs,CreateAnnualStatements,The following statement contains a magic number: foreach (Organization organization in organizations)              {                  // Get all salaries for this organization (filter year in logic - this function is allowed to be expensive' rather than                  // adding a custom database query for this particular operation)                    Salaries allSalaries = ForOrganization (organization' true);                    Salaries yearSalaries = new Salaries();                  yearSalaries.AddRange (allSalaries.Where (salary => salary.PayoutDate.Year == year));                    Dictionary<int' Dictionary<int' Salary>> personSalaryLookup = new Dictionary<int' Dictionary<int' Salary>>();                    // Go through the salaries and store them in the dictionary' so we can process the statement by person later                    foreach (Salary salary in yearSalaries)                  {                      int personId = salary.PayrollItem.PersonId;                        if (!personSalaryLookup.ContainsKey (personId))                      {                          personSalaryLookup[personId] = new Dictionary<int' Salary>();                      }                        personSalaryLookup[personId][salary.PayoutDate.Month] = salary;                  }                    // Once here' salaries are arranged by person and month. Iterate over people' create statements.                    foreach (int personId in personSalaryLookup.Keys)                  {                      Person person = Person.FromIdentity (personId);                      Int64 grossTotal = 0;                      Int64 subTaxTotal = 0;                      Int64 addTaxTotal = 0;                      Int64 netTotal = 0;                        string preFormattedStatement = string.Empty;                        for (int monthNumber = 1; monthNumber <= 12; monthNumber++)                      {                          string monthName = new DateTime (year' monthNumber' 1).ToString ("MMM"'                              new CultureInfo (person.PreferredCulture));                          monthName = monthName.Substring (0' 3); // believe it or not some .Net localizations don't respect the three letter limit                          string lineItem = "  " + monthName;                            if (personSalaryLookup[personId].ContainsKey (monthNumber) && personSalaryLookup[personId][monthNumber].GrossSalaryCents > 0)                          {                              Salary monthSalary = personSalaryLookup[personId][monthNumber];                                // TODO: replace "bitcoin" with actual payout method - this is just for show at the moment                                lineItem += String.Format ("  {0'10:N2}  {1'11:N2}  {2'10:N2}  bitcoin"'                                  monthSalary.GrossSalaryCents/100.0' -monthSalary.SubtractiveTaxCents/100.0'                                  monthSalary.NetSalaryCents/100.0);                                grossTotal += monthSalary.GrossSalaryCents;                              addTaxTotal += monthSalary.AdditiveTaxCents;                              subTaxTotal += monthSalary.SubtractiveTaxCents;                              netTotal += monthSalary.NetSalaryCents;                          }                            preFormattedStatement += lineItem + "\r\n";                      }                        NotificationStrings notificationStrings = new NotificationStrings();                      NotificationCustomStrings customStrings = new NotificationCustomStrings();                        notificationStrings[NotificationString.CurrencyCode] = organization.Currency.DisplayCode;                      notificationStrings[NotificationString.EmbeddedPreformattedText] = preFormattedStatement;                      customStrings["LastYear"] = year.ToString(CultureInfo.InvariantCulture);                      customStrings["GrossSalaryTotal"] = String.Format("{0'10:N2}"' grossTotal / 100.0);                      customStrings["TaxDeductedTotal"] = String.Format("{0'11:N2}"' -subTaxTotal / 100.0);                      customStrings["NetSalaryTotal"] = String.Format("{0'10:N2}"' netTotal / 100.0);                      customStrings["TaxAdditiveTotalUnpadded"] = String.Format("{0:N2}"' addTaxTotal / 100.0);                        // Send notification if gross is nonzero                        if (grossTotal > 0)                      {                          OutboundComm.CreateNotification (organization' NotificationResource.Salary_LastYearSummary'                              notificationStrings' customStrings' People.FromSingle (person));                      }                  }              }
Magic Number,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,Attest,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().CreateFinancialValidation (FinancialValidationType.Attestation'                  FinancialDependencyType.Salary' Identity' DateTime.Now' attester.Identity' CostTotalCents/100.0);
Magic Number,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,Deattest,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().CreateFinancialValidation (FinancialValidationType.Deattestation'                  FinancialDependencyType.Salary' Identity' DateTime.Now' deattester.Identity' CostTotalCents/100.0);
Magic Number,Swarmops.Logic.Financial,Salary,C:\repos\Swarmops_Swarmops\Logic\Financial\Salary.cs,DenyAttestation,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation(Budget' this.PayrollItem.Person' NetSalaryCents / 100.0' this.PayoutDate.ToString("MMMM yyyy")'                  NotificationResource.Salary_Denied' reason);
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,GetTax,The following statement contains a magic number: double taxLevel = SwarmDb.GetDatabaseForReading().GetSalaryTaxLevel (country.Identity' taxLevelIdentifier'                  (int) Math.Floor (grossCentsInCountryCurrency / 100.0));
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,GetTax,The following statement contains a magic number: return new Money((Int64) (taxLevel * 100.0)' country.Currency);
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,TaxLevels,C:\repos\Swarmops_Swarmops\Logic\Financial\TaxLevels.cs,ImportTaxLevels,The following statement contains a magic number: foreach (string line in lines)              {                  if (line.Length > 5)                  {                      // LAYOUT:                      // 30B36  79801  80000381673984037340373403984039840                      // 30%36  80001  84800   48   50   47   47   50   50                      // +---------+---------+---------+                      // 0123456789012345678901234567890                      // 0         1         2         3                        // First example line is a fixed tax amount' second is a percentage                      // We're only interested in "column one" in positions 19-23                        // This is for Sweden only' ffs!                        bool isPercentage = line[2] == '%' ? true : false;                        int lowerBracket = Int32.Parse (line.Substring (5' 7));                      double tax = Double.Parse (line.Substring (19' 5));                      int taxLevelId = Int32.Parse (line.Substring (3' 2));                        if (isPercentage)                      {                          tax = tax/100.0;                      }                        SwarmDb.GetDatabaseForWriting()                          .CreateSalaryTaxLevel (country.Identity' taxLevelId' lowerBracket' year' tax);                  }              }
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: if (transactionDescription.Length > 64)              {                  transactionDescription = transactionDescription.Substring (0' 61) + "...";              }
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: if (transactionDescription.Length > 64)              {                  transactionDescription = transactionDescription.Substring (0' 61) + "...";              }
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: OutboundComm.CreateNotificationAttestationNeeded (budget' claimer' string.Empty' newClaim.BudgetAmountCents/100.0'                  description' NotificationResource.ExpenseClaim_Created);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: OutboundComm.CreateNotificationFinancialValidationNeeded (organization' newClaim.AmountCents/100.0'                  NotificationResource.Receipts_Filed);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: SwarmopsLogEntry.Create (claimer'                  new ExpenseClaimFiledLogEntry (claimer /*filing person*/' claimer /*beneficiary*/' newClaim.BudgetAmountCents/100.0'                      vatCents / 100.0' budget' description)' newClaim);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Create,The following statement contains a magic number: SwarmopsLogEntry.Create (claimer'                  new ExpenseClaimFiledLogEntry (claimer /*filing person*/' claimer /*beneficiary*/' newClaim.BudgetAmountCents/100.0'                      vatCents / 100.0' budget' description)' newClaim);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Validate,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Claimer' AmountCents/100.0' Description'                  NotificationResource.ExpenseClaim_Validated);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Devalidate,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Claimer' AmountCents/100.0' Description'                  NotificationResource.ExpenseClaim_Devalidated);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Attest,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Claimer' AmountCents/100.0' Description'                  NotificationResource.ExpenseClaim_Attested);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,Deattest,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation (Budget' Claimer' AmountCents/100.0' Description'                  NotificationResource.ExpenseClaim_Deattested);
Magic Number,Swarmops.Logic.Financial,ExpenseClaim,C:\repos\Swarmops_Swarmops\Logic\Financial\ExpenseClaim.cs,DenyAttestation,The following statement contains a magic number: OutboundComm.CreateNotificationOfFinancialValidation(Budget' Claimer' AmountCents / 100.0' Description'                  NotificationResource.ExpenseClaim_Denied' reason);
Magic Number,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,CheckForexProfitLoss,The following statement contains a magic number: if (nativeCents - 100 > currentNativeValueOfForeignCents)              {                  // log a loss                    Int64 lossCents = nativeCents - currentNativeValueOfForeignCents;                  FinancialTransaction lossTx = FinancialTransaction.Create (Organization' DateTime.UtcNow' "Forex Loss");                  lossTx.AddRow (this' -lossCents' null);                  lossTx.AddRow (Organization.FinancialAccounts.CostsCurrencyFluctuations' lossCents' null);              }              else if (nativeCents + 100 < currentNativeValueOfForeignCents)              {                  // log a profit                    Int64 profitCents = currentNativeValueOfForeignCents - nativeCents;                  FinancialTransaction profitTx = FinancialTransaction.Create(Organization' DateTime.UtcNow' "Forex Gains");                  profitTx.AddRow(this' profitCents' null);                  profitTx.AddRow(Organization.FinancialAccounts.IncomeCurrencyFluctuations' -profitCents' null);              }
Magic Number,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,CheckForexProfitLoss,The following statement contains a magic number: if (nativeCents - 100 > currentNativeValueOfForeignCents)              {                  // log a loss                    Int64 lossCents = nativeCents - currentNativeValueOfForeignCents;                  FinancialTransaction lossTx = FinancialTransaction.Create (Organization' DateTime.UtcNow' "Forex Loss");                  lossTx.AddRow (this' -lossCents' null);                  lossTx.AddRow (Organization.FinancialAccounts.CostsCurrencyFluctuations' lossCents' null);              }              else if (nativeCents + 100 < currentNativeValueOfForeignCents)              {                  // log a profit                    Int64 profitCents = currentNativeValueOfForeignCents - nativeCents;                  FinancialTransaction profitTx = FinancialTransaction.Create(Organization' DateTime.UtcNow' "Forex Gains");                  profitTx.AddRow(this' profitCents' null);                  profitTx.AddRow(Organization.FinancialAccounts.IncomeCurrencyFluctuations' -profitCents' null);              }
Magic Number,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,GetBudgetCents,The following statement contains a magic number: return (Int64) (SwarmDb.GetDatabaseForReading().GetFinancialAccountBudget (Identity' year)*100);
Magic Number,Swarmops.Logic.Financial,FinancialAccount,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialAccount.cs,SetBudgetCents,The following statement contains a magic number: SwarmDb.GetDatabaseForWriting().SetFinancialAccountBudget (Identity' year' amount/100.0);
Magic Number,Swarmops.Logic.Financial,FinancialTransaction,C:\repos\Swarmops_Swarmops\Logic\Financial\FinancialTransaction.cs,AddRow,The following statement contains a magic number: AddRow (account' (Int64) (amount*100)' person);
Magic Number,Swarmops.Logic.Cache,GuidCache,C:\repos\Swarmops_Swarmops\Logic\Cache\GuidCache.cs,ConditionalGarbageCollect,The following statement contains a magic number: DateTime expired = DateTime.UtcNow.AddHours (-24);
Magic Number,Swarmops.Logic.Communications.Payload,ParticipantMailPayload,C:\repos\Swarmops_Swarmops\Logic\Communications\Payload\ParticipantMailPayload.cs,RenderComm,The following statement contains a magic number: if (body.Contains ("[RandomPassword]"))              {                  string randomPassword = Authentication.CreateWeakSecret (24);                  person.SetPassword (randomPassword);                  body = body.Replace ("[RandomPassword]"' randomPassword);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: StringBuilder rs = new StringBuilder (length*2);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: for (int offset = 0' c1' c2; offset < length;)              {                  c1 = d[offset++] & 0xff;                  rs.Append (base64_code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append (base64_code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append (base64_code[c1 & 0x3f]);                  rs.Append (base64_code[c2 & 0x3f]);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: for (int offset = 0' c1' c2; offset < length;)              {                  c1 = d[offset++] & 0xff;                  rs.Append (base64_code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append (base64_code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append (base64_code[c1 & 0x3f]);                  rs.Append (base64_code[c2 & 0x3f]);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: for (int offset = 0' c1' c2; offset < length;)              {                  c1 = d[offset++] & 0xff;                  rs.Append (base64_code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append (base64_code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append (base64_code[c1 & 0x3f]);                  rs.Append (base64_code[c2 & 0x3f]);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: for (int offset = 0' c1' c2; offset < length;)              {                  c1 = d[offset++] & 0xff;                  rs.Append (base64_code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append (base64_code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append (base64_code[c1 & 0x3f]);                  rs.Append (base64_code[c2 & 0x3f]);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EncodeBase64,The following statement contains a magic number: for (int offset = 0' c1' c2; offset < length;)              {                  c1 = d[offset++] & 0xff;                  rs.Append (base64_code[(c1 >> 2) & 0x3f]);                  c1 = (c1 & 0x03) << 4;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 4) & 0x0f;                  rs.Append (base64_code[c1 & 0x3f]);                  c1 = (c2 & 0x0f) << 2;                  if (offset >= length)                  {                      rs.Append (base64_code[c1 & 0x3f]);                      break;                  }                  c2 = d[offset++] & 0xff;                  c1 |= (c2 >> 6) & 0x03;                  rs.Append (base64_code[c1 & 0x3f]);                  rs.Append (base64_code[c2 & 0x3f]);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,DecodeBase64,The following statement contains a magic number: for (int offset = 0' slen = s.Length' length = 0; offset < slen - 1 && length < maximumLength;)              {                  int c1 = Char64 (s[offset++]);                  int c2 = Char64 (s[offset++]);                  if (c1 == -1 || c2 == -1)                  {                      break;                  }                    bytes.Add ((byte) ((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c3 = Char64 (s[offset++]);                  if (c3 == -1)                  {                      break;                  }                    bytes.Add ((byte) (((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c4 = Char64 (s[offset++]);                  bytes.Add ((byte) (((c3 & 0x03) << 6) | c4));                    ++length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,DecodeBase64,The following statement contains a magic number: for (int offset = 0' slen = s.Length' length = 0; offset < slen - 1 && length < maximumLength;)              {                  int c1 = Char64 (s[offset++]);                  int c2 = Char64 (s[offset++]);                  if (c1 == -1 || c2 == -1)                  {                      break;                  }                    bytes.Add ((byte) ((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c3 = Char64 (s[offset++]);                  if (c3 == -1)                  {                      break;                  }                    bytes.Add ((byte) (((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c4 = Char64 (s[offset++]);                  bytes.Add ((byte) (((c3 & 0x03) << 6) | c4));                    ++length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,DecodeBase64,The following statement contains a magic number: for (int offset = 0' slen = s.Length' length = 0; offset < slen - 1 && length < maximumLength;)              {                  int c1 = Char64 (s[offset++]);                  int c2 = Char64 (s[offset++]);                  if (c1 == -1 || c2 == -1)                  {                      break;                  }                    bytes.Add ((byte) ((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c3 = Char64 (s[offset++]);                  if (c3 == -1)                  {                      break;                  }                    bytes.Add ((byte) (((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c4 = Char64 (s[offset++]);                  bytes.Add ((byte) (((c3 & 0x03) << 6) | c4));                    ++length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,DecodeBase64,The following statement contains a magic number: for (int offset = 0' slen = s.Length' length = 0; offset < slen - 1 && length < maximumLength;)              {                  int c1 = Char64 (s[offset++]);                  int c2 = Char64 (s[offset++]);                  if (c1 == -1 || c2 == -1)                  {                      break;                  }                    bytes.Add ((byte) ((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c3 = Char64 (s[offset++]);                  if (c3 == -1)                  {                      break;                  }                    bytes.Add ((byte) (((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c4 = Char64 (s[offset++]);                  bytes.Add ((byte) (((c3 & 0x03) << 6) | c4));                    ++length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,DecodeBase64,The following statement contains a magic number: for (int offset = 0' slen = s.Length' length = 0; offset < slen - 1 && length < maximumLength;)              {                  int c1 = Char64 (s[offset++]);                  int c2 = Char64 (s[offset++]);                  if (c1 == -1 || c2 == -1)                  {                      break;                  }                    bytes.Add ((byte) ((c1 << 2) | ((c2 & 0x30) >> 4)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c3 = Char64 (s[offset++]);                  if (c3 == -1)                  {                      break;                  }                    bytes.Add ((byte) (((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)));                  if (++length >= maximumLength || offset >= s.Length)                  {                      break;                  }                    int c4 = Char64 (s[offset++]);                  bytes.Add ((byte) (((c3 & 0x03) << 6) | c4));                    ++length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Encipher,The following statement contains a magic number: unchecked                  // Added as per http://bcrypt.codeplex.com/SourceControl/network/forks/mammo/UncheckedFix/changeset/96b7f8314be4 to fix overflow exception.              {                  for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;)                  {                      // Feistel substitution on left word                      n = this.s[(l >> 24) & 0xff];                      n += this.s[0x100 | ((l >> 16) & 0xff)];                      n ^= this.s[0x200 | ((l >> 8) & 0xff)];                      n += this.s[0x300 | (l & 0xff)];                      r ^= n ^ this.p[++i];                        // Feistel substitution on right word                      n = this.s[(r >> 24) & 0xff];                      n += this.s[0x100 | ((r >> 16) & 0xff)];                      n ^= this.s[0x200 | ((r >> 8) & 0xff)];                      n += this.s[0x300 | (r & 0xff)];                      l ^= n ^ this.p[++i];                  }                  block[offset] = r ^ this.p[BLOWFISH_NUM_ROUNDS + 1];                  block[offset + 1] = l;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  word = (word << 8) | data[offset];                  offset = (offset + 1)%data.Length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,StreamToWord,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  word = (word << 8) | data[offset];                  offset = (offset + 1)%data.Length;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Key,The following statement contains a magic number: for (int i = 0; i < plen; i += 2)              {                  Encipher (lr' 0);                  this.p[i] = lr[0];                  this.p[i + 1] = lr[1];              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,Key,The following statement contains a magic number: for (int i = 0; i < slen; i += 2)              {                  Encipher (lr' 0);                  this.s[i] = lr[0];                  this.s[i + 1] = lr[1];              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EksKey,The following statement contains a magic number: for (int i = 0; i < plen; i += 2)              {                  lr[0] ^= StreamToWord (data' ref dataOffset);                  lr[1] ^= StreamToWord (data' ref dataOffset);                  Encipher (lr' 0);                  this.p[i] = lr[0];                  this.p[i + 1] = lr[1];              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,EksKey,The following statement contains a magic number: for (int i = 0; i < slen; i += 2)              {                  lr[0] ^= StreamToWord (data' ref dataOffset);                  lr[1] ^= StreamToWord (data' ref dataOffset);                  Encipher (lr' 0);                  this.s[i] = lr[0];                  this.s[i + 1] = lr[1];              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)              {                  throw new ArgumentOutOfRangeException ("logRounds"' logRounds' null);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: if (logRounds < 4 || logRounds > 31)              {                  throw new ArgumentOutOfRangeException ("logRounds"' logRounds' null);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  for (int j = 0; j < (clen >> 1); j++)                  {                      Encipher (cdata' j << 1);                  }              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: ret = new byte[clen*4];
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte) (cdata[i] & 0xff);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte) (cdata[i] & 0xff);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,CryptRaw,The following statement contains a magic number: for (int i = 0' j = 0; i < clen; i++)              {                  ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);                  ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);                  ret[j++] = (byte) (cdata[i] & 0xff);              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[1] != '$')              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                  {                      throw new ArgumentException ("Invalid salt revision");                  }                  offset = 4;              }              else              {                  offset = 3;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[1] != '$')              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                  {                      throw new ArgumentException ("Invalid salt revision");                  }                  offset = 4;              }              else              {                  offset = 3;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[1] != '$')              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                  {                      throw new ArgumentException ("Invalid salt revision");                  }                  offset = 4;              }              else              {                  offset = 3;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[1] != '$')              {                  minor = salt[2];                  if (minor != 'a' || salt[3] != '$')                  {                      throw new ArgumentException ("Invalid salt revision");                  }                  offset = 4;              }              else              {                  offset = 3;              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (salt[offset + 2] > '$')              {                  throw new ArgumentException ("Missing salt rounds");              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: int rounds = Int32.Parse (salt.Substring (offset' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: byte[] saltBytes = DecodeBase64 (salt.Substring (offset + 3' 22)'                  BCRYPT_SALT_LEN);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: byte[] saltBytes = DecodeBase64 (salt.Substring (offset + 3' 22)'                  BCRYPT_SALT_LEN);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: if (rounds < 10)              {                  rs.Append ('0');              }
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,HashPassword,The following statement contains a magic number: rs.Append (EncodeBase64 (hashed'                  (bf_crypt_ciphertext.Length*4) - 1));
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,GenerateSalt,The following statement contains a magic number: StringBuilder rs = new StringBuilder ((randomBytes.Length*2) + 8);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,GenerateSalt,The following statement contains a magic number: StringBuilder rs = new StringBuilder ((randomBytes.Length*2) + 8);
Magic Number,Swarmops.Logic.Security,BCrypt,C:\repos\Swarmops_Swarmops\Logic\Security\BCrypt.cs,GenerateSalt,The following statement contains a magic number: if (logRounds < 10)              {                  rs.Append ('0');              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,GenerateNewPasswordHash,The following statement contains a magic number: string salt = BCrypt.GenerateSalt (12);
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,GetPeopleByLoginToken,The following statement contains a magic number: if (cleanedNumber.Length == 10)              {                  int[] personIds = database.GetObjectsByOptionalData (ObjectType.Person'                      ObjectOptionalDataType.PersonalNumber'                      cleanedNumber);                    foreach (int personId in personIds)                  {                      result.Add (Person.FromIdentity (personId));                  }              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,ValidateEmailVerificationTicket,The following statement contains a magic number: if (storedParts.Length < 2)              {                  throw new VerificationTicketWrongException ("No such code exists.");              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,ValidateEmailVerificationTicket,The following statement contains a magic number: if (DateTime.Now.Subtract (createdTime).TotalHours > 10)              {                  throw new VerificationTicketTooOldException (                      "Verification code too old' it must be used within 10 hours.");              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,RequestActivistSignoffProcess,The following statement contains a magic number: if (candidatePeople.Count == 1 && candidatePeople[0].IsActivist)              {                  personIsActivist = true;                  Person p = candidatePeople[0];                  if (App_LocalResources.Authentication.Culture == CultureInfo.InvariantCulture)                  {                      App_LocalResources.Authentication.Culture = CultureInfo.GetCultureInfo (p.PreferredCulture);                  }                      string encodedPasswordTicket =                      SHA1.Hash (p.Identity.ToString (CultureInfo.InvariantCulture)).Replace (" "' "").Substring (0' 4) +                      p.Identity;                    mailbody = App_LocalResources.Authentication.RequestActivistSignoff_Mail_Preamble;                  mailbody += App_LocalResources.Authentication.RequestActivistSignoff_Mail_ClickOneLink;                      mailbody += "\r\n" + String.Format (URL' encodedPasswordTicket);              }              else              {                  string links = "";                  foreach (Person p in candidatePeople)                  {                      Participations msList = p.GetParticipations();                      if (msList.Count == 0 && p.IsActivist)                      {                          personIsActivist = true;                          if (App_LocalResources.Authentication.Culture == CultureInfo.InvariantCulture)                          {                              App_LocalResources.Authentication.Culture = CultureInfo.GetCultureInfo (p.PreferredCulture);                          }                              string encodedPasswordTicket =                              GenerateNewPasswordHash (p' p.Identity.ToString()).Replace (" "' "").Substring (0' 4) +                              p.Identity;                          links += "\r\n\r\n";                          links += "#" + p.PersonId;                            links += "\r\n" + String.Format (URL' encodedPasswordTicket);                      }                  }                    mailbody = App_LocalResources.Authentication.RequestActivistSignoff_Mail_Preamble;                  mailbody += App_LocalResources.Authentication.RequestActivistSignoff_Mail_ClickOneOfLinks;                  mailbody += links;              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,RequestActivistSignoffProcess,The following statement contains a magic number: if (candidatePeople.Count == 1 && candidatePeople[0].IsActivist)              {                  personIsActivist = true;                  Person p = candidatePeople[0];                  if (App_LocalResources.Authentication.Culture == CultureInfo.InvariantCulture)                  {                      App_LocalResources.Authentication.Culture = CultureInfo.GetCultureInfo (p.PreferredCulture);                  }                      string encodedPasswordTicket =                      SHA1.Hash (p.Identity.ToString (CultureInfo.InvariantCulture)).Replace (" "' "").Substring (0' 4) +                      p.Identity;                    mailbody = App_LocalResources.Authentication.RequestActivistSignoff_Mail_Preamble;                  mailbody += App_LocalResources.Authentication.RequestActivistSignoff_Mail_ClickOneLink;                      mailbody += "\r\n" + String.Format (URL' encodedPasswordTicket);              }              else              {                  string links = "";                  foreach (Person p in candidatePeople)                  {                      Participations msList = p.GetParticipations();                      if (msList.Count == 0 && p.IsActivist)                      {                          personIsActivist = true;                          if (App_LocalResources.Authentication.Culture == CultureInfo.InvariantCulture)                          {                              App_LocalResources.Authentication.Culture = CultureInfo.GetCultureInfo (p.PreferredCulture);                          }                              string encodedPasswordTicket =                              GenerateNewPasswordHash (p' p.Identity.ToString()).Replace (" "' "").Substring (0' 4) +                              p.Identity;                          links += "\r\n\r\n";                          links += "#" + p.PersonId;                            links += "\r\n" + String.Format (URL' encodedPasswordTicket);                      }                  }                    mailbody = App_LocalResources.Authentication.RequestActivistSignoff_Mail_Preamble;                  mailbody += App_LocalResources.Authentication.RequestActivistSignoff_Mail_ClickOneOfLinks;                  mailbody += links;              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,ValidateRequestActivistSignoffProcess,The following statement contains a magic number: string encodedPasswordTicket =                  SHA1.Hash (p.Identity.ToString (CultureInfo.InvariantCulture)).Replace (" "' "").Substring (0' 4) +                  p.Identity;
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,InitializeSymmetricDatabaseKey,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.KeySize = 256;                  aes.GenerateKey();                  byte[] key = aes.Key;                    string keyString = Convert.ToBase64String (key);                  Persistence.Key["SymmetricEncryptionKey"] = keyString;                    return key;              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,InitializeSymmetricFileSystemKey,The following statement contains a magic number: if (Debugger.IsAttached && Path.DirectorySeparatorChar == '\\') // check if we're debugging - double check to overdo security              {                  return new byte[32]; // can't write to /etc/swarmops in the debugger; return an all-zero key while debugging              }
Magic Number,Swarmops.Logic.Security,Authentication,C:\repos\Swarmops_Swarmops\Logic\Security\Authentication.cs,InitializeSymmetricFileSystemKey,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.KeySize = 256;                  aes.GenerateKey();                  byte[] key = aes.Key;                    string keyString = Convert.ToBase64String(key);                  File.WriteAllText("/etc/swarmops/symmetricKey.config"' keyString' Encoding.ASCII);                    return key;              }
Magic Number,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,EncryptString,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.Key = keyBytes;                  aes.GenerateIV(); // unique for every encryption                    if (aes.IV.Length != 16)                  {                      throw new InvalidDataException("IV is not 16 bytes long");                  }                    using (ICryptoTransform crypto = aes.CreateEncryptor())                  {                      byte[] cryptoBytes = crypto.TransformFinalBlock(dataBytes' 0' dataBytes.Length);                      return Convert.ToBase64String(aes.IV.Concat(cryptoBytes).ToArray()); // joins two byte[] arrays                  }              }
Magic Number,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,DecryptString,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.Key = keyBytes;                  aes.IV = new ArraySegment<byte>(cryptoBytes' 0' 16).ToArray();                  cryptoBytes = new ArraySegment<byte>(cryptoBytes' 16' cryptoBytes.Length - 16).ToArray();                    using (ICryptoTransform crypto = aes.CreateDecryptor())                  {                      byte[] clearBytes = crypto.TransformFinalBlock(cryptoBytes' 0' cryptoBytes.Length);                      return Encoding.UTF8.GetString(clearBytes);                  }              }
Magic Number,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,DecryptString,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.Key = keyBytes;                  aes.IV = new ArraySegment<byte>(cryptoBytes' 0' 16).ToArray();                  cryptoBytes = new ArraySegment<byte>(cryptoBytes' 16' cryptoBytes.Length - 16).ToArray();                    using (ICryptoTransform crypto = aes.CreateDecryptor())                  {                      byte[] clearBytes = crypto.TransformFinalBlock(cryptoBytes' 0' cryptoBytes.Length);                      return Encoding.UTF8.GetString(clearBytes);                  }              }
Magic Number,Swarmops.Logic.Security,Authority,C:\repos\Swarmops_Swarmops\Logic\Security\Authority.cs,DecryptString,The following statement contains a magic number: using (AesCryptoServiceProvider aes = new AesCryptoServiceProvider())              {                  aes.Key = keyBytes;                  aes.IV = new ArraySegment<byte>(cryptoBytes' 0' 16).ToArray();                  cryptoBytes = new ArraySegment<byte>(cryptoBytes' 16' cryptoBytes.Length - 16).ToArray();                    using (ICryptoTransform crypto = aes.CreateDecryptor())                  {                      byte[] clearBytes = crypto.TransformFinalBlock(cryptoBytes' 0' cryptoBytes.Length);                      return Encoding.UTF8.GetString(clearBytes);                  }              }
Magic Number,Swarmops.Logic.Security,SHA1,C:\repos\Swarmops_Swarmops\Logic\Security\SHA1.cs,Hash,The following statement contains a magic number: byte[] data = Encoding.GetEncoding (1252).GetBytes (input);
Magic Number,Swarmops.Logic.Support,BlockchainTransaction,C:\repos\Swarmops_Swarmops\Logic\Support\BlockchainTransaction.cs,FromBlockchainInfoJson,The following statement contains a magic number: System.DateTime transactionDateTimeUtc = new DateTime(1970' 1' 1' 0' 0' 0' 0' System.DateTimeKind.Utc);
Magic Number,Swarmops.Logic.Support,BlockchainTransaction,C:\repos\Swarmops_Swarmops\Logic\Support\BlockchainTransaction.cs,FromInsightInfoJson,The following statement contains a magic number: System.DateTime transactionDateTimeUtc = new DateTime(1970' 1' 1' 0' 0' 0' 0' System.DateTimeKind.Utc);
Magic Number,Swarmops.Logic.Support,SupportFunctions,C:\repos\Swarmops_Swarmops\Logic\Support\General.cs,GenerateSecureRandomKey,The following statement contains a magic number: StringBuilder result = new StringBuilder(byteCount * 2);
Magic Number,Swarmops.Logic.Support,Imagery,C:\repos\Swarmops_Swarmops\Logic\Support\Imagery.cs,Resize,The following statement contains a magic number: if (nPercentH > nPercentW) // modified: crop' don't pad              {                  nPercent = nPercentH;                  destX = Convert.ToInt16 ((width -                                            (sourceWidth*nPercent))/2);              }              else              {                  nPercent = nPercentW;                  destY = Convert.ToInt16 ((height -                                            (sourceHeight*nPercent))/2);              }
Magic Number,Swarmops.Logic.Support,Imagery,C:\repos\Swarmops_Swarmops\Logic\Support\Imagery.cs,Resize,The following statement contains a magic number: if (nPercentH > nPercentW) // modified: crop' don't pad              {                  nPercent = nPercentH;                  destX = Convert.ToInt16 ((width -                                            (sourceWidth*nPercent))/2);              }              else              {                  nPercent = nPercentW;                  destY = Convert.ToInt16 ((height -                                            (sourceHeight*nPercent))/2);              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,RerasterizeAll,The following statement contains a magic number: foreach (Document document in documents)              {                  if (document.Description.Length < 32)                  {                      continue; // no GUID                  }                    // a ServerFileName looks like "2015/06/22/29c88f2b-44e6-4a05-a6b0-f9aaec835c5b-00000001-0007-01-0019.png"                  //                              1234567890123456789012345678901234567890123456789012345678901234                    if (document.ServerFileName.Length < 64)                  {                      continue;                  }                  if (!document.ServerFileName.ToLowerInvariant().EndsWith(".png"))                  {                      continue;                  }                  if (document.ForeignId == 0)                  {                      // orphan document                      continue;                  }                    firstPart = document.ServerFileName.Substring(0' 64);                    if (firstPart != lastFirstPart)                  {                      if (startId != 0)                      {                          // wrap up the previous one                          if (lastId != startId)                          {                              Console.WriteLine("{0}' done."' lastId);                          }                          else                          {                              Console.WriteLine("' done.");                          }                      }                        // Start processing a new document                      wroteDots = false; // this is just cosmetics                        startId = lastId = document.Identity;                        Console.Write(@"Regenerating document #{0}"' startId);                        Process process = Process.Start("bash"'                              "-c \"convert -density 600 -background white -alpha remove " + StorageRoot + firstPart + " " +                              StorageRoot + firstPart +                              "-%04d.png\""); // Density 600 means 600dpi means production-grade conversion                        process.WaitForExit();                        lastFirstPart = firstPart;                  }                  else                  {                      // if firstPart and lastFirstPart still match                      // we've already regenerated this document                        if (!wroteDots) // cosmetics                      {                          Console.Write("..");                          wroteDots = true;                      }                      lastId = document.Identity;                  }              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,RerasterizeAll,The following statement contains a magic number: foreach (Document document in documents)              {                  if (document.Description.Length < 32)                  {                      continue; // no GUID                  }                    // a ServerFileName looks like "2015/06/22/29c88f2b-44e6-4a05-a6b0-f9aaec835c5b-00000001-0007-01-0019.png"                  //                              1234567890123456789012345678901234567890123456789012345678901234                    if (document.ServerFileName.Length < 64)                  {                      continue;                  }                  if (!document.ServerFileName.ToLowerInvariant().EndsWith(".png"))                  {                      continue;                  }                  if (document.ForeignId == 0)                  {                      // orphan document                      continue;                  }                    firstPart = document.ServerFileName.Substring(0' 64);                    if (firstPart != lastFirstPart)                  {                      if (startId != 0)                      {                          // wrap up the previous one                          if (lastId != startId)                          {                              Console.WriteLine("{0}' done."' lastId);                          }                          else                          {                              Console.WriteLine("' done.");                          }                      }                        // Start processing a new document                      wroteDots = false; // this is just cosmetics                        startId = lastId = document.Identity;                        Console.Write(@"Regenerating document #{0}"' startId);                        Process process = Process.Start("bash"'                              "-c \"convert -density 600 -background white -alpha remove " + StorageRoot + firstPart + " " +                              StorageRoot + firstPart +                              "-%04d.png\""); // Density 600 means 600dpi means production-grade conversion                        process.WaitForExit();                        lastFirstPart = firstPart;                  }                  else                  {                      // if firstPart and lastFirstPart still match                      // we've already regenerated this document                        if (!wroteDots) // cosmetics                      {                          Console.Write("..");                          wroteDots = true;                      }                      lastId = document.Identity;                  }              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,RerasterizeAll,The following statement contains a magic number: foreach (Document document in documents)              {                  if (document.Description.Length < 32)                  {                      continue; // no GUID                  }                    // a ServerFileName looks like "2015/06/22/29c88f2b-44e6-4a05-a6b0-f9aaec835c5b-00000001-0007-01-0019.png"                  //                              1234567890123456789012345678901234567890123456789012345678901234                    if (document.ServerFileName.Length < 64)                  {                      continue;                  }                  if (!document.ServerFileName.ToLowerInvariant().EndsWith(".png"))                  {                      continue;                  }                  if (document.ForeignId == 0)                  {                      // orphan document                      continue;                  }                    firstPart = document.ServerFileName.Substring(0' 64);                    if (firstPart != lastFirstPart)                  {                      if (startId != 0)                      {                          // wrap up the previous one                          if (lastId != startId)                          {                              Console.WriteLine("{0}' done."' lastId);                          }                          else                          {                              Console.WriteLine("' done.");                          }                      }                        // Start processing a new document                      wroteDots = false; // this is just cosmetics                        startId = lastId = document.Identity;                        Console.Write(@"Regenerating document #{0}"' startId);                        Process process = Process.Start("bash"'                              "-c \"convert -density 600 -background white -alpha remove " + StorageRoot + firstPart + " " +                              StorageRoot + firstPart +                              "-%04d.png\""); // Density 600 means 600dpi means production-grade conversion                        process.WaitForExit();                        lastFirstPart = firstPart;                  }                  else                  {                      // if firstPart and lastFirstPart still match                      // we've already regenerated this document                        if (!wroteDots) // cosmetics                      {                          Console.Write("..");                          wroteDots = true;                      }                      lastId = document.Identity;                  }              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,Rerasterize,The following statement contains a magic number: if (document.Description.Length < 32)              {                  throw new InvalidOperationException("Document has no GUID");              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,Rerasterize,The following statement contains a magic number: if (document.ServerFileName.Length < 64)              {                  throw new InvalidOperationException("Server file name has wrong scheme");              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,Rerasterize,The following statement contains a magic number: int density = 75;
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,Rerasterize,The following statement contains a magic number: if (((int) options & (int) PdfProcessorOptions.HighQuality) > 0)              {                  density = 600;                  suffix = "-hires"; // hires conversion uses different filename              }
Magic Number,Swarmops.Logic.Support,PdfProcessor,C:\repos\Swarmops_Swarmops\Logic\Support\PdfProcessor.cs,Rerasterize,The following statement contains a magic number: string firstPart = document.ServerFileName.Substring(0' 64);
Magic Number,Swarmops.Logic.Support,PluralBase<TPlural;TSingular;TBasic>,C:\repos\Swarmops_Swarmops\Logic\Support\PluralBase.cs,FromArray,The following statement contains a magic number: TPlural result = new TPlural {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Support,PluralBase<TPlural;TSingular;TBasic>,C:\repos\Swarmops_Swarmops\Logic\Support\PluralBase.cs,FromArray,The following statement contains a magic number: TPlural result = new TPlural {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Support,PluralBase<TPlural;TSingular;TBasic>,C:\repos\Swarmops_Swarmops\Logic\Support\PluralBase.cs,FromArray,The following statement contains a magic number: TPlural result = new TPlural {Capacity = logicObjectArray.Length*11/10};
Magic Number,Swarmops.Logic.Support,PluralBase<TPlural;TSingular;TBasic>,C:\repos\Swarmops_Swarmops\Logic\Support\PluralBase.cs,FromArray,The following statement contains a magic number: TPlural result = new TPlural {Capacity = logicObjectArray.Length*11/10};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[1] = new[] {1' 2' 3' 4' 0' 6' 7' 8' 9' 5};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[2] = new[] {2' 3' 4' 0' 1' 7' 8' 9' 5' 6};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[3] = new[] {3' 4' 0' 1' 2' 8' 9' 5' 6' 7};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[4] = new[] {4' 0' 1' 2' 3' 9' 5' 6' 7' 8};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[5] = new[] {5' 9' 8' 7' 6' 0' 4' 3' 2' 1};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[6] = new[] {6' 5' 9' 8' 7' 1' 0' 4' 3' 2};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[7] = new[] {7' 6' 5' 9' 8' 2' 1' 0' 4' 3};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[8] = new[] {8' 7' 6' 5' 9' 3' 2' 1' 0' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.op[9] = new[] {9' 8' 7' 6' 5' 4' 3' 2' 1' 0};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[0] = new[] {0' 1' 2' 3' 4' 5' 6' 7' 8' 9};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: this.F[1] = new[] {1' 5' 7' 6' 2' 8' 3' 0' 9' 4};
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: for (int i = 2; i < 8; i++)              {                  // iterate for remaining permutations                  this.F[i] = new int[10];                  for (int j = 0; j < 10; j++)                      this.F[i][j] = this.F[i - 1][this.F[1][j]];              }
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: for (int i = 2; i < 8; i++)              {                  // iterate for remaining permutations                  this.F[i] = new int[10];                  for (int j = 0; j < 10; j++)                      this.F[i][j] = this.F[i - 1][this.F[1][j]];              }
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: for (int i = 2; i < 8; i++)              {                  // iterate for remaining permutations                  this.F[i] = new int[10];                  for (int j = 0; j < 10; j++)                      this.F[i][j] = this.F[i - 1][this.F[1][j]];              }
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,CheckDigit,The following statement contains a magic number: for (int i = 2; i < 8; i++)              {                  // iterate for remaining permutations                  this.F[i] = new int[10];                  for (int j = 0; j < 10; j++)                      this.F[i][j] = this.F[i - 1][this.F[1][j]];              }
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,_ConvertToLong,The following statement contains a magic number: for (int i = 0; i < input.Length; i++)              {                  result += input[input.Length - (i + 1)]*power;                  power *= 10;              }
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,_CalculateCheckDigit,The following statement contains a magic number: for (int i = 0; i < reversedInput.Length; i++)                  check = this.op[check][this.F[(i + 1)%8][reversedInput[i]]];
Magic Number,Swarmops.Logic.Support,CheckDigit,C:\repos\Swarmops_Swarmops\Logic\Support\CheckDigit.cs,_Check,The following statement contains a magic number: for (int i = 0; i < reversedInput.Length; i++)                  check = this.op[check][this.F[i%8][reversedInput[i]]];
Magic Number,Swarmops.Logic.Support,Documents,C:\repos\Swarmops_Swarmops\Logic\Support\Documents.cs,FromArray,The following statement contains a magic number: Documents result = new Documents {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Support,Documents,C:\repos\Swarmops_Swarmops\Logic\Support\Documents.cs,FromArray,The following statement contains a magic number: Documents result = new Documents {Capacity = (basicArray.Length*11/10)};
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GenerateRangeString,The following statement contains a magic number: for (int index = 1; index <= ids.Length; index++)              {                  if (index == ids.Length || ids[index] != ids[index - 1] + 1)                  {                      // We have a break in the continuity.                        if (indexOfLastDiscontinuity == index - 1)                      {                          // The last sequence was just a single number.                            result += "' #" + ids[index - 1].ToString("N0");                      }                      else if (indexOfLastDiscontinuity == index - 2)                      {                          // Two numbers in last sequence. Treat as discontinuous.                          result += "' #" + ids[indexOfLastDiscontinuity].ToString("N0") + "' #" + ids[index - 1].ToString("N0");                      }                      else                      {                          // Contiguity.                          result += "' #" + ids[indexOfLastDiscontinuity].ToString("N0") + "-" + ids[index - 1].ToString("N0");                      }                        indexOfLastDiscontinuity = index;                  }              }
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GenerateRangeString,The following statement contains a magic number: return result.Substring (2);
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: for (int i = 0; i < number.Length; i++)              {                  int temp = (number[i] - '0') * (((number.Length - i) % 2) == 1 ? 2 : 1);                  if (temp > 9) temp -= 9;                  sum += temp;              }
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: for (int i = 0; i < number.Length; i++)              {                  int temp = (number[i] - '0') * (((number.Length - i) % 2) == 1 ? 2 : 1);                  if (temp > 9) temp -= 9;                  sum += temp;              }
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: for (int i = 0; i < number.Length; i++)              {                  int temp = (number[i] - '0') * (((number.Length - i) % 2) == 1 ? 2 : 1);                  if (temp > 9) temp -= 9;                  sum += temp;              }
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: for (int i = 0; i < number.Length; i++)              {                  int temp = (number[i] - '0') * (((number.Length - i) % 2) == 1 ? 2 : 1);                  if (temp > 9) temp -= 9;                  sum += temp;              }
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: return ((10 - (sum % 10)) % 10).ToString(CultureInfo.InvariantCulture);
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: return ((10 - (sum % 10)) % 10).ToString(CultureInfo.InvariantCulture);
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,GetLuhnChecksum,The following statement contains a magic number: return ((10 - (sum % 10)) % 10).ToString(CultureInfo.InvariantCulture);
Magic Number,Swarmops.Logic.Support,Formatting,C:\repos\Swarmops_Swarmops\Logic\Support\Formatting.cs,CheckLuhnChecksum,The following statement contains a magic number: if (number.Length < 2)              {                  return false; // requires at least data and checksum              }
Magic Number,Swarmops.Logic.Support,LogicServices,C:\repos\Swarmops_Swarmops\Logic\Support\LogicServices.cs,ObjectsToIdentifiers,The following statement contains a magic number: result.Capacity = identifiables.Length*11/10;
Magic Number,Swarmops.Logic.Support,LogicServices,C:\repos\Swarmops_Swarmops\Logic\Support\LogicServices.cs,ObjectsToIdentifiers,The following statement contains a magic number: result.Capacity = identifiables.Length*11/10;
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,EncodeString,The following statement contains a magic number: foreach (byte b in bytes)              {                  if (b != 0)                      if ((b < 32) || (b > 126))                          builder.Append (String.Format ("={0}"' b.ToString ("X2")));                      else                      {                          switch (b)                          {                              case 13:                                  builder.Append ("=0D");                                  break;                              case 10:                                  builder.Append ("=0A");                                  break;                              case 61:                                  builder.Append ("=3D");                                  break;                              default:                                  builder.Append (Convert.ToChar (b));                                  break;                          }                      }              }
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,EncodeString,The following statement contains a magic number: foreach (byte b in bytes)              {                  if (b != 0)                      if ((b < 32) || (b > 126))                          builder.Append (String.Format ("={0}"' b.ToString ("X2")));                      else                      {                          switch (b)                          {                              case 13:                                  builder.Append ("=0D");                                  break;                              case 10:                                  builder.Append ("=0A");                                  break;                              case 61:                                  builder.Append ("=3D");                                  break;                              default:                                  builder.Append (Convert.ToChar (b));                                  break;                          }                      }              }
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,EncodeString,The following statement contains a magic number: foreach (byte b in bytes)              {                  if (b != 0)                      if ((b < 32) || (b > 126))                          builder.Append (String.Format ("={0}"' b.ToString ("X2")));                      else                      {                          switch (b)                          {                              case 13:                                  builder.Append ("=0D");                                  break;                              case 10:                                  builder.Append ("=0A");                                  break;                              case 61:                                  builder.Append ("=3D");                                  break;                              default:                                  builder.Append (Convert.ToChar (b));                                  break;                          }                      }              }
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,EncodeString,The following statement contains a magic number: foreach (byte b in bytes)              {                  if (b != 0)                      if ((b < 32) || (b > 126))                          builder.Append (String.Format ("={0}"' b.ToString ("X2")));                      else                      {                          switch (b)                          {                              case 13:                                  builder.Append ("=0D");                                  break;                              case 10:                                  builder.Append ("=0A");                                  break;                              case 61:                                  builder.Append ("=3D");                                  break;                              default:                                  builder.Append (Convert.ToChar (b));                                  break;                          }                      }              }
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,EncodeString,The following statement contains a magic number: foreach (byte b in bytes)              {                  if (b != 0)                      if ((b < 32) || (b > 126))                          builder.Append (String.Format ("={0}"' b.ToString ("X2")));                      else                      {                          switch (b)                          {                              case 13:                                  builder.Append ("=0D");                                  break;                              case 10:                                  builder.Append ("=0A");                                  break;                              case 61:                                  builder.Append ("=3D");                                  break;                              default:                                  builder.Append (Convert.ToChar (b));                                  break;                          }                      }              }
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,HexDecoderEvaluator,The following statement contains a magic number: CaptureCollection captures = m.Groups[3].Captures;
Magic Number,Swarmops.Logic.Support,QuotedPrintable,C:\repos\Swarmops_Swarmops\Logic\Support\QuotedPrintable.cs,HexDecoderEvaluator,The following statement contains a magic number: for (int i = 0; i < captures.Count; i++)              {                  bytes[i] = Convert.ToByte (captures[i].Value' 16);              }
Magic Number,Swarmops.Logic.Support.LogEntries,SalaryCreatedLogEntry,C:\repos\Swarmops_Swarmops\Logic\Support\LogEntries\SalaryCreatedLogEntry.cs,SalaryCreatedLogEntry,The following statement contains a magic number: Amount = salary.NetSalaryCents/100.0;
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,Election,C:\repos\Swarmops_Swarmops\Logic\Governance\Election.cs,FromIdentity,The following statement contains a magic number: switch (electionId)              {                  case 1:                      return                          FromBasic (new BasicElection (1' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2006' 9' 17)));                  case 2:                      return                          FromBasic (new BasicElection (2' "SE European Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2009' 6' 7)));                  case 3:                      return                          FromBasic (new BasicElection (3' "SE General Elections"' Country.FromCode ("SE").GeographyId'                              new DateTime (2010' 9' 19)));                    default:                      throw new NotImplementedException ("Elections are not in the db yet.");              }
Magic Number,Swarmops.Logic.Governance,MeetingElectionVote,C:\repos\Swarmops_Swarmops\Logic\Governance\MeetingElectionVote.cs,Create,The following statement contains a magic number: return                  FromIdentity (SwarmDb.GetDatabaseForWriting()                      .CreateInternalPollVote (poll.Identity' voteGeography.Identity'                          Authentication.                              CreateWeakSecret (12)));
Magic Number,Swarmops.Logic.Governance,MeetingElectionVoters,C:\repos\Swarmops_Swarmops\Logic\Governance\MeetingElectionVoters.cs,FromArray,The following statement contains a magic number: MeetingElectionVoters result = new MeetingElectionVoters {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Governance,MeetingElectionVoters,C:\repos\Swarmops_Swarmops\Logic\Governance\MeetingElectionVoters.cs,FromArray,The following statement contains a magic number: MeetingElectionVoters result = new MeetingElectionVoters {Capacity = basicArray.Length*11/10};
Magic Number,Swarmops.Logic.Media,MediaCategories,C:\repos\Swarmops_Swarmops\Logic\Media\MediaCategories.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Media,MediaCategories,C:\repos\Swarmops_Swarmops\Logic\Media\MediaCategories.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Media,MediaEntries,C:\repos\Swarmops_Swarmops\Logic\Media\MediaEntries.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Media,MediaEntries,C:\repos\Swarmops_Swarmops\Logic\Media\MediaEntries.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Media,Reporters,C:\repos\Swarmops_Swarmops\Logic\Media\Reporters.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Media,Reporters,C:\repos\Swarmops_Swarmops\Logic\Media\Reporters.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,GetUndeliverableCases,The following statement contains a magic number: return GetUndeliverableCases (0' 99999);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,GetCaseDeltas,The following statement contains a magic number: using (MySqlConnection connection = GetConnection())              {                  connection.Open();                    MySqlCommand command =                      new MySqlCommand (                          "SELECT ixBugEvent'ixBug'ixPerson'dt'sVerb'sChanges FROM BugEvent WHERE ixBugEvent > " +                          fromDeltaId + "  ORDER BY ixBugEvent"'                          connection);                  command.CommandTimeout = 600;                    using (MySqlDataReader reader = command.ExecuteReader())                  {                      while (reader.Read())                      {                          if (!reader.IsDBNull (1)) // Safeguard -- some ixBug are NULL due to data corruption                          {                              result.Add (ReadSupportCaseDeltaFromReader (reader));                          }                      }                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The following statement contains a magic number: email.Body = Encoding.UTF8.GetString (Encoding.GetEncoding (1252).GetBytes (reader.GetString (4)));
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The following statement contains a magic number: email.Body = Encoding.UTF8.GetString (Encoding.GetEncoding (1252).GetBytes (reader.GetString (4)));
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The following statement contains a magic number: email.From = reader.GetString (5);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The following statement contains a magic number: email.To = reader.GetString (3);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportEmailFromReader,The following statement contains a magic number: email.CaseTitle = reader.GetString (2);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadFullSupportCaseFromReader,The following statement contains a magic number: if (!reader.IsDBNull (2))              {                  email = reader.GetString (2);              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadFullSupportCaseFromReader,The following statement contains a magic number: if (!reader.IsDBNull (2))              {                  email = reader.GetString (2);              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportCaseDeltaFromReader,The following statement contains a magic number: int personId = reader.GetInt32 (2);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportCaseDeltaFromReader,The following statement contains a magic number: DateTime dateTime = reader.GetDateTime (3);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportCaseDeltaFromReader,The following statement contains a magic number: string verb = reader.GetString (4);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,ReadSupportCaseDeltaFromReader,The following statement contains a magic number: string changes = reader.GetString (5);
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,The following statement contains a magic number: while (lastCaseHandled == 0 || (cases != null && cases.Length > 0))              {                  cases = GetUndeliverableCases (lastCaseHandled' 100);                    if (cases.Length == 0) // very very important bugfix                  {                      break;                  }                    foreach (SupportCase @case in cases)                  {                      lastCaseHandled = @case.Identity;                      bool attemptRecovery = true;                        if (@case.Title.ToLower().Contains ("ditt medlemskap har"))                      {                          // "Ditt medlemskap har g�tt ut"                            attemptRecovery = false;                      }                        if (@case.Title.ToLower().Contains ("press"))                      {                          // Press release                            attemptRecovery = false;                      }                        if (attemptRecovery)                      {                          string body = GetFirstEventText (@case.Identity);                            // Strip the mail header                            int bodySeparator = body.IndexOf ("\r\n\r\n");                            if (bodySeparator > 0)                          {                              body = body.Substring (bodySeparator + 4);                          }                          else                          {                              body = string.Empty;                          }                            Match match = regex.Match (body);                          if (match.Success)                          {                              string email = match.Groups["email"].Value;                              People people = People.FromMail (email);                                if (people.Count > 2)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. More than one person matches the email address. Both marked unreachable.");                                    foreach (Person person in people)                                  {                                      person.MailUnreachable = true;                                  }                              }                                else if (people.Count < 1)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. No person in the database matches the email address.");                              }                                else                              {                                  // When we get here' there is exactly one person matching in the database                                    Person person = people[0];                                    bool hasActiveMemberships = false;                                    Participations participations = person.GetParticipations();                                    foreach (Participation membership in participations)                                  {                                      if (membership.Active)                                      {                                          hasActiveMemberships = true;                                      }                                  }                                    if (hasActiveMemberships)                                  {                                      // Attempt to contact by SMS.                                      if (!holdSMS)                                      {                                          if (person.Phone.Trim().Length > 2)                                          {                                              if (dontSendSMS)                                              {                                                  CloseWithComment (@case.Identity'                                                      "The person at phone# " + person.Phone + "' " + person.Name +                                                      " (#" + person.Identity +                                                      ")' was not contacted due to that SMS notification is currently turned off. Bounced message closed.");                                              }                                              else                                              {                                                  try                                                  {                                                      person.SendPhoneMessage (                                                          "Piratpartiet: den mailadress vi har till dig (" +                                                          person.Mail +                                                          ") studsar. Kontakta medlemsservice@piratpartiet.se med ny adress.");                                                      CloseWithComment (@case.Identity'                                                          "Successfully notified the member at phone# " + person.Phone +                                                          "' " + person.Name + " (#" + person.Identity +                                                          ")' about the bounced email using an SMS message. Case closed.");                                                  }                                                  catch (Exception)                                                  {                                                      CloseWithComment (@case.Identity'                                                          "The person at phone# " + person.Phone + "' " + person.Name +                                                          " (#" + person.Identity +                                                          ")' could not be reached over SMS. This member has been marked unreachable. Bounced message closed.");                                                      person.MailUnreachable = true;                                                  }                                              }                                          }                                          else                                          {                                              CloseWithComment (@case.Identity'                                                  person.Name + " (#" + person.Identity +                                                  ") does not have a listed phone number. This member has been marked unreachable. Bounced message closed.");                                              person.MailUnreachable = true;                                          }                                      }                                  }                                  else                                  {                                      CloseWithComment (@case.Identity'                                          "The person at phone# " + person.Phone + "' " + person.Name + " (#" +                                          person.Identity +                                          ") has no active memberships. Bounced message closed.");                                  }                              }                          }                          else                          {                              CloseWithComment (@case.Identity'                                  "Bounced message closed. No email address could be located.");                          }                      }                      else                      {                          CloseWithComment (@case.Identity' "Bounced message closed without attempt of recovery.");                      }                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,The following statement contains a magic number: while (lastCaseHandled == 0 || (cases != null && cases.Length > 0))              {                  cases = GetUndeliverableCases (lastCaseHandled' 100);                    if (cases.Length == 0) // very very important bugfix                  {                      break;                  }                    foreach (SupportCase @case in cases)                  {                      lastCaseHandled = @case.Identity;                      bool attemptRecovery = true;                        if (@case.Title.ToLower().Contains ("ditt medlemskap har"))                      {                          // "Ditt medlemskap har g�tt ut"                            attemptRecovery = false;                      }                        if (@case.Title.ToLower().Contains ("press"))                      {                          // Press release                            attemptRecovery = false;                      }                        if (attemptRecovery)                      {                          string body = GetFirstEventText (@case.Identity);                            // Strip the mail header                            int bodySeparator = body.IndexOf ("\r\n\r\n");                            if (bodySeparator > 0)                          {                              body = body.Substring (bodySeparator + 4);                          }                          else                          {                              body = string.Empty;                          }                            Match match = regex.Match (body);                          if (match.Success)                          {                              string email = match.Groups["email"].Value;                              People people = People.FromMail (email);                                if (people.Count > 2)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. More than one person matches the email address. Both marked unreachable.");                                    foreach (Person person in people)                                  {                                      person.MailUnreachable = true;                                  }                              }                                else if (people.Count < 1)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. No person in the database matches the email address.");                              }                                else                              {                                  // When we get here' there is exactly one person matching in the database                                    Person person = people[0];                                    bool hasActiveMemberships = false;                                    Participations participations = person.GetParticipations();                                    foreach (Participation membership in participations)                                  {                                      if (membership.Active)                                      {                                          hasActiveMemberships = true;                                      }                                  }                                    if (hasActiveMemberships)                                  {                                      // Attempt to contact by SMS.                                      if (!holdSMS)                                      {                                          if (person.Phone.Trim().Length > 2)                                          {                                              if (dontSendSMS)                                              {                                                  CloseWithComment (@case.Identity'                                                      "The person at phone# " + person.Phone + "' " + person.Name +                                                      " (#" + person.Identity +                                                      ")' was not contacted due to that SMS notification is currently turned off. Bounced message closed.");                                              }                                              else                                              {                                                  try                                                  {                                                      person.SendPhoneMessage (                                                          "Piratpartiet: den mailadress vi har till dig (" +                                                          person.Mail +                                                          ") studsar. Kontakta medlemsservice@piratpartiet.se med ny adress.");                                                      CloseWithComment (@case.Identity'                                                          "Successfully notified the member at phone# " + person.Phone +                                                          "' " + person.Name + " (#" + person.Identity +                                                          ")' about the bounced email using an SMS message. Case closed.");                                                  }                                                  catch (Exception)                                                  {                                                      CloseWithComment (@case.Identity'                                                          "The person at phone# " + person.Phone + "' " + person.Name +                                                          " (#" + person.Identity +                                                          ")' could not be reached over SMS. This member has been marked unreachable. Bounced message closed.");                                                      person.MailUnreachable = true;                                                  }                                              }                                          }                                          else                                          {                                              CloseWithComment (@case.Identity'                                                  person.Name + " (#" + person.Identity +                                                  ") does not have a listed phone number. This member has been marked unreachable. Bounced message closed.");                                              person.MailUnreachable = true;                                          }                                      }                                  }                                  else                                  {                                      CloseWithComment (@case.Identity'                                          "The person at phone# " + person.Phone + "' " + person.Name + " (#" +                                          person.Identity +                                          ") has no active memberships. Bounced message closed.");                                  }                              }                          }                          else                          {                              CloseWithComment (@case.Identity'                                  "Bounced message closed. No email address could be located.");                          }                      }                      else                      {                          CloseWithComment (@case.Identity' "Bounced message closed without attempt of recovery.");                      }                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,The following statement contains a magic number: while (lastCaseHandled == 0 || (cases != null && cases.Length > 0))              {                  cases = GetUndeliverableCases (lastCaseHandled' 100);                    if (cases.Length == 0) // very very important bugfix                  {                      break;                  }                    foreach (SupportCase @case in cases)                  {                      lastCaseHandled = @case.Identity;                      bool attemptRecovery = true;                        if (@case.Title.ToLower().Contains ("ditt medlemskap har"))                      {                          // "Ditt medlemskap har g�tt ut"                            attemptRecovery = false;                      }                        if (@case.Title.ToLower().Contains ("press"))                      {                          // Press release                            attemptRecovery = false;                      }                        if (attemptRecovery)                      {                          string body = GetFirstEventText (@case.Identity);                            // Strip the mail header                            int bodySeparator = body.IndexOf ("\r\n\r\n");                            if (bodySeparator > 0)                          {                              body = body.Substring (bodySeparator + 4);                          }                          else                          {                              body = string.Empty;                          }                            Match match = regex.Match (body);                          if (match.Success)                          {                              string email = match.Groups["email"].Value;                              People people = People.FromMail (email);                                if (people.Count > 2)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. More than one person matches the email address. Both marked unreachable.");                                    foreach (Person person in people)                                  {                                      person.MailUnreachable = true;                                  }                              }                                else if (people.Count < 1)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. No person in the database matches the email address.");                              }                                else                              {                                  // When we get here' there is exactly one person matching in the database                                    Person person = people[0];                                    bool hasActiveMemberships = false;                                    Participations participations = person.GetParticipations();                                    foreach (Participation membership in participations)                                  {                                      if (membership.Active)                                      {                                          hasActiveMemberships = true;                                      }                                  }                                    if (hasActiveMemberships)                                  {                                      // Attempt to contact by SMS.                                      if (!holdSMS)                                      {                                          if (person.Phone.Trim().Length > 2)                                          {                                              if (dontSendSMS)                                              {                                                  CloseWithComment (@case.Identity'                                                      "The person at phone# " + person.Phone + "' " + person.Name +                                                      " (#" + person.Identity +                                                      ")' was not contacted due to that SMS notification is currently turned off. Bounced message closed.");                                              }                                              else                                              {                                                  try                                                  {                                                      person.SendPhoneMessage (                                                          "Piratpartiet: den mailadress vi har till dig (" +                                                          person.Mail +                                                          ") studsar. Kontakta medlemsservice@piratpartiet.se med ny adress.");                                                      CloseWithComment (@case.Identity'                                                          "Successfully notified the member at phone# " + person.Phone +                                                          "' " + person.Name + " (#" + person.Identity +                                                          ")' about the bounced email using an SMS message. Case closed.");                                                  }                                                  catch (Exception)                                                  {                                                      CloseWithComment (@case.Identity'                                                          "The person at phone# " + person.Phone + "' " + person.Name +                                                          " (#" + person.Identity +                                                          ")' could not be reached over SMS. This member has been marked unreachable. Bounced message closed.");                                                      person.MailUnreachable = true;                                                  }                                              }                                          }                                          else                                          {                                              CloseWithComment (@case.Identity'                                                  person.Name + " (#" + person.Identity +                                                  ") does not have a listed phone number. This member has been marked unreachable. Bounced message closed.");                                              person.MailUnreachable = true;                                          }                                      }                                  }                                  else                                  {                                      CloseWithComment (@case.Identity'                                          "The person at phone# " + person.Phone + "' " + person.Name + " (#" +                                          person.Identity +                                          ") has no active memberships. Bounced message closed.");                                  }                              }                          }                          else                          {                              CloseWithComment (@case.Identity'                                  "Bounced message closed. No email address could be located.");                          }                      }                      else                      {                          CloseWithComment (@case.Identity' "Bounced message closed without attempt of recovery.");                      }                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SupportDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SupportDatabase.cs,NotifyBouncingEmails,The following statement contains a magic number: while (lastCaseHandled == 0 || (cases != null && cases.Length > 0))              {                  cases = GetUndeliverableCases (lastCaseHandled' 100);                    if (cases.Length == 0) // very very important bugfix                  {                      break;                  }                    foreach (SupportCase @case in cases)                  {                      lastCaseHandled = @case.Identity;                      bool attemptRecovery = true;                        if (@case.Title.ToLower().Contains ("ditt medlemskap har"))                      {                          // "Ditt medlemskap har g�tt ut"                            attemptRecovery = false;                      }                        if (@case.Title.ToLower().Contains ("press"))                      {                          // Press release                            attemptRecovery = false;                      }                        if (attemptRecovery)                      {                          string body = GetFirstEventText (@case.Identity);                            // Strip the mail header                            int bodySeparator = body.IndexOf ("\r\n\r\n");                            if (bodySeparator > 0)                          {                              body = body.Substring (bodySeparator + 4);                          }                          else                          {                              body = string.Empty;                          }                            Match match = regex.Match (body);                          if (match.Success)                          {                              string email = match.Groups["email"].Value;                              People people = People.FromMail (email);                                if (people.Count > 2)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. More than one person matches the email address. Both marked unreachable.");                                    foreach (Person person in people)                                  {                                      person.MailUnreachable = true;                                  }                              }                                else if (people.Count < 1)                              {                                  CloseWithComment (@case.Identity'                                      "Bounced message closed. No person in the database matches the email address.");                              }                                else                              {                                  // When we get here' there is exactly one person matching in the database                                    Person person = people[0];                                    bool hasActiveMemberships = false;                                    Participations participations = person.GetParticipations();                                    foreach (Participation membership in participations)                                  {                                      if (membership.Active)                                      {                                          hasActiveMemberships = true;                                      }                                  }                                    if (hasActiveMemberships)                                  {                                      // Attempt to contact by SMS.                                      if (!holdSMS)                                      {                                          if (person.Phone.Trim().Length > 2)                                          {                                              if (dontSendSMS)                                              {                                                  CloseWithComment (@case.Identity'                                                      "The person at phone# " + person.Phone + "' " + person.Name +                                                      " (#" + person.Identity +                                                      ")' was not contacted due to that SMS notification is currently turned off. Bounced message closed.");                                              }                                              else                                              {                                                  try                                                  {                                                      person.SendPhoneMessage (                                                          "Piratpartiet: den mailadress vi har till dig (" +                                                          person.Mail +                                                          ") studsar. Kontakta medlemsservice@piratpartiet.se med ny adress.");                                                      CloseWithComment (@case.Identity'                                                          "Successfully notified the member at phone# " + person.Phone +                                                          "' " + person.Name + " (#" + person.Identity +                                                          ")' about the bounced email using an SMS message. Case closed.");                                                  }                                                  catch (Exception)                                                  {                                                      CloseWithComment (@case.Identity'                                                          "The person at phone# " + person.Phone + "' " + person.Name +                                                          " (#" + person.Identity +                                                          ")' could not be reached over SMS. This member has been marked unreachable. Bounced message closed.");                                                      person.MailUnreachable = true;                                                  }                                              }                                          }                                          else                                          {                                              CloseWithComment (@case.Identity'                                                  person.Name + " (#" + person.Identity +                                                  ") does not have a listed phone number. This member has been marked unreachable. Bounced message closed.");                                              person.MailUnreachable = true;                                          }                                      }                                  }                                  else                                  {                                      CloseWithComment (@case.Identity'                                          "The person at phone# " + person.Phone + "' " + person.Name + " (#" +                                          person.Identity +                                          ") has no active memberships. Bounced message closed.");                                  }                              }                          }                          else                          {                              CloseWithComment (@case.Identity'                                  "Bounced message closed. No email address could be located.");                          }                      }                      else                      {                          CloseWithComment (@case.Identity' "Bounced message closed without attempt of recovery.");                      }                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,GetDatabase,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/')              {                  if (string.IsNullOrEmpty (Persistence.Key["SwedishForumDatabaseVBulletin_ConnectionString_Bot"]))                      return GetDatabase (1);                  return GetDatabase (2);              }
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,GetDatabase,The following statement contains a magic number: return GetDatabase (2);
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,IsPartyMember,The following statement contains a magic number: using (SqlConnection connection = new SqlConnection (this.connectString))              {                  connection.Open();                    SqlCommand command =                      new SqlCommand (                          String.Format ("Select PrimaryRoleID from InstantASP_Users where UserID=" + accountId)'                          connection);                    using (SqlDataReader reader = command.ExecuteReader())                  {                      if (reader.Read())                      {                          int roleId = reader.GetInt16 (0);                          if (roleId == 7)                          {                              return true;                          }                          return false;                      }                        throw new Exception ("Account Id does not exist");                  }              }
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The following statement contains a magic number: using (SqlConnection connection = new SqlConnection (this.connectString))              {                  connection.Open();                    // First' insert the post itself                    SqlCommand command = new SqlCommand ("if_sp_InsertPost"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.AddWithValue ("@intForumID"' forumId);                  command.Parameters.AddWithValue ("@intTopicID"' 0);                  command.Parameters.AddWithValue ("@intParentID"' 0);                  command.Parameters.AddWithValue ("@intUserID"' poster.SwedishForumAccountId);                  command.Parameters.AddWithValue ("@strMessageIcon"' string.Empty);                  command.Parameters.AddWithValue ("@strTitle"' title);                  command.Parameters.AddWithValue ("@strDescription"' description);                  command.Parameters.AddWithValue ("@bitForumModerated"' false);                  command.Parameters.AddWithValue ("@bitIsPoll"' false);                  command.Parameters.AddWithValue ("@strIPAddress"' "127.0.0.1");                    SqlParameter parameterText = new SqlParameter ("@strMessage"' SqlDbType.NText' post.Length*2 + 2048);                  parameterText.Value = post;                    command.Parameters.Add (parameterText);                    SqlParameter parameterResult = new SqlParameter ("@intIdentity"' SqlDbType.Int' 4);                  parameterResult.Direction = ParameterDirection.Output;                    command.Parameters.Add (parameterResult);                    command.ExecuteNonQuery();                    int postId = (int) parameterResult.Value;                    // Then' update the LastRead for this forum                    command = new SqlCommand ("if_sp_UpdateForumLastPostInformation"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.Add (new SqlParameter ("@intForumID"' forumId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterPostID"' postId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterUserID"' poster.SwedishForumAccountId));                  command.Parameters.Add (new SqlParameter ("@strLastPosterUsername"' poster.Name));                  command.Parameters.Add (new SqlParameter ("@strLastPosterSubject"' title));                  command.Parameters.Add (new SqlParameter ("@dtLastPosterDate"' DateTime.Now));                    command.ExecuteNonQuery();                    return postId;              }
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The following statement contains a magic number: using (SqlConnection connection = new SqlConnection (this.connectString))              {                  connection.Open();                    // First' insert the post itself                    SqlCommand command = new SqlCommand ("if_sp_InsertPost"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.AddWithValue ("@intForumID"' forumId);                  command.Parameters.AddWithValue ("@intTopicID"' 0);                  command.Parameters.AddWithValue ("@intParentID"' 0);                  command.Parameters.AddWithValue ("@intUserID"' poster.SwedishForumAccountId);                  command.Parameters.AddWithValue ("@strMessageIcon"' string.Empty);                  command.Parameters.AddWithValue ("@strTitle"' title);                  command.Parameters.AddWithValue ("@strDescription"' description);                  command.Parameters.AddWithValue ("@bitForumModerated"' false);                  command.Parameters.AddWithValue ("@bitIsPoll"' false);                  command.Parameters.AddWithValue ("@strIPAddress"' "127.0.0.1");                    SqlParameter parameterText = new SqlParameter ("@strMessage"' SqlDbType.NText' post.Length*2 + 2048);                  parameterText.Value = post;                    command.Parameters.Add (parameterText);                    SqlParameter parameterResult = new SqlParameter ("@intIdentity"' SqlDbType.Int' 4);                  parameterResult.Direction = ParameterDirection.Output;                    command.Parameters.Add (parameterResult);                    command.ExecuteNonQuery();                    int postId = (int) parameterResult.Value;                    // Then' update the LastRead for this forum                    command = new SqlCommand ("if_sp_UpdateForumLastPostInformation"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.Add (new SqlParameter ("@intForumID"' forumId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterPostID"' postId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterUserID"' poster.SwedishForumAccountId));                  command.Parameters.Add (new SqlParameter ("@strLastPosterUsername"' poster.Name));                  command.Parameters.Add (new SqlParameter ("@strLastPosterSubject"' title));                  command.Parameters.Add (new SqlParameter ("@dtLastPosterDate"' DateTime.Now));                    command.ExecuteNonQuery();                    return postId;              }
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseInstantForum,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CreateNewPost,The following statement contains a magic number: using (SqlConnection connection = new SqlConnection (this.connectString))              {                  connection.Open();                    // First' insert the post itself                    SqlCommand command = new SqlCommand ("if_sp_InsertPost"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.AddWithValue ("@intForumID"' forumId);                  command.Parameters.AddWithValue ("@intTopicID"' 0);                  command.Parameters.AddWithValue ("@intParentID"' 0);                  command.Parameters.AddWithValue ("@intUserID"' poster.SwedishForumAccountId);                  command.Parameters.AddWithValue ("@strMessageIcon"' string.Empty);                  command.Parameters.AddWithValue ("@strTitle"' title);                  command.Parameters.AddWithValue ("@strDescription"' description);                  command.Parameters.AddWithValue ("@bitForumModerated"' false);                  command.Parameters.AddWithValue ("@bitIsPoll"' false);                  command.Parameters.AddWithValue ("@strIPAddress"' "127.0.0.1");                    SqlParameter parameterText = new SqlParameter ("@strMessage"' SqlDbType.NText' post.Length*2 + 2048);                  parameterText.Value = post;                    command.Parameters.Add (parameterText);                    SqlParameter parameterResult = new SqlParameter ("@intIdentity"' SqlDbType.Int' 4);                  parameterResult.Direction = ParameterDirection.Output;                    command.Parameters.Add (parameterResult);                    command.ExecuteNonQuery();                    int postId = (int) parameterResult.Value;                    // Then' update the LastRead for this forum                    command = new SqlCommand ("if_sp_UpdateForumLastPostInformation"' connection);                  command.CommandType = CommandType.StoredProcedure;                    command.Parameters.Add (new SqlParameter ("@intForumID"' forumId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterPostID"' postId));                  command.Parameters.Add (new SqlParameter ("@intLastPosterUserID"' poster.SwedishForumAccountId));                  command.Parameters.Add (new SqlParameter ("@strLastPosterUsername"' poster.Name));                  command.Parameters.Add (new SqlParameter ("@strLastPosterSubject"' title));                  command.Parameters.Add (new SqlParameter ("@dtLastPosterDate"' DateTime.Now));                    command.ExecuteNonQuery();                    return postId;              }
Magic Number,Swarmops.Logic.Special.Sweden,ErrorIgnorerPolicy,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,CheckValidationResult,The following statement contains a magic number: if (error != -2146762486)                  return false;
Magic Number,Swarmops.Logic.Special.Sweden,SwedishForumDatabaseVBulletin,C:\repos\Swarmops_Swarmops\Logic\Special\Sweden\SwedishForumDatabase.cs,GetAccountId,The following statement contains a magic number: using (MySqlConnection connection = new MySqlConnection (this.connectString))              {                  connection.Open();                    MySqlCommand command =                      new MySqlCommand (                          String.Format ("Select userid from vb_user Where username='{0}'"'                              nick.Replace ("'"' "''"))' connection);                  command.CommandTimeout = 20;                  using (MySqlDataReader reader = command.ExecuteReader())                  {                      if (reader.Read())                      {                          return reader.GetInt32 (0);                      }                      throw new ArgumentException ("No such nick in database");                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,PrimeCountry,The following statement contains a magic number: StringBuilder sqlCityBuild =                  new StringBuilder("INSERT INTO Cities (CityName' GeographyId' CountryId' Comment) VALUES "' 65536);
Magic Number,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,PrimeCountry,The following statement contains a magic number: if (postalCodes.Length > 0)              {                  StringBuilder sqlBuild =                      new StringBuilder ("INSERT INTO PostalCodes (PostalCode' CityId' CountryId) VALUES "' 65536);                  insertComma = false;                    foreach (MasterPostalCode postalCode in postalCodes)                  {                      if (cityIdsUsedLookup[postalCode.CityId] == false)                      {                          // Remnants of invalid pointers                            continue;                      }                        int newCityId = cityIdTranslation[postalCode.CityId];                        if (insertComma)                      {                          sqlBuild.Append ("'");                      }                        sqlBuild.Append ("('" + postalCode.PostalCode.Replace ("'"' "\\'") + "''" + newCityId + "'" +                                       newCountryId + ")");                      insertComma = true;                  }                    sqlBuild.Append (";");                    // Insert all postal codes in one bulk op' to save roundtrips                  SwarmDb.GetDatabaseForAdmin().ExecuteAdminCommand(sqlBuild.ToString());              }
Magic Number,Swarmops.Logic.Structure,GeographyUpdate,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyUpdate.cs,InitDatabaseThreadCreateGeographyChildren,The following statement contains a magic number: if (total != 0)              {                  GuidCache.Set("DbInitProgress"' String.Format ("({0}%)"' count * 100 / total));                  // shouldn't be here but wtf              }
Magic Number,Swarmops.Logic.Structure,PostalCodes,C:\repos\Swarmops_Swarmops\Logic\Structure\PostalCodes.cs,FromArray,The following statement contains a magic number: PostalCodes result = new PostalCodes {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,PostalCodes,C:\repos\Swarmops_Swarmops\Logic\Structure\PostalCodes.cs,FromArray,The following statement contains a magic number: PostalCodes result = new PostalCodes {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Cities,C:\repos\Swarmops_Swarmops\Logic\Structure\Cities.cs,FromArray,The following statement contains a magic number: Cities result = new Cities {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Cities,C:\repos\Swarmops_Swarmops\Logic\Structure\Cities.cs,FromArray,The following statement contains a magic number: Cities result = new Cities {Capacity = (array.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Geographies,C:\repos\Swarmops_Swarmops\Logic\Structure\Geographies.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Structure,Geographies,C:\repos\Swarmops_Swarmops\Logic\Structure\Geographies.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Structure,Geographies,C:\repos\Swarmops_Swarmops\Logic\Structure\Geographies.cs,BuildHierarchicalSortOrder,The following statement contains a magic number: if (level > 20)              {                  throw new Exception ("Detected loop in Geographic data at geography id:" + currentParent.Identity + "' " +                                       currentParent.Name);              }
Magic Number,Swarmops.Logic.Structure,GeographyDataPoint,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyDataPoint.cs,GeographyDataPoint,The following statement contains a magic number: this.OrganizationData = new GeographyOrganizationDataPoint[2];
Magic Number,Swarmops.Logic.Structure,GeographyDataPoint,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyDataPoint.cs,GeographyDataPoint,The following statement contains a magic number: this.OrganizationData[1].OrganizationId = 2;
Magic Number,Swarmops.Logic.Structure,GeographyOrganizationDataPoint,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyDataPoint.cs,GeographyOrganizationDataPoint,The following statement contains a magic number: this.BirthYearBracketMemberCounts = new int[30];
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (int orgId in memberCountForOrganizations)              {                  People members =                      People.FromMemberships (                          Participations.ForOrganizations (Organization.FromIdentity (orgId).ThisAndBelow()));                    foreach (Person person in members)                  {                      Geography geography = person.Geography;                        // If we don't have this key' it's because it's too far down. Move up the tree until we're at least                      // at municipal level.                        while (geography.Identity != 1 && !result.ContainsKey (geography.Identity))                      {                          geography = geography.Parent;                      }                        // Add the data' unless we hit the roof in the last op.                        if (geography.Identity != 1)                      {                          int birthYearBracket = (person.Birthdate.Year - 1900)/5;                            if (birthYearBracket >= 0 && birthYearBracket < 30)                          {                              result[geography.Identity].OrganizationData[orgId - 1].BirthYearBracketMemberCounts[                                  birthYearBracket]++;                          }                            if (person.IsFemale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].FemaleMemberCount++;                          }                          else if (person.IsMale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].MaleMemberCount++;                          }                      }                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (int orgId in memberCountForOrganizations)              {                  People members =                      People.FromMemberships (                          Participations.ForOrganizations (Organization.FromIdentity (orgId).ThisAndBelow()));                    foreach (Person person in members)                  {                      Geography geography = person.Geography;                        // If we don't have this key' it's because it's too far down. Move up the tree until we're at least                      // at municipal level.                        while (geography.Identity != 1 && !result.ContainsKey (geography.Identity))                      {                          geography = geography.Parent;                      }                        // Add the data' unless we hit the roof in the last op.                        if (geography.Identity != 1)                      {                          int birthYearBracket = (person.Birthdate.Year - 1900)/5;                            if (birthYearBracket >= 0 && birthYearBracket < 30)                          {                              result[geography.Identity].OrganizationData[orgId - 1].BirthYearBracketMemberCounts[                                  birthYearBracket]++;                          }                            if (person.IsFemale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].FemaleMemberCount++;                          }                          else if (person.IsMale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].MaleMemberCount++;                          }                      }                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (int orgId in memberCountForOrganizations)              {                  People members =                      People.FromMemberships (                          Participations.ForOrganizations (Organization.FromIdentity (orgId).ThisAndBelow()));                    foreach (Person person in members)                  {                      Geography geography = person.Geography;                        // If we don't have this key' it's because it's too far down. Move up the tree until we're at least                      // at municipal level.                        while (geography.Identity != 1 && !result.ContainsKey (geography.Identity))                      {                          geography = geography.Parent;                      }                        // Add the data' unless we hit the roof in the last op.                        if (geography.Identity != 1)                      {                          int birthYearBracket = (person.Birthdate.Year - 1900)/5;                            if (birthYearBracket >= 0 && birthYearBracket < 30)                          {                              result[geography.Identity].OrganizationData[orgId - 1].BirthYearBracketMemberCounts[                                  birthYearBracket]++;                          }                            if (person.IsFemale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].FemaleMemberCount++;                          }                          else if (person.IsMale)                          {                              result[geography.Identity].OrganizationData[orgId - 1].MaleMemberCount++;                          }                      }                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (Geography geography in allGeographies)              {                  Geographies localTree = geography.ThisAndBelow();                  int voterCount = 0;                  GeographyOrganizationDataPoint[] tempOrgData = new GeographyOrganizationDataPoint[2]; // HACK                  tempOrgData[0] = new GeographyOrganizationDataPoint();                  tempOrgData[1] = new GeographyOrganizationDataPoint();                    foreach (Geography localNode in localTree)                  {                      // Increment our temp values for every geo node below the one we're currently processing.                        if (!result.ContainsKey (localNode.Identity))                      {                          continue;                      }                        voterCount += result[localNode.Identity].VoterCount;                        for (int orgIndex = 0; orgIndex < 2; orgIndex++)                      {                          for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                          {                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex] +=                                  result[localNode.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                                      ageBracketIndex];                          }                            tempOrgData[orgIndex].ActivistCount +=                              result[localNode.Identity].OrganizationData[orgIndex].ActivistCount;                          tempOrgData[orgIndex].FemaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].FemaleMemberCount;                          tempOrgData[orgIndex].MaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].MaleMemberCount;                      }                  }                    if (!result.ContainsKey (geography.Identity))                  {                      result[geography.Identity] = new GeographyDataPoint                      {                          GeographyId = geography.Identity'                          GeographyName = geography.Name                      };                  }                    // Save our temp values to the processed node.                    result[geography.Identity].VoterCount = voterCount;                    for (int orgIndex = 0; orgIndex < 2; orgIndex++)                  {                      for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                      {                          result[geography.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                              ageBracketIndex] =                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex];                      }                        result[geography.Identity].OrganizationData[orgIndex].ActivistCount =                          tempOrgData[orgIndex].ActivistCount;                      result[geography.Identity].OrganizationData[orgIndex].FemaleMemberCount =                          tempOrgData[orgIndex].FemaleMemberCount;                      result[geography.Identity].OrganizationData[orgIndex].MaleMemberCount =                          tempOrgData[orgIndex].MaleMemberCount;                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (Geography geography in allGeographies)              {                  Geographies localTree = geography.ThisAndBelow();                  int voterCount = 0;                  GeographyOrganizationDataPoint[] tempOrgData = new GeographyOrganizationDataPoint[2]; // HACK                  tempOrgData[0] = new GeographyOrganizationDataPoint();                  tempOrgData[1] = new GeographyOrganizationDataPoint();                    foreach (Geography localNode in localTree)                  {                      // Increment our temp values for every geo node below the one we're currently processing.                        if (!result.ContainsKey (localNode.Identity))                      {                          continue;                      }                        voterCount += result[localNode.Identity].VoterCount;                        for (int orgIndex = 0; orgIndex < 2; orgIndex++)                      {                          for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                          {                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex] +=                                  result[localNode.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                                      ageBracketIndex];                          }                            tempOrgData[orgIndex].ActivistCount +=                              result[localNode.Identity].OrganizationData[orgIndex].ActivistCount;                          tempOrgData[orgIndex].FemaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].FemaleMemberCount;                          tempOrgData[orgIndex].MaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].MaleMemberCount;                      }                  }                    if (!result.ContainsKey (geography.Identity))                  {                      result[geography.Identity] = new GeographyDataPoint                      {                          GeographyId = geography.Identity'                          GeographyName = geography.Name                      };                  }                    // Save our temp values to the processed node.                    result[geography.Identity].VoterCount = voterCount;                    for (int orgIndex = 0; orgIndex < 2; orgIndex++)                  {                      for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                      {                          result[geography.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                              ageBracketIndex] =                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex];                      }                        result[geography.Identity].OrganizationData[orgIndex].ActivistCount =                          tempOrgData[orgIndex].ActivistCount;                      result[geography.Identity].OrganizationData[orgIndex].FemaleMemberCount =                          tempOrgData[orgIndex].FemaleMemberCount;                      result[geography.Identity].OrganizationData[orgIndex].MaleMemberCount =                          tempOrgData[orgIndex].MaleMemberCount;                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (Geography geography in allGeographies)              {                  Geographies localTree = geography.ThisAndBelow();                  int voterCount = 0;                  GeographyOrganizationDataPoint[] tempOrgData = new GeographyOrganizationDataPoint[2]; // HACK                  tempOrgData[0] = new GeographyOrganizationDataPoint();                  tempOrgData[1] = new GeographyOrganizationDataPoint();                    foreach (Geography localNode in localTree)                  {                      // Increment our temp values for every geo node below the one we're currently processing.                        if (!result.ContainsKey (localNode.Identity))                      {                          continue;                      }                        voterCount += result[localNode.Identity].VoterCount;                        for (int orgIndex = 0; orgIndex < 2; orgIndex++)                      {                          for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                          {                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex] +=                                  result[localNode.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                                      ageBracketIndex];                          }                            tempOrgData[orgIndex].ActivistCount +=                              result[localNode.Identity].OrganizationData[orgIndex].ActivistCount;                          tempOrgData[orgIndex].FemaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].FemaleMemberCount;                          tempOrgData[orgIndex].MaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].MaleMemberCount;                      }                  }                    if (!result.ContainsKey (geography.Identity))                  {                      result[geography.Identity] = new GeographyDataPoint                      {                          GeographyId = geography.Identity'                          GeographyName = geography.Name                      };                  }                    // Save our temp values to the processed node.                    result[geography.Identity].VoterCount = voterCount;                    for (int orgIndex = 0; orgIndex < 2; orgIndex++)                  {                      for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                      {                          result[geography.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                              ageBracketIndex] =                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex];                      }                        result[geography.Identity].OrganizationData[orgIndex].ActivistCount =                          tempOrgData[orgIndex].ActivistCount;                      result[geography.Identity].OrganizationData[orgIndex].FemaleMemberCount =                          tempOrgData[orgIndex].FemaleMemberCount;                      result[geography.Identity].OrganizationData[orgIndex].MaleMemberCount =                          tempOrgData[orgIndex].MaleMemberCount;                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (Geography geography in allGeographies)              {                  Geographies localTree = geography.ThisAndBelow();                  int voterCount = 0;                  GeographyOrganizationDataPoint[] tempOrgData = new GeographyOrganizationDataPoint[2]; // HACK                  tempOrgData[0] = new GeographyOrganizationDataPoint();                  tempOrgData[1] = new GeographyOrganizationDataPoint();                    foreach (Geography localNode in localTree)                  {                      // Increment our temp values for every geo node below the one we're currently processing.                        if (!result.ContainsKey (localNode.Identity))                      {                          continue;                      }                        voterCount += result[localNode.Identity].VoterCount;                        for (int orgIndex = 0; orgIndex < 2; orgIndex++)                      {                          for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                          {                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex] +=                                  result[localNode.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                                      ageBracketIndex];                          }                            tempOrgData[orgIndex].ActivistCount +=                              result[localNode.Identity].OrganizationData[orgIndex].ActivistCount;                          tempOrgData[orgIndex].FemaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].FemaleMemberCount;                          tempOrgData[orgIndex].MaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].MaleMemberCount;                      }                  }                    if (!result.ContainsKey (geography.Identity))                  {                      result[geography.Identity] = new GeographyDataPoint                      {                          GeographyId = geography.Identity'                          GeographyName = geography.Name                      };                  }                    // Save our temp values to the processed node.                    result[geography.Identity].VoterCount = voterCount;                    for (int orgIndex = 0; orgIndex < 2; orgIndex++)                  {                      for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                      {                          result[geography.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                              ageBracketIndex] =                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex];                      }                        result[geography.Identity].OrganizationData[orgIndex].ActivistCount =                          tempOrgData[orgIndex].ActivistCount;                      result[geography.Identity].OrganizationData[orgIndex].FemaleMemberCount =                          tempOrgData[orgIndex].FemaleMemberCount;                      result[geography.Identity].OrganizationData[orgIndex].MaleMemberCount =                          tempOrgData[orgIndex].MaleMemberCount;                  }              }
Magic Number,Swarmops.Logic.Structure,GeographyStatistics,C:\repos\Swarmops_Swarmops\Logic\Structure\GeographyStatistics.cs,GeneratePresent,The following statement contains a magic number: foreach (Geography geography in allGeographies)              {                  Geographies localTree = geography.ThisAndBelow();                  int voterCount = 0;                  GeographyOrganizationDataPoint[] tempOrgData = new GeographyOrganizationDataPoint[2]; // HACK                  tempOrgData[0] = new GeographyOrganizationDataPoint();                  tempOrgData[1] = new GeographyOrganizationDataPoint();                    foreach (Geography localNode in localTree)                  {                      // Increment our temp values for every geo node below the one we're currently processing.                        if (!result.ContainsKey (localNode.Identity))                      {                          continue;                      }                        voterCount += result[localNode.Identity].VoterCount;                        for (int orgIndex = 0; orgIndex < 2; orgIndex++)                      {                          for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                          {                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex] +=                                  result[localNode.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                                      ageBracketIndex];                          }                            tempOrgData[orgIndex].ActivistCount +=                              result[localNode.Identity].OrganizationData[orgIndex].ActivistCount;                          tempOrgData[orgIndex].FemaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].FemaleMemberCount;                          tempOrgData[orgIndex].MaleMemberCount +=                              result[localNode.Identity].OrganizationData[orgIndex].MaleMemberCount;                      }                  }                    if (!result.ContainsKey (geography.Identity))                  {                      result[geography.Identity] = new GeographyDataPoint                      {                          GeographyId = geography.Identity'                          GeographyName = geography.Name                      };                  }                    // Save our temp values to the processed node.                    result[geography.Identity].VoterCount = voterCount;                    for (int orgIndex = 0; orgIndex < 2; orgIndex++)                  {                      for (int ageBracketIndex = 0; ageBracketIndex < 30; ageBracketIndex++)                      {                          result[geography.Identity].OrganizationData[orgIndex].BirthYearBracketMemberCounts[                              ageBracketIndex] =                              tempOrgData[orgIndex].BirthYearBracketMemberCounts[ageBracketIndex];                      }                        result[geography.Identity].OrganizationData[orgIndex].ActivistCount =                          tempOrgData[orgIndex].ActivistCount;                      result[geography.Identity].OrganizationData[orgIndex].FemaleMemberCount =                          tempOrgData[orgIndex].FemaleMemberCount;                      result[geography.Identity].OrganizationData[orgIndex].MaleMemberCount =                          tempOrgData[orgIndex].MaleMemberCount;                  }              }
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organization,C:\repos\Swarmops_Swarmops\Logic\Structure\Organization.cs,GetEndOfFiscalYear,The following statement contains a magic number: return new DateTime (year' 12' 31' 23' 59' 59' 999);
Magic Number,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,FromArray,The following statement contains a magic number: Organizations result = new Organizations {Capacity = (organizationArray.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,FromArray,The following statement contains a magic number: Organizations result = new Organizations {Capacity = (organizationArray.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,FromArray,The following statement contains a magic number: Organizations result = new Organizations {Capacity = (organizationArray.Length*11/10)};
Magic Number,Swarmops.Logic.Structure,Organizations,C:\repos\Swarmops_Swarmops\Logic\Structure\Organizations.cs,FromArray,The following statement contains a magic number: Organizations result = new Organizations {Capacity = (organizationArray.Length*11/10)};
Magic Number,Swarmops,MD5,C:\repos\Swarmops_Swarmops\Logic\Security\MD5.cs,Hash,The following statement contains a magic number: byte[] data = Encoding.GetEncoding (1252).GetBytes (input);
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,AddAccount,The following statement contains a magic number: using (MySqlConnection connection = new MySqlConnection (connectionString))              {                  connection.Open();                    using (                      MySqlCommand command =                          new MySqlCommand (                              "INSERT INTO users (email' password' quota) VALUES ('" + email.Replace ("'"' "''") +                              "'' ENCRYPT('" + initialPassword.Replace ("'"' "''") + "')' " +                              (1048576*quotaMegabytes) + ");"' connection))                  {                      command.ExecuteNonQuery();                  }              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,FindFreeAccount,The following statement contains a magic number: if (email == null || email.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("email too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,StartForwarding,The following statement contains a magic number: if (fromEmail == null || fromEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("fromEmail too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,StartForwarding,The following statement contains a magic number: if (toEmail == null || toEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("toEmail too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,StopSpecificForwarding,The following statement contains a magic number: if (fromEmail == null || fromEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("fromEmail too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,StopSpecificForwarding,The following statement contains a magic number: if (toEmail == null || toEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("toEmail too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,StopForwarding,The following statement contains a magic number: if (fromEmail == null || fromEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("fromEmail too short");              }
Magic Number,Swarmops.Logic.Special.Mail,MailServerDatabase,C:\repos\Swarmops_Swarmops\Logic\Special\Mail\MailServerDatabase.cs,DeleteAccount,The following statement contains a magic number: if (fromEmail == null || fromEmail.IndexOf ("@") < 2)              {                  throw new ArgumentOutOfRangeException ("Email too short");              }
Magic Number,Swarmops.Logic.Swarm,ChurnData,C:\repos\Swarmops_Swarmops\Logic\Swarm\ChurnData.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,ChurnData,C:\repos\Swarmops_Swarmops\Logic\Swarm\ChurnData.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,DashboardTodos,C:\repos\Swarmops_Swarmops\Logic\Swarm\DashboardTodos.cs,AddPayouts,The following statement contains a magic number: foreach (Payout payout in payouts)              {                  payoutCount++;                    if (payout.DependentInvoices.Count > 0)                  {                      if (payout.ExpectedTransactionDate < DateTime.Today)                      {                          overduePayoutCount++;                      }                      else if (payout.ExpectedTransactionDate < DateTime.Today.AddDays (7))                      {                          urgentPayoutCount++;                      }                  }              }
Magic Number,Swarmops.Logic.Swarm,Participation,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participation.cs,Terminate,The following statement contains a magic number: if (base.Active)              {                    // REMOVED: everything Roles related; being phased out                      //PWLog.Write (actingPerson.Identity' PWLogItem.Person' Person.Identity' PWLogAction.MemberLost'                  //    eventSource + ":" + description' string.Empty);                  PWEvents.CreateEvent (EventSource.PirateWeb' EventType.LostMember' actingPerson.Identity' OrganizationId' Person.GeographyId'                      Person.Identity' 0' OrganizationId.ToString());                      //Added LogChurn here to make SURE they always are logged with the membership.                  if (PersonId > 0 && OrganizationId > 0 && base.Expires.IsDefined())                  {                      ChurnData.LogChurn (PersonId' OrganizationId);                  }                  SwarmDb.GetDatabaseForWriting().TerminateParticipation (Identity);                  base.Active = false;                  base.DateTerminated = DateTime.Now;                    // Remove all newsletter subscriptions once the membership is terminated (to make sure default is now off and only turn off explicitly turned-on subscriptions)                    // HACK HACK HACK: uses feed IDs in an extremely ugly way to loop 1-9. Should use NewsletterFeeds.ForOrganization() once support for newsletters in different orgs are established.                    for (int newsletterFeedId = 1; newsletterFeedId < 10; newsletterFeedId++)                  {                      try                      {                          if (this._person.IsSubscribing (newsletterFeedId))                          {                              this._person.SetSubscription (newsletterFeedId' false);                          }                      }                      catch (Exception)                      {                          // ignore nonexisting newsletter feeds -- this is a hack anyway                      }                  }              }
Magic Number,Swarmops.Logic.Swarm,MembershipEvents,C:\repos\Swarmops_Swarmops\Logic\Swarm\MembershipEvents.cs,LoadAll,The following statement contains a magic number: foreach (BasicParticipation membership in allParticipations)              {                  int geographyId = 1;                  int birthYear = 0;                  PersonGender gender = PersonGender.Unknown;                    if (geoLookup.ContainsKey (membership.PersonId))                  {                      geographyId = geoLookup[membership.PersonId];                      gender = genderLookup[membership.PersonId];                      birthYear = birthYearLookup[membership.PersonId];                  }                    result.Add (new MembershipEvent (membership.MemberSince' membership.PersonId' membership.OrganizationId'                      geographyId' birthYear' gender' 1));                    if (!membership.Active)                  {                      TimeSpan safetyDelta = new TimeSpan (0);                        // A few records in the database have had their memberships terminated at the exact time of creation. This means that sorting will                      // be unpredictable' when it relies on the termination coming at a later time than the creation.                        // To solve this' make sure they are more than five seconds apart.                        if (membership.DateTerminated.Date == membership.MemberSince.Date)                          // First simple check                      {                          if ((membership.DateTerminated - membership.MemberSince) < new TimeSpan (0' 0' 5))                          {                              safetyDelta = new TimeSpan (0' 0' 5);                          }                      }                        result.Add (new MembershipEvent (membership.DateTerminated + safetyDelta'                          membership.PersonId' membership.OrganizationId' geographyId'                          birthYear' gender' -1));                  }              }
Magic Number,Swarmops.Logic.Swarm,MembershipEvents,C:\repos\Swarmops_Swarmops\Logic\Swarm\MembershipEvents.cs,LoadAll,The following statement contains a magic number: foreach (BasicParticipation membership in allParticipations)              {                  int geographyId = 1;                  int birthYear = 0;                  PersonGender gender = PersonGender.Unknown;                    if (geoLookup.ContainsKey (membership.PersonId))                  {                      geographyId = geoLookup[membership.PersonId];                      gender = genderLookup[membership.PersonId];                      birthYear = birthYearLookup[membership.PersonId];                  }                    result.Add (new MembershipEvent (membership.MemberSince' membership.PersonId' membership.OrganizationId'                      geographyId' birthYear' gender' 1));                    if (!membership.Active)                  {                      TimeSpan safetyDelta = new TimeSpan (0);                        // A few records in the database have had their memberships terminated at the exact time of creation. This means that sorting will                      // be unpredictable' when it relies on the termination coming at a later time than the creation.                        // To solve this' make sure they are more than five seconds apart.                        if (membership.DateTerminated.Date == membership.MemberSince.Date)                          // First simple check                      {                          if ((membership.DateTerminated - membership.MemberSince) < new TimeSpan (0' 0' 5))                          {                              safetyDelta = new TimeSpan (0' 0' 5);                          }                      }                        result.Add (new MembershipEvent (membership.DateTerminated + safetyDelta'                          membership.PersonId' membership.OrganizationId' geographyId'                          birthYear' gender' -1));                  }              }
Magic Number,Swarmops.Logic.Swarm,Participations,C:\repos\Swarmops_Swarmops\Logic\Swarm\Participations.cs,GetExpired,The following statement contains a magic number: return                  FromArray (SwarmDb.GetDatabaseForReading().GetExpiringParticipations (organization' new DateTime(1800'1'1)'                      DateTime.Now));
Magic Number,Swarmops.Logic.Swarm,ParleyAttendee,C:\repos\Swarmops_Swarmops\Logic\Swarm\ParleyAttendee.cs,SendInvoice,The following statement contains a magic number: DateTime invoiceDue = DateTime.Today.AddDays (14);
Magic Number,Swarmops.Logic.Swarm,ParleyAttendee,C:\repos\Swarmops_Swarmops\Logic\Swarm\ParleyAttendee.cs,SendInvoice,The following statement contains a magic number: DateTime maxInvoiceDue = Parley.StartDate.AddDays (-10);
Magic Number,Swarmops.Logic.Swarm,PaymentCode,C:\repos\Swarmops_Swarmops\Logic\Swarm\PaymentCode.cs,Create,The following statement contains a magic number: while (!success)              {                  string randomCode = CreateRandomCode (5);                    try                  {                      int codeId = SwarmDb.GetDatabaseForWriting().CreatePaymentCode (randomCode' phoneNumber' personId);                      success = true;                      return FromBasic (SwarmDb.GetDatabaseForReading().GetPaymentCode (randomCode));                  }                  catch (Exception)                  {                      // If the creation throws' we had a duplicate code. Re-randomize and try again.                        // TODO: Set a maximum attempt count' like 1E5 or something like that.                  }              }
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromIdentities,The following statement contains a magic number: if (personIds.Length > 500)              {                  // If over fivehundred identities are requested' we won't pass the array to                  // SQL Server. Rather' we'll get ALL the people and parse the list ourselves.                    Dictionary<int' bool> lookup = new Dictionary<int' bool>();                    foreach (int key in personIds)                  {                      lookup[key] = true;                  }                    BasicPerson[] basicArray = SwarmDb.GetDatabaseForReading().GetAllPeople();                  People result = new People();                    for (int index = 0; index < basicArray.Length; index++)                  {                      if (lookup.ContainsKey (basicArray[index].Identity))                      {                          result.Add (Person.FromBasic (basicArray[index]));                      }                  }                    return result;              }
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromNamePattern,The following statement contains a magic number: if (namePattern.Trim().Length < 3)              {                  return new People();              }
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromOrganizationAndGeographyWithPattern,The following statement contains a magic number: if (pattern.Length < 3)              {                  // too short pattern! Return empty set.                  return new People();              }
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromArray,The following statement contains a magic number: result.Capacity = personArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromArray,The following statement contains a magic number: result.Capacity = personArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromArray,The following statement contains a magic number: result.Capacity = personArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromArray,The following statement contains a magic number: result.Capacity = personArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,People,C:\repos\Swarmops_Swarmops\Logic\Swarm\People.cs,FromNewsletterFeed,The following statement contains a magic number: int[] subscriberIds = SwarmDb.GetDatabaseForReading().GetSubscribersForNewsletterFeed (2);
Magic Number,Swarmops.Logic.Swarm,Person,C:\repos\Swarmops_Swarmops\Logic\Swarm\Person.cs,ResolveGeography,The following statement contains a magic number: if (cities.Count == 0 && PostalCode.Length > 3)              {                  // try shortening the postal code - like NL dataset - and see if we find anything                    for (int shortening = 1; shortening <= 3; shortening++)                  {                      cities = Cities.FromPostalCode (PostalCode.Substring (0' PostalCode.Length - shortening)'                          base.CountryId);                      if (cities.Count > 0)                      {                          break;                      }                  }              }
Magic Number,Swarmops.Logic.Swarm,Person,C:\repos\Swarmops_Swarmops\Logic\Swarm\Person.cs,ResolveGeography,The following statement contains a magic number: if (cities.Count == 0 && PostalCode.Length > 3)              {                  // try shortening the postal code - like NL dataset - and see if we find anything                    for (int shortening = 1; shortening <= 3; shortening++)                  {                      cities = Cities.FromPostalCode (PostalCode.Substring (0' PostalCode.Length - shortening)'                          base.CountryId);                      if (cities.Count > 0)                      {                          break;                      }                  }              }
Magic Number,Swarmops.Logic.Swarm,Positions,C:\repos\Swarmops_Swarmops\Logic\Swarm\Positions.cs,ForOrganizationGeography,The following statement contains a magic number: if (geography.ChildrenCount > 0)              {                  Tree<Geography> geoTree = geography.Tree;                    Position expandingSubleaderNode =                      Position.FromBasic(new BasicPosition(0' PositionLevel.GeographyDefault' organization.Identity'                          geography.Identity' 0' 0' 0' DateTime.Today'                          "Geographic_ExpandingSubleaderNode"' "UxElement"' false' true' false' false' false' 0' 0' 0' 0));                      // UX element' not real position                  TreeNode<Position> expandingNode = treeResult.RootNodes[0].AddChild(expandingSubleaderNode);                    ForOrganizationGeographyRecurse(geoTree.RootNodes[0]' expandingNode' geographyLeaderTemplate' 2);              }
Magic Number,Swarmops.Logic.Swarm,Roles,C:\repos\Swarmops_Swarmops\Logic\Swarm\Roles.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,Roles,C:\repos\Swarmops_Swarmops\Logic\Swarm\Roles.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,VolunteerRoles,C:\repos\Swarmops_Swarmops\Logic\Swarm\VolunteerRoles.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,VolunteerRoles,C:\repos\Swarmops_Swarmops\Logic\Swarm\VolunteerRoles.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,Volunteers,C:\repos\Swarmops_Swarmops\Logic\Swarm\Volunteers.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Magic Number,Swarmops.Logic.Swarm,Volunteers,C:\repos\Swarmops_Swarmops\Logic\Swarm\Volunteers.cs,FromArray,The following statement contains a magic number: result.Capacity = basicArray.Length*11/10;
Duplicate Code,Swarmops.Logic.Financial,BitcoinUtility,C:\repos\Swarmops_Swarmops\Logic\Financial\BitcoinUtility.cs,TestUnspents,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 62)' (121' 155))
Missing Default,Swarmops.Logic.DataObjects,OrganizationsDataObject,C:\repos\Swarmops_Swarmops\Logic\DataObjects\OrganizationDataObject.cs,SelectSortedStatic,The following switch statement is missing a default case: switch (sort)              {                  case "OrganizationId":                      pList.Sort (IdentityComparison);                      break;              }
Missing Default,Swarmops.Logic.DataObjects,PeopleDataObject,C:\repos\Swarmops_Swarmops\Logic\DataObjects\PeopleDataObject.cs,SelectSortedStatic,The following switch statement is missing a default case: switch (sort)              {                  case "PersonId":                      pList.Sort (PersonIdComparison);                      break;                  case "Name":                      pList.Sort (NameComparison);                      break;                  case "PostalCode":                      pList.Sort (PostalCodeComparison);                      break;                  case "CityName":                      pList.Sort (CityComparison);                      break;                  case "Birthdate":                      pList.Sort (BirthdateComparison);                      break;                        // New sortexpressions                  case "Email":                      pList.Sort (EmailComparison);                      break;                  case "Phone":                      pList.Sort (PhoneComparison);                      break;              }
