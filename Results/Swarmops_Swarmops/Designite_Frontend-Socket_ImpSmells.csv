Implementation smell,Namespace,Class,File,Method,Description
Long Method,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The method has 146 lines of code.
Long Method,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The method has 132 lines of code.
Long Parameter List,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The method has 5 parameters. Parameters: pdfFiles' pdfClientNames' guid' person' organization
Long Statement,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,OnMessage,The length of the statement  "                    ConvertPdf(pdfFilesList.ToArray()' pdfClientNames.ToArray()' (string) json["Guid"]' Person.FromIdentity((int) json["PersonId"])' Organization.FromIdentity((int) json["OrganizationId"])); " is 186.
Long Statement,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,OnOpen,The length of the statement  "            authBase64 = Uri.UnescapeDataString (authBase64); // Defensive programming - % sign does not exist in base64 so this won't ever collapse a working encoding " is 155.
Long Statement,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,OnClose,The length of the statement  "            // Sessions.Broadcast("{\"messageType\":\"EditorCount\"'" + String.Format("\"editorCount\":\"{0}\""' Sessions.ActiveIDs.ToArray().Length) + '}'); " is 145.
Long Statement,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,CheckPublish,The length of the statement  "            //Console.WriteLine(" * FWN-Internal: Last pub was {0:HH:mm}' next scheduled for {1:HH:mm}' now {2:HH:mm}"' lastPublishUtc' nextPublish' nowUtc); " is 145.
Long Statement,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,CheckStoryAges,The length of the statement  "                // Console.WriteLine("Story #{0:N0} is {1:N0} minutes old ({4:N1} hours)' last notify at {2} minutes ({3} hours)"' story.Identity' ageMinutes' story.NotifiedAgeMinutes' story.NotifiedAgeMinutes / 60' ageMinutes / 60); " is 217.
Long Statement,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,RecordStoryMetrics,The length of the statement  "            ProcessStartInfo processInfo = new ProcessStartInfo("/usr/local/bin/twurl"' " /1.1/statuses/user_timeline.json?screen_name=FalconwingNews&exclude_replies=true&count=200&include_rts=false"); " is 189.
Long Statement,Swarmops.Frontend.Socket,SocketServerExtensionMethods,C:\repos\Swarmops_Swarmops\FrontSocket\SocketServerExtensionMethods.cs,BroadcastToOrganization,The length of the statement  "                        Console.WriteLine("INVALID STATE: Authority lookup for " + _sessionAuthorityLookup[key].Person.Canonical + " has no session"); " is 126.
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendServices,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendServices.cs,ConvertPdf,The following statement contains a magic number: using (StreamWriter debugWriter = new StreamWriter("/tmp/PdfConversionDebug-" + guid + ".txt"))              {                    try                  {                      debugWriter.WriteLine("ConvertPdf started");                        int fileCount = pdfFiles.Length;                        Process process = null;                      Document lastDocument = null;                        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)                      {                          // Set progress to indicate we're at file 'index' of 'fileCount'                            int progress = fileIndex * 99 / fileCount; // 99 at most -- 100 indicates complete                          int progressFileStep = 99 / fileCount;                          int currentFilePageCount = 0;                          int currentFilePageStepMilli = 0;                            string relativeFileName = pdfFiles[fileIndex];                            debugWriter.WriteLine("------------------------------------");                          debugWriter.WriteLine("{3:D2}%' Converting PDF file {0} of {1}; {2}"' fileIndex + 1' fileCount'                              relativeFileName' progress);                            // Use qpdf to determine the number of pages in the PDF                            string pageCountFileName = "/tmp/pagecount-" + guid + ".txt";                            process = Process.Start("bash"'                              "-c \"qpdf --show-npages " + Document.StorageRoot + relativeFileName + " > " + pageCountFileName + "\"");                            process.WaitForExit();                            if (process.ExitCode == 2)                          {                              // Bad PDF file                              failedConversionFileNames.Add(                                  ((string[])GuidCache.Get("PdfClientNames-" + guid))[fileIndex].Replace("'"' "")                                      .Replace("\""' "")); // caution; we're displaying user input' guard against XSS                              continue;                          }                            // Read the resulting page count from the file we piped                            using (StreamReader pageCountReader = new StreamReader(pageCountFileName))                          {                              string line = pageCountReader.ReadLine().Trim();                              while (line.StartsWith("WARNING") || line.StartsWith("qpdf:"))                              {                                  line = pageCountReader.ReadLine().Trim();  // ignore warnings and chatter                              }                              currentFilePageCount = Int32.Parse(line);                              debugWriter.WriteLine("{0:D2}%' parsed to int as {1}"' progress' currentFilePageCount);                              currentFilePageStepMilli = progressFileStep * 1000 / currentFilePageCount;                          }                            File.Delete(pageCountFileName);                            // Begin the conversion                            debugWriter.WriteLine("{0:D2}%' deleted page count file' starting conversion process"' progress);                            // Density 75 means 75dpi means conversion                          // Hires 600dpi conversion is also made' but from backend after this conversion                            process = Process.Start("bash"'                              "-c \"convert -density 75 -background white -alpha remove " + Document.StorageRoot + relativeFileName +                              " " + Document.StorageRoot + relativeFileName + "-%04d.png\"");                            int pageCounter = 0; // the first produced page will be zero                          string testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                          debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          string lastPageFileName = testPageFileName;                            // Convert works by first calling imagemagick that creates /tmp/magick-* files                            int lastProgress = 0;                            while (pageCounter < currentFilePageCount)                          {                              while (!File.Exists(Document.StorageRoot + testPageFileName))                              {                                  // Wait for file to appear                                    debugWriter.WriteLine("{0:D2}%' {2:O}' waiting for page #{1} to appear"' progress' pageCounter + 1' DateTime.UtcNow);                                  debugWriter.Flush();                                  GuidCache.Set("Pdf-" + guid + "-Progress"' progress);                                    if (!process.HasExited)                                  {                                      process.WaitForExit(250);                                  }                                    if (pageCounter == 0)                                  {                                      // If first page hasn't appeared yet' check for the Magick temp files                                        int currentMagickCount = Directory.GetFiles("/tmp"' "magick-*").Count();                                      int currentFilePercentage = currentMagickCount*50/currentFilePageCount;                                      if (currentFilePercentage > 50)                                      {                                          currentFilePercentage = 50; // we may be not the only one converting right now                                      }                                        progress = progressFileStep*fileIndex + currentFilePercentage*100/progressFileStep;                                      if (progress > lastProgress)  // can't use Not-Equal; temp files slowly deleted before next step                                      {                                          BroadcastGuidProgress(organization' guid' progress);                                          lastProgress = progress;                                      }                                  }                              }                                progress = progressFileStep * fileIndex + progressFileStep / 2 + currentFilePageStepMilli * (pageCounter + 1) / 2000;                              if (progress != lastProgress)                              {                                  BroadcastGuidProgress(organization' guid' progress);                                  lastProgress = progress;                              }                                debugWriter.WriteLine("{0:D2}%' found page #{1}"' progress' pageCounter + 1);                                // If the page# file that has appeared is 1+' then the preceding file is ready                                if (pageCounter > 0)                              {                                  long fileLength = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                                  debugWriter.WriteLine("{0:D2}%' saving page #{1}' bytecount {2}"' progress' pageCounter' fileLength);                                    Document.Create(lastPageFileName' pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                                      fileLength' guid' null' person);                                    // Set to readonly' lock out changes' permit all read                                    Syscall.chmod(Document.StorageRoot + lastPageFileName'                                      FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                                    // Prepare to save the next file                                  lastPageFileName = testPageFileName;                              }                                // Increase the page counter and the file we're looking for                                pageCounter++;                              testPageFileName = String.Format("{0}-{1:D4}.png"' relativeFileName' pageCounter);                              debugWriter.WriteLine("{0:D2}%' testPageFileName set to {1}"' progress' testPageFileName);                          }                            // We've seen the last page being written -- wait for process to exit to assure it's complete                          debugWriter.WriteLine("{0:D2}%' waiting for process exit"' progress);                            if (!process.HasExited)                          {                              process.WaitForExit();                          }                            // Save the last page                            long fileLengthLastPage = new FileInfo(Document.StorageRoot + lastPageFileName).Length;                          debugWriter.WriteLine("{0:D2}%' saving last page #{1}' bytecount {2}"' progress' pageCounter' fileLengthLastPage);                            lastDocument = Document.Create(lastPageFileName'                              pdfClientNames[fileIndex] + " " + pageCounter.ToString(CultureInfo.InvariantCulture)'                              fileLengthLastPage' guid' null' person);                            // Set to readonly' lock out changes' permit all read                            Syscall.chmod(Document.StorageRoot + lastPageFileName'                              FilePermissions.S_IRUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH);                            // Finally' ask the backend to do the high-res conversions' but now we have the basic' fast ones                            RasterizeDocumentHiresOrder backendOrder = new RasterizeDocumentHiresOrder(lastDocument);                          backendOrder.Create();                        }                    }                  catch (Exception e)                  {                      debugWriter.WriteLine("Exception thrown: " + e.ToString());                        throw;                  }                  finally                  {                      debugWriter.WriteLine("Handler exiting");                        BroadcastGuidProgress(organization' guid' 100);                  }              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,Main,The following statement contains a magic number: using (_backendSocket = new WebSocket(backendSocketUri))              {                  _backendSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBackendMessage);                  _backendSocket.OnOpen += new EventHandler(OnBackendOpen);                  _backendSocket.OnClose += new EventHandler<CloseEventArgs>(OnBackendClose);                  _backendSocket.OnError += new EventHandler<ErrorEventArgs>(OnBackendError);                  _backendSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                                if (cycleStartTime.Minute%30 == 0)                              {                                  OnEveryHalfHour();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  // OnTuesdayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              // OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              // OnMidnight();                          }                      }                        catch (Exception e)                      {                          Console.WriteLine(e.ToString());                            // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            // ExceptionMail.Send (new Exception ("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine(" * Swarmops Frontend Socket Server caught signal " +                                                killSignals[signalIndex].Signum + "' exiting");                          }                            utcNow = DateTime.UtcNow;                      }                  }                    _socketServer.Stop();                  Thread.Sleep(2000);                    Console.WriteLine(" * Swarmops Frontend Socket Server exiting");              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,OnEveryTenSeconds,The following statement contains a magic number: if (_lastBackendHeartBeat.AddSeconds(5) < DateTime.UtcNow)              {                  RaiseAlarm(FrontendMalfunctions.BackendHeartbeatLost);              }              else              {                  ClearAlarm(FrontendMalfunctions.BackendHeartbeatLost);              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,OnEveryTenSeconds,The following statement contains a magic number: if (_isSandbox)              {                  _sandboxDummy1 += new Random().Next(10) - 3;                  _sandboxDummy2 += new Random().Next(1000) - 200;                    JObject data1 = new JObject();                  data1["MessageType"] = "SandboxUpdate";                  data1["Local"] = _sandboxDummy1.ToString(CultureInfo.InvariantCulture);                  data1["Profit"] = _sandboxDummy2.ToString(CultureInfo.InvariantCulture);                    _socketServer.WebSocketServices.Broadcast(data1.ToString());              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,OnEveryTenSeconds,The following statement contains a magic number: if (_isSandbox)              {                  _sandboxDummy1 += new Random().Next(10) - 3;                  _sandboxDummy2 += new Random().Next(1000) - 200;                    JObject data1 = new JObject();                  data1["MessageType"] = "SandboxUpdate";                  data1["Local"] = _sandboxDummy1.ToString(CultureInfo.InvariantCulture);                  data1["Profit"] = _sandboxDummy2.ToString(CultureInfo.InvariantCulture);                    _socketServer.WebSocketServices.Broadcast(data1.ToString());              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,OnEveryTenSeconds,The following statement contains a magic number: if (_isSandbox)              {                  _sandboxDummy1 += new Random().Next(10) - 3;                  _sandboxDummy2 += new Random().Next(1000) - 200;                    JObject data1 = new JObject();                  data1["MessageType"] = "SandboxUpdate";                  data1["Local"] = _sandboxDummy1.ToString(CultureInfo.InvariantCulture);                  data1["Profit"] = _sandboxDummy2.ToString(CultureInfo.InvariantCulture);                    _socketServer.WebSocketServices.Broadcast(data1.ToString());              }
Magic Number,Swarmops.Frontend.Socket,FrontendLoop,C:\repos\Swarmops_Swarmops\FrontSocket\FrontendLoop.cs,OnEveryTenSeconds,The following statement contains a magic number: if (_isSandbox)              {                  _sandboxDummy1 += new Random().Next(10) - 3;                  _sandboxDummy2 += new Random().Next(1000) - 200;                    JObject data1 = new JObject();                  data1["MessageType"] = "SandboxUpdate";                  data1["Local"] = _sandboxDummy1.ToString(CultureInfo.InvariantCulture);                  data1["Profit"] = _sandboxDummy2.ToString(CultureInfo.InvariantCulture);                    _socketServer.WebSocketServices.Broadcast(data1.ToString());              }
