Implementation smell,Namespace,Class,File,Method,Description
Long Method,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The method has 274 lines of code.
Complex Method,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,Cyclomatic complexity of the method is 15
Long Statement,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The length of the statement  "                        // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]." " is 120.
Long Statement,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The length of the statement  "                        // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients' " is 122.
Long Statement,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,FormatTimespan,The length of the statement  "            return String.Format("{0} min {1:D2}.{2:D3} sec"' Math.Floor(span.TotalMinutes)' Math.Floor((double) span.Seconds)' span.Milliseconds); " is 135.
Long Statement,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,FindResolver,The length of the statement  "            var methodInfo = payloadType.GetMethod("FromXml"' BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy); " is 125.
Long Statement,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The length of the statement  "            SupportFunctions.DisableSslCertificateChecks(); // MONO BUG/MISFEATURE: Mono has no root certificates' so can't verify cert " is 123.
Long Statement,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The length of the statement  "                ExceptionMail.Send(new Exception("HeartBeater triggered restart of Swarmops Backend. Will commence after 800 seconds.")' false); " is 128.
Long Statement,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,ProcessBitcoinTransaction,The length of the statement  "                                "script": "483045022100e4ff962c292705f051c2c2fc519fa775a4d8955bce1a3e29884b2785277999ed02200b537ebd22a9f25fbbbcc9113c69c1389400703ef2017d80959ef0f1d685756c012102618e08e0c8fd4c5fe539184a30fe35a2f5fccf7ad62054cad29360d871f8187d" " is 226.
Long Statement,Swarmops.Backend.SocketServices,BackendServices,C:\repos\Swarmops_Swarmops\Backend\SocketServices\BackendServices.cs,OnMessage,The length of the statement  "                        PdfProcessor.Rerasterize(Document.FromIdentity(Int32.Parse((string) json["DocumentId"]))' PdfProcessor.PdfProcessorOptions.HighQuality | PdfProcessor.PdfProcessorOptions.ForceOrphans); " is 184.
Long Statement,Swarmops.Backend.SocketServices,BackendServices,C:\repos\Swarmops_Swarmops\Backend\SocketServices\BackendServices.cs,OnOpen,The length of the statement  "            //authBase64 = Uri.UnescapeDataString(authBase64); // Defensive programming - % sign does not exist in base64 so this won't ever collapse a working encoding " is 156.
Long Statement,Swarmops.Backend.SocketServices,BackendServices,C:\repos\Swarmops_Swarmops\Backend\SocketServices\BackendServices.cs,OnClose,The length of the statement  "            Sessions.Broadcast("{\"messageType\":\"EditorCount\"'" + String.Format("\"editorCount\":\"{0}\""' Sessions.Count) + '}'); " is 121.
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,CommsTransmitter,C:\repos\Swarmops_Swarmops\Backend\CommsTransmitter.cs,Run,The following statement contains a magic number: foreach (OutboundComm comm in comms)              {                  BotLog.Write(1' "CommsTx"' "OutboundComm #" + comm.Identity.ToString("N0"));                    if (!comm.Resolved)                  {                      BotLog.Write(2' "CommsTx"' "--resolving");                        ICommsResolver resolver = FindResolver(comm);                      resolver.Resolve(comm);                      comm.Resolved = true;                        int recipientCount = comm.Recipients.Count;                      BotLog.Write(2' "CommsTx"' "--resolved to " + recipientCount.ToString("N0") + " recipients");                        if (recipientCount > 1 && comm.SenderPersonId != 0)                      {                          // "Your message has been queued for delivery and the recipients have been resolved.                           // Your mail will be sent to' or be attempted to sent to' [RecipientCount] people in [Geography] in [OrganizationName]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] = Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = comm.Recipients.Count.ToString("N0");                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                              OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                                  NotificationResource.OutboundComm_Resolved' notifyStrings' customStrings'                                  People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                        comm.StartTransmission();                        continue; // continue is not strictly necessary; could continue processing the same OutboundComm after resolution                  }                    if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                  {                      throw new NotImplementedException();                  }                    ICommsTransmitter transmitter = new CommsTransmitterMail();                    const int batchSize = 1000;                    OutboundCommRecipients recipients = comm.GetRecipientBatch(batchSize);                  PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                    BotLog.Write(2' "CommsTx"' "--transmitting to " + recipients.Count.ToString("N0") + " recipients");                    foreach (OutboundCommRecipient recipient in recipients)                  {                      try                      {                          transmitter.Transmit (envelope' recipient.Person);                          recipient.CloseSuccess();                      }                      catch (OutboundCommTransmitException e)                      {                          recipient.CloseFailed (e.Description);                      }                  }                    if (recipients.Count < batchSize) // Was this the last batch?                  {                      comm.Open = false;                        BotLog.Write(2' "CommsTx"' "--closing");                        OutboundComm reloadedComm = OutboundComm.FromIdentity(comm.Identity);                          // active object doesn't update as we get results' so need to load                          // from database to get final counts of successes and fails                        if (comm.RecipientCount > 1 && comm.SenderPersonId != 0)                      {                          BotLog.Write(2' "CommsTx"' "--notifying");                            ICommsResolver resolver = FindResolver(comm);                            // "Your message to [GeographyName] has been sent to all scheduled recipients. Of the [RecipientCount] planned recipients'                          // [RecipientsSuccess] succeeded from Swarmops' horizon. (These can fail later for a number of reasons' from broken                          // computers to hospitalized recipients.) Time spent transmitting: [TransmissionTime]."                            NotificationStrings notifyStrings = new NotificationStrings();                          NotificationCustomStrings customStrings = new NotificationCustomStrings();                          notifyStrings[NotificationString.OrganizationName] =                              Organization.FromIdentity(comm.OrganizationId).Name;                          customStrings["RecipientCount"] = reloadedComm.RecipientCount.ToString("N0");                          customStrings["RecipientsSuccess"] = reloadedComm.RecipientsSuccess.ToString("N0");                            TimeSpan resolveTime = comm.StartTransmitDateTime - comm.CreatedDateTime;                          TimeSpan transmitTime = comm.ClosedDateTime - comm.StartTransmitDateTime;                          TimeSpan totalTime = resolveTime + transmitTime;                            customStrings["TransmissionTime"] = FormatTimespan(transmitTime);                          customStrings["ResolvingTime"] = FormatTimespan(resolveTime);                          customStrings["TotalTime"] = FormatTimespan(totalTime);                          if (resolver is IHasGeography)                          {                              customStrings["GeographyName"] = ((IHasGeography) resolver).Geography.Localized;                          }                          OutboundComm.CreateNotification(Organization.FromIdentity(comm.OrganizationId)'                              NotificationResource.OutboundComm_Sent' notifyStrings' customStrings'                              People.FromSingle(Person.FromIdentity(comm.SenderPersonId)));                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: if (args.Length > 0)              {                  if (args[0].ToLower() == "test")                  {  /*                      BotLog.Write(0' "MainCycle"' "Running self-tests");                      HeartBeater.Instance.Beat(heartbeatFile);  // Otherwise Heartbeater.Beat() will fail in various places                        testMode = true;                      Console.WriteLine("Testing All Maintenance Processes (except membership-changing ones).");                      PWLog.Write(PWLogItem.None' 0' PWLogAction.SystemTest' string.Empty' string.Empty);                        Console.WriteLine("\r\n10-second intervals:");                      OnEveryTenSeconds();                      Console.WriteLine("\r\nEvery minute:");                      OnEveryMinute();                      Console.WriteLine("\r\nEvery five minutes:");                      OnEveryFiveMinutes();                      Console.WriteLine("\r\nEvery hour:");                      OnEveryHour();                      Console.WriteLine("\r\nNoon:");                      OnNoon();                      Console.WriteLine("\r\nMidnight:");                      OnMidnight();                      */                        Console.WriteLine ("Testing database access...");                        Console.WriteLine (SwarmDb.GetDatabaseForReading().GetPerson (1).Name);                      Console.WriteLine (SwarmDb.GetDatabaseForReading().GetPerson (1).PasswordHash);                        Console.WriteLine ("Creating OutboundComm...");                        OutboundComm.CreateNotification (null' NotificationResource.System_Startup_Backend);                        Console.WriteLine ("Transmitting...");                        OutboundComms comms = OutboundComms.GetOpen();                        Console.WriteLine ("{0} open items in outbound comms."' comms.Count);                        foreach (OutboundComm comm in comms)                      {                          if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                          {                              throw new NotImplementedException();                          }                            ICommsTransmitter transmitter = new CommsTransmitterMail();                            OutboundCommRecipients recipients = comm.Recipients;                          PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                            foreach (OutboundCommRecipient recipient in recipients)                          {                              transmitter.Transmit (envelope' recipient.Person);                          }                      }                          Console.Write ("\r\nAll tests run. Waiting for mail queue to flush... ");                      while (!MailTransmitter.CanExit)                      {                          Thread.Sleep (50);                      }                        Console.WriteLine ("done.");                      BotLog.Write (0' "MainCycle"' "Exiting self-tests");                      return;                  }                    if (args[0].ToLower() == "console")                  {                      Console.WriteLine ("\r\nRunning Swarmops-Backend in CONSOLE mode.\r\n");                        // -------------------------------------------------------------------------------------                      // -------------------------------------------------------------------------------------                      // -------------------------------------------------------------------------------------                        // -----------------------    INSERT ANY ONE-OFF ACTIONS HERE  -------------------------                          Console.Write ("\r\nWaiting for mail queue to flush... ");                        while (!MailTransmitter.CanExit)                      {                          Thread.Sleep (50);                      }                        Console.WriteLine ("done.");                        return;                  }                    if (args[0].ToLowerInvariant() == "pdfregen")                  {                      if (args.Length > 1)                      {                          int docId = Int32.Parse(args[1]);                          PdfProcessor.Rerasterize(Document.FromIdentity(docId));                      }                      else                      {                          Console.WriteLine("Regenerating all bitmaps from PDF uploads.");                          PdfProcessor.RerasterizeAll();                          Console.WriteLine("Done.");                      }                        return;                  }                      if (args[0].ToLower() == "rsm")                  {                      Console.WriteLine ("Testing character encoding: rδksmφrgεs RΔKSMΦRGΕS");                      return;                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: if (args.Length > 0)              {                  if (args[0].ToLower() == "test")                  {  /*                      BotLog.Write(0' "MainCycle"' "Running self-tests");                      HeartBeater.Instance.Beat(heartbeatFile);  // Otherwise Heartbeater.Beat() will fail in various places                        testMode = true;                      Console.WriteLine("Testing All Maintenance Processes (except membership-changing ones).");                      PWLog.Write(PWLogItem.None' 0' PWLogAction.SystemTest' string.Empty' string.Empty);                        Console.WriteLine("\r\n10-second intervals:");                      OnEveryTenSeconds();                      Console.WriteLine("\r\nEvery minute:");                      OnEveryMinute();                      Console.WriteLine("\r\nEvery five minutes:");                      OnEveryFiveMinutes();                      Console.WriteLine("\r\nEvery hour:");                      OnEveryHour();                      Console.WriteLine("\r\nNoon:");                      OnNoon();                      Console.WriteLine("\r\nMidnight:");                      OnMidnight();                      */                        Console.WriteLine ("Testing database access...");                        Console.WriteLine (SwarmDb.GetDatabaseForReading().GetPerson (1).Name);                      Console.WriteLine (SwarmDb.GetDatabaseForReading().GetPerson (1).PasswordHash);                        Console.WriteLine ("Creating OutboundComm...");                        OutboundComm.CreateNotification (null' NotificationResource.System_Startup_Backend);                        Console.WriteLine ("Transmitting...");                        OutboundComms comms = OutboundComms.GetOpen();                        Console.WriteLine ("{0} open items in outbound comms."' comms.Count);                        foreach (OutboundComm comm in comms)                      {                          if (comm.TransmitterClass != "Swarmops.Utility.Communications.CommsTransmitterMail")                          {                              throw new NotImplementedException();                          }                            ICommsTransmitter transmitter = new CommsTransmitterMail();                            OutboundCommRecipients recipients = comm.Recipients;                          PayloadEnvelope envelope = PayloadEnvelope.FromXml (comm.PayloadXml);                            foreach (OutboundCommRecipient recipient in recipients)                          {                              transmitter.Transmit (envelope' recipient.Person);                          }                      }                          Console.Write ("\r\nAll tests run. Waiting for mail queue to flush... ");                      while (!MailTransmitter.CanExit)                      {                          Thread.Sleep (50);                      }                        Console.WriteLine ("done.");                      BotLog.Write (0' "MainCycle"' "Exiting self-tests");                      return;                  }                    if (args[0].ToLower() == "console")                  {                      Console.WriteLine ("\r\nRunning Swarmops-Backend in CONSOLE mode.\r\n");                        // -------------------------------------------------------------------------------------                      // -------------------------------------------------------------------------------------                      // -------------------------------------------------------------------------------------                        // -----------------------    INSERT ANY ONE-OFF ACTIONS HERE  -------------------------                          Console.Write ("\r\nWaiting for mail queue to flush... ");                        while (!MailTransmitter.CanExit)                      {                          Thread.Sleep (50);                      }                        Console.WriteLine ("done.");                        return;                  }                    if (args[0].ToLowerInvariant() == "pdfregen")                  {                      if (args.Length > 1)                      {                          int docId = Int32.Parse(args[1]);                          PdfProcessor.Rerasterize(Document.FromIdentity(docId));                      }                      else                      {                          Console.WriteLine("Regenerating all bitmaps from PDF uploads.");                          PdfProcessor.RerasterizeAll();                          Console.WriteLine("Done.");                      }                        return;                  }                      if (args[0].ToLower() == "rsm")                  {                      Console.WriteLine ("Testing character encoding: rδksmφrgεs RΔKSMΦRGΕS");                      return;                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: using (                  _blockChainInfoSocket =                      new WebSocket("wss://ws.blockchain.info/inv?api_code=" + SystemSettings.BlockchainSwarmopsApiKey))              {                    // Begin maintenance loop                    DateTime cycleStartTime = DateTime.UtcNow;                  DateTime cycleEndTime;                    int lastSecond = cycleStartTime.Second;                  int lastMinute = cycleStartTime.Minute;                  int lastHour = cycleStartTime.Hour;                    bool exitFlag = false;                    _blockChainInfoSocket.OnOpen += new EventHandler(OnBlockchainOpen);                  _blockChainInfoSocket.OnError += new EventHandler<ErrorEventArgs>(OnBlockchainError);                  _blockChainInfoSocket.OnClose += new EventHandler<CloseEventArgs>(OnBlockchainClose);                  _blockChainInfoSocket.OnMessage += new EventHandler<MessageEventArgs>(OnBlockchainMessage);                    _blockChainInfoSocket.Connect();                    while (!exitFlag) // exit is handled by signals handling at end of loop                  {                      BotLog.Write(0' "MainCycle"' "Cycle Start");                        cycleStartTime = DateTime.UtcNow;                      cycleEndTime = cycleStartTime.AddSeconds(10);                        try                      {                          OnEveryTenSeconds();                            if (cycleStartTime.Second < lastSecond)                          {                              OnEveryMinute();                                if (cycleStartTime.Minute%5 == 0)                              {                                  OnEveryFiveMinutes();                              }                          }                            if (cycleStartTime.Minute < lastMinute)                          {                              OnEveryHour();                                if (DateTime.Now.Hour == 10 && DateTime.Today.DayOfWeek == DayOfWeek.Tuesday)                              {                                  OnTuesdayMorning();                              }                                if (DateTime.Now.Hour == 7 && DateTime.Today.DayOfWeek == DayOfWeek.Monday)                              {                                  OnMondayMorning();                              }                          }                            if (cycleStartTime.Hour >= 12 && lastHour < 12)                          {                              OnNoon();                          }                            if (cycleStartTime.Hour < lastHour)                          {                              OnMidnight();                          }                      }                        catch (Exception e)                      {                          // Note each "OnEvery..." catches its own errors and sends Exception mails'                          // so that failure in one should not stop the others from running. This particular                          // code should never run.                            ExceptionMail.Send(new Exception("Failed in swarmops-backend main loop"' e)' true);                      }                        lastSecond = cycleStartTime.Second;                      lastMinute = cycleStartTime.Minute;                      lastHour = cycleStartTime.Hour;                        // Wait for a maximum of ten seconds (the difference between cycleStartTime and cycleEndTime)                        int iterationCount = 0;                      DateTime utcNow = DateTime.UtcNow;                      while (utcNow < cycleEndTime && !exitFlag)                      {                          int signalIndex = 250;                            // Handle important service orders (those that can't be lost in a random loss                          // of connection of a socket):                            BackendServiceOrders backendOrders = BackendServiceOrders.GetNextBatch(5);                          backendOrders.Execute(); // takes at most 250ms per BSO reqs                            // Block until a SIGINT or SIGTERM signal is generated' or 1/4 second has passed.                          // However' we can't do that in a development environment - it won't have the                          // Mono.Posix assembly' and won't understand UnixSignals. So people running this in                          // a dev environment will need to stop it manually.                            if (!Debugger.IsAttached)                          {                              signalIndex = UnixSignal.WaitAny(killSignals' 250);                          }                          else                          {                              TimeSpan timeLeft = (cycleEndTime - utcNow);                                BotLog.Write(0' "MainCycle Debug"'                                  string.Format(CultureInfo.InvariantCulture'                                      "Waiting for {0:F2} more seconds for cycle end"'                                      timeLeft.TotalMilliseconds/1000.0));                              Thread.Sleep(250);                          }                            if (signalIndex < 250)                          {                              exitFlag = true;                              Console.WriteLine("Caught signal " + killSignals[signalIndex].Signum + "' exiting");                              BotLog.Write(0' "MainCycle"'                                  "EXIT SIGNAL (" + killSignals[signalIndex].Signum + ")' terminating backend");                          }                            utcNow = DateTime.UtcNow;                            // Every second' send an internal heartbeat                            if (iterationCount++%4 == 0)                          {                              InternalHeartbeat();                          }                      }                  }              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,Main,The following statement contains a magic number: Thread.Sleep (2000);
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,OnMidnight,The following statement contains a magic number: try              {                  BotLog.Write (0' "MainCycle"' "Midnight entry");                    try                  {                      if (!testMode)                      {                          /*TestTrace("Running RosterHousekeeping.ChurnExpiredMembers()...");                          RosterHousekeeping.ChurnExpiredMembers();                          TestTrace(" done.\r\n");*/                      }                        ExchangeRateSnapshot.Create();                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                                    try                  {                      BotLog.DeleteOld (14); // delete logs older than 14 days                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    try                  {                      /*TestTrace("Running SwedishForumMemberCheck.Run()...");                      SwedishForumMemberCheck.Run();                      TestTrace(" done.\r\n");*/                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    try                  {                      /*TestTrace("Running SalaryProcessor.Run()...");                      SalaryProcessor.Run();                      TestTrace(" done.\r\n");*/                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    try                  {                      /*TestTrace("Running TurnaroundTracker.Housekeeping()...");                      TurnaroundTracker.Housekeeping();                      TestTrace(" done.\r\n");*/                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    try                  {                      /*TestTrace("Running Mappery.CreateUngPiratUptakeMap()...");                      Mappery.CreateUngPiratUptakeMap();                      TestTrace(" done.\r\n");*/                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    try                  {                      /*TestTrace("Running RosterHousekeeping.TimeoutVolunteers()...");                      RosterHousekeeping.TimeoutVolunteers();                      TestTrace(" done.\r\n");*/                  }                  catch (Exception e)                  {                      TraceAndReport (e);                  }                    BotLog.Write (0' "MainCycle"' "Midnight exit");              }              catch (Exception e)              {                  ExceptionMail.Send (e' true);                  TestTrace (e.ToString());              }
Magic Number,Swarmops.Backend,BackendLoop,C:\repos\Swarmops_Swarmops\Backend\BackendLoop.cs,ProcessBitcoinTransaction,The following statement contains a magic number: foreach (JObject outpoint in blockchainTransaction["x"]["out"])              {                  Satoshis satoshis = Int64.Parse((string) outpoint["value"]);                  string addressString = (string) outpoint["addr"];                    HotBitcoinAddress hotAddress = null;                    try                  {                      hotAddress = HotBitcoinAddress.FromAddress(BitcoinChain.Cash' addressString);                  }                  catch (ArgumentException)                  {                      // Ignore this - it means the addressString isn't ours                      continue;                  }                    if (hotAddress != null)                  {                      JObject json = new JObject();                      json["MessageType"] = "BitcoinReceived";                      json["Address"] = addressString;                      json["Hash"] = txHash;                        Currency currency = hotAddress.Organization.Currency;                      json["OrganizationId"] = hotAddress.OrganizationId.ToString();                      json["Currency"] = currency.Code;                      Swarmops.Logic.Financial.Money organizationCents = new Money(satoshis' Currency.BitcoinCore).ToCurrency(currency);                      json["Satoshis"] = satoshis.ToString();                      json["Cents"] = organizationCents.Cents.ToString();                      json["CentsFormatted"] = String.Format("{0:N2}"' organizationCents.Cents/100.0);                        _socketServer.WebSocketServices.Broadcast(json.ToString());                        // TODO: Examine what address this is' handle accordingly                  }              }
