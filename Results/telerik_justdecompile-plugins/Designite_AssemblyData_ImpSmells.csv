Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\AssemblyResolver.cs,GetTypeResolver,Cyclomatic complexity of the method is 8
Complex Method,AssemblyData.methodsrewriter,CodeGenerator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\CodeGenerator.cs,UpdateExceptionHandlers,Cyclomatic complexity of the method is 8
Complex Method,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,Cyclomatic complexity of the method is 14
Long Statement,AssemblyData,AssemblyService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyService.cs,LoadAssemblyInternal,The length of the statement  "				throw new ApplicationException(string.Format("Could not load assembly {0}. Maybe it's 32-bit or 64-bit only?"' filename)' ex); " is 126.
Long Statement,AssemblyData,GenericService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\GenericService.cs,GetCreateUserServiceMethod,The length of the statement  "			foreach (var method in createServiceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)) { " is 150.
Long Statement,AssemblyData,GenericService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\GenericService.cs,GetCreateUserServiceMethod,The length of the statement  "			throw new ApplicationException(string.Format("Failed to find create-service-method. Type token: Type: {0}"' createServiceType)); " is 128.
Long Statement,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\AssemblyResolver.cs,InitGlobalFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\AssemblyResolver.cs,InitGlobalMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,CodeGenerator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\CodeGenerator.cs,WriteSpecialInstr,The length of the statement  "				flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public; " is 127.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,CreateDelegate,The length of the statement  "			var dm = new DynamicMethod(newMethodInfo.rewrittenMethodName' typeof(object)' new Type[] { GetType()' typeof(object[]) }' newMethodInfo.oldMethod.Module' true); " is 160.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,CreateDelegate,The length of the statement  "			ilg.Emit(ROpCodes.Call' GetType().GetMethod("RtGetDelegateInstance"' BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Instance)); " is 146.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,CreateMethod,The length of the statement  "			var newMethodInfo = new NewMethodInfo(realMethod' newMethodInfos.Count' GetDelegateMethodName(realMethod)' GetDelegateMethodName(realMethod)); " is 142.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,CreateMethod,The length of the statement  "				throw new ApplicationException(string.Format("Method {0} ({1:X8}) has no body"' methodInfo.methodDef' methodInfo.methodDef.MDToken.Raw)); " is 137.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,GetStackTraceStackFramesField,The length of the statement  "			return ResolverUtils.GetFieldThrow(typeof(StackTrace)' typeof(StackFrame[])' flags' "Could not find StackTrace's frames (StackFrame[]) field"); " is 143.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,GetStackFrameMethodField,The length of the statement  "			return ResolverUtils.GetFieldThrow(typeof(StackFrame)' typeof(MethodBase)' flags' "Could not find StackFrame's method (MethodBase) field"); " is 139.
Long Statement,AssemblyData.methodsrewriter,MModule,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MModule.cs,InitGlobalMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MModule,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MModule.cs,InitGlobalFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MType.cs,InitMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MType.cs,InitFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\Resolver.cs,Resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve type {0} ({1:X8}) in assembly {2}"' typeRef' typeRef.MDToken.Raw' resolver)); " is 141.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\Resolver.cs,Resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve field {0} ({1:X8}) in assembly {2}"' fieldRef' fieldRef.MDToken.Raw' resolver)); " is 144.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\Resolver.cs,Resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve method {0} ({1:X8}) in assembly {2}"' methodRef' methodRef.MDToken.Raw' resolver)); " is 147.
Long Statement,AssemblyData.methodsrewriter,ResolverUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\ResolverUtils.cs,GetReturnType,The length of the statement  "			throw new ApplicationException(string.Format("Could not figure out return type: {0} ({1:X8})"' methodBase' methodBase.MetadataToken)); " is 134.
Long Statement,AssemblyData.methodsrewriter,TypeInstanceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\TypeInstanceResolver.cs,InitFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,TypeInstanceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\TypeInstanceResolver.cs,InitMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AssemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AddConfigFile,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyResolver.cs,AddConfigFile,The method has an empty catch block.
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,GetDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyServer,Start,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyServer.cs,Main,The following statement contains a magic number: if (args.Length != 3)  				Environment.Exit(1);
Magic Number,AssemblyServer,Start,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\AssemblyServer.cs,Main,The following statement contains a magic number: var uri = args[2];
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\AssemblyData\methodsrewriter\MethodsRewriter.cs,Update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						InsertLoadThis(block' i + 1);  						InsertCallOurMethod(block' i + 2' "static_RtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							InsertCallOurMethod(block' i + 2' "static_RtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.Replace(i' 1' OpCodes.Nop.ToInstruction());  							InsertLoadThis(block' i + 1);  							block.Insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							InsertCallOurMethod(block' i + 3' "RtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.GetMethod((IMethod)instr.Operand);  					if (method != null) {  						CreateMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.Replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = GetParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.Insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.Insert(n++' Create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.Insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						InsertLoadThis(block' n++);  						block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						InsertCallOurMethod(block' n++' "RtGetDelegateInstance");  						block.Insert(n++' Create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.Insert(n++' Create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.Insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.Insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.Insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						InsertLoadThis(block' n++);  						block.Insert(n++' Create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
