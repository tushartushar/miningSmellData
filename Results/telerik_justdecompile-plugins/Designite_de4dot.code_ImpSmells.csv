Implementation smell,Namespace,Class,File,Method,Description
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The method has 158 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The method has 157 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators,MethodStack,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodStack.cs,GetLoadedType,The method has 121 lines of code.
Long Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The method has 145 lines of code.
Long Method,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The method has 127 lines of code.
Long Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The method has 121 lines of code.
Long Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The method has 116 lines of code.
Long Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The method has 716 lines of code.
Long Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The method has 130 lines of code.
Long Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The method has 115 lines of code.
Long Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,The method has 132 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The method has 103 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 116 lines of code.
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,SplitMethodDesc,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,DeobfuscateMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,Deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,PrintNewTokens,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\PrintNewTokens.cs,PrintTokens,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code,StringInlinerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\StringInliner.cs,InlineReturnValues,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DeobfuscateEnd,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\ResourceDecrypter.cs,FindResourceType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,GetKeyArrayField,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,FindStringDecrypters,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,RestoreConstrainedPrefix,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandler,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,Detect,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CompositeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CompositeHandlerDetector.cs,Matches,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators,ArrayFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsTypeCalled,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,GetInitCctors,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,ExceptionLoggerRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,Find,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,MethodStack,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodStack.cs,GetPushedArgInstructions,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,FindProxyCall,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateFields,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,UnusedMethodsFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\UnusedMethodsFinder.cs,Check,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,FindRegisterMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,IsConstantDecrypter,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,CompareMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,FindDelegateCreator,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckDecryptMethodBabel2x,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindBundleType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindXmlParserType,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindStreamProviderType,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResourceEnumerator,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,IsTamperDetectionClass,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,GetResource,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,CheckMethodsV36,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,InlinedMethodTypes,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\InlinedMethodTypes.cs,IsValidType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,FindFieldTypes,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,FindFieldTypes,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,Restore,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreateMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreatorType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFrameworkV1,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindSilverlight,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate3,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,FindFieldsToKeep,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV4,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV404_41,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,Deobfuscate,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,CanInline,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,GetMovedTypes,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,GetPossibleFields,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,CheckMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV40,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKeyShift,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,LibAssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\LibAssemblyResolver.cs,CheckInitMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,GetPatchInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,CheckType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,Deobfuscate,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,FindInitMethod,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckCalledMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetFlagsLocal,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindResourceFromStringBuilder,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocode,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindIntsCctor,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3New,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,Cyclomatic complexity of the method is 24
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Initialize,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,GetDecrypterInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,FindDelegateInitType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,LocalsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\LocalsRestorer.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Goliath_NET,LocalsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\LocalsRestorer.cs,Deobfuscate,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,CheckProxyMethod,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,CheckDecrypterType,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.ILProtector,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MainType.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,RemoveDuplicateEmbeddedResources,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectVersion,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetStringInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitializeBaseOffs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GetTypeIdAttribute,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitStringDecrypterInfos,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,CheckAttachAppMethod,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindSimpleZipTypeMethod,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,RenameResources,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,Deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,RestoreMethodBodies,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,CheckRestoreBody,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,CheckMethodsType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,CheckMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,IsTypeWithThousandsOfMethods,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer.asmmodules,MemberRefFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\MemberRefFinder.cs,GetObjectType2,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer.asmmodules,Module,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\Module.cs,ResolveAllRefs,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\Modules.cs,InitAllTypes,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\Modules.cs,ResolveOther,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\Modules.cs,FindModules,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer.asmmodules,AssemblyKeyDictionary<T>,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\Modules.cs,TryGetSimilarValue,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,AddMembers,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,InstantiateVirtualMembers,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,MemberInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\MemberInfos.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RemoveUselessOverrides,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RemoveOneClassNamespaces,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RenameMethods2,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RenameMemberRefs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,ResetVirtualPropertyNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,ResetVirtualEventNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreVirtualProperties,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,CreatePropertyGetter,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,CreatePropertySetter,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreVirtualEvents,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreMethodArgs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,GetValidArgNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameEvent,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameProperty,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameVirtualMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,GroupHelper,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,GetResourceName,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,PrepareRenameFields,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethodArgs,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,GetFieldRef,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,GetVbHandler,Cyclomatic complexity of the method is 23
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeNames,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeNames.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.resources,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceReader.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 10
Long Parameter List,de4dot.code,Logger,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Logger.cs,Log,The method has 5 parameters. Parameters: canIgnore' sender' loggerEvent' format' args
Long Parameter List,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,Deobfuscate,The method has 5 parameters. Parameters: method' cflowDeobfuscator' methodPrinter' isVerbose' isVV
Long Parameter List,de4dot.code,OneArgOption,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Option.cs,OneArgOption,The method has 5 parameters. Parameters: shortName' longName' description' typeName' action
Long Parameter List,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The method has 5 parameters. Parameters: type' e1' e2' e3' code
Long Parameter List,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,DesDecrypt,The method has 5 parameters. Parameters: data' start' len' key' iv
Long Parameter List,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,AddInitializeArrayCode,The method has 5 parameters. Parameters: block' start' numToRemove' elementType' data
Long Parameter List,de4dot.code.deobfuscators,MemberRefBuilder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MemberReferenceBuilder.cs,Method,The method has 5 parameters. Parameters: isInstance' name' declaringType' returnType' args
Long Parameter List,de4dot.code.deobfuscators,MethodStack,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodStack.cs,GetLoadedType,The method has 5 parameters. Parameters: method' instructions' instrIndex' argIndexFromEnd' wasNewobj
Long Parameter List,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,FindProxyCall,The method has 5 parameters. Parameters: di' block' index' visited' stack
Long Parameter List,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Copy,The method has 5 parameters. Parameters: src' srcIndex' dst' dstIndex' size
Long Parameter List,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,GetLoadedType,The method has 5 parameters. Parameters: gpp' method' instructions' instrIndex' wasNewobj
Long Parameter List,de4dot.code.deobfuscators.CodeFort,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyData.cs,TypeInfo,The method has 5 parameters. Parameters: baseType' name' dcNamespace' dcName' fieldInfos
Long Parameter List,de4dot.code.deobfuscators.CodeFort,AssemblyInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' resource' asmFullName' asmSimpleName' extension
Long Parameter List,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Compare,The method has 5 parameters. Parameters: a1' i1' a2' i2' len
Long Parameter List,de4dot.code.deobfuscators.CodeWall,AssemblyInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' extension' assemblyFullName' assemblySimpleName' isEntryPointAssembly
Long Parameter List,de4dot.code.deobfuscators.CryptoObfuscator,ArrayInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,ArrayInfo,The method has 5 parameters. Parameters: start' len' arrayType' arySize' index
Long Parameter List,de4dot.code.deobfuscators.DeepSea,AssemblyInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' fullName' simpleName' extension' resource
Long Parameter List,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail,The method has 7 parameters. Parameters: magic2' magic3' keyCharOffs' cachedIndexOffs' flagsOffset' flag' keyDispl
Long Parameter List,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The method has 5 parameters. Parameters: peImage' simpleDeobfuscator' dumpedMethods' tokenToNativeCode' unpackedNativeFile
Long Parameter List,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetTheOnlyMethod,The method has 5 parameters. Parameters: type' typeName' methodName' returnType' parameters
Long Parameter List,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetIndexOfCall,The method has 5 parameters. Parameters: instrs' startIndex' endIndex' returnType' parameters
Long Parameter List,de4dot.code.deobfuscators.ILProtector,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,Copy,The method has 5 parameters. Parameters: src' srcIndex' dst' dstIndex' size
Long Parameter List,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_12_3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecryptCallback,The method has 5 parameters. Parameters: a' pMethodCode' methodSize' methodId' e
Long Parameter List,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecryptCallback,The method has 5 parameters. Parameters: a' pMethodCode' methodSize' methodId' e
Long Parameter List,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,MethodInfos,The method has 5 parameters. Parameters: module' mainType' peImage' peHeader' mcKey
Long Parameter List,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt,The method has 5 parameters. Parameters: decrypter' type' dataOffset' encryptedSize' realSize
Long Parameter List,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The method has 6 parameters. Parameters: outBuf' outIndex' outLen' inBuf' inIndex' inLen
Long Parameter List,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,CreateProperty,The method has 5 parameters. Parameters: ownerType' name' propType' getter' setter
Long Identifier,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobfuscatorBase.cs,,The length of the parameter DEFAULT_ASIAN_VALID_NAME_REGEX is 30.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp2 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceSet_GetDefaultReader is 37.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceReaderTypeDict is 31.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceReaderType_fields is 34.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceStreamType_fields is 34.
Long Identifier,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,,The length of the parameter foundCryptoObfuscatorAttribute is 30.
Long Identifier,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the parameter compileMethodHasConstant_0x70000000 is 35.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the parameter CompileAssemblyFromSourceBatch2 is 31.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,,The length of the parameter codeCompilerMethodCallRestorer is 30.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,,The length of the parameter getManifestResourceStreamTypeResource is 37.
Long Identifier,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,,The length of the parameter methodReaderHasDelegateTypeFlag is 31.
Long Identifier,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_12_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,,The length of the parameter getCallerMethodAsILByteArrayDelegate is 36.
Long Identifier,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_12_3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,,The length of the parameter getCallerMethodAsILByteArrayDelegate is 36.
Long Identifier,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,,The length of the parameter getCallerMethodAsILByteArrayDelegate is 36.
Long Identifier,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,,The length of the parameter initializeVirtualMembersCalled is 30.
Long Statement,de4dot.code,DumpedMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\DumpedMethodsRestorer.cs,GetMethodBody,The length of the statement  "			methodBody = MethodBodyReader.CreateCilBody(module' dm.code' dm.extraSections' parameters' dm.mhFlags' dm.mhMaxStack' dm.mhCodeSize' dm.mhLocalVarSigTok); " is 154.
Long Statement,de4dot.code,MethodPrinter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodPrinter.cs,Print,The length of the statement  "					Logger.Log(loggerEvent' "{0'-9} {1} // {2:X8}"' instrString' Utils.RemoveNewlines(operandString)' memberRef.MDToken.ToUInt32()); " is 128.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,UnpackNativeImage,The length of the statement  "						Logger.w("Could not load unpacked data. File: {0}' deobfuscator: {0}"' peImage.FileName ?? "(unknown filename)"' deob.TypeLong); " is 128.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,The length of the statement  "					if (method.MethodSig.GetRetType().GetElementType() != ElementType.String && method.MethodSig.GetRetType().GetElementType() != ElementType.Object) " is 145.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,The length of the statement  "					Logger.v("Adding string decrypter; token: {0:X8}' method: {1}"' method.MDToken.ToInt32()' Utils.RemoveNewlines(method.FullName)); " is 129.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,FindCliSecureAttribute,The length of the statement  "				if (Utils.StartsWith(type.FullName' "SecureTeam.Attributes.ObfuscatedByCliSecureAttribute"' StringComparison.Ordinal)) { " is 120.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,FindCliSecureAttribute,The length of the statement  "				else if (Utils.StartsWith(type.FullName' "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute"' StringComparison.Ordinal)) { " is 127.
Long Statement,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsOldHeader,The length of the statement  "			if ((uint)methodDefTable.StartOffset - peImage.RvaToOffset((uint)peImage.Cor20Header.MetaData.VirtualAddress) != codeHeader.methodDefTableOffset) " is 145.
Long Statement,de4dot.code.deobfuscators.Agile_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\ResourceDecrypter.cs,FindResourceType,The length of the statement  "				var resolveHandler = DotNetUtils.GetMethod(type' "System.Reflection.Assembly"' "(System.Object'System.ResolveEventArgs)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,Csvm,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\Csvm.cs,GetVmOpCodeHandlerDetector,The length of the statement  "				deobfuscatorContext.SetData(dataKey' dict = new Dictionary<string' VmOpCodeHandlerDetector>(StringComparer.OrdinalIgnoreCase)); " is 127.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,endfinally_check,The length of the statement  "			return DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 152.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ldtoken_check,The length of the statement  "			return DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,leave_check,The length of the statement  "			return !DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)") && " is 140.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,leave_check,The length of the statement  "				!DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 131.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ret_check,The length of the statement  "			return DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,throw_check,The length of the statement  "			return !DotNetUtils.CallsMethod(info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 153.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,Csvm,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\Csvm.cs,GetVmOpCodeHandlerDetector,The length of the statement  "				deobfuscatorContext.SetData(dataKey' dict = new Dictionary<string' VmOpCodeHandlerDetector>(StringComparer.OrdinalIgnoreCase)); " is 127.
Long Statement,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The length of the statement  "				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl]; " is 121.
Long Statement,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The length of the statement  "				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl]; " is 121.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "				var runtimeHelpersType = DotNetUtils.FindOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System.Runtime.CompilerServices"' "RuntimeHelpers"' false); " is 157.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "				var systemArrayType = DotNetUtils.FindOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System"' "Array"' false); " is 120.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "				var runtimeFieldHandleType = DotNetUtils.FindOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System"' "RuntimeFieldHandle"' true); " is 139.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "				initializeArrayMethod = module.UpdateRowId(new MemberRefUser(module' "InitializeArray"' methodSig' runtimeHelpersType.TypeDefOrRef)); " is 133.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,AddInitializeArrayCode,The length of the statement  "			block.Replace(index++' numToRemove' Instruction.CreateLdcI4(data.Length / elementType.ToTypeSig().ElementType.GetPrimitiveSize())); " is 131.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateOurType,The length of the statement  "			ourType = new TypeDefUser(""' string.Format("<PrivateImplementationDetails>{0}"' GetModuleId())' module.CorLibTypes.Object.TypeDefOrRef); " is 137.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,CreateGetManifestResourceStream1,The length of the statement  "			var newMethod = builder.InstanceMethod("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' builder.String); " is 123.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,CreateGetManifestResourceStream2,The length of the statement  "			var newMethod = builder.InstanceMethod("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' typeType' builder.String); " is 133.
Long Statement,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,FindSection,The length of the statement  "				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,FixBrokenCalls,The length of the statement  "					Logger.w("Holy obfuscator bugs' Batman! Found a proxy delegate call with no instance push in {0:X8}. Replacing it with a throw..."' obfuscatedMethod.MDToken.ToInt32()); " is 168.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,RestoreFieldTypes,The length of the statement  "				Logger.v("Field {0:X8}: type {1} ({2:X8})"' updatedField.token' Utils.RemoveNewlines(updatedField.newFieldType.FullName)' updatedField.newFieldType.MDToken.ToInt32()); " is 167.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The length of the statement  "							AddMethodArgType(method' GetParameter(methodParams' ldInstr)' DotNetUtils.GetArg(calledMethodParams' calledMethodParamIndex)); " is 126.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateFields,The length of the statement  "						calledMethodArgs = DotNetUtils.ReplaceGenericParameters(calledMethodDefOrRef.DeclaringType.TryGetGenericInstSig()' calledMethodSpec' calledMethodArgs); " is 151.
Long Statement,de4dot.code.deobfuscators,ValueInlinerBase<TValue>,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ValueInlinerBase.cs,Add,The length of the statement  "				throw new ApplicationException(string.Format("Handler for method {0:X8} has already been added"' method.MDToken.ToInt32())); " is 124.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,The length of the statement  "					initializedDataCreator.AddInitializeArrayCode(block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef()' decrypted); " is 124.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,ScanForObfuscator,The length of the statement  "			methodsDecrypter = new MethodsDecrypter(module' resourceDecrypterCreator.Create()' DeobfuscatedFile.DeobfuscatorContext); " is 121.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The length of the statement  "			if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) { " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				int32ValueInliner.Add(constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt32((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				int64ValueInliner.Add(constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt64((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				singleValueInliner.Add(constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.DecryptSingle((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				doubleValueInliner.Add(constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.DecryptDouble((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,ReadMethodRef,The length of the statement  "			var mr = new MemberRefUser(module' method.Name' method.MethodSig.Clone()' babelMethodRef.DeclaringType.ToTypeDefOrRef()); " is 121.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call); " is 138.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The length of the statement  "				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) { " is 139.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "					if (!DotNetUtils.IsMethod(method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.RuntimeFieldHandle)") && " is 120.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "						!DotNetUtils.IsMethod(method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.Int32'System.RuntimeFieldHandle)")) " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,GetProxyCreatorType,The length of the statement  "				if (DotNetUtils.IsMethod(calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.MethodInfo)")) " is 128.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,GetProxyCreatorType,The length of the statement  "				if (DotNetUtils.IsMethod(calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.ConstructorInfo)")) " is 133.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The length of the statement  "				var decrypterBuilderMethod = DotNetUtils.GetMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)"); " is 139.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,The length of the statement  "				if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)") " is 128.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ReflectionToDNLibMethodCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,DoCall,The length of the statement  "				else if (sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit") { " is 148.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,CheckType,The length of the statement  "			if (DotNetUtils.GetMethod(type' "System.Byte[]"' "(System.Byte[]'System.String'System.String'System.Int32'System.String'System.Int32)") == null) " is 144.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,Decrypt,The length of the statement  "			var key = new Rfc2898DeriveBytes(password.passphrase' Encoding.UTF8.GetBytes(password.salt)' iterations).GetBytes(numBits / 8); " is 127.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,GetAssemblyInfos,The length of the statement  "				infos.Add(new AssemblyInfo(asmData' resource' mod.Assembly.FullName' mod.Assembly.Name.String' DeobUtils.GetExtension(mod.Kind))); " is 130.
Long Statement,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckMethods,The length of the statement  "				if (DotNetUtils.IsMethod(method' "System.MulticastDelegate"' "(System.Type'System.Reflection.MethodInfo'System.Int32)")) " is 120.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,The length of the statement  "				if (!FindManifestResourceStreamMethods(type' out getManifestResourceStreamMethodTmp1' out getManifestResourceStreamMethodTmp2)) " is 127.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindXxteaMethod,The length of the statement  "				else if (DotNetUtils.IsMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) { " is 218.
Long Statement,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call); " is 133.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,GetMainResourceKey,The length of the statement  "				return BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(new ASCIIEncoding().GetBytes(keyInfo))).Replace("-"' ""); " is 129.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,DecryptAllAssemblies,The length of the statement  "				assemblyInfos.Add(new AssemblyInfo(assemblyData' DeobUtils.GetExtension(theModule.Kind)' theModule.Assembly.FullName' theModule.Assembly.Name.String' isMain)); " is 159.
Long Statement,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,InitializeStringDecrypter,The length of the statement  "				staticStringInliner.Add(info.Method' (method' gim' args) => stringDecrypter.Decrypt(method' (int)args[0]' (int)args[1]' (int)args[2])); " is 135.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,CheckInitMethod,The length of the statement  "				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,GetResource,The length of the statement  "					resource = DotNetUtils.GetResource(module' Encoding.UTF8.GetString(Convert.FromBase64String(name))) as EmbeddedResource; " is 120.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,ScanForObfuscator,The length of the statement  "			foundObfuscatorUserString = Utils.StartsWith(module.ReadUserString(0x70000001)' "\u0011\"3D9B94A98B-76A8-4810-B1A0-4BE7C4F9C98D"' StringComparison.Ordinal); " is 156.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				int32ValueInliner.Add(constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt32((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				int64ValueInliner.Add(constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt64((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				singleValueInliner.Add(constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.DecryptSingle((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				doubleValueInliner.Add(constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.DecryptDouble((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DumpEmbeddedAssemblies,The length of the statement  "					DumpEmbeddedFile(info.symbolsResource' info.assemblyName' ".pdb"' string.Format("Embedded pdb: {0}"' info.assemblyName)); " is 121.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DumpEmbeddedFile,The length of the statement  "			DeobfuscatedFile.CreateAssemblyFile(resourceDecrypter.Decrypt(resource.GetResourceStream())' Utils.GetAssemblySimpleName(assemblyName)' extension); " is 147.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call); " is 120.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFrameworkV1,The length of the statement  "					if (!DotNetUtils.CallsMethod(method' "System.Void"' "(System.Array'System.Int32'System.Array'System.Int32'System.Int32)")) " is 122.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,MergeResources,The length of the statement  "			DeobUtils.DecryptAndAddResources(module' resource.Name.String' () => resourceDecrypter.Decrypt(resource.Data.CreateStream())); " is 126.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The length of the statement  "				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 134.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The length of the statement  "				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The length of the statement  "					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3Old,The length of the statement  "			return DotNetUtils.CallsMethod(method' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)") && " is 121.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckResolverInitMethodInternal,The length of the statement  "			return DotNetUtils.CallsMethod(resolverInitMethod' "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)"); " is 132.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV4,The length of the statement  "				if (!DotNetUtils.IsMethod(decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)")) " is 131.
Long Statement,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,Deobfuscate,The length of the statement  "							AddCast(block' castIndex' i + 1' instr.Instruction.GetArgumentType(blocks.Method.MethodSig' blocks.Method.DeclaringType)); " is 122.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,Initialize,The length of the statement  "						var newField = module.UpdateRowId(new FieldDefUser(structField.Name' structField.FieldSig.Clone()' structField.Attributes)); " is 124.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,CheckMethods,The length of the statement  "				if (type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount() == 0) " is 138.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckResolverInitMethodInternal,The length of the statement  "			return DotNetUtils.CallsMethod(resolverInitMethod' "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)"); " is 132.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,DecryptResource,The length of the statement  "			string name = string.Format("Embedded data field {0:X8} RVA {1:X8}"' resourceField.MDToken.ToInt32()' (uint)resourceField.RVA); " is 127.
Long Statement,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,RemoveInitializeArrayCall,The length of the statement  "				if (calledMethod.ToString() != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 149.
Long Statement,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,GetArrayInfo,The length of the statement  "					var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 134.
Long Statement,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindEncryptedStrings,The length of the statement  "					var instrs = DotNetUtils.GetInstructions(initMethod.Body.Instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 121.
Long Statement,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "				staticStringInliner.Add(info.method' (method' gim' args) => stringDecrypter.Decrypt(method' (string)args[0]' (int)args[1])); " is 124.
Long Statement,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The length of the statement  "			foreach (var method in DotNetUtils.FindMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) { " is 130.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the statement  "				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)"); " is 120.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the statement  "				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm"); " is 127.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The length of the statement  "				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva); " is 128.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,GetCompileMethodType,The length of the statement  "			if (DotNetUtils.IsMethod(method' "System.UInt32"' "(System.UInt64&'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr&'System.UInt32&)")) " is 142.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,GetCompileMethodType,The length of the statement  "			if (DotNetUtils.IsMethod(method' "System.UInt32"' "(System.IntPtr'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr'System.UInt32&)")) " is 140.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDom1         = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 258.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFile1        = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 242.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSource1      = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 244.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDom2         = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit"); " is 254.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDomBatch2    = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDomBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 261.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFile2        = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 238.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFileBatch2   = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFileBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 245.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSource2      = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 240.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSourceBatch2 = GetTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSourceBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 247.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromDom,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromDom"' CodeDomProvider' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 141.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromFile,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromFile"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 133.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromSource,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromSource"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 135.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromDom,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromDom"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnit)); " is 134.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromDomBatch,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromDomBatch"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 144.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromFile,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromFile"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 134.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromFileBatch,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromFileBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromSource,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromSource"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromSourceBatch,The length of the statement  "			Add(oldMethod' builder.InstanceMethod("CompileAssemblyFromSourceBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 138.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod1,The length of the statement  "			return BinOp3(BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[0].DeclaringType.MDToken.ToInt32()' efConstMethods[4].DeclaringType.MDToken.ToInt32()))' ConstMethod6()); " is 199.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The length of the statement  "			return BinOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' ConstMethod4()))); " is 251.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The length of the statement  "			return BinOp3(BinOp1(ConstMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' BinOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2)); " is 209.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The length of the statement  "			return BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32()))))); " is 352.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The length of the statement  "			return BinOp2(BinOp2(ConstMethod3()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' ConstMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32()); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The length of the statement  "			return BinOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' BinOp3(BinOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' ConstMethod5()))); " is 263.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,StringDecrypterBugWorkaround,The length of the statement  "			var newType = module.UpdateRowId(new TypeDefUser(Guid.NewGuid().ToString("B")' module.CorLibTypes.Object.TypeDefOrRef)); " is 120.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,StringDecrypterBugWorkaround,The length of the statement  "			var newMethod = module.UpdateRowId(new MethodDefUser("x"' MethodSig.CreateStatic(module.CorLibTypes.Void)' 0' MethodAttributes.Static | MethodAttributes.HideBySig)); " is 165.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DynocodeService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DynocodeService.cs,CreateEnumerator,The length of the statement  "			foreach (var method in ienumerable.GetType().GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { " is 156.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DynocodeService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DynocodeService.cs,FindEnumeratorMethods,The length of the statement  "			foreach (var method in ienumerable.GetType().GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { " is 156.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckDecrypterMethod,The length of the statement  "				if (calledMethod != null && calledMethod.FullName == "System.IO.Stream System.Reflection.Assembly::GetManifestResourceStream(System.String)") " is 141.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindResourceFromStringBuilder,The length of the statement  "			int endIndex = EfUtils.FindOpCodeIndex(method' startIndex' Code.Call' "System.String System.Text.StringBuilder::ToString()"); " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindResourceFromStringBuilder,The length of the statement  "				if (instr.OpCode.Code == Code.Call && instr.Operand.ToString() == "System.Text.StringBuilder System.Text.StringBuilder::Append(System.Char)") { " is 143.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The length of the statement  "					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4) " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The length of the statement  "					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4) " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadInt16,The length of the statement  "			return FindCall(stringMethod' ref index' streamHelperType == null ? "System.Int16 System.IO.BinaryReader::ReadInt16()" : streamHelperType.readInt16Method.FullName); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadInt32,The length of the statement  "			return FindCall(stringMethod' ref index' streamHelperType == null ? "System.Int32 System.IO.BinaryReader::ReadInt32()" : streamHelperType.readInt32Method.FullName); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadBytes,The length of the statement  "			return FindCall(stringMethod' ref index' streamHelperType == null ? "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)" : streamHelperType.readBytesMethod.FullName); " is 177.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallGetFrame,The length of the statement  "			return FindCall(method' ref index' "System.Diagnostics.StackFrame System.Diagnostics.StackTrace::GetFrame(System.Int32)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,ArrayValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\ArrayValueInliner.cs,InlineReturnValues,The length of the statement  "				initializedDataCreator.AddInitializeArrayCode(block' callResult.callStartIndex' num' module.CorLibTypes.Byte.TypeDefOrRef' arrayData); " is 134.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The length of the statement  "				decryptedData[i] = (byte)(encryptedData[KEY_LEN + i] ^ encryptedData[(encryptedData[j] + encryptedData[ki]) % (KEY_LEN - 1)]); " is 126.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,Decrypt,The length of the statement  "				throw new ApplicationException(string.Format("Probably a new version. Could not decrypt method. ID:{0}' RID:{1:X4}"' methodId' rid)); " is 133.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV1_0_7_0,The length of the statement  "			return FindDelegateField(mainType' "System.Boolean"' "(System.Int32'System.Int32'System.Int32'System.Byte*&'System.Int32&)"); " is 125.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_0_0,The length of the statement  "			return FindDelegateField(mainType' "System.Boolean"' "(System.Int32'System.Int32'System.Int32'System.Int32'System.Byte*&'System.Int32&)"); " is 138.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_8_0,The length of the statement  "			return FindDelegateField(mainType' "System.Boolean"' string.Format("(System.Int32'System.Int32'System.Int32'System.Int32'{0}'System.Delegate&)"' type.FullName)); " is 161.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_8_5,The length of the statement  "			return FindDelegateField(mainType' "System.Boolean"' string.Format("(System.Int32'System.Int32'System.Int32'System.Int32'System.Diagnostics.StackTrace'{0}'System.Delegate&)"' type.FullName)); " is 191.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_9_0,The length of the statement  "			return FindDelegateField(mainType' "System.Boolean"' string.Format("(System.Int32'System.Int32'System.Int32'System.Int32'System.Diagnostics.StackTrace'{0})"' type.FullName)); " is 174.
Long Statement,de4dot.code.deobfuscators.ILProtector,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetNativeAddressOfDelegate,The length of the statement  "				var field = typeof(Delegate).GetField("_methodPtrAux"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 125.
Long Statement,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_8_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,Decrypt,The length of the statement  "				if (!decryptMethod(Environment.Version.Major' appDomainId' asmHashCode' methodId' MyDecryptCallback' out createdDelegate)) " is 122.
Long Statement,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_8_5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,Decrypt,The length of the statement  "				if (!decryptMethod(Environment.Version.Major' appDomainId' asmHashCode' methodId' new StackTrace()' MyDecryptCallback' out createdDelegate) && " is 142.
Long Statement,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The length of the statement  "					var del = (InitCode32Delegate)Marshal.GetDelegateForFunctionPointer(CodeAllocator.Allocate(initCode_x86)' typeof(InitCode32Delegate)); " is 134.
Long Statement,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The length of the statement  "					var del = (InitCode64Delegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + 0x00014CF0)' typeof(InitCode64Delegate)); " is 125.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsRestorer.cs,DecryptInternal,The length of the statement  "				decryptedData = client.GenericService.SendMessage(DynamicMethodsDecrypterService.MSG_DECRYPT_METHODS' new object[] { GetMethodIds() }) as IList<DecryptedMethodInfo>; " is 165.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsRestorer.cs,DecryptInternal,The length of the statement  "				MethodReaderHasDelegateTypeFlag = (bool)client.GenericService.SendMessage(DynamicMethodsDecrypterService.MSG_HAS_DELEGATE_TYPE_FLAG' new object[0]); " is 148.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptMethods,The length of the statement  "			var methodInfos = new MethodInfos(module' decrypterInfo.mainType' peImage' decrypterInfo.peHeader' decrypterInfo.mcKey); " is 120.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptMethods,The length of the statement  "				var mbHeader = MethodBodyParser.ParseMethodBody(MemoryImageStream.Create(info.body)' out dm.code' out dm.extraSections); " is 120.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The length of the statement  "					Logger.v("Decrypted string: {0}"' Utils.ToCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1))); " is 136.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v1' Decrypt4_v1' Decrypt2_v1' Decrypt3_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x462FA2D2 })); " is 161.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v1' Decrypt1_v1' Decrypt2_v1' Decrypt3_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x471299D3 })); " is 161.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "				case EncryptionVersion.V2: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v1' Decrypt2_v1' Decrypt1_v1' Decrypt4_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x482384FB' 0x4A5EEC64' 0x4BD6F703' 0x4C6220EC' 0x4C622357' 0x4C6E4605' 0x4D0E220D' 0x4DC2FC75' 0x4DC2FE0C' 0x4DFA3D5D })); break; " is 303.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "				case EncryptionVersion.V3: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v1' Decrypt2_v1' Decrypt3_v1' Decrypt4_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x4ECF2195' 0x4ED76740' 0x4EE1FAD1 })); break; " is 219.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "				case EncryptionVersion.V4: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt2_v1' Decrypt1_v1' Decrypt3_v1' Decrypt4_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x4F832868' 0x4F8C86BE' 0x4F9447DB' 0x4FDEF2FF })); break; " is 231.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v1' Decrypt2_v1' Decrypt3_v1' Decrypt1_v1' Decrypt5' Decrypt6' Decrypt7 }' new uint[] { 0x4F8E262C' 0x4F966B0B' 0x4FAB3CCF })); " is 185.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v2' Decrypt2_v2' Decrypt3_v2' Decrypt1_v2' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x4FC7459E' 0x4FCEBD7B })); " is 173.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v3' Decrypt2_v3' Decrypt3_v3' Decrypt1_v3' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x4FBE81DE })); " is 161.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "				case EncryptionVersion.V6: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v4' Decrypt2_v4' Decrypt3_v4' Decrypt1_v4' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x50A0963C })); break; " is 195.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "				case EncryptionVersion.V7: decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v5' Decrypt2_v5' Decrypt3_v5' Decrypt1_v5' Decrypt6' Decrypt8_v5' Decrypt9_v5' Decrypt7' Decrypt5 }' new uint[] { 0x50D367A5 })); break; " is 221.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v6' Decrypt2_v2' Decrypt3_v6' Decrypt1_v6' Decrypt6' Decrypt8_v6' Decrypt9_v6' Decrypt7' Decrypt10' Decrypt5 }' new uint[] { 0x5166DB4F' 0x51927495 })); " is 210.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v7' Decrypt2_v2' Decrypt3_v6' Decrypt1_v7' Decrypt6' Decrypt8_v7' Decrypt9_v7' Decrypt7' Decrypt5 }' new uint[] { 0x51413D68 })); " is 187.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v7' Decrypt2_v2' Decrypt3_v6' Decrypt1_v7' Decrypt6' Decrypt8_v8' Decrypt9_v8' Decrypt7' Decrypt5 }' new uint[] { 0x513D7124' 0x51413BD8 })); " is 199.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v5' Decrypt2_v2' Decrypt3_v6' Decrypt1_v9' Decrypt6' Decrypt8_v8' Decrypt9_v9' Decrypt7' Decrypt5 }' new uint[] { 0x513D4492' 0x5113E277 })); " is 199.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v6' Decrypt2_v2' Decrypt4_v8' Decrypt1_v10' Decrypt8_v9' Decrypt9_v10' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x526BDD12 })); " is 189.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v10' Decrypt4_v8' Decrypt2_v2' Decrypt3_v6' Decrypt6' Decrypt8_v9' Decrypt9_v10' Decrypt7' Decrypt5 }' new uint[] { 0x526BC020 })); " is 189.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt3_v7' Decrypt2_v6' Decrypt4_v9' Decrypt1_v11' Decrypt8_v10' Decrypt11_v1' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x5296E242' 0x52B3043C })); " is 202.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt4_v10' Decrypt1_v12' Decrypt3_v8' Decrypt2_v7' Decrypt6' Decrypt8_v11' Decrypt9_v11' Decrypt7' Decrypt5 }' new uint[] { 0x531729C4 })); " is 191.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt1_v13' Decrypt4_v11' Decrypt2_v8' Decrypt3_v9' Decrypt6' Decrypt8_v11' Decrypt9_v12' Decrypt7' Decrypt5 }' new uint[] { 0x52B2B2A3 })); " is 191.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeDecrypter,The length of the statement  "					decrypters.Add(new Decrypter(new DecryptFunc[] { Decrypt2_v9' Decrypt3_v10' Decrypt1_v10' Decrypt4_v12' Decrypt8_v12' Decrypt9_v13' Decrypt6' Decrypt7' Decrypt5 }' new uint[] { 0x53172907 })); " is 192.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,FindDecryptMethod,The length of the statement  "				if (!DotNetUtils.CallsMethod(method' "System.String System.Runtime.InteropServices.Marshal::PtrToStringAnsi(System.IntPtr)")) " is 125.
Long Statement,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,Initialize,The length of the statement  "				reader = new BinaryReader(new FileStream(decrypterMethod.DeclaringType.Module.Location' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 137.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolver.cs,RemoveDecryptedResource,The length of the statement  "				throw new ApplicationException(string.Format("Could not remove resource {0}"' Utils.ToCsharpString(info.resourceName))); " is 120.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,CheckResolverType,The length of the statement  "				DotNetUtils.FindFieldType(type' "System.Collections.Generic.Dictionary`2<System.String'System.Reflection.Assembly>"' true) != null) " is 131.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt); " is 137.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindDecrypterMethod,The length of the statement  "			var methods = new List<MethodDef>(DotNetUtils.FindMethods(stringsEncodingClass.Methods' "System.String"' new string[] { "System.Int32" })); " is 139.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The length of the statement  "			int start = FindCallMethod(block' index' true' (calledMethod) => calledMethod.ToString() == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()"); " is 173.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The length of the statement  "			index = FindCallMethod(block' index' false' (calledMethod) => calledMethod.ToString() == "System.String System.Reflection.Assembly::get_Location()"); " is 149.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,RemoveTamperProtection,The length of the statement  "					Logger.w("Could not remove tamper protection code: {0} ({1:X8})"' Utils.RemoveNewlines(blocks.Method)' blocks.Method.MDToken.ToUInt32()); " is 137.
Long Statement,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CheckCctor,The length of the statement  "				var instrs = DotNetUtils.GetInstructions(instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call); " is 122.
Long Statement,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "			staticStringInliner.Add(stringDecrypter.Method' (method' gim' args) => stringDecrypter.Decrypt((string)args[0]' (int)args[1])); " is 127.
Long Statement,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\TypeDef.cs,InstantiateVirtualMembers,The length of the statement  "					virtualMethodInstances.InitializeFrom(baseType.typeDef.virtualMethodInstances' baseType.typeRef.TryGetGenericInstSig()); " is 120.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,renameGenericParams2,The length of the statement  "					Logger.v("GenParam: {0} => {1}"' Utils.RemoveNewlines(info.oldFullName)' Utils.RemoveNewlines(param.GenericParam.FullName)); " is 124.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RenameMethods2,The length of the statement  "						Logger.v("Name: {0} => {1}"' Utils.RemoveNewlines(methodInfo.oldFullName)' Utils.RemoveNewlines(methodDef.MethodDef.FullName)); " is 127.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RenameMethods2,The length of the statement  "								Logger.v("Param ({0}/{1}): {2} => {3}"' param.ParameterDef.MethodSigIndex + 1' methodDef.MethodDef.MethodSig.GetParamCount()' Utils.RemoveNewlines(paramInfo.oldName)' Utils.RemoveNewlines(paramInfo.newName)); " is 208.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameMemberDefs,The length of the statement  "				else if (group.HasGetterOrSetterPropertyMethod() && GetPropertyMethodType(group.Methods[0]) != PropertyMethodType.Other) " is 120.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameProperty,The length of the statement  "				newPropName = GetAvailableName(propPrefix' trySameName' group' (group2' newName) => IsPropertyAvailable(group2' newName)); " is 122.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameEntryPoints,The length of the statement  "					Logger.w(string.Format("Could not find entry point. Module: {0}' Method: {1}"' module.ModuleDefMD.Location' Utils.RemoveNewlines(entryPoint))); " is 143.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The length of the statement  "					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)": " is 131.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The length of the statement  "					Logger.v("Renamed resource key {0} => {1}"' Utils.ToCsharpString(info.element.Name)' Utils.ToCsharpString(info.newName)); " is 121.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,The length of the statement  "						Logger.v("Possible resource name in code: '{0}' => '{1}' in method {2}"' Utils.RemoveNewlines(codeString)' newName' Utils.RemoveNewlines(method)); " is 146.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,The length of the statement  "						Logger.v("Renamed resource string in code: '{0}' => '{1}' ({2})"' Utils.RemoveNewlines(codeString)' newName' Utils.RemoveNewlines(method)); " is 139.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,IsCallingResourceManagerCtor,The length of the statement  "				if (newobj.Operand.ToString() != "System.Void System.Resources.ResourceManager::.ctor(System.String'System.Reflection.Assembly)") " is 129.
Long Statement,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethods2,The length of the statement  "				PrepareRenameGenericParams(methodDef.GenericParams' checker' methodDef.Owner == null ? null : methodDef.Owner.GenericParams); " is 125.
Long Statement,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitVbEventHandlers,The length of the statement  "				memberInfos.Method(handlerDef).suggestedName = string.Format("{0}_{1}"' memberInfos.Property(propDef).newName' eventName); " is 122.
Long Statement,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The length of the statement  "					memberInfos.Method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.Field(fieldDef).newName' eventName); " is 123.
Long Statement,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The length of the statement  "			var formatter = new BinaryFormatter(null' new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence)); " is 130.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The conditional expression  "sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.HasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]""  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The conditional expression  "LogicalOpShrUn != null && LogicalOpShl != null &&  					LogicalOpShr != null && LogicalOpAnd != null &&  					LogicalOpXor != null && LogicalOpOr != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The conditional expression  "CompareLt != null && CompareLte != null &&  					CompareGt != null && CompareGte != null &&  					CompareEq != null && CompareEqz != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The conditional expression  "ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null &&  					ArithmeticRemUn != null && ArithmeticRem != null &&  					ArithmeticDivUn != null && ArithmeticDiv != null &&  					ArithmeticMul != null && ArithmeticMulOvf != null &&  					ArithmeticSub != null && ArithmeticSubOvf != null &&  					ArithmeticAddOvfUn != null && ArithmeticAddOvf != null &&  					ArithmeticAdd != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The conditional expression  "versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Babel_NET,ReflectionToDNLibMethodCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,DoCall,The conditional expression  "sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit""  is complex.
Complex Conditional,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DeobfuscateEnd,The conditional expression  "!type.HasNestedTypes && !type.HasProperties && !type.HasEvents && !type.HasFields"  is complex.
Complex Conditional,de4dot.code.deobfuscators.CryptoObfuscator,AntiDebugger,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\AntiDebugger.cs,Find,The conditional expression  "!ContainsString(method' "debugger is activ") &&  					!ContainsString(method' "debugger is running") &&  					!ContainsString(method' "Debugger detected") &&  					!ContainsString(method' "Debugger was detected") &&  					!ContainsString(method' "{0} was detected") &&  					!ContainsString(method' "run under") &&  					!ContainsString(method' "run with") &&  					!ContainsString(method' "started under") &&  					!ContainsString(method' "{0} detected")"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The conditional expression  "!foundOpCodes.ContainsKey(Code.Brtrue) && !foundOpCodes.ContainsKey(Code.Brtrue_S) &&  					!foundOpCodes.ContainsKey(Code.Brfalse) && !foundOpCodes.ContainsKey(Code.Brfalse_S)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,CheckMethods,The conditional expression  "type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount() == 0"  is complex.
Complex Conditional,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The conditional expression  "clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The conditional expression  "CompileAssemblyFromDom1 == null && CompileAssemblyFromFile1 == null &&  					CompileAssemblyFromSource1 == null && CompileAssemblyFromDom2 == null &&  					CompileAssemblyFromDomBatch2 == null && CompileAssemblyFromFile2 == null &&  					CompileAssemblyFromFileBatch2 == null && CompileAssemblyFromSource2 == null &&  					CompileAssemblyFromSourceBatch2 == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,Find,The conditional expression  "getStream2 == null && getNames == null && getRefAsms == null &&  					bitmapCtor == null && iconCtor == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,StreamHelperType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,StreamHelperType,The conditional expression  "method.IsStatic || method.Body == null || method.IsPrivate || method.GenericParameters.Count > 0"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals11) &&  				CheckTypeFields(fields11)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals13) &&  				CheckTypeFields(fields13)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals14) &&  				CheckTypeFields(fields14)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals24) &&  				CheckTypeFields(fields24)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals26) &&  				CheckTypeFields(fields26)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals27) &&  				CheckTypeFields(fields27)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals28) &&  				CheckTypeFields(fields28)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals29) &&  				CheckTypeFields(fields29)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals30) &&  				CheckTypeFields(fields30)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals31) &&  				CheckTypeFields(fields31)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals32) &&  				CheckTypeFields(fields32)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,HasEmptyClassesInEveryNamespace,The conditional expression  "type.Name != "" || type.IsPublic || type.HasFields || type.HasMethods || type.HasProperties || type.HasEvents"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,CheckMethodsType,The conditional expression  "type.HasProperties || type.HasEvents || type.HasFields || type.HasNestedTypes"  is complex.
Complex Conditional,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethodArgs,The conditional expression  "(methodDef.Property != null && methodDef == methodDef.Property.SetMethod) ||  				(methodDef.Event != null && (methodDef == methodDef.Event.AddMethod || methodDef == methodDef.Event.RemoveMethod))"  is complex.
Virtual Method Call from Constructor,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The constructor "DecrypterV2_0_13_0_Base" calls a virtual method "InitCode".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClient.cs,WaitConnected,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,UnloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,UnloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,UnpackNativeImage,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators,MethodStack,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodStack.cs,GetPushedArgInstructions,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Babel_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\MethodsDecrypter.cs,GetFile,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,GetResource,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,GetResourceName,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,InitializeNameAndExtension,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,PatchRuntime,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,RuntimeFileInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\RuntimeFileInfo.cs,GetVersion2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,RuntimeFileInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\RuntimeFileInfo.cs,GetHash,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,GetMethodsData,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,GetMethodsData,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,GetRuntimeTimeStamp,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,GetRuntimeTimeStamp,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The method has an empty catch block.
Empty Catch Block,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,HasXamlFiles,The method has an empty catch block.
Empty Catch Block,de4dot.code.resources,ResourceDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceDataCreator.cs,GetSerializedTypeAndAssemblyName,The method has an empty catch block.
Magic Number,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClient.cs,WaitConnected,The following statement contains a magic number: while (true) {  				try {  					service.DoNothing();  					break;  				}  				catch (RemotingException) {  					// Couldn't connect  				}  				var elapsedTime = DateTime.UtcNow - startTime;  				if (elapsedTime.TotalMilliseconds >= MAX_CONNECT_WAIT_TIME_MS)  					throw new ApplicationException("Could not connect to server");  				Thread.Sleep(20);  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,GetServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize()) {  			default:  			case 4:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x86;  				return ServerClrVersion.CLR_v20_x86;    			case 8:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x64;  				return ServerClrVersion.CLR_v20_x64;  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,GetServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize()) {  			default:  			case 4:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x86;  				return ServerClrVersion.CLR_v20_x86;    			case 8:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x64;  				return ServerClrVersion.CLR_v20_x64;  			}
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.RandomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.RandomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.RandomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.RandomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,GetServerName,The following statement contains a magic number: if (serverVersion == ServerClrVersion.CLR_ANY_ANYCPU)  				serverVersion = IntPtr.Size == 4 ? ServerClrVersion.CLR_ANY_x86 : ServerClrVersion.CLR_ANY_x64;
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain(Utils.RandomName(15' 20));
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain(Utils.RandomName(15' 20));
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (thread != null) {  				try {  					if (!thread.Join(100))  						thread.Abort();  				}  				catch (ThreadStateException) {  					// Here if eg. the thread wasn't started  				}  				thread = null;  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (process != null) {  				if (!process.WaitForExit(300)) {  					try {  						process.Kill();  					}  					catch (InvalidOperationException) {  						// Here if process has already exited.  					}  				}  				process = null;  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.RemoveNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					GetLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.RemoveNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!GetArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,GetMethodTokens,The following statement contains a magic number: foreach (var val in options.StringDecrypterMethods) {  				var tokenStr = val.Trim();  				if (Utils.StartsWith(tokenStr' "0x"' StringComparison.OrdinalIgnoreCase))  					tokenStr = tokenStr.Substring(2);  				int methodToken;  				if (int.TryParse(tokenStr' NumberStyles.HexNumber' null' out methodToken))  					tokens.Add(methodToken);  				else  					tokens.AddRange(FindMethodTokens(val));  			}
Magic Number,de4dot.code,ObfuscatedFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\ObfuscatedFile.cs,SplitMethodDesc,The following statement contains a magic number: if (index >= 0) {  				type = remaining.Substring(0' index);  				remaining = remaining.Substring(index + 2);  			}
Magic Number,de4dot.code,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Utils.cs,ToCsharpString,The following statement contains a magic number: var sb = new StringBuilder(s.Length + 2);
Magic Number,de4dot.code,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Utils.cs,ShellEscape,The following statement contains a magic number: var sb = new StringBuilder(s.Length + 2);
Magic Number,de4dot.code,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code,Utils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find2,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors(module' 3)) {  				foreach (var calledMethod in DotNetUtils.GetCalledMethods(module' cctor)) {  					var type = calledMethod.DeclaringType;  					if (type.IsPublic)  						continue;  					var fieldTypes = new FieldTypes(type);  					if (!fieldTypes.All(requiredFields1))  						continue;  					if (!HasInitializeMethod(type' "_Initialize") && !HasInitializeMethod(type' "_Initialize64"))  						continue;    					initializeMethod = calledMethod;  					postInitializeMethod = FindMethod(type' "System.Void"' "PostInitialize"' "()");  					loadMethod = FindMethod(type' "System.IntPtr"' "Load"' "()");  					cliSecureRtType = type;  					FindStringDecrypters();  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Fields.Count < 1 || type.Fields.Count > 2)  					continue;  				var fieldTypes = new FieldTypes(type);  				if (!fieldTypes.Exactly(requiredFields6) && !fieldTypes.Exactly(requiredFields7))  					continue;  				if (type.Methods.Count != 2)  					continue;  				if (type.FindStaticConstructor() == null)  					continue;  				var cs = type.FindMethod("cs");  				if (cs == null)  					continue;    				AddStringDecrypterMethod(cs);  				cliSecureRtType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Fields.Count < 1 || type.Fields.Count > 2)  					continue;  				var fieldTypes = new FieldTypes(type);  				if (!fieldTypes.Exactly(requiredFields6) && !fieldTypes.Exactly(requiredFields7))  					continue;  				if (type.Methods.Count != 2)  					continue;  				if (type.FindStaticConstructor() == null)  					continue;  				var cs = type.FindMethod("cs");  				if (cs == null)  					continue;    				AddStringDecrypterMethod(cs);  				cliSecureRtType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: rxr = xl ^ P[16];
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: rxl = xr ^ P[17];
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: const int dataDirNum = 6;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: const int dotNetDirNum = 14;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: int dataDir = (int)dataDirBaseOffset + dataDirNum * 8;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: int dotNetDir = (int)dataDirBaseOffset + dotNetDirNum * 8;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32(fileData' dotNetDir + 4' BitConverter.ToUInt32(fileData' dataDir + 4));
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32(fileData' dotNetDir + 4' BitConverter.ToUInt32(fileData' dataDir + 4));
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32(fileData' dataDir + 4' 0);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile2,The following statement contains a magic number: var data = peImage.FindWin32ResourceData("ASSEMBLY"' 101' 0);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data[offset + 1] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data[offset + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data[offset + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (cliSecureAttributes.Count != 0)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsCsHeader40,The following statement contains a magic number: try {  				uint offset = codeHeaderOffset + codeHeader.totalCodeSize + 0x28;  				uint prevCodeOffs = 0;  				for (int i = 0; i < (int)codeHeader.numMethods; i++' offset += 4) {  					uint codeOffs = peImage.OffsetReadUInt32(offset);  					if (prevCodeOffs != 0 && codeOffs != 0 && codeOffs < prevCodeOffs)  						return false;  					if (codeOffs != 0)  						prevCodeOffs = codeOffs;  				}    				return true;  			}  			catch (IOException) {  				return false;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: var moduleCctorBytes = new byte[6];
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[2] = (byte)(initToken >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[2] = (byte)(initToken >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[3] = (byte)(initToken >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[3] = (byte)(initToken >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[4] = (byte)(initToken >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[4] = (byte)(initToken >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[5] = 0x2A;
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadCodeHeader,The following statement contains a magic number: codeHeader.signature = peImage.OffsetReadBytes(offset' 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadCodeHeader,The following statement contains a magic number: codeHeader.decryptionKey = peImage.OffsetReadBytes(offset + 0x10' 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: try {  				uint codeHeaderOffset = GetCodeHeaderOffset(peImage);  				if (IsValidSignature(peImage.OffsetReadBytes(codeHeaderOffset' 16)))  					return true;  			}  			catch {  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: try {  				uint codeHeaderOffset = GetOldCodeHeaderOffset(peImage);  				if (codeHeaderOffset != 0 && IsValidSignature(peImage.OffsetReadBytes(codeHeaderOffset' 16)))  					return true;  			}  			catch {  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter45,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - 0x28 + i) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ProDecrypter,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					key[i] = ReadUInt32_be(codeHeader.decryptionKey' i * 4);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ProDecrypter,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					key[i] = ReadUInt32_be(codeHeader.decryptionKey' i * 4);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: int numQwords = (int)(methodInfo.codeSize / 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = ReadUInt32_be(data' offset);  					uint q1 = ReadUInt32_be(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					WriteUInt32_be(data' offset' q0);  					WriteUInt32_be(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadUInt32_be,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadUInt32_be,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadUInt32_be,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadUInt32_be,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadUInt32_be,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,WriteUInt32_be,The following statement contains a magic number: data[offset] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,WriteUInt32_be,The following statement contains a magic number: data[offset + 1] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,WriteUInt32_be,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,WriteUInt32_be,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,WriteUInt32_be,The following statement contains a magic number: data[offset + 3] = (byte)value;
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos1,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 4) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					methodInfos.Add(new MethodInfo(codeOffs' 0' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos2,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 8) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos2,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 8) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.OffsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.OffsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.OffsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.OffsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.OffsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.OffsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.OffsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.OffsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.OffsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeader5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,PatchMethodTable,The following statement contains a magic number: foreach (var methodInfo in methodInfos) {  					offset += methodDefTable.RowSize;  					if (methodInfo.flags == 0 || methodInfo.codeOffs == 0)  						continue;  					uint rva = methodsDecrypter.peImage.OffsetReadUInt32(offset);  					methodsDecrypter.peImage.WriteUInt16(rva' (ushort)methodInfo.flags);  					methodsDecrypter.peImage.WriteUInt32(rva + 8' methodInfo.localVarSigTok);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs[2].OpCode != OpCodes.Ret)  				return null;
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (!type.HasMethods)  					continue;  				if (type.Methods.Count > 3)  					continue;    				MethodDef errorMethod = null;  				foreach (var method in type.Methods) {  					if (method.Name == ".ctor")  						continue;	// .ctor is allowed  					if (method.Name == ".cctor")  						continue;	// .cctor is allowed  					var sig = method.MethodSig;  					if (sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.HasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]") {  						errorMethod = method;  					}  					else  						break;  				}  				if (errorMethod != null) {  					stackFrameHelperType = type;  					exceptionLoggerRemover.Add(errorMethod);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (!type.HasMethods)  					continue;  				if (type.Methods.Count > 3)  					continue;    				MethodDef errorMethod = null;  				foreach (var method in type.Methods) {  					if (method.Name == ".ctor")  						continue;	// .ctor is allowed  					if (method.Name == ".cctor")  						continue;	// .cctor is allowed  					var sig = method.MethodSig;  					if (sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.HasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]") {  						errorMethod = method;  					}  					else  						break;  				}  				if (errorMethod != null) {  					stackFrameHelperType = type;  					exceptionLoggerRemover.Add(errorMethod);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = instrs.Count - 2; i >= 0; i--) {  					var newobj = instrs[i];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					var ctor = newobj.Operand as IMethod;  					if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  						continue;  					var stsfld = instrs[i + 1];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					var field = stsfld.Operand as FieldDef;  					if (field == null || !decrypterFields.ContainsKey(field))  						continue;    					block.Remove(i' 2);  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = instrs.Count - 2; i >= 0; i--) {  					var newobj = instrs[i];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					var ctor = newobj.Operand as IMethod;  					if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  						continue;  					var stsfld = instrs[i + 1];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					var field = stsfld.Operand as FieldDef;  					if (field == null || !decrypterFields.ContainsKey(field))  						continue;    					block.Remove(i' 2);  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.Operand != null)  					continue;    				TypeSig operandType = null' operandTypeTmp;  				OpCode newOpCode = null;  				SZArraySig arrayType;  				switch (instr.OpCode.Code) {  				case Code.Ldelem:  					arrayType = MethodStack.GetLoadedType(method' instrs' i' 1) as SZArraySig;  					if (arrayType == null)  						break;  					operandTypeTmp = arrayType.Next;  					if (operandTypeTmp == null)  						newOpCode = OpCodes.Ldelem_Ref;  					else {  						switch (operandTypeTmp.ElementType) {  						case ElementType.Boolean: newOpCode = OpCodes.Ldelem_I1; break;  						case ElementType.Char: newOpCode = OpCodes.Ldelem_U2; break;  						case ElementType.I:  newOpCode = OpCodes.Ldelem_I; break;  						case ElementType.I1: newOpCode = OpCodes.Ldelem_I1; break;  						case ElementType.I2: newOpCode = OpCodes.Ldelem_I2; break;  						case ElementType.I4: newOpCode = OpCodes.Ldelem_I4; break;  						case ElementType.I8: newOpCode = OpCodes.Ldelem_I8; break;  						case ElementType.U:  newOpCode = OpCodes.Ldelem_I; break;  						case ElementType.U1: newOpCode = OpCodes.Ldelem_U1; break;  						case ElementType.U2: newOpCode = OpCodes.Ldelem_U2; break;  						case ElementType.U4: newOpCode = OpCodes.Ldelem_U4; break;  						case ElementType.U8: newOpCode = OpCodes.Ldelem_I8; break;  						case ElementType.R4: newOpCode = OpCodes.Ldelem_R4; break;  						case ElementType.R8: newOpCode = OpCodes.Ldelem_R8; break;  						default:             newOpCode = OpCodes.Ldelem_Ref; break;  						//TODO: Ldelem  						}  					}  					break;    				case Code.Stelem:  					arrayType = MethodStack.GetLoadedType(method' instrs' i' 2) as SZArraySig;  					if (arrayType == null)  						break;  					operandTypeTmp = arrayType.Next;  					if (operandTypeTmp == null)  						newOpCode = OpCodes.Stelem_Ref;  					else {  						switch (operandTypeTmp.ElementType) {  						case ElementType.U:  						case ElementType.I:  newOpCode = OpCodes.Stelem_I; break;  						case ElementType.Boolean:  						case ElementType.U1:  						case ElementType.I1: newOpCode = OpCodes.Stelem_I1; break;  						case ElementType.Char:  						case ElementType.U2:  						case ElementType.I2: newOpCode = OpCodes.Stelem_I2; break;  						case ElementType.U4:  						case ElementType.I4: newOpCode = OpCodes.Stelem_I4; break;  						case ElementType.U8:  						case ElementType.I8: newOpCode = OpCodes.Stelem_I8; break;  						case ElementType.R4: newOpCode = OpCodes.Stelem_R4; break;  						case ElementType.R8: newOpCode = OpCodes.Stelem_R8; break;  						default: newOpCode = OpCodes.Stelem_Ref; break;  						//TODO: Stelem  						}  					}  					break;    				case Code.Ldelema:  					arrayType = MethodStack.GetLoadedType(method' instrs' i' 1) as SZArraySig;  					if (arrayType == null)  						break;  					operandType = arrayType.Next;  					break;    				case Code.Ldobj:  					operandType = GetPtrElementType(MethodStack.GetLoadedType(method' instrs' i' 0));  					break;    				case Code.Stobj:  					operandType = MethodStack.GetLoadedType(method' instrs' i' 0);  					if (!IsValidType(operandType))  						operandType = GetPtrElementType(MethodStack.GetLoadedType(method' instrs' i' 1));  					break;    				default:  					continue;  				}  				if (newOpCode == null && !IsValidType(operandType)) {  					atLeastOneFailed = true;  					continue;  				}    				instr.Operand = operandType.ToTypeDefOrRef();  				if (newOpCode != null)  					instr.OpCode = newOpCode;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmDataReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmDataReader.cs,Read,The following statement contains a magic number: for (int i = 0; i < numMethods; i++) {  				var csvmMethod = new CsvmMethodData();  				csvmMethod.Guid = new Guid(reader.ReadBytes(16));  				csvmMethod.Token = reader.ReadInt32();  				csvmMethod.Locals = reader.ReadBytes(reader.ReadInt32());  				csvmMethod.Instructions = reader.ReadBytes(reader.ReadInt32());  				csvmMethod.Exceptions = reader.ReadBytes(reader.ReadInt32());  				methods.Add(csvmMethod);  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldarg:  			case Code.Ldarg_S:  				if (index == 0) {  					instr.OpCode = OpCodes.Ldarg_0;  					instr.Operand = null;  				}  				else if (index == 1) {  					instr.OpCode = OpCodes.Ldarg_1;  					instr.Operand = null;  				}  				else if (index == 2) {  					instr.OpCode = OpCodes.Ldarg_2;  					instr.Operand = null;  				}  				else if (index == 3) {  					instr.OpCode = OpCodes.Ldarg_3;  					instr.Operand = null;  				}  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = arg;  				}  				break;    			case Code.Starg:  			case Code.Starg_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Starg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Starg;  					instr.Operand = arg;  				}  				break;    			case Code.Ldarga:  			case Code.Ldarga_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarga_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarga;  					instr.Operand = arg;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldarg:  			case Code.Ldarg_S:  				if (index == 0) {  					instr.OpCode = OpCodes.Ldarg_0;  					instr.Operand = null;  				}  				else if (index == 1) {  					instr.OpCode = OpCodes.Ldarg_1;  					instr.Operand = null;  				}  				else if (index == 2) {  					instr.OpCode = OpCodes.Ldarg_2;  					instr.Operand = null;  				}  				else if (index == 3) {  					instr.OpCode = OpCodes.Ldarg_3;  					instr.Operand = null;  				}  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = arg;  				}  				break;    			case Code.Starg:  			case Code.Starg_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Starg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Starg;  					instr.Operand = arg;  				}  				break;    			case Code.Ldarga:  			case Code.Ldarga_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarga_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarga;  					instr.Operand = arg;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,GetInstructionSize,The following statement contains a magic number: if (opcode == null)  				return 5;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,GetInstructionSize,The following statement contains a magic number: return instr.OpCode.Size + (op.TargetDisplacements.Length + 1) * 4;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,Csvm,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: foreach (var memberRef in module.GetMemberRefs()) {  				var sig = memberRef.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.Object)  					continue;  				if (sig.Params.Count != 2)  					continue;  				if (memberRef.Name != "RunMethod")  					continue;  				if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String'System.Object[])")  					return memberRef.DeclaringType.Scope as AssemblyRef;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,call_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: instr.OpCode = OpCodes.Newobj; break;  			case 1: instr.OpCode = OpCodes.Call; break;  			case 2: instr.OpCode = OpCodes.Callvirt; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: if (type < 13)  				instr.Operand = new TargetDisplOperand(reader.ReadInt32());
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ldfld_read,The following statement contains a magic number: switch (b) {  			case 0: return new Instruction(null' new FieldInstructionOperand(OpCodes.Ldsfld' OpCodes.Ldfld' field));  			case 1: return new Instruction(null' new FieldInstructionOperand(OpCodes.Ldsflda' OpCodes.Ldflda' field));  			case 2: return new Instruction(null' new FieldInstructionOperand(OpCodes.Stsfld' OpCodes.Stfld' field));  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (type.Fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (type.Interfaces.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,FindVmHandlerTypes,The following statement contains a magic number: foreach (var type in module.Types) {  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;  				requiredFields[0] = type.FullName;  				if (!new FieldTypes(type).Exactly(requiredFields))  					continue;    				cflowDeobfuscator.Deobfuscate(cctor);  				var handlers = FindVmHandlerTypes(cctor);  				if (handlers.Count != 31)  					continue;    				return handlers;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,Csvm,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: foreach (var memberRef in module.GetMemberRefs()) {  				var sig = memberRef.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.Object)  					continue;  				if (sig.Params.Count != 2)  					continue;  				if (memberRef.Name != "RunMethod")  					continue;  				if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String'System.Object[])")  					return memberRef.DeclaringType.Scope as AssemblyRef;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmHandlerBase,The following statement contains a magic number: foreach (var type in module.Types) {  				if (!type.IsPublic || !type.IsAbstract)  					continue;  				if (type.HasProperties || type.HasEvents)  					continue;  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (CountVirtual(type) != 2)  					continue;    				VmHandlerBaseType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (type.Methods.Count != 6 && type.Methods.Count != 7)  					continue;  				LogicalOpShrUn = FindLogicalOpMethodShrUn(type);  				if (LogicalOpShrUn == null)  					continue;  				LogicalOpShl = FindLogicalOpMethodShl(type);  				LogicalOpShr = FindLogicalOpMethodShr(type);  				LogicalOpAnd = FindLogicalOpMethodAnd(type);  				LogicalOpXor = FindLogicalOpMethodXor(type);  				LogicalOpOr = FindLogicalOpMethodOr(type);  				if (LogicalOpShrUn != null && LogicalOpShl != null &&  					LogicalOpShr != null && LogicalOpAnd != null &&  					LogicalOpXor != null && LogicalOpOr != null)  					return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (type.Methods.Count != 6 && type.Methods.Count != 7)  					continue;  				LogicalOpShrUn = FindLogicalOpMethodShrUn(type);  				if (LogicalOpShrUn == null)  					continue;  				LogicalOpShl = FindLogicalOpMethodShl(type);  				LogicalOpShr = FindLogicalOpMethodShr(type);  				LogicalOpAnd = FindLogicalOpMethodAnd(type);  				LogicalOpXor = FindLogicalOpMethodXor(type);  				LogicalOpOr = FindLogicalOpMethodOr(type);  				if (LogicalOpShrUn != null && LogicalOpShl != null &&  					LogicalOpShr != null && LogicalOpAnd != null &&  					LogicalOpXor != null && LogicalOpOr != null)  					return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' e1))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' e2))  						continue;  					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0x1F)  						continue;  					if (instrs[i + 5].OpCode.Code != Code.And)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' e3))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckLogicalMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckLogicalMethodSig,The following statement contains a magic number: return method != null &&  				method.IsStatic &&  				method.MethodSig.GetParamCount() == 2 &&  				method.MethodSig.RetType.GetElementType() == ElementType.Object &&  				method.MethodSig.Params[0].GetElementType() == ElementType.Object &&  				method.MethodSig.Params[1].GetElementType() == ElementType.Object;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (type.Methods.Count != 9)  					continue;  				CompareLt = FindCompareLt(type);  				if (CompareLt == null)  					continue;  				CompareLte = FindCompareLte(type);  				CompareGt = FindCompareGt(type);  				CompareGte = FindCompareGte(type);  				CompareEq = FindCompareEq(type);  				CompareEqz = FindCompareEqz(type);  				if (CompareLt != null && CompareLte != null &&  					CompareGt != null && CompareGte != null &&  					CompareEq != null && CompareEqz != null)  					return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				int end = instrs.Count - 6;  				if (invert)  					end -= 2;  				for (int i = 0; i < end; i++) {  					int index = i;  					var ldarg0 = instrs[index++];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[index++]' ElementType.I4))  						continue;  					var ldarg1 = instrs[index++];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[index++]' ElementType.I4))  						continue;  					if (instrs[index++].OpCode.Code != code)  						continue;  					if (invert) {  						var ldci4 = instrs[index++];  						if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  							continue;  						if (instrs[index++].OpCode.Code != Code.Ceq)  							continue;  					}  					if (!instrs[index++].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				int end = instrs.Count - 6;  				if (invert)  					end -= 2;  				for (int i = 0; i < end; i++) {  					int index = i;  					var ldarg0 = instrs[index++];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[index++]' ElementType.I4))  						continue;  					var ldarg1 = instrs[index++];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[index++]' ElementType.I4))  						continue;  					if (instrs[index++].OpCode.Code != code)  						continue;  					if (invert) {  						var ldci4 = instrs[index++];  						if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  							continue;  						if (instrs[index++].OpCode.Code != Code.Ceq)  							continue;  					}  					if (!instrs[index++].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareMethodSig,The following statement contains a magic number: if (sig == null || sig.GetParamCount() != 3)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareMethodSig,The following statement contains a magic number: var arg2 = sig.Params[2] as ValueTypeSig;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 5].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 5].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 5].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 5].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 5].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareEqMethodSig,The following statement contains a magic number: return method != null &&  				method.IsStatic &&  				method.MethodSig.GetParamCount() == 2 &&  				method.MethodSig.RetType.GetElementType() == ElementType.Boolean &&  				method.MethodSig.Params[0].GetElementType() == ElementType.Object &&  				method.MethodSig.Params[1].GetElementType() == ElementType.Object;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqzMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 4; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldci4 = instrs[i + 2];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 4].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqzMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 4; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldci4 = instrs[i + 2];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 4].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqzMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 4; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldci4 = instrs[i + 2];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 4].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckCompareEqzMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 4; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldci4 = instrs[i + 2];  					if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Ceq)  						continue;  					if (!instrs[i + 4].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (type.Methods.Count != 15)  					continue;  				ArithmeticSubOvfUn = FindArithmeticSubOvfUn(type);  				if (ArithmeticSubOvfUn == null)  					continue;  				ArithmeticMulOvfUn = FindArithmeticMulOvfUn(type);  				ArithmeticRemUn = FindArithmeticRemUn(type);  				ArithmeticRem = FindArithmeticRem(type);  				ArithmeticDivUn = FindArithmeticDivUn(type);  				ArithmeticDiv = FindArithmeticDiv(type);  				ArithmeticMul = FindArithmeticMul(type);  				ArithmeticMulOvf = FindArithmeticMulOvf(type);  				ArithmeticSub = FindArithmeticSub(type);  				ArithmeticSubOvf = FindArithmeticSubOvf(type);  				ArithmeticAddOvfUn = FindArithmeticAddOvfUn(type);  				ArithmeticAddOvf = FindArithmeticAddOvf(type);  				ArithmeticAdd = FindArithmeticAdd(type);    				if (ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null &&  					ArithmeticRemUn != null && ArithmeticRem != null &&  					ArithmeticDivUn != null && ArithmeticDiv != null &&  					ArithmeticMul != null && ArithmeticMulOvf != null &&  					ArithmeticSub != null && ArithmeticSubOvf != null &&  					ArithmeticAddOvfUn != null && ArithmeticAddOvf != null &&  					ArithmeticAdd != null)  					return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 8; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					var ldarg1 = instrs[i + 3];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 4]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 5].OpCode.Code != Code.Conv_Ovf_U4)  						continue;  					if (instrs[i + 6].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 7]' ElementType.U4))  						continue;  					if (!instrs[i + 8].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticUnMethodSig,The following statement contains a magic number: return method != null &&  				method.IsStatic &&  				method.MethodSig.GetParamCount() == 2 &&  				method.MethodSig.RetType.GetElementType() == ElementType.Object &&  				method.MethodSig.Params[0].GetElementType() == ElementType.Class &&  				method.MethodSig.Params[1].GetElementType() == ElementType.Class;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticUnMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 7; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckCallvirt(instrs[i + 1]' "System.Int32"' "()"))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckCallvirt(instrs[i + 3]' "System.Int32"' "()"))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.U4))  						continue;  					if (!instrs[i + 6].IsStloc())  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticOtherMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 6; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticOtherMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 6; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticOtherMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 6; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticOtherMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 6; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!CheckArithmeticOtherMethodSig(method))  					continue;  				if (method.Body == null)  					continue;  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 6; i++) {  					var ldarg0 = instrs[i];  					if (!ldarg0.IsLdarg() || ldarg0.GetParameterIndex() != 0)  						continue;  					if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  						continue;  					var ldarg1 = instrs[i + 2];  					if (!ldarg1.IsLdarg() || ldarg1.GetParameterIndex() != 1)  						continue;  					if (!CheckUnboxAny(instrs[i + 3]' ElementType.I4))  						continue;  					if (instrs[i + 4].OpCode.Code != code)  						continue;  					if (!CheckBox(instrs[i + 5]' ElementType.I4))  						continue;    					return method;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticOtherMethodSig,The following statement contains a magic number: return method != null &&  				method.IsStatic &&  				method.MethodSig.GetParamCount() == 2 &&  				method.MethodSig.RetType.GetElementType() == ElementType.Object &&  				method.MethodSig.Params[0].GetElementType() == ElementType.Object &&  				method.MethodSig.Params[1].GetElementType() == ElementType.Object;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod1,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType != VmHandlerBaseType)  					continue;  				if (type.Methods.Count != 4)  					continue;  				var method = FindUnaryMethod(type' code);  				if (method != null)  					return method;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod2,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (type.Methods.Count != 3)  					continue;    				UnaryNot = FindUnaryMethod(type' Code.Not);  				UnaryNeg = FindUnaryMethod(type' Code.Neg);  				if (UnaryNot != null && UnaryNeg != null)  					return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  					continue;  				if (instrs[i + 2].OpCode.Code != code)  					continue;  				if (!CheckBox(instrs[i + 3]' ElementType.I4))  					continue;  				if (!instrs[i + 4].IsStloc())  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  					continue;  				if (instrs[i + 2].OpCode.Code != code)  					continue;  				if (!CheckBox(instrs[i + 3]' ElementType.I4))  					continue;  				if (!instrs[i + 4].IsStloc())  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  					continue;  				if (instrs[i + 2].OpCode.Code != code)  					continue;  				if (!CheckBox(instrs[i + 3]' ElementType.I4))  					continue;  				if (!instrs[i + 4].IsStloc())  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				if (!CheckUnboxAny(instrs[i + 1]' ElementType.I4))  					continue;  				if (instrs[i + 2].OpCode.Code != code)  					continue;  				if (!CheckBox(instrs[i + 3]' ElementType.I4))  					continue;  				if (!instrs[i + 4].IsStloc())  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArgsLocals,The following statement contains a magic number: return FindArgsLocals(ctor' 1' out ArgsGet' out ArgsSet) &&  				FindArgsLocals(ctor' 2' out LocalsGet' out LocalsSet);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmState,The following statement contains a magic number: foreach (var method in VmHandlerBaseType.Methods) {  				if (method.IsStatic || !method.IsAbstract)  					continue;  				if (method.Parameters.Count != 2)  					continue;  				var arg1 = method.Parameters[1].Type.TryGetTypeDef();  				if (arg1 == null)  					continue;    				return arg1;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Beq:  			case Code.Beq_S:  				return GetHash(BASE_INDEX + 0);    			case Code.Bge:  			case Code.Bge_S:  				return GetHash(BASE_INDEX + 1);    			case Code.Bge_Un:  			case Code.Bge_Un_S:  				return GetHash(BASE_INDEX + 2);    			case Code.Bgt:  			case Code.Bgt_S:  				return GetHash(BASE_INDEX + 3);    			case Code.Bgt_Un:  			case Code.Bgt_Un_S:  				return GetHash(BASE_INDEX + 4);    			case Code.Ble:  			case Code.Ble_S:  				return GetHash(BASE_INDEX + 5);    			case Code.Ble_Un:  			case Code.Ble_Un_S:  				return GetHash(BASE_INDEX + 6);    			case Code.Blt:  			case Code.Blt_S:  				return GetHash(BASE_INDEX + 7);    			case Code.Blt_Un:  			case Code.Blt_Un_S:  				return GetHash(BASE_INDEX + 8);    			case Code.Bne_Un:  			case Code.Bne_Un_S:  				return GetHash(BASE_INDEX + 9);    			case Code.Brfalse:  			case Code.Brfalse_S:  				return GetHash(BASE_INDEX + 10);    			case Code.Brtrue:  			case Code.Brtrue_S:  				return GetHash(BASE_INDEX + 11);    			case Code.Switch:  				return GetHash(BASE_INDEX + 12);    			case Code.Ceq:  				return GetHash(BASE_INDEX + 13);    			case Code.Cgt:  				return GetHash(BASE_INDEX + 14);    			case Code.Cgt_Un:  				return GetHash(BASE_INDEX + 15);    			case Code.Clt:  				return GetHash(BASE_INDEX + 16);    			case Code.Clt_Un:  				return GetHash(BASE_INDEX + 17);    			case Code.Ldc_I4:  			case Code.Ldc_I4_0:  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  			case Code.Ldc_I4_M1:  			case Code.Ldc_I4_S:  				return GetHash(instr.GetLdcI4Value());    			case Code.Ldstr:  				return GetHash(instr.Operand as string);    			case Code.Rethrow:  				return GetHash(BASE_INDEX + 18);    			case Code.Throw:  				return GetHash(BASE_INDEX + 19);    			case Code.Call:  			case Code.Callvirt:  				Hash(instr.Operand);  				return (BlockElementHash)hasher.GetHash();    			case Code.Ldfld:  				var field = instr.Operand as FieldDef;  				if (!IsTypeField(field))  					return null;  				if (index + 1 >= instrs.Count || !instrs[index + 1].IsLdcI4())  					return null;  				index++;  				return GetHash(GetFieldId(field));    			default:  				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,GetFieldId,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				result += (int)fieldType.ElementType;  				if (fieldType.Next == null)  					break;  				result += 0x100;  				fieldType = fieldType.Next;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,The following statement contains a magic number: if (level++ > 20)  				return;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,IsFromNonObfuscatedAssembly,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				var asmRef = tr.ResolutionScope as AssemblyRef;  				if (asmRef != null)  					return IsNonObfuscatedAssembly(asmRef);    				var tr2 = tr.ResolutionScope as TypeRef;  				if (tr2 != null) {  					tr = tr2;  					continue;  				}    				break;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LogicalOpShl' 2);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LogicalOpShr' 3);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LogicalOpAnd' 4);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LogicalOpXor' 5);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LogicalOpOr' 6);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareLt' 7);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareLte' 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareGt' 9);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareGte' 10);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareEq' 11);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.CompareEqz' 12);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticSubOvfUn' 13);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticMulOvfUn' 14);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticRemUn' 15);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticRem' 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticDivUn' 17);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticDiv' 18);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticMul' 19);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticMulOvf' 20);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticSub' 21);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticSubOvf' 22);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticAddOvfUn' 23);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticAddOvf' 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArithmeticAdd' 25);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.UnaryNot' 26);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.UnaryNeg' 27);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArgsGet' 28);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.ArgsSet' 29);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LocalsGet' 30);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId(csvmInfo.LocalsSet' 31);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId(creator' csvmInfo.LogicalOpShrUn' 32);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId(creator' csvmInfo.CompareLt' 33);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId(creator' csvmInfo.ArithmeticSubOvfUn' 34);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId(creator' csvmInfo.UnaryNot' 35);
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId(creator' csvmInfo.ArgsGet' 36);
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ArrayFinder.cs,GetArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var newarr = instrs[i++];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;    				if (instrs[i++].OpCode.Code != Code.Dup)  					continue;    				var ldtoken = instrs[i++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null)  					continue;    				index = i - 3;  				type = newarr.Operand as IType;  				return field.InitialValue;  			}
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ArrayFinder.cs,GetArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var newarr = instrs[i++];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;    				if (instrs[i++].OpCode.Code != Code.Dup)  					continue;    				var ldtoken = instrs[i++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null)  					continue;    				index = i - 3;  				type = newarr.Operand as IType;  				return field.InitialValue;  			}
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following statement contains a magic number: for (i = newarrIndex + 1; i < instructions.Count; i++) {  				var instr = instructions[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					break;  				if (instr.OpCode.Code == Code.Newarr)  					break;  				switch (instr.OpCode.Code) {  				case Code.Newarr:  				case Code.Newobj:  					goto done;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stsfld:  				case Code.Stfld:  					if (emulator.Peek() == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  						goto done;  					break;  				}    				if (instr.OpCode.Code == stelemOpCode) {  					var value = emulator.Pop();  					var index = emulator.Pop() as Int32Value;  					var array = emulator.Pop();  					if (ReferenceEquals(array' theArray) && index != null && index.AllBitsValid()) {  						if (0 <= index.Value && index.Value < resultValueArray.Length)  							resultValueArray[index.Value] = value;  					}  				}  				else  					emulator.Emulate(instr);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  				Encrypt(ref xl' ref xr);  				P[i] = xl;  				P[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  				Encrypt(ref xl' ref xr);  				P[i] = xl;  				P[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  				Encrypt(ref xl' ref xr);  				S[i] = xl;  				S[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  				Encrypt(ref xl' ref xr);  				S[i] = xl;  				S[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: rxr = xl ^ P[16];
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: rxl = xr ^ P[17];
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				Decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (ProcessInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!GetLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!GetArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: foreach (var b in data) {  				int i = (byte)(checkSum ^ b);  				checkSum = (checkSum >> 8) ^ table[i];  			}
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 32));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 40));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 48));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 56));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 32));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 40));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 48));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 56));
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table[i];
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CRC32.cs,CheckSum,The following statement contains a magic number: foreach (var b in data) {  				int i = (byte)(cs ^ b);  				cs = (cs >> 8) ^ table[i];  			}
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsFatHeader,The following statement contains a magic number: if (body.InitLocals || body.MaxStack > 8)  				return true;
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsFatHeader,The following statement contains a magic number: if (GetCodeSize(method) > 63)  				return true;
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: uint rounds = (uint)(6 + 52 / n);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: uint rounds = (uint)(6 + 52 / n);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: if ((b & 0x40) == 0)  				return (((int)b & 0x3F) << 8) + data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				foreach (var method in type.Methods) {  					if (!method.IsStatic)  						continue;  					if (!method.IsAssembly && !method.IsPrivateScope && !method.IsPrivate)  						continue;  					if (method.GenericParameters.Count > 0)  						continue;  					if (method.Name == ".cctor")  						continue;  					if (method.Body == null)  						continue;  					var instrs = method.Body.Instructions;  					if (instrs.Count < 2)  						continue;    					switch (instrs[0].OpCode.Code) {  					case Code.Ldc_I4:  					case Code.Ldc_I4_0:  					case Code.Ldc_I4_1:  					case Code.Ldc_I4_2:  					case Code.Ldc_I4_3:  					case Code.Ldc_I4_4:  					case Code.Ldc_I4_5:  					case Code.Ldc_I4_6:  					case Code.Ldc_I4_7:  					case Code.Ldc_I4_8:  					case Code.Ldc_I4_M1:  					case Code.Ldc_I4_S:  					case Code.Ldc_I8:  					case Code.Ldc_R4:  					case Code.Ldc_R8:  					case Code.Ldftn:  					case Code.Ldnull:  					case Code.Ldstr:  					case Code.Ldtoken:  					case Code.Ldsfld:  					case Code.Ldsflda:  						if (instrs[1].OpCode.Code != Code.Ret)  							continue;  						break;    					case Code.Ldarg:  					case Code.Ldarg_S:  					case Code.Ldarg_0:  					case Code.Ldarg_1:  					case Code.Ldarg_2:  					case Code.Ldarg_3:  					case Code.Ldarga:  					case Code.Ldarga_S:  					case Code.Call:  					case Code.Newobj:  						if (!IsCallMethod(method))  							continue;  						break;    					default:  						continue;  					}    					inlinedMethods.Add(method);  				}  			}
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((mbHeader.flags & 8) != 0)  				extraSections = ReadExtraSections2(reader);  			else  				extraSections = null;
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ReadExtraSections2,The following statement contains a magic number: Align(reader' 4);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  				Align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  				try {  					return Decrypt2(serverVersion' filename' moduleCctorBytes);  				}  				catch (RemotingException ex) {  					lastEx = ex;  					continue;  				}  			}
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 1] = (byte)(val >> 8);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 2] = (byte)(val >> 16);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 2] = (byte)(val >> 16);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 3] = (byte)(val >> 24);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 3] = (byte)(val >> 24);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt16,The following statement contains a magic number: peImageData[offset + 1] = (byte)(val >> 8);
Magic Number,de4dot.code.deobfuscators,ProxyCallFixerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Deobfuscate,The following statement contains a magic number: int loops = ProxyCallIsObfuscated ? 50 : 1;
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = Read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = Read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)Read32(inData' inIndex + 4);  							count = Read32(inData' inIndex + 8);  							inIndex += 12;  						}  						Copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)Read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					Copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (outIndex < decompressedLength) {  				if (val1 == 1) {  					inIndex += 4;  					val1 = 0x80000000;  				}  				outData[outIndex++] = inData[inIndex++];  				val1 >>= 1;  			}
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,IsCompressed,The following statement contains a magic number: if (data.Length < 4)  				return false;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: int mode = BitConverter.ToInt32(inData' 4);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: int compressedLength = BitConverter.ToInt32(inData' 8);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: int decompressedLength = BitConverter.ToInt32(inData' 12);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: bool isDataCompressed = BitConverter.ToInt32(inData' 16) == 1;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: int headerLength = 32;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (BitConverter.ToInt32(inData' 0) != sig || BitConverter.ToInt32(inData' compressedLength - 4) != sig)  				throw new ApplicationException("No QCLZ sig");
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: if (name.Length < 5)  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (len < 5)  				return false;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (CountNumbers(typeWords' 2))  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (upper >= 3)  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: bool hasTwoUpperWords = upper == 2;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  				if (IsDigit(typeWords[i - 1][0]) && IsLower(typeWords[i - 2][0]) && IsLower(typeWords[i][0]))  					return true;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  				if (IsDigit(typeWords[i - 1][0]) && IsLower(typeWords[i - 2][0]) && IsLower(typeWords[i][0]))  					return true;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (IsLower(name[len - 3]) && IsUpper(name[len - 2]) && IsDigit(name[len - 1]))  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (IsLower(name[len - 3]) && IsUpper(name[len - 2]) && IsDigit(name[len - 1]))  				return true;
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateLoop,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  				bool modified = false;  				modified |= DeobfuscateFields();  				modified |= DeobfuscateMethods();  				if (!modified)  					break;  			}
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instr = instructions[i];  				switch (instr.OpCode.Code) {  				case Code.Ret:  					if (!fixReturnType)  						break;  					bool wasNewobj;  					var type = GetLoadedType(method' method' instructions' i' out wasNewobj);  					if (type == null)  						break;  					methodReturnInfo.Add(type);  					break;    				case Code.Call:  				case Code.Calli:  				case Code.Callvirt:  				case Code.Newobj:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					var calledMethod = instr.Operand as IMethod;  					if (calledMethod == null)  						break;  					var calledMethodParams = DotNetUtils.GetArgs(calledMethod);  					for (int j = 0; j < pushedArgs.NumValidArgs; j++) {  						int calledMethodParamIndex = calledMethodParams.Count - j - 1;  						var ldInstr = pushedArgs.GetEnd(j);  						switch (ldInstr.OpCode.Code) {  						case Code.Ldarg:  						case Code.Ldarg_S:  						case Code.Ldarg_0:  						case Code.Ldarg_1:  						case Code.Ldarg_2:  						case Code.Ldarg_3:  							AddMethodArgType(method' GetParameter(methodParams' ldInstr)' DotNetUtils.GetArg(calledMethodParams' calledMethodParamIndex));  							break;    						default:  							break;  						}  					}  					break;    				case Code.Castclass:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(0))' instr.Operand as ITypeDefOrRef);  					break;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(0))' instr.GetLocal(method.Body.Variables));  					break;    				case Code.Stsfld:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(0))' instr.Operand as IField);  					break;    				case Code.Stfld:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs >= 1) {  						var field = instr.Operand as IField;  						AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(0))' field);  						if (pushedArgs.NumValidArgs >= 2 && field != null)  							AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(1))' field.DeclaringType);  					}  					break;    				case Code.Ldfld:  				case Code.Ldflda:  					pushedArgs = MethodStack.GetPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					AddMethodArgType(method' GetParameter(methodParams' pushedArgs.GetEnd(0))' instr.Operand as IField);  					break;    				//TODO: For better results' these should be checked:  				case Code.Starg:  				case Code.Starg_S:    				case Code.Ldelema:  				case Code.Ldelem:  				case Code.Ldelem_I:  				case Code.Ldelem_I1:  				case Code.Ldelem_I2:  				case Code.Ldelem_I4:  				case Code.Ldelem_I8:  				case Code.Ldelem_R4:  				case Code.Ldelem_R8:  				case Code.Ldelem_Ref:  				case Code.Ldelem_U1:  				case Code.Ldelem_U2:  				case Code.Ldelem_U4:    				case Code.Ldind_I:  				case Code.Ldind_I1:  				case Code.Ldind_I2:  				case Code.Ldind_I4:  				case Code.Ldind_I8:  				case Code.Ldind_R4:  				case Code.Ldind_R8:  				case Code.Ldind_Ref:  				case Code.Ldind_U1:  				case Code.Ldind_U2:  				case Code.Ldind_U4:    				case Code.Ldobj:    				case Code.Stelem:  				case Code.Stelem_I:  				case Code.Stelem_I1:  				case Code.Stelem_I2:  				case Code.Stelem_I4:  				case Code.Stelem_I8:  				case Code.Stelem_R4:  				case Code.Stelem_R8:  				case Code.Stelem_Ref:    				case Code.Stind_I:  				case Code.Stind_I1:  				case Code.Stind_I2:  				case Code.Stind_I4:  				case Code.Stind_I8:  				case Code.Stind_R4:  				case Code.Stind_R8:  				case Code.Stind_Ref:    				case Code.Stobj:  				default:  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: const int numBits = 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  			case 1: blockType = STORED_BLOCK; break;  			case 5: blockType = STATIC_TREES; break;  			case 6: blockType = DYN_TREES; break;  			default: throw new SharpZipBaseException("Unknown block type: " + type);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  			case 1: blockType = STORED_BLOCK; break;  			case 5: blockType = STATIC_TREES; break;  			case 6: blockType = DYN_TREES; break;  			default: throw new SharpZipBaseException("Unknown block type: " + type);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits(16)) < 0)  				return false;
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,The following statement contains a magic number: while (true) {  				if (counter++ >= 50)  					return false;  				if (emulateIndex < 0 || emulateIndex >= instructions.Count)  					return false;  				instr = instructions[emulateIndex];  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  				case Code.Ldc_I4:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  				case Code.Ldc_I4_S:  				case Code.Add:  				case Code.Sub:  				case Code.Xor:  				case Code.Or:  				case Code.Nop:  				case Code.Dup:  				case Code.Mul:  				case Code.Rem:  				case Code.Div:  					emulator.Emulate(instr);  					emulateIndex++;  					break;    				case Code.Br:  				case Code.Br_S:  				case Code.Beq:  				case Code.Beq_S:  				case Code.Bge:  				case Code.Bge_S:  				case Code.Bge_Un:  				case Code.Bge_Un_S:  				case Code.Bgt:  				case Code.Bgt_S:  				case Code.Bgt_Un:  				case Code.Bgt_Un_S:  				case Code.Ble:  				case Code.Ble_S:  				case Code.Ble_Un:  				case Code.Ble_Un_S:  				case Code.Blt:  				case Code.Blt_S:  				case Code.Blt_Un:  				case Code.Blt_Un_S:  				case Code.Bne_Un:  				case Code.Bne_Un_S:  				case Code.Brfalse:  				case Code.Brfalse_S:  				case Code.Brtrue:  				case Code.Brtrue_S:  				case Code.Switch:  					if (!branchEmulator.Emulate(instr))  						return false;  					break;    				case Code.Ret:  					var retValue = emulator.Pop();  					if (!retValue.IsInt32())  						return false;  					var retValue2 = (Int32Value)retValue;  					if (!retValue2.AllBitsValid())  						return false;  					newValue = retValue2.Value;  					return true;    				default:  					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  						return false;  					emulateIndex++;  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,GetXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldelem = instrs[i];  				if (ldelem.OpCode.Code != Code.Ldelem_U2)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				xorKey = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,GetXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldelem = instrs[i];  				if (ldelem.OpCode.Code != Code.Ldelem_U2)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				xorKey = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				infos.Clear();  				for (int i = 0; i < instrs.Count - 6; i++) {  					int index = i;    					var ldci4 = instrs[index++];  					if (!ldci4.IsLdcI4())  						continue;    					var newarr = instrs[index++];  					if (newarr.OpCode.Code != Code.Newarr)  						continue;  					if (newarr.Operand == null || newarr.Operand.ToString() != "System.Byte")  						continue;    					if (instrs[index++].OpCode.Code != Code.Dup)  						continue;    					var ldtoken = instrs[index++];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					var field = ldtoken.Operand as FieldDef;  					if (field == null)  						continue;    					var call1 = instrs[index++];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.IsMethod(call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  						continue;    					var call2 = instrs[index++];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' arrayDecrypter))  						continue;    					var castclass = instrs[index++];  					if (castclass.OpCode.Code != Code.Castclass)  						continue;  					var arrayType = (castclass.Operand as ITypeDefOrRef).TryGetSZArraySig();  					if (arrayType == null)  						continue;  					if (arrayType.Next.ElementType.GetPrimitiveSize() == -1) {  						Logger.w("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32());  						continue;  					}    					infos.Add(new ArrayInfo(i' index - i' field' arrayType));  				}    				infos.Reverse();  				foreach (var info in infos) {  					var elemSize = info.arrayType.Next.ElementType.GetPrimitiveSize();  					var decrypted = DecryptArray(info.encryptedField.InitialValue' elemSize);    					initializedDataCreator.AddInitializeArrayCode(block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef()' decrypted);  					Logger.v("Decrypted {0} array: {1} elements"' info.arrayType.Next.ToString()' decrypted.Length / elemSize);  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundBabelAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The following statement contains a magic number: if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) {  				var val = Regex.Match((string)versionField.Constant.Value' @"^(\d+\.\d+\.\d+\.\d+)$");  				if (val.Groups.Count < 2)  					return;  				obfuscatorName = string.Format("{0} {1}"' DeobfuscatorInfo.THE_NAME' val.Groups[1].ToString());  				return;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,Initialize,The following statement contains a magic number: long pos = metadataOffset + 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: reader.Position = reader.Length - 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,MethodBodyReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\MethodBodyReader.cs,ReadInlineTok,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return imageReader.ReadTypeSig().ToTypeDefOrRef();  			case 1: return imageReader.ReadFieldRef();  			case 2: return imageReader.ReadMethodRef();  			default: throw new ApplicationException("Unknown token type");  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.Find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.Find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.Find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.Find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.Find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (decryptMethod != null && DeobUtils.HasInteger(decryptMethod' 6))  				return new Decrypter3(module' decryptMethod);
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: Array.Copy(encryptedData' index + 2' headerData' 0' headerData.Length);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: index += headerData.Length + 2;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: var key = new byte[8];
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (headerData[(int)reader.BaseStream.Position] != 8) {  					var license = reader.ReadString();  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (headerData[(int)reader.BaseStream.Position] != 8)  					isCompressed = reader.ReadBoolean();
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: Array.Copy(encryptedData' index + 2' headerData' 0' headerData.Length);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: index += headerData.Length + 2;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetHeaderData,The following statement contains a magic number: var key = new byte[6];
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,GetKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var callvirt = instrs[i];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;  				var calledMethod = callvirt.Operand as IMethod;  				if (calledMethod == null)  					continue;  				if (calledMethod.FullName != "System.Int32 System.IO.BinaryReader::ReadInt32()")  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				ints.Add(ldci4.GetLdcI4Value());  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,The following statement contains a magic number: if (ints.Count == 2) {  				hasXorKeys = true;  				xorKey1 = ints[0];  				xorKey2 = ints[1];  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (type.NestedTypes.Count > 2)  				return null;
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  				// 4.0+    				if (!HasFieldType(nested.Fields' nested))  					return null;    				var decrypterBuilderMethod = DotNetUtils.GetMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  				if (decrypterBuilderMethod == null)  					return null;    				resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));    				var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.Int32)");  				if (nestedDecrypter == null || nestedDecrypter.IsStatic)  					return null;  				var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.Int32)");  				if (decrypter == null || !decrypter.IsStatic)  					return null;    				simpleDeobfuscator.Deobfuscate(decrypterBuilderMethod);  				return new DecrypterInfoV3(resourceDecrypter) {  					Decrypter = decrypter'  					OffsetCalcInstructions = GetOffsetCalcInstructions(decrypterBuilderMethod)'  				};  			}  			else if (nested.Fields.Count == 2) {  				// 3.0 - 3.5    				if (CheckFields(nested' "System.Collections.Hashtable"' nested)) {  					// 3.0 - 3.5  					var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));    					return new DecrypterInfoV3(resourceDecrypter) { Decrypter = decrypter };  				}  				else if (CheckFields(nested' "System.Byte[]"' nested)) {  					// 3.0  					var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.String'System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.String'System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					return new DecrypterInfoV2 { Decrypter = decrypter };  				}  				else  					return null;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  				// 4.0+    				if (!HasFieldType(nested.Fields' nested))  					return null;    				var decrypterBuilderMethod = DotNetUtils.GetMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  				if (decrypterBuilderMethod == null)  					return null;    				resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));    				var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.Int32)");  				if (nestedDecrypter == null || nestedDecrypter.IsStatic)  					return null;  				var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.Int32)");  				if (decrypter == null || !decrypter.IsStatic)  					return null;    				simpleDeobfuscator.Deobfuscate(decrypterBuilderMethod);  				return new DecrypterInfoV3(resourceDecrypter) {  					Decrypter = decrypter'  					OffsetCalcInstructions = GetOffsetCalcInstructions(decrypterBuilderMethod)'  				};  			}  			else if (nested.Fields.Count == 2) {  				// 3.0 - 3.5    				if (CheckFields(nested' "System.Collections.Hashtable"' nested)) {  					// 3.0 - 3.5  					var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod(nested.FindMethod(".ctor"));    					return new DecrypterInfoV3(resourceDecrypter) { Decrypter = decrypter };  				}  				else if (CheckFields(nested' "System.Byte[]"' nested)) {  					// 3.0  					var nestedDecrypter = DotNetUtils.GetMethod(nested' "System.String"' "(System.String'System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.GetMethod(type' "System.String"' "(System.String'System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					return new DecrypterInfoV2 { Decrypter = decrypter };  				}  				else  					return null;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;    				var ldsfld1 = instrs[index++];  				if (ldsfld1.OpCode.Code != Code.Ldsfld)  					continue;    				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;    				var callvirt = instrs[index++];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;  				var calledMethod = callvirt.Operand as IMethod;  				if (calledMethod == null)  					continue;  				if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)")  					continue;    				if (!instrs[index++].IsLdloc())  					continue;    				var ldsfld2 = instrs[index++];  				if (ldsfld2.OpCode.Code != Code.Ldsfld)  					continue;  				var field = ldsfld2.Operand as IField;  				if (field == null)  					continue;  				if (field.FullName != "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Xor")  					continue;    				// Here if Babel.NET 5.5  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckFields,The following statement contains a magic number: if (type.Fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ReflectionToDNLibMethodCreator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,DoCall,The following statement contains a magic number: if (fn == "System.Byte[] System.Convert::FromBase64String(System.String)") {  					emulator.Push(new UserValue(Convert.FromBase64String(((StringValue)emulator.Pop()).value)));  					return true;  				}  				else if (fn == "System.String System.Text.Encoding::GetString(System.Byte[])") {  					emulator.Push(new StringValue(Encoding.UTF8.GetString((byte[])((UserValue)emulator.Pop()).obj)));  					return true;  				}  				else if (fn == "System.Int32 System.Int32::Parse(System.String)") {  					emulator.Push(new Int32Value(int.Parse(((StringValue)emulator.Pop()).value)));  					return true;  				}  				else if (fn == "System.String[] System.String::Split(System.Char[])") {  					var ary = (char[])((UserValue)emulator.Pop()).obj;  					var s = ((StringValue)emulator.Pop()).value;  					emulator.Push(new UserValue(s.Split(ary)));  					return true;  				}  				else if (sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit") {  					Value operand = null;  					if (calledMethod.MethodSig.GetParamCount() == 2)  						operand = emulator.Pop();  					var opcode = ReflectionToOpCode((IField)((UserValue)emulator.Pop()).obj);  					emulator.Pop();	// the this ptr  					AddInstruction(new Instruction {  						OpCode = opcode'  						Operand = CreateDNLibOperand(opcode' operand)'  					});  					return true;  				}  				else {  					emulator.Emulate(instr);  					return true;  				}
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,CheckCalledMethods,The following statement contains a magic number: if (calls != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: const int iterations = 2;
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: var key = new Rfc2898DeriveBytes(password.passphrase' Encoding.UTF8.GetBytes(password.salt)' iterations).GetBytes(numBits / 8);
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,GetEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldstr1 = instrs[index++];  				if (ldstr1.OpCode.Code != Code.Ldstr)  					continue;  				var passphrase = GetString(ldstr1' instrs' ref index);    				var ldstr2 = instrs[index++];  				if (ldstr2.OpCode.Code != Code.Ldstr)  					continue;  				var salt = GetString(ldstr2' instrs' ref index);    				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;    				var ldstr3 = instrs[index++];  				if (ldstr3.OpCode.Code != Code.Ldstr)  					continue;  				var iv = GetString(ldstr3' instrs' ref index);    				return new PasswordInfo(passphrase' salt' iv);  			}
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeFort,PasswordFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\PasswordFinder.cs,FindEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldstr1 = instrs[index++];  				if (ldstr1.OpCode != "ldstr")  					continue;  				var passphrase = GetString(ldstr1' instrs' ref index);    				var ldstr2 = instrs[index++];  				if (ldstr2.OpCode != "ldstr")  					continue;  				var salt = GetString(ldstr2' instrs' ref index);    				var ldc = instrs[index++];  				if (!ldc.OpCode.StartsWith("ldc.i4"))  					continue;    				var ldstr3 = instrs[index++];  				if (ldstr3.OpCode != "ldstr")  					continue;  				var iv = GetString(ldstr3' instrs' ref index);    				return new PasswordInfo(passphrase' salt' iv);  			}
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckMethods,The following statement contains a magic number: if (type.Methods.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,GetCallInfo,The following statement contains a magic number: foreach (var c in field.Name.String)  				rid = (rid << 4) + (uint)HexToInt((char)((byte)c + 0x2F));
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: if ('a' <= c && c <= 'f')  				return c - 'a' + 10;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: if ('A' <= c && c <= 'F')  				return c - 'A' + 10;
Magic Number,de4dot.code.deobfuscators.CodeFort,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeFort\StringDecrypter.cs,CheckMethods,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Name == ".cctor")  					continue;  				if (!method.IsStatic || method.Body == null)  					return null;  				if (!DotNetUtils.IsMethod(method' "System.String"' "(System.String)"))  					return null;  				if (!HasDouble(method' 3992.0))  					return null;    				decryptMethod = method;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindBundleType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Namespace != "")  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null || !ctor.IsPrivate)  					continue;  				if (!DotNetUtils.IsMethod(ctor' "System.Void"' "(System.Reflection.Assembly)"))  					continue;    				var initMethodTmp = FindInitMethod(type);  				if (initMethodTmp == null)  					continue;  				var getTempFilenameMethod = FindGetTempFilenameMethod(type);  				if (getTempFilenameMethod == null)  					continue;    				return type;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  				var type = field.FieldSig.GetFieldType().TryGetTypeDef();  				if (type == null)  					continue;  				if (type == bundleType)  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null)  					continue;  				var sig = ctor.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				var iface = sig.Params[1].TryGetTypeDef();  				if (iface == null || !iface.IsInterface)  					continue;    				assemblyManagerType = type;  				bundleStreamProviderIFace = iface;  				return;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  				var type = field.FieldSig.GetFieldType().TryGetTypeDef();  				if (type == null)  					continue;  				if (type == bundleType)  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null)  					continue;  				var sig = ctor.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				var iface = sig.Params[1].TryGetTypeDef();  				if (iface == null || !iface.IsInterface)  					continue;    				assemblyManagerType = type;  				bundleStreamProviderIFace = iface;  				return;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: bool isDeflated = (flags & 2) != 0;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: var block = new uint[4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: var decrypted = new byte[16];
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  				block[0] = reader.ReadUInt32();  				block[1] = reader.ReadUInt32();  				block[2] = reader.ReadUInt32();  				block[3] = reader.ReadUInt32();  				DeobUtils.XxteaDecrypt(block' key);  				Buffer.BlockCopy(block' 0' decrypted' 0' decrypted.Length);  				outStream.Write(decrypted' 0' decrypted.Length);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  				block[0] = reader.ReadUInt32();  				block[1] = reader.ReadUInt32();  				block[2] = reader.ReadUInt32();  				block[3] = reader.ReadUInt32();  				DeobUtils.XxteaDecrypt(block' key);  				Buffer.BlockCopy(block' 0' decrypted' 0' decrypted.Length);  				outStream.Write(decrypted' 0' decrypted.Length);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,Find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;    				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;    				var call = instrs[i + 2];  				if (call.OpCode.Code != Code.Call)  					continue;  				var initMethodTmp = call.Operand as MethodDef;  				ObfuscatorVersion obfuscatorVersionTmp;  				if (!CheckInitMethod(initMethodTmp' out obfuscatorVersionTmp))  					continue;  				if (!CheckMethodsType(initMethodTmp.DeclaringType))  					continue;    				obfuscatorVersion = obfuscatorVersionTmp;  				theType = initMethodTmp.DeclaringType;  				initMethod = initMethodTmp;  				break;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,Find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;    				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;    				var call = instrs[i + 2];  				if (call.OpCode.Code != Code.Call)  					continue;  				var initMethodTmp = call.Operand as MethodDef;  				ObfuscatorVersion obfuscatorVersionTmp;  				if (!CheckInitMethod(initMethodTmp' out obfuscatorVersionTmp))  					continue;  				if (!CheckMethodsType(initMethodTmp.DeclaringType))  					continue;    				obfuscatorVersion = obfuscatorVersionTmp;  				theType = initMethodTmp.DeclaringType;  				initMethod = initMethodTmp;  				break;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,CheckMethodsType,The following statement contains a magic number: if (fields.Count < 2)	// RVAs for executive and stub are always present if encrypted methods  				return true;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].IsLdcI4())  						continue;  					if (!instrs[i + 1].IsLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.Remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].IsLdcI4())  						continue;  					if (!instrs[i + 1].IsLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.Remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].IsLdcI4())  						continue;  					if (!instrs[i + 1].IsLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.Remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.ReadMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				byte b = peImage.OffsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.OffsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.OffsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.OffsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.OffsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.Decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.Add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: const int RVA_EXECUTIVE_OFFSET = 1 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: const int ENC_CODE_OFFSET = 6 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: const int ENC_CODE_OFFSET = 6 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: for (int offset = GetStartOffset(peImage); offset < lastOffset; ) {  				offset = FindSig(fileData' offset' lastOffset' initializeMethodEnd);  				if (offset < 0)  					return null;  				offset += initializeMethodEnd.Length;    				short retImm16 = BitConverter.ToInt16(fileData' offset);  				if (retImm16 != 0x0C && retImm16 != 0x10)  					continue;  				offset += 2;  				if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  					return null;    				// rva is 0 when the assembly has been embedded  				uint rva = BitConverter.ToUInt32(fileData' offset + RVA_EXECUTIVE_OFFSET);  				if (rva != 0 && mainType.Rvas.IndexOf(rva) < 0)  					continue;    				int relOffs = BitConverter.ToInt32(fileData' offset + ENC_CODE_OFFSET);  				if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  					continue;  				reader.Position = section.PointerToRawData + relOffs;    				int size = (int)reader.ReadCompressedUInt32();  				int endOffset = relOffs + size;  				if (endOffset < relOffs || endOffset > section.SizeOfRawData)  					continue;    				return reader.ReadBytes(size);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: for (int offset = GetStartOffset(peImage); offset < lastOffset; ) {  				offset = FindSig(fileData' offset' lastOffset' initializeMethodEnd);  				if (offset < 0)  					return null;  				offset += initializeMethodEnd.Length;    				short retImm16 = BitConverter.ToInt16(fileData' offset);  				if (retImm16 != 0x0C && retImm16 != 0x10)  					continue;  				offset += 2;  				if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  					return null;    				// rva is 0 when the assembly has been embedded  				uint rva = BitConverter.ToUInt32(fileData' offset + RVA_EXECUTIVE_OFFSET);  				if (rva != 0 && mainType.Rvas.IndexOf(rva) < 0)  					continue;    				int relOffs = BitConverter.ToInt32(fileData' offset + ENC_CODE_OFFSET);  				if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  					continue;  				reader.Position = section.PointerToRawData + relOffs;    				int size = (int)reader.ReadCompressedUInt32();  				int endOffset = relOffs + size;  				if (endOffset < relOffs || endOffset > section.SizeOfRawData)  					continue;    				return reader.ReadBytes(size);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,Decrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((dm.mhFlags & 8) != 0)  					dm.extraSections = MethodBodyParser.ReadExtraSections(methodsDataReader);
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Initialize,The following statement contains a magic number: var newMethodsData = new byte[data.Length - 4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Initialize,The following statement contains a magic number: Array.Copy(data' 4' newMethodsData' 0' newMethodsData.Length);
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,DecryptCode,The following statement contains a magic number: for (int i = 0; i < code.Length; i++) {  					for (int j = 0; j < 4 && i + j < code.Length; j++)  						code[i + j] ^= decryptKey[j];  				}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,GetCallInfo,The following statement contains a magic number: int methodToken = 0x06000000 + ((flags & 0x3F) << 24) + (int)reader.ReadCompressedUInt32();
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!CheckMethodType(methodType))  					continue;  				if (!CheckFieldType(fieldType))  					continue;  				if (!CheckIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!CheckMethodType(methodType))  					continue;  				if (!CheckFieldType(fieldType))  					continue;  				if (!CheckIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!CheckMethodType(methodType))  					continue;  				if (!CheckFieldType(fieldType))  					continue;  				if (!CheckIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.Create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.Create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.Create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.Create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.Create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.Create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.Create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.Create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.Create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.Create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.Create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.Create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.Create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.Create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.Create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.Create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.Create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.CreateIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.CreateImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.CreateSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResourceFlags,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  				return;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResourceFlags,The following statement contains a magic number: var type = sig.Params[2].TryGetTypeDef();
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResType,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  				return;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,GetDlxResDict,The following statement contains a magic number: foreach (var field in type.Fields) {  				var fieldType = field.FieldSig.GetFieldType().ToGenericInstSig();  				if (fieldType == null)  					continue;  				if (fieldType.GenericType.FullName != "System.Collections.Generic.Dictionary`2")  					continue;  				if (fieldType.GenericArguments.Count != 2)  					continue;  				if (fieldType.GenericArguments[0].FullName != "System.String")  					continue;  				if (fieldType.GenericArguments[1].TryGetTypeDef() == null)  					continue;  				return fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindXxteaMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsPrivate || method.IsStatic || method.Body == null)  					continue;  				if (DotNetUtils.IsMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[])")) {  					if (!DeobUtils.HasInteger(method' 0x9E3779B9))  						continue;  				}  				else if (DotNetUtils.IsMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) {  					// Here if 5.0. 0x9E3779B9 is passed to it as the last arg.  				}  				else  					continue;  				if (!DeobUtils.HasInteger(method' 52))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: bool encrypted = (flags & 2) != 0;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.XxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.XxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.XxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.XxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,CheckFields,The following statement contains a magic number: if (data == null || data.Length == 0 || data.Length % 4 != 0)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,GetKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;    				if (instrs[i + 1].OpCode.Code != Code.Newarr)  					continue;    				i++;  				var key = ArrayFinder.GetInitializedUInt32Array(4' method' ref i);  				if (key == null)  					continue;    				return key;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,GetKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;    				if (instrs[i + 1].OpCode.Code != Code.Newarr)  					continue;    				i++;  				var key = ArrayFinder.GetInitializedUInt32Array(4' method' ref i);  				if (key == null)  					continue;    				return key;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,DecryptStrings,The following statement contains a magic number: var encryptedData = new uint[data.Length / 4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  				if (instrs == null)  					continue;    				if (!CheckInvokeCall(instrs[1]' "System.Type"' "(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckInvokeCall(instrs[2]' "System.Reflection.Assembly"' "(System.Object)"))  					continue;  				if (!CheckInvokeCall(instrs[4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  				if (instrs == null)  					continue;    				if (!CheckInvokeCall(instrs[1]' "System.Type"' "(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckInvokeCall(instrs[2]' "System.Reflection.Assembly"' "(System.Object)"))  					continue;  				if (!CheckInvokeCall(instrs[4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: return DeobUtils.Inflate(DeobUtils.AesDecrypt(encrypted' keyGenerator.GetBytes(32)' keyGenerator.GetBytes(16))' false);
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: return DeobUtils.Inflate(DeobUtils.AesDecrypt(encrypted' keyGenerator.GetBytes(32)' keyGenerator.GetBytes(16))' false);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (methodsDecrypter.Detected)  				val += 50;
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,InitializeStringDecrypter,The following statement contains a magic number: foreach (var info in stringDecrypter.Infos)  				staticStringInliner.Add(info.Method' (method' gim' args) => stringDecrypter.Decrypt(method' (int)args[0]' (int)args[1]' (int)args[2]));
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Find,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors(module' 3)) {  				if (CheckCctor(cctor))  					return;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();  				peImage.ReadMethodTableRowTo(dm' rid);    				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				peImage.Reader.Position = bodyOffset;  				var mbHeader = MethodBodyParser.ParseMethodBody(peImage.Reader' out dm.code' out dm.extraSections);  				peImage.UpdateMethodHeaderInfo(dm' mbHeader);    				if (dm.code.Length < 6 || dm.code[0] != 0x2A || dm.code[1] != 0x2A)  					continue;    				int seed = BitConverter.ToInt32(dm.code' 2);  				Array.Copy(newCodeHeader' dm.code' newCodeHeader.Length);  				if (seed == 0)  					Decrypt(dm.code);  				else  					Decrypt(dm.code' seed);    				dumpedMethods.Add(dm);  				decrypted = true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();  				peImage.ReadMethodTableRowTo(dm' rid);    				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.RvaToOffset(dm.mdRVA);    				peImage.Reader.Position = bodyOffset;  				var mbHeader = MethodBodyParser.ParseMethodBody(peImage.Reader' out dm.code' out dm.extraSections);  				peImage.UpdateMethodHeaderInfo(dm' mbHeader);    				if (dm.code.Length < 6 || dm.code[0] != 0x2A || dm.code[1] != 0x2A)  					continue;    				int seed = BitConverter.ToInt32(dm.code' 2);  				Array.Copy(newCodeHeader' dm.code' newCodeHeader.Length);  				if (seed == 0)  					Decrypt(dm.code);  				else  					Decrypt(dm.code' seed);    				dumpedMethods.Add(dm);  				decrypted = true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  				data[i] ^= decryptKey[i % decryptKey.Length];
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  				data[i] ^= key[i];
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,CheckMethodsV30,The following statement contains a magic number: if (type.Methods.Count < 1 || type.Methods.Count > 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,CheckMethodsV36,The following statement contains a magic number: if (type.Methods.Count != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldloc = instrs[i];  				if (!ldloc.IsLdloc())  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldloc = instrs[i];  				if (!ldloc.IsLdloc())  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringEncrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,GetDataOffset,The following statement contains a magic number: if (pkt == null)  					return magic2 ^ Magic2;  				else  					return magic2 ^ BitConverter.ToInt32(pkt' 0) ^ BitConverter.ToInt32(pkt' 4);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: const uint factor = 1812433253;
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: for (mti = 1; mti < MERS_N; mti++) {  				mt[mti] = (factor * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + (uint)mti);  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,RandomInit,The following statement contains a magic number: for (int i = 0; i < 37; i++) BRandom();
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  				s = s * 29943829 - 1;  				x[i] = s;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  				s = s * 29943829 - 1;  				x[i] = s;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 19; i++) BRandom();
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[3] = x[2];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[3] = x[2];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[2] = x[1];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[4] = (uint)(sum >> 32);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[4] = (uint)(sum >> 32);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom() * (1.0/(65536.0*65536.0));
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom() * (1.0/(65536.0*65536.0));
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  				if (instrs == null)  					continue;    				IMethod methodRef;  				var ldftn = instrs[1];  				var newobj = instrs[2];    				methodRef = ldftn.Operand as IMethod;  				if (methodRef == null || !new SigComparer().Equals(initMethod.DeclaringType' methodRef.DeclaringType))  					continue;    				methodRef = newobj.Operand as IMethod;  				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,InitializeEmbeddedAssemblies,The following statement contains a magic number: var newAssemblyInfos = new List<AssemblyInfo>(tmpAssemblyInfos.Length / 2);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,InitializeEmbeddedAssemblies,The following statement contains a magic number: for (int i = 0; i < tmpAssemblyInfos.Length; i += 2) {  				var assemblyName = tmpAssemblyInfos[i];  				var resourceName = tmpAssemblyInfos[i + 1];  				var resource = DotNetUtils.GetResource(module' resourceName) as EmbeddedResource;  				var symbolsResource = DotNetUtils.GetResource(module' resourceName + "#") as EmbeddedResource;  				if (resource == null)  					return null;  				newAssemblyInfos.Add(new AssemblyInfo(assemblyName' resource' symbolsResource));  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Methods.Count != 7)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				infos.Clear();    				for (int i = 0; i < instrs.Count - 5; i++) {  					int index = i;    					var ldci4_arySize = instrs[index++];  					if (!ldci4_arySize.IsLdcI4())  						continue;    					var newarr = instrs[index++];  					if (newarr.OpCode.Code != Code.Newarr)  						continue;  					var arrayType = module.CorLibTypes.GetCorLibTypeSig(newarr.Operand as ITypeDefOrRef);  					if (arrayType == null)  						continue;    					if (instrs[index++].OpCode.Code != Code.Dup)  						continue;    					var ldci4_index = instrs[index++];  					if (!ldci4_index.IsLdcI4())  						continue;    					var call = instrs[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call.Operand as IMethod' methodArray))  						continue;    					if (arrayType.ElementType.GetPrimitiveSize() == -1) {  						Logger.w("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32());  						continue;  					}    					infos.Add(new ArrayInfo(i' index - i' arrayType' ldci4_arySize.GetLdcI4Value()'  								ldci4_index.GetLdcI4Value()));  				}    				infos.Reverse();  				foreach (var info in infos) {  					var elemSize = info.arrayType.ElementType.GetPrimitiveSize();  					var decrypted = DecryptArray(info);  					initializedDataCreator.AddInitializeArrayCode(block' info.start' info.len' info.arrayType.ToTypeDefOrRef()' decrypted);  					Logger.v("Decrypted {0} array: {1} elements"' info.arrayType.ToString()' decrypted.Length / elemSize);  				}  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundCryptoObfuscatorAttribute || foundObfuscatedSymbols || foundObfuscatorUserString)  				val += 10;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,CheckCryptoObfuscator,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Namespace != "A")  					continue;  				if (Regex.IsMatch(type.Name.String' "^c[0-9a-f]{32}$"))  					return true;  				else if (Regex.IsMatch(type.Name.String' "^A[A-Z]*$")) {  					if (++matched >= 10)  						return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ReadExceptionHandlers((totalSize - 4) / 24);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ReadExceptionHandlers((totalSize - 4) / 24);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,Check,The following statement contains a magic number: if (type.Fields.Count != 3)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  				if (instrs == null)  					continue;    				uint typeToken = (uint)(int)instrs[0].Operand;  				uint methodToken = (uint)(int)instrs[1].Operand;  				uint declaringTypeToken = (uint)(int)instrs[2].Operand;  				var createMethod = instrs[3].Operand as MethodDef;    				ProxyCreatorType proxyCreatorType;  				if (!methodToType.TryGetValue(createMethod' out proxyCreatorType))  					continue;    				return new Context(typeToken' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  				if (instrs == null)  					continue;    				uint typeToken = (uint)(int)instrs[0].Operand;  				uint methodToken = (uint)(int)instrs[1].Operand;  				uint declaringTypeToken = (uint)(int)instrs[2].Operand;  				var createMethod = instrs[3].Operand as MethodDef;    				ProxyCreatorType proxyCreatorType;  				if (!methodToType.TryGetValue(createMethod' out proxyCreatorType))  					continue;    				return new Context(typeToken' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreateMethod,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 18)  				return null;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFramework,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Fields.Count < 5)  					continue;  				if (!new FieldTypes(type).All(requiredTypes))  					continue;    				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				if (!CheckCctor(cctor))  					continue;    				resourceDecrypterType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,InitializeHeaderInfo,The following statement contains a magic number: deflatedFlag = 2;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,InitializeHeaderInfo,The following statement contains a magic number: bitwiseNotEncryptedFlag = 4;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: if (method == null || method.Body == null || method.Body.Variables.Count < 3)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  				var and = instructions[i];  				if (and.OpCode.Code != Code.And)  					continue;  				var ldci4 = instructions[i - 1];  				if (!ldci4.IsLdcI4())  					continue;  				int flagValue = ldci4.GetLdcI4Value();  				if (!IsFlag(flagValue))  					continue;  				var ldloc = instructions[i - 2];  				if (!ldloc.IsLdloc())  					continue;  				var local = ldloc.GetLocal(method.Body.Variables);  				if (local.Type.GetElementType().GetPrimitiveSize() < 0)  					continue;  				constants.Add(flagValue);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  				var and = instructions[i];  				if (and.OpCode.Code != Code.And)  					continue;  				var ldci4 = instructions[i - 1];  				if (!ldci4.IsLdcI4())  					continue;  				int flagValue = ldci4.GetLdcI4Value();  				if (!IsFlag(flagValue))  					continue;  				var ldloc = instructions[i - 2];  				if (!ldloc.IsLdloc())  					continue;  				var local = ldloc.GetLocal(method.Body.Variables);  				if (local.Type.GetElementType().GetPrimitiveSize() < 0)  					continue;  				constants.Add(flagValue);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: switch (frameworkType) {  			case FrameworkType.Desktop:  				if (!module.IsClr1x) {  					if (constants.Count == 2) {  						desEncryptedFlag = (byte)constants[0];  						deflatedFlag = (byte)constants[1];  						return true;  					}  				}  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.Silverlight:  				if (constants.Count == 1) {  					bitwiseNotEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.CompactFramework:  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int loopCount = ldci4.GetLdcI4Value();  				if (loopCount < 2 || loopCount > 4)  					continue;  				var blt = instrs[i + 1];  				if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  					continue;  				return loopCount - 1;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int loopCount = ldci4.GetLdcI4Value();  				if (loopCount < 2 || loopCount > 4)  					continue;  				var blt = instrs[i + 1];  				if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  					continue;  				return loopCount - 1;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  				var memStream = new MemoryStream((int)resourceStream.Length);  				using (var provider = new DESCryptoServiceProvider()) {  					var iv = new byte[8];  					sourceStream.Read(iv' 0' 8);  					provider.IV = iv;  					provider.Key = GetKey(sourceStream);    					using (var transform = provider.CreateDecryptor()) {  						while (true) {  							int count = sourceStream.Read(buffer1' 0' buffer1.Length);  							if (count <= 0)  								break;  							int count2 = transform.TransformBlock(buffer1' 0' count' buffer2' 0);  							memStream.Write(buffer2' 0' count2);  						}  						var finalData = transform.TransformFinalBlock(buffer1' 0' 0);  						memStream.Write(finalData' 0' finalData.Length);  					}  				}  				sourceStream = memStream;  				sourceStreamOffset = 0;  				didSomething = true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  				var memStream = new MemoryStream((int)resourceStream.Length);  				using (var provider = new DESCryptoServiceProvider()) {  					var iv = new byte[8];  					sourceStream.Read(iv' 0' 8);  					provider.IV = iv;  					provider.Key = GetKey(sourceStream);    					using (var transform = provider.CreateDecryptor()) {  						while (true) {  							int count = sourceStream.Read(buffer1' 0' buffer1.Length);  							if (count <= 0)  								break;  							int count2 = transform.TransformBlock(buffer1' 0' count' buffer2' 0);  							memStream.Write(buffer2' 0' count2);  						}  						var finalData = transform.TransformFinalBlock(buffer1' 0' 0);  						memStream.Write(finalData' 0' finalData.Length);  					}  				}  				sourceStream = memStream;  				sourceStreamOffset = 0;  				didSomething = true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetKey,The following statement contains a magic number: byte[] key = new byte[8];
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  				if (instrs == null)  					continue;    				IMethod methodRef;  				var ldftn = instrs[1];  				var newobj = instrs[2];    				methodRef = ldftn.Operand as IMethod;  				if (methodRef == null || !new SigComparer().Equals(setupMethod.DeclaringType' methodRef.DeclaringType))  					continue;    				methodRef = newobj.Operand as IMethod;  				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  					continue;    				foundCount++;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The following statement contains a magic number: switch (foundCount) {  			case 1: return ResolverVersion.V1;  			case 2: return ResolverVersion.V2;  			default: return ResolverVersion.None;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.IsPublic)  					continue;  				if (type.Fields.Count != 1)  					continue;  				if (DotNetUtils.FindFieldType(type' "System.Byte[]"' true) == null)  					continue;  				if (type.Methods.Count != 2 && type.Methods.Count != 3)  					continue;  				if (type.NestedTypes.Count > 0)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.IsMethod(m' "System.String"' "(System.Int32)")) {  						method = m;  						continue;  					}  					break;  				}  				if (method == null)  					continue;    				theType = type;  				theMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.IsPublic)  					continue;  				if (type.Fields.Count != 1)  					continue;  				if (DotNetUtils.FindFieldType(type' "System.Byte[]"' true) == null)  					continue;  				if (type.Methods.Count != 2 && type.Methods.Count != 3)  					continue;  				if (type.NestedTypes.Count > 0)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.IsMethod(m' "System.String"' "(System.Int32)")) {  						method = m;  						continue;  					}  					break;  				}  				if (method == null)  					continue;    				theType = type;  				theMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 27)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 27)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod(type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  			}  			else if (DotNetUtils.GetPInvokeMethod(type' "mscoree"' "CLRCreateInstance") != null) {  				if (type.NestedTypes.Count != 3)  					return false;  				if (!type.NestedTypes[0].IsInterface || !type.NestedTypes[1].IsInterface || !type.NestedTypes[2].IsInterface)  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod(type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  			}  			else if (DotNetUtils.GetPInvokeMethod(type' "mscoree"' "CLRCreateInstance") != null) {  				if (type.NestedTypes.Count != 3)  					return false;  				if (!type.NestedTypes[0].IsInterface || !type.NestedTypes[1].IsInterface || !type.NestedTypes[2].IsInterface)  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate1,The following statement contains a magic number: if (i >= instrs.Count - 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate1,The following statement contains a magic number: var ldelem = instrs[i + 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate1,The following statement contains a magic number: block.Remove(i' 3 - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate2,The following statement contains a magic number: if (i >= instrs.Count - 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate2,The following statement contains a magic number: var ldelem = instrs[i + 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate2,The following statement contains a magic number: block.Remove(i' 3 - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate3,The following statement contains a magic number: i += 2;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.Find(targetField) == null) {  					fieldToInfo.Add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.Find(targetField) == null) {  					fieldToInfo.Add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.Find(targetField) == null) {  					fieldToInfo.Add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.Remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,CreateArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,CreateArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,CreateArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,CreateArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV4,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldtoken = instrs[index++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					return false;    				var ldci4_len = instrs[index++];  				if (!ldci4_len.IsLdcI4())  					return false;  				if (ldci4_len.GetLdcI4Value() != field.InitialValue.Length)  					return false;    				var ldci4_magic = instrs[index++];  				if (!ldci4_magic.IsLdcI4())  					return false;  				int magic = ldci4_magic.GetLdcI4Value();    				var call = instrs[index++];  				if (call.OpCode.Code == Code.Tailcall)  					call = instrs[index++];  				if (call.OpCode.Code != Code.Call)  					return false;  				var decryptMethodTmp = call.Operand as MethodDef;  				if (!DotNetUtils.IsMethod(decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)"))  					return false;    				decryptMethod = decryptMethodTmp;  				fieldInfos.Add(new FieldInfo(field' magic));  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV404_41,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  				int index = i;    				var ldci4_len = instrs[index++];  				if (!ldci4_len.IsLdcI4())  					continue;  				if (instrs[index++].OpCode.Code != Code.Newarr)  					continue;  				if (!instrs[index++].IsStloc())  					continue;  				if (!instrs[index++].IsLdloc())  					continue;    				var ldtoken = instrs[index++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					continue;    				var call1 = instrs[index++];  				if (call1.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsMethod(call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				int callIndex = GetCallDecryptMethodIndex(instrs' index);  				if (callIndex < 0)  					continue;  				var args = DsUtils.GetArgValues(instrs' callIndex);  				if (args == null)  					continue;  				var decryptMethodTmp = instrs[callIndex].Operand as MethodDef;  				if (decryptMethodTmp == null)  					continue;  				int magic;  				Version versionTmp;  				GetMagic(decryptMethodTmp' args' out versionTmp' out magic);    				version = versionTmp;  				decryptMethod = decryptMethodTmp;  				fieldInfos.Add(new FieldInfo(field' magic));  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetMagicIndex404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;  				if (!instrs[index++].IsLdloc())  					continue;  				var ldarg = instrs[index++];  				if (!ldarg.IsLdarg())  					continue;  				if (instrs[index++].OpCode.Code != Code.Add)  					continue;  				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 0xFF)  					continue;  				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetMagicIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;  				if (instrs[index++].OpCode.Code != Code.Div)  					continue;  				var ldarg = instrs[index++];  				if (!ldarg.IsLdarg())  					continue;  				if (instrs[index++].OpCode.Code != Code.Add)  					continue;  				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 0xFF)  					continue;  				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetCallDecryptMethodIndex,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  				var instr = instrs[i];  				if (!IsCallOrNext(instr))  					break;  				if (instr.OpCode.Code != Code.Call)  					continue;  				var calledMethod = instr.Operand as IMethod;  				if (calledMethod == null || calledMethod.MethodSig.GetParamCount() < 2)  					continue;    				return i;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,Decrypt41Trial,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  				data[i] ^= (byte)(i / 3 + magic);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectMethodProxyObfuscation,The following statement contains a magic number: const int MIN_FOUND_PROXIES = 10;
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectMethodProxyObfuscation,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				foreach (var method in type.Methods) {  					if (foundProxies >= MIN_FOUND_PROXIES)  						goto done;  					if (!method.IsStatic || method.Body == null)  						continue;  					if (checkedMethods++ >= 1000)  						goto done;  					if (!DsMethodCallInliner.CanInline(method))  						continue;  					foundProxies++;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: if (instrIndex < 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: var ldci4_1st = block.Instructions[instrIndex - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: arg1 = parameters[parameters.Count - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: var patcher = TryInlineOtherMethod(instrIndex' methodToInline' methodToInline.Body.Instructions[index]' index + 1' 2);
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The following statement contains a magic number: while (true) {  				if (counter++ >= 50)  					return false;  				if (index < 0 || index >= instrs.Count)  					return false;  				instr = instrs[index];  				foundOpCodes[instr.OpCode.Code] = true;  				switch (instr.OpCode.Code) {  				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  				case Code.Ldc_I4:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  				case Code.Ldc_I4_S:  				case Code.Add:  				case Code.Sub:  				case Code.Xor:  				case Code.Or:  				case Code.Nop:  				case Code.Dup:  				case Code.Mul:  				case Code.Rem:  				case Code.Div:  					instructionEmulator.Emulate(instr);  					index++;  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					var arg = instr.GetParameter(parameters);  					if (arg != arg1 && arg != arg2) {  						if (!allowUnknownArgs)  							goto done;  						checkInstrs = true;  					}  					instructionEmulator.Emulate(instr);  					index++;  					break;    				case Code.Call:  				case Code.Callvirt:  				case Code.Newobj:  					goto done;    				case Code.Switch:  					var value = instructionEmulator.Pop() as Int32Value;  					if (value == null || !value.AllBitsValid())  						return false;  					var targets = (Instruction[])instr.Operand;  					if (value.Value >= 0 && value.Value < targets.Length)  						index = instrs.IndexOf(targets[value.Value]);  					else  						index++;  					break;    				case Code.Br:  				case Code.Br_S:  					index = instrs.IndexOf((Instruction)instr.Operand);  					break;    				case Code.Brtrue:  				case Code.Brtrue_S:  					index = EmulateBrtrue(index);  					break;    				case Code.Brfalse:  				case Code.Brfalse_S:  					index = EmulateBrfalse(index);  					break;    				case Code.Isinst:  				case Code.Castclass:  					if (returnValue != null && instructionEmulator.Peek() == returnValue) {  						// Do nothing  					}  					else  						instructionEmulator.Emulate(instr);  					index++;  					break;    				default:  					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  						goto done;  					index++;  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,CanInline,The following statement contains a magic number: if (paramCount < 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,CanInline,The following statement contains a magic number: var param2 = parameters[paramCount - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var stfld = instrs[i];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;  					var field = stfld.Operand as IField;  					if (field == null)  						continue;  					if (!structFieldsToFix.Find(field))  						continue;  					var instrs2 = ToInstructionList(instrs);  					var instrPushes = DotNetUtils.GetArgPushes(instrs2' i);  					if (instrPushes == null || instrPushes.Count != 2)  						continue;  					block.Remove(i' 1);  					block.Remove(instrs2.IndexOf(instrPushes[1])' 1);  					block.Remove(instrs2.IndexOf(instrPushes[0])' 1);  					i -= 3;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var stfld = instrs[i];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;  					var field = stfld.Operand as IField;  					if (field == null)  						continue;  					if (!structFieldsToFix.Find(field))  						continue;  					var instrs2 = ToInstructionList(instrs);  					var instrPushes = DotNetUtils.GetArgPushes(instrs2' i);  					if (instrPushes == null || instrPushes.Count != 2)  						continue;  					block.Remove(i' 1);  					block.Remove(instrs2.IndexOf(instrPushes[1])' 1);  					block.Remove(instrs2.IndexOf(instrPushes[0])' 1);  					i -= 3;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResolverBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResolverBase.cs,DecryptResourceV41SL,The following statement contains a magic number: for (int i = 0; i < data.Length - 1; i++)  				data[i + 1] ^= (byte)((k << (i & 5)) + i);
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg())  					continue;  				if (!instrs[i + 1].IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Shr)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg())  					continue;  				if (!instrs[i + 1].IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Shr)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				var newarr = instrs[i + 1];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;  				if (newarr.Operand.ToString() != "System.Char")  					continue;    				var stloc = instrs[i + 2];  				if (!stloc.IsStloc())  					continue;  				var local = stloc.GetLocal(initMethod.Body.Variables);    				int startInitIndex = i;  				i++;  				var array = ArrayFinder.GetInitializedInt16Array(ldci4.GetLdcI4Value()' initMethod' ref i);  				if (array == null)  					continue;    				var field = GetStoreField(initMethod' startInitIndex' local);  				if (field == null)  					continue;  				if (fields.Find(field))  					return array;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				var newarr = instrs[i + 1];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;  				if (newarr.Operand.ToString() != "System.Char")  					continue;    				var stloc = instrs[i + 2];  				if (!stloc.IsStloc())  					continue;  				var local = stloc.GetLocal(initMethod.Body.Variables);    				int startInitIndex = i;  				i++;  				var array = ArrayFinder.GetInitializedInt16Array(ldci4.GetLdcI4Value()' initMethod' ref i);  				if (array == null)  					continue;    				var field = GetStoreField(initMethod' startInitIndex' local);  				if (field == null)  					continue;  				if (fields.Find(field))  					return array;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,IsPossibleDecrypterMethod,The following statement contains a magic number: if (fields == null || fields.Count != 3)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,CheckMethodSignature,The following statement contains a magic number: return count >= 2;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (arrayInfo.initField.InitialValue.Length % 2 == 1)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Initialize,The following statement contains a magic number: encryptedData = new ushort[arrayInfo.initField.InitialValue.Length / 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKeyShift,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  					int index = i;    					var ldci4 = instrs[index++];  					if (!ldci4.IsLdcI4())  						continue;  					if (ldci4.GetLdcI4Value() != 0xFF)  						continue;    					if (instrs[index++].OpCode.Code != Code.And)  						continue;  					if (instrs[index++].OpCode.Code != Code.Dup)  						continue;    					var ldci4_2 = instrs[index++];  					if (!ldci4_2.IsLdcI4())  						continue;    					if (FindNextFieldUse(method' index) < 0)  						continue;    					return ldci4_2.GetLdcI4Value();  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,GetArrayInfo,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  					var ldci4_arraySizeInBytes = instructions[i];  					if (!ldci4_arraySizeInBytes.IsLdcI4())  						continue;  					i++;  					var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					int sizeInBytes = ldci4_arraySizeInBytes.GetLdcI4Value();  					var elementType = instrs[0].Operand as ITypeDefOrRef;  					var initField = instrs[2].Operand as FieldDef;  					var field = instrs[4].Operand as FieldDef;  					if (elementType == null)  						continue;  					if (initField == null || initField.InitialValue == null || initField.InitialValue.Length == 0)  						continue;  					if (!fields.Find(field))  						continue;    					return new ArrayInfo(sizeInBytes' elementType' initField' field);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,GetArrayInfo,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  					var ldci4_arraySizeInBytes = instructions[i];  					if (!ldci4_arraySizeInBytes.IsLdcI4())  						continue;  					i++;  					var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					int sizeInBytes = ldci4_arraySizeInBytes.GetLdcI4Value();  					var elementType = instrs[0].Operand as ITypeDefOrRef;  					var initField = instrs[2].Operand as FieldDef;  					var field = instrs[4].Operand as FieldDef;  					if (elementType == null)  						continue;  					if (initField == null || initField.InitialValue == null || initField.InitialValue.Length == 0)  						continue;  					if (!fields.Find(field))  						continue;    					return new ArrayInfo(sizeInBytes' elementType' initField' field);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptTrial,The following statement contains a magic number: offset += 4;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail2,The following statement contains a magic number: return DecryptRetail(magic2' magic3' 2' 1' 0' 8' 0);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail2,The following statement contains a magic number: return DecryptRetail(magic2' magic3' 2' 1' 0' 8' 0);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail3,The following statement contains a magic number: return DecryptRetail(magic2' magic3' 0' 2' 1' 0x20' 17);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail3,The following statement contains a magic number: return DecryptRetail(magic2' magic3' 0' 2' 1' 0x20' 17);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail,The following statement contains a magic number: if ((flags & flag) != 0) {  					numChars <<= 15;  					numChars |= encryptedData[offset + 3] ^ keyChar;  					offset++;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail,The following statement contains a magic number: if ((flags & flag) != 0) {  					numChars <<= 15;  					numChars |= encryptedData[offset + 3] ^ keyChar;  					offset++;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,DecryptRetail,The following statement contains a magic number: offset += 3;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (charArrayFields == null || charArrayFields.Count != 2)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (encryptedDataField.InitialValue.Length % 2 == 1)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Initialize,The following statement contains a magic number: encryptedData = new ushort[encryptedDataField.InitialValue.Length / 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindEncryptedStrings,The following statement contains a magic number: for (int i = 0; i < initMethod.Body.Instructions.Count; i++) {  					var instrs = DotNetUtils.GetInstructions(initMethod.Body.Instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					dataField = instrs[0].Operand as FieldDef;  					if (dataField == null || dataField.InitialValue == null || dataField.InitialValue.Length == 0)  						continue;    					var savedField = instrs[2].Operand as FieldDef;  					if (savedField == null || !Matches(ourFields' savedField))  						continue;    					return savedField;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,GetPublicKeyTokenKey,The following statement contains a magic number: for (int i = 0; i < publicKeyToken.Length; i++) {  					int b = publicKeyToken[i];  					key[i] = (short)((b << 4) ^ b);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Decrypt,The following statement contains a magic number: int stringLen = encryptedData[index++] + ((int)encryptedData[index++] << 16);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,GetPublicKeyTokenKey,The following statement contains a magic number: for (int i = 0; i < publicKeyToken.Length; i++) {  					int b = publicKeyToken[i];  					key[i] = (short)((b << 4) ^ b);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var ldarg = instrs[i];  					if (ldarg.GetParameterIndex() < 0)  						continue;  					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Xor)  						continue;  					magic = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var ldarg = instrs[i];  					if (ldarg.GetParameterIndex() < 0)  						continue;  					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Xor)  						continue;  					magic = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundDotfuscatorAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) {  				if (method.Body.HasExceptionHandlers)  					continue;    				if (DotNetUtils.GetMethodCalls(method' "System.Char[] System.String::ToCharArray()") != 1)  					continue;  				if (DotNetUtils.GetMethodCalls(method' "System.String System.String::Intern(System.String)") != 1)  					continue;    				simpleDeobfuscator.Deobfuscate(method);  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 3; i++) {  					var ldarg = instrs[i];  					if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  						continue;  					var callvirt = instrs[i + 1];  					if (callvirt.OpCode.Code != Code.Callvirt)  						continue;  					var calledMethod = callvirt.Operand as MemberRef;  					if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  						continue;  					var stloc = instrs[i + 2];  					if (!stloc.IsStloc())  						continue;  					var ldci4 = instrs[i + 3];  					if (!ldci4.IsLdcI4())  						continue;    					var info = new StringDecrypterInfo(method' ldci4.GetLdcI4Value());  					stringDecrypterMethods.Add(info.method' info);  					Logger.v("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines(info.method)' info.magic);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) {  				if (method.Body.HasExceptionHandlers)  					continue;    				if (DotNetUtils.GetMethodCalls(method' "System.Char[] System.String::ToCharArray()") != 1)  					continue;  				if (DotNetUtils.GetMethodCalls(method' "System.String System.String::Intern(System.String)") != 1)  					continue;    				simpleDeobfuscator.Deobfuscate(method);  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 3; i++) {  					var ldarg = instrs[i];  					if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  						continue;  					var callvirt = instrs[i + 1];  					if (callvirt.OpCode.Code != Code.Callvirt)  						continue;  					var calledMethod = callvirt.Operand as MemberRef;  					if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  						continue;  					var stloc = instrs[i + 2];  					if (!stloc.IsStloc())  						continue;  					var ldci4 = instrs[i + 3];  					if (!ldci4.IsLdcI4())  						continue;    					var info = new StringDecrypterInfo(method' ldci4.GetLdcI4Value());  					stringDecrypterMethods.Add(info.method' info);  					Logger.v("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines(info.method)' info.magic);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) {  				if (method.Body.HasExceptionHandlers)  					continue;    				if (DotNetUtils.GetMethodCalls(method' "System.Char[] System.String::ToCharArray()") != 1)  					continue;  				if (DotNetUtils.GetMethodCalls(method' "System.String System.String::Intern(System.String)") != 1)  					continue;    				simpleDeobfuscator.Deobfuscate(method);  				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count - 3; i++) {  					var ldarg = instrs[i];  					if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  						continue;  					var callvirt = instrs[i + 1];  					if (callvirt.OpCode.Code != Code.Callvirt)  						continue;  					var calledMethod = callvirt.Operand as MemberRef;  					if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  						continue;  					var stloc = instrs[i + 2];  					if (!stloc.IsStloc())  						continue;  					var ldci4 = instrs[i + 3];  					if (!ldci4.IsLdcI4())  						continue;    					var info = new StringDecrypterInfo(method' ldci4.GetLdcI4Value());  					stringDecrypterMethods.Add(info.method' info);  					Logger.v("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines(info.method)' info.magic);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  				char c = chars[i];  				byte b1 = (byte)((byte)c ^ key++);  				byte b2 = (byte)((byte)(c >> 8) ^ key++);  				chars[i] = (char)((b1 << 8) | b2);  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  				char c = chars[i];  				byte b1 = (byte)((byte)c ^ key++);  				byte b2 = (byte)((byte)(c >> 8) ^ key++);  				chars[i] = (char)((b1 << 8) | b2);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,The following statement contains a magic number: const int numInstrsToRemove = 11;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock == goodblock) {  				// All of the bad block was removed by the cflow deobfuscator. It was just a useless  				// calculation (div by zero).  				block.ReplaceLastInstrsWithBranch(numInstrsToRemove' goodblock);  			}  			else if (badBlock.Sources.Count == 1) {  				instrs = badBlock.Instructions;  				if (instrs.Count != 12)  					return false;  				index = 0;  				if (!instrs[index++].IsLdcI4())  					return false;  				if (!instrs[index].IsStloc())  					return false;  				var local = Instr.GetLocalVar(blocks.Locals' instrs[index++]);  				if (local == null)  					return false;  				if (!CheckLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!CheckLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (instrs[index++].OpCode.Code != Code.Sub)  					return false;  				if (instrs[index++].OpCode.Code != Code.Conv_U1)  					return false;  				if (!CheckStloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!CheckLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!CheckLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (instrs[index++].OpCode.Code != Code.Div)  					return false;  				if (instrs[index++].OpCode.Code != Code.Conv_U1)  					return false;  				if (!CheckStloc(blocks.Locals' instrs[index++]' local))  					return false;    				block.ReplaceLastInstrsWithBranch(numInstrsToRemove' goodblock);  				badBlock.Parent.RemoveDeadBlock(badBlock);  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader(new MemoryStream(data)' Encoding.UTF8)) {  				while (true) {  					var line = reader.ReadLine();  					if (line == null)  						break;  					var match = Regex.Match(line' @"^([^=]+)=([^;]+);?\s*$");  					if (match.Groups.Count < 3)  						continue;  					var name = match.Groups[1].ToString().Trim();  					var value = match.Groups[2].ToString().Trim();  					nameToValue[name] = value;  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader(new MemoryStream(data)' Encoding.UTF8)) {  				while (true) {  					var line = reader.ReadLine();  					if (line == null)  						break;  					var match = Regex.Match(line' @"^([^=]+)=([^;]+);?\s*$");  					if (match.Groups.Count < 3)  						continue;  					var name = match.Groups[1].ToString().Trim();  					var value = match.Groups[2].ToString().Trim();  					nameToValue[name] = value;  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint headerOffset = (uint)peImage.Length - 12;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint ezencryptionLibLength = peImage.OffsetReadUInt32(headerOffset + 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint iniFileLength = peImage.OffsetReadUInt32(headerOffset + 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint offsetClrVersionNumber = checked(offsetEncryptedAssembly - 12);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint clrVerMinor = peImage.OffsetReadUInt32(offsetClrVersionNumber + 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: uint clrVerBuild = peImage.OffsetReadUInt32(offsetClrVersionNumber + 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,ClearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage(peImageData)) {  				uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  				ushort characteristics = mainPeImage.OffsetReadUInt16(characteristicsOffset);  				characteristics &= 0xDFFF;  				characteristics |= 2;  				mainPeImage.OffsetWriteUInt16(characteristicsOffset' characteristics);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,ClearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage(peImageData)) {  				uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  				ushort characteristics = mainPeImage.OffsetReadUInt16(characteristicsOffset);  				characteristics &= 0xDFFF;  				characteristics |= 2;  				mainPeImage.OffsetWriteUInt16(characteristicsOffset' characteristics);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: uint numPatches = peImage.OffsetReadUInt32(peImage.Length - 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: uint offset = checked(peImage.Length - 4 - numPatches * 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: uint offset = checked(peImage.Length - 4 - numPatches * 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = GetValue(peImage.OffsetReadUInt32(offset));  				var value = peImage.OffsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = GetValue(peImage.OffsetReadUInt32(offset));  					value = peImage.OffsetReadUInt32(offset + 4);  				}  				else  					value = GetValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = GetValue(peImage.OffsetReadUInt32(offset));  				var value = peImage.OffsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = GetValue(peImage.OffsetReadUInt32(offset));  					value = peImage.OffsetReadUInt32(offset + 4);  				}  				else  					value = GetValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = GetValue(peImage.OffsetReadUInt32(offset));  				var value = peImage.OffsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = GetValue(peImage.OffsetReadUInt32(offset));  					value = peImage.OffsetReadUInt32(offset + 4);  				}  				else  					value = GetValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = GetValue(peImage.OffsetReadUInt32(offset));  				var value = peImage.OffsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = GetValue(peImage.OffsetReadUInt32(offset));  					value = peImage.OffsetReadUInt32(offset + 4);  				}  				else  					value = GetValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = GetValue(peImage.OffsetReadUInt32(offset));  				var value = peImage.OffsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = GetValue(peImage.OffsetReadUInt32(offset));  					value = peImage.OffsetReadUInt32(offset + 4);  				}  				else  					value = GetValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.DotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,GetValue,The following statement contains a magic number: const uint magic = 2749;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,GetValue,The following statement contains a magic number: if (value % 3 != 0)  				throw new Exception();
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,GetValue,The following statement contains a magic number: return value / 3;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecryptMethod,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecryptMethod.cs,GetKey,The following statement contains a magic number: var tmpKey = ArrayFinder.GetInitializedByteArray(method' 32);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecryptMethod,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecryptMethod.cs,GetKey,The following statement contains a magic number: var tmpIv = ArrayFinder.GetInitializedByteArray(method' 16);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,GetPatchInfo,The following statement contains a magic number: if (size1 <= 0 || size1 > 35)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: var newData = new int[decrypted.Length / 4];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newData.Length; i++)  				newData[i] = BitConverter.ToInt32(decrypted' i * 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,CheckType,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				if (!CheckType(sig.RetType' ElementType.String))  					continue;  				if (!CheckType(sig.Params[0]' ElementType.String))  					continue;  				if (!CheckType(sig.Params[1]' ElementType.String))  					continue;    				var localTypes = new LocalTypes(method);  				if (!localTypes.All(requiredTypes))  					continue;    				antiStrongNameMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock.Instructions.Count <= 1 && badBlock.LastInstr.OpCode.Code == Code.Nop) {  				if (badBlock.FallThrough != null && badBlock.Targets == null && badBlock.Sources.Count == 0) {  					var badBlock2 = badBlock.FallThrough;  					if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {  						badBlock.Parent.RemoveGuaranteedDeadBlock(badBlock);  						badBlock2.Parent.RemoveGuaranteedDeadBlock(badBlock2);  						return true;  					}  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: const int NUM_INSTRS = 11;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				if (!block.LastInstr.IsBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!CheckCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!CheckCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!CheckCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!CheckCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!CheckCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!CheckCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckMethod,The following statement contains a magic number: foreach (var method in DotNetUtils.GetCalledMethods(module' methodToCheck)) {  				var type = method.DeclaringType;  				if (!DotNetUtils.IsMethod(method' "System.Void"' "()"))  					continue;  				if (!method.IsStatic)  					continue;    				if (type.Fields.Count != 2)  					continue;  				if (type.HasNestedTypes)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (!CheckFields(type.Fields))  					continue;    				var resolverMethod = FindAssemblyResolveMethod(type);  				if (resolverMethod == null)  					continue;    				var localTypes = new LocalTypes(resolverMethod);  				if (!localTypes.All(resolverLocals))  					continue;    				assemblyResolverType = type;  				assemblyResolverMethod = resolverMethod;  				assemblyResolverInitMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckFields,The following statement contains a magic number: if (fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum == 0) {  				if (HasMetadataStream("#GUlD") && HasMetadataStream("#Blop"))  					val += 10;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: foreach (var info in stringDecrypter.DecrypterInfos) {  				if (info.key == null)  					continue;  				localTypes = new LocalTypes(info.method);  				if (!localTypes.Exists("System.IntPtr"))  					return DeobfuscatorInfo.THE_NAME + " <= 3.7";  				minVer = 3800;  				break;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (methodsDecrypter.Method == null) {  				if (minVer >= 3800)  					return DeobfuscatorInfo.THE_NAME + " >= 3.8";  				return DeobfuscatorInfo.THE_NAME;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (localTypes.Exists("System.Int32[]")) {  				if (minVer >= 3800)  					return DeobfuscatorInfo.THE_NAME + " 3.8.4.1 - 3.9.0.1";  				return DeobfuscatorInfo.THE_NAME + " <= 3.9.0.1";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  				bool callsReverse = DotNetUtils.CallsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  				if (!callsReverse)  					return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";    				int numIntPtrSizeCompares = CountCompareSystemIntPtrSize(methodsDecrypter.Method);  				bool hasSymmetricAlgorithm = new LocalTypes(methodsDecrypter.Method).Exists("System.Security.Cryptography.SymmetricAlgorithm");  				if (module.IsClr40) {  					switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}  				else {  					switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}  				}    				// Should never be reached unless it's a new version  				return DeobfuscatorInfo.THE_NAME + " 4.5+";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,CountCompareSystemIntPtrSize,The following statement contains a magic number: for (int i = 1; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (!instrs[i + 1].IsConditionalBranch())  					continue;  				var call = instrs[i - 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MemberRef;  				if (calledMethod == null || calledMethod.FullName != "System.Int32 System.IntPtr::get_Size()")  					continue;    				count++;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				if (count >= 40)  					break;  				foreach (var method in type.Methods) {  					if (method.Name != ".ctor" && method.Name != ".cctor" && module.EntryPoint != method)  						continue;  					foreach (var calledMethod in DotNetUtils.GetCalledMethods(module' method)) {  						if (!calledMethod.IsStatic || calledMethod.Body == null)  							continue;  						if (!DotNetUtils.IsMethod(calledMethod' "System.Void"' "()"))  							continue;  						if (IsEmptyClass(calledMethod)) {  							callCounter.Add(calledMethod);  							count++;  						}  					}  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,The following statement contains a magic number: if (numCalls >= 10)  				emptyMethod = theMethod;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Name == ".ctor" || method.Name == ".cctor")  					continue;  				if (method == emptyMethod)  					continue;  				otherMethods++;  				if (method.Body == null)  					return false;  				if (method.Body.Instructions.Count > 20)  					return false;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,The following statement contains a magic number: if (otherMethods > 8)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: key = ArrayFinder.GetInitializedByteArray(resourceDecrypterMethod' 32);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: iv = ArrayFinder.GetInitializedByteArray(resourceDecrypterMethod' 16);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (UsesPublicKeyToken()) {  				var publicKeyToken = module.Assembly.PublicKeyToken;  				if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  					for (int i = 0; i < 8; i++)  						iv[i * 2 + 1] = publicKeyToken.Data[i];  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (UsesPublicKeyToken()) {  				var publicKeyToken = module.Assembly.PublicKeyToken;  				if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  					for (int i = 0; i < 8; i++)  						iv[i * 2 + 1] = publicKeyToken.Data[i];  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Find,The following statement contains a magic number: int typesLeft = 30;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,XorEncrypt,The following statement contains a magic number: int count = data.Length / 8;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,XorEncrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				long val = reader.ReadInt64();  				val ^= xorKey;  				stream.Position -= 8;  				writer.Write(val);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodsDataReader.Position -= 4;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				PatchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					PatchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0+    				PatchDwords(peImage' methodsDataReader' patchCount);  				bool oldCode = !IsNewer45Decryption(encryptedResource.Method);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					int size;  					if (oldCode) {  						methodsDataReader.ReadUInt32();	// token' unknown' or index  						size = methodsDataReader.ReadInt32();  					}  					else  						size = methodsDataReader.ReadInt32() * 4;    					var newData = methodsDataReader.ReadBytes(size);  					if (unpackedNativeFile)  						peImage.DotNetSafeWriteOffset(rva' newData);  					else  						peImage.DotNetSafeWrite(rva' newData);  				}  			}  			else {  				// DNR 4.0+ (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.OffsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.ReadByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.ReadByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				PatchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.IsCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.IsCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.ReadMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.RvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.ParseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.UpdateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.Add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Mul)  					continue;  				ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 4)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Ldloca_S && instrs[i + 3].OpCode.Code != Code.Ldloca)  					continue;  				var call = instrs[i + 4];  				if (call.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.IsPinvokeMethod(call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: int len = 12;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  				if (kv.Key.DeclaringType == null)  					continue;	// Method was removed  				if (kv.Key.DeclaringType.Module != module)  					continue;	// method.DeclaringType was removed  				validNativeMethods.Add(kv.Key);  				len += 3 * 4 + kv.Value.Length;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  				if (kv.Key.DeclaringType == null)  					continue;	// Method was removed  				if (kv.Key.DeclaringType.Module != module)  					continue;	// method.DeclaringType was removed  				validNativeMethods.Add(kv.Key);  				len += 3 * 4 + kv.Value.Length;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  				var code = methodToNativeMethod[method];    				var mb = moduleWriter.MetaData.GetMethodBody(method);  				if (mb == null) {  					Logger.e("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  					continue;  				}    				uint codeRva = (uint)mb.RVA;  				if (mb.IsTiny)  					codeRva++;  				else  					codeRva += (uint)(4 * (mb.Code[1] >> 4));    				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva);    				writer.Write(codeRva);  				writer.Write(0x70000000 + index++);  				writer.Write(code.Length);  				writer.Write(code);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  				var code = methodToNativeMethod[method];    				var mb = moduleWriter.MetaData.GetMethodBody(method);  				if (mb == null) {  					Logger.e("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  					continue;  				}    				uint codeRva = (uint)mb.RVA;  				if (mb.IsTiny)  					codeRva++;  				else  					codeRva += (uint)(4 * (mb.Code[1] >> 4));    				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva);    				writer.Write(codeRva);  				writer.Write(0x70000000 + index++);  				writer.Write(code.Length);  				writer.Write(code);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,FindDnrCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 6)  					continue;  				if (GetCompileMethodType(method) == CompileMethodType.Unknown)  					continue;  				return method;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: key = new byte[32];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  				key[i] = (byte)(i + keyInit[i % keyInit.Length] * keyInit[((i + 0x0B) | 0x1F) % keyInit.Length]);  				kb += key[i];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var transformTemp = new ushort[256' 256];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var transformTemp = new ushort[256' 256];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				for (int j = 0; j < 256; j++)  					transformTemp[i' j] = 0x400;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				for (int j = 0; j < 256; j++)  					transformTemp[i' j] = 0x400;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				while (true) {  					for (int j = key.Length - 1; j >= ki; j--)  						newByte += (byte)(key[j] + counter);  					bool done = true;  					ki = (ki + 1) % key.Length;  					for (int k = 0; k <= i; k++) {  						if (newByte == transformTemp[k' 0]) {  							done = false;  							break;  						}  					}  					if (done)  						break;  					counter++;  				}  				transformTemp[i' 0] = newByte;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				for (int j = 0; j < 256; j++)  					transform[(byte)transformTemp[i' j]' j] = (byte)i;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				for (int j = 0; j < 256; j++)  					transform[(byte)transformTemp[i' j]' j] = (byte)i;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: var dataEntry = peImage.PEImage.Win32Resources.Find(10' "__"' 0);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: if (isNet1x)  				inflatedData = DeobUtils.Inflate(encryptedData' false);  			else {  				int inflatedSize = BitConverter.ToInt32(encryptedData' 0);  				inflatedData = new byte[inflatedSize];  				var inflater = new Inflater(false);  				inflater.SetInput(encryptedData' 4' encryptedData.Length - 4);  				int count = inflater.Inflate(inflatedData);  				if (count != inflatedSize)  					return null;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: if (isNet1x)  				inflatedData = DeobUtils.Inflate(encryptedData' false);  			else {  				int inflatedSize = BitConverter.ToInt32(encryptedData' 0);  				inflatedData = new byte[inflatedSize];  				var inflater = new Inflater(false);  				inflater.SetInput(encryptedData' 4' encryptedData.Length - 4);  				int count = inflater.Inflate(inflatedData);  				if (count != inflatedSize)  					return null;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: if (DeobUtils.IsCode(startMethodNet1xPattern' net1xCode)) {  				isNet1x = true;  				return new byte[6] { 0x34' 0x38' 0x63' 0x65' 0x7A' 0x35 };  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: return new byte[6] {  				peImage.OffsetReadByte(baseOffset + 5)'  				peImage.OffsetReadByte(baseOffset + 0xF)'  				peImage.OffsetReadByte(baseOffset + 0x58)'  				peImage.OffsetReadByte(baseOffset + 0x6D)'  				peImage.OffsetReadByte(baseOffset + 0x98)'  				peImage.OffsetReadByte(baseOffset + 0xA6)'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: return new byte[6] {  				peImage.OffsetReadByte(baseOffset + 5)'  				peImage.OffsetReadByte(baseOffset + 0xF)'  				peImage.OffsetReadByte(baseOffset + 0x58)'  				peImage.OffsetReadByte(baseOffset + 0x6D)'  				peImage.OffsetReadByte(baseOffset + 0x98)'  				peImage.OffsetReadByte(baseOffset + 0xA6)'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,CheckFields,The following statement contains a magic number: if (fields.Count != 3)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,CheckFields,The following statement contains a magic number: if (fieldTypes.Count("System.Object") == 2)  				return true;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.GetCalledMethods(module' method)) {  				if (calledMethod.DeclaringType != method.DeclaringType)  					continue;  				if (calledMethod.MethodSig.GetRetType().GetFullName() != "System.Byte[]")  					continue;  				var localTypes = new LocalTypes(calledMethod);  				if (!localTypes.All(requiredTypes))  					continue;    				var instructions = calledMethod.Body.Instructions;  				byte[] newKey = null' newIv = null;  				for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  					var instr = instructions[i];  					if (instr.OpCode.Code != Code.Ldtoken)  						continue;  					var field = instr.Operand as FieldDef;  					if (field == null)  						continue;  					if (field.InitialValue == null)  						continue;  					if (field.InitialValue.Length == 32)  						newKey = field.InitialValue;  					else if (field.InitialValue.Length == 16)  						newIv = field.InitialValue;  				}  				if (newKey == null || newIv == null)  					continue;    				InitializeStringDecrypterVersion(method);  				key = newKey;  				iv = newIv;  				return;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.GetCalledMethods(module' method)) {  				if (calledMethod.DeclaringType != method.DeclaringType)  					continue;  				if (calledMethod.MethodSig.GetRetType().GetFullName() != "System.Byte[]")  					continue;  				var localTypes = new LocalTypes(calledMethod);  				if (!localTypes.All(requiredTypes))  					continue;    				var instructions = calledMethod.Body.Instructions;  				byte[] newKey = null' newIv = null;  				for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  					var instr = instructions[i];  					if (instr.OpCode.Code != Code.Ldtoken)  						continue;  					var field = instr.Operand as FieldDef;  					if (field == null)  						continue;  					if (field.InitialValue == null)  						continue;  					if (field.InitialValue.Length == 32)  						newKey = field.InitialValue;  					else if (field.InitialValue.Length == 16)  						newIv = field.InitialValue;  				}  				if (newKey == null || newIv == null)  					continue;    				InitializeStringDecrypterVersion(method);  				key = newKey;  				iv = newIv;  				return;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.ReadInt32(rva);  					encryptedStringData = peImage.ReadBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.AesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.ReadInt32(rva);  					encryptedStringData = peImage.ReadBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.AesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.ReadInt32(rva);  					encryptedStringData = peImage.ReadBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.AesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethodSilverlight,The following statement contains a magic number: if (type.NestedTypes.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				if (!DotNetUtils.IsMethod(method' "System.Byte[]"' "(System.Byte[])"))  					continue;  				if (!DeobUtils.HasInteger(method' 32) ||  					!DeobUtils.HasInteger(method' 121))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				if (!DotNetUtils.IsMethod(method' "System.Byte[]"' "(System.Byte[])"))  					continue;  				if (!DeobUtils.HasInteger(method' 32) ||  					!DeobUtils.HasInteger(method' 121))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings(decryptMethod)) {  				decryptKey = DecodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.GetMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.HasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.HasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.HasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  				var info = new AssemblyInfo();    				info.AssemblyFullName = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i]));  				info.ResourceName = ary[i + 1];  				if (numElements >= 3)  					info.Filename = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i + 2]));  				else  					info.Filename = Utils.GetAssemblySimpleName(info.AssemblyFullName) + ".dll";  				int index = info.ResourceName.IndexOf('|');  				if (index >= 0) {  					var flags = info.ResourceName.Substring(0' index);  					info.ResourceName = info.ResourceName.Substring(index + 1);  					info.IsEncrypted = flags.IndexOf('a') >= 0;  					info.IsCompressed = flags.IndexOf('b') >= 0;  				}    				infos.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  				var info = new AssemblyInfo();    				info.AssemblyFullName = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i]));  				info.ResourceName = ary[i + 1];  				if (numElements >= 3)  					info.Filename = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i + 2]));  				else  					info.Filename = Utils.GetAssemblySimpleName(info.AssemblyFullName) + ".dll";  				int index = info.ResourceName.IndexOf('|');  				if (index >= 0) {  					var flags = info.ResourceName.Substring(0' index);  					info.ResourceName = info.ResourceName.Substring(index + 1);  					info.IsEncrypted = flags.IndexOf('a') >= 0;  					info.IsCompressed = flags.IndexOf('b') >= 0;  				}    				infos.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: var indexes = new byte[256];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					Swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					Swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					Swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decompress,The following statement contains a magic number: return DeobUtils.Inflate(compressedData' 8' compressedData.Length - 8' true);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decompress,The following statement contains a magic number: return DeobUtils.Inflate(compressedData' 8' compressedData.Length - 8' true);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods = new MethodDef[6];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods[5] = FindEfConstMethodCall(efConstMethods[0]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods[4] = FindEfConstMethodCall(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods[4] = FindEfConstMethodCall(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: var calls = FindEfConstMethodCalls(efConstMethods[4]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (calls.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods[3] = FindEfConstMethodCall(efConstMethods[1]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindInt1And2,The following statement contains a magic number: var consts = GetConstants(efConstMethods[2]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindInt1And2,The following statement contains a magic number: if (consts.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindInt3,The following statement contains a magic number: var consts = GetConstants(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethodInts,The following statement contains a magic number: foreach (var nestedType in type.NestedTypes) {  				var methods = GetBinaryIntMethods(nestedType);  				if (methods.Count < 3)  					continue;  				foreach (var m in methods)  					simpleDeobfuscator.Deobfuscate(m);  				if (!FindMethod1Int(methods))  					continue;  				if (!FindMethod2Int(methods))  					continue;  				if (!FindMethod3Int(methods))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod2Int,The following statement contains a magic number: foreach (var method in methods) {  				var constants = GetConstants(method);  				if (constants.Count != 2)  					continue;    				m2_i1 = constants[0];  				m2_i2 = constants[1];  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod3Int,The following statement contains a magic number: foreach (var method in methods) {  				if (CountInstructions(method' Code.Ldarg_0) != 2)  					continue;  				var constants = GetConstants(method);  				if (constants.Count != 1)  					continue;    				m3_i1 = constants[0];  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod1,The following statement contains a magic number: return BinOp3(BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[0].DeclaringType.MDToken.ToInt32()' efConstMethods[4].DeclaringType.MDToken.ToInt32()))' ConstMethod6());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' ConstMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' ConstMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' ConstMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The following statement contains a magic number: return BinOp3(BinOp1(ConstMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' BinOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The following statement contains a magic number: return BinOp3(BinOp1(ConstMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' BinOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' BinOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The following statement contains a magic number: return BinOp2(BinOp2(ConstMethod3()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' ConstMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The following statement contains a magic number: return BinOp2(BinOp2(ConstMethod3()' BinOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' ConstMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' BinOp3(BinOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' ConstMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' BinOp3(BinOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' ConstMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' BinOp3(BinOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' BinOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' ConstMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 24));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 16));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 8));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 16));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 8));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 24));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: foreach (var b in bytes) {  				magic += b;  				magic += magic << 20;  				magic ^= magic >> 12;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: foreach (var b in bytes) {  				magic += b;  				magic += magic << 20;  				magic ^= magic >> 12;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic += magic << 6;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic ^= magic >> 22;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic += magic << 30;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (detectedVersion)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,EfConstantsReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\EfConstantsReader.cs,FindConstants,The following statement contains a magic number: if (localsValuesInt32.Count != 2)  				localsValuesInt32.Clear();
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckIfV32OrLater,The following statement contains a magic number: return numInts >= 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckType,The following statement contains a magic number: if (type.NestedTypes.Count == 0) {  				return DotNetUtils.FindFieldType(type' "System.IO.BinaryReader"' true) != null &&  					DotNetUtils.FindFieldType(type' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' true) != null;  			}  			else if (type.NestedTypes.Count == 3) {  				streamHelperType = FindStreamHelperType(type);  				return streamHelperType != null;  			}  			else if (type.NestedTypes.Count == 1) {  				return type.NestedTypes[0].IsEnum;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: checkMinus2 = isV32OrLater || DeobUtils.HasInteger(stringMethod' -2);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,The following statement contains a magic number: var flags = new List<FlagsInfo>(3);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  				var instr = stringMethod.Body.Instructions[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					break;  				if (!stringMethodConsts.IsLoadConstantInt32(instr))  					continue;  				int index2 = i' value;  				if (!stringMethodConsts.GetInt32(ref index2' out value))  					continue;  				if ((uint)value != 0x80000000 && value != 0x40000000 && value != 0x20000000)  					continue;  				var local = GetFlagsLocal(stringMethod' index2);  				if (local == null)  					continue;  				int offset = GetFlagsOffset(stringMethod' index2' local);  				if (offset < 0)  					continue;    				flags.Add(new FlagsInfo(local' (uint)value' offset));  				if (flags.Count != 3)  					continue;    				return flags;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetFlagsLocal,The following statement contains a magic number: if (index + 5 >= instrs.Count)  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				Decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: int srcIndex = 4;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: int bit = 128;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: byte b = (byte)((key[1] + 7) ^ (dest.Length + 11));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: byte b = (byte)((key[1] + 7) ^ (dest.Length + 11));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: b += 3;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = LcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = LcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = LcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,LcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,LcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var instr = instrs[i];    				FieldDef field;  				switch (instr.OpCode.Code) {  				case Code.Ldsfld:  					field = instr.Operand as FieldDef;  					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)  						goto default;  					fields[field] = null;  					emu.Push(new Int32Value(i1));  					break;    				case Code.Stsfld:  					field = instr.Operand as FieldDef;  					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)  						goto default;  					if (fields.ContainsKey(field) && fields[field] == null)  						goto default;  					var val = emu.Pop() as Int32Value;  					if (val == null || !val.AllBitsValid())  						fields[field] = null;  					else  						fields[field] = val.Value;  					break;    				case Code.Call:  					var method = instr.Operand as MethodDef;  					if (!decrypterType.Detected || method != decrypterType.Int64Method)  						goto done;  					emu.Push(new Int64Value((long)decrypterType.GetMagic()));  					break;    				case Code.Newobj:  					if (!EmulateDynocode(emu' ref i))  						goto default;  					break;    				default:  					if (instr.OpCode.FlowControl != FlowControl.Next)  						goto done;  					emu.Emulate(instr);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocode,The following statement contains a magic number: if (index + 4 >= instrs.Count)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocode,The following statement contains a magic number: var ldloc = instrs[index + 3];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocode,The following statement contains a magic number: var stfld = instrs[index + 4];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInitIntsIndex,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var ldnull = instrs[i];  				if (ldnull.OpCode.Code != Code.Ldnull)  					continue;    				var stsfld = instrs[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;    				var storeField = stsfld.Operand as FieldDef;  				if (storeField == null || storeField.FieldType.FullName != "System.Byte[]")  					continue;    				var instr = instrs[i + 2];  				if (instr.OpCode.Code == Code.Ldsfld) {  					var loadField = instr.Operand as FieldDef;  					if (loadField == null || loadField.FieldType.GetElementType() != ElementType.I4)  						continue;  				}  				else if (instr.IsLdcI4()) {  					initializedAll = true;  				}  				else  					continue;    				return i;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3Old,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg0 = instrs[i];  				if (ldarg0.OpCode.Code != Code.Ldarg_0)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				int index = i + 1;  				int value;  				if (!stringMethodConsts.GetInt32(ref index' out value))  					continue;  				if (index >= instrs.Count)  					continue;    				if (instrs[index].OpCode.Code != Code.Xor)  					continue;    				i3 = value;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3New,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				int index = i;    				var ldarg0 = instrs[index++];  				if (ldarg0.OpCode.Code != Code.Ldarg_0)  					continue;    				int value;  				if (!stringMethodConsts.GetInt32(ref index' out value))  					continue;    				if (index + 3 >= instrs.Count)  					break;    				if (instrs[index++].OpCode.Code != Code.Xor)  					continue;    				if (!instrs[index++].IsLdloc())  					continue;    				if (instrs[index++].OpCode.Code != Code.Xor)  					continue;    				i3 = value;  				if (!FindInt6(index++))  					return false;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt5,The following statement contains a magic number: while (true) {  				index++;  				if (!FindCallReadBytes(ref index))  					return false;  				if (index <= 0)  					continue;  				var ldci4 = stringMethod.Body.Instructions[index - 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;  				if (!stringMethodConsts.GetNextInt32(ref index' out i5))  					return false;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: bool hasConstantM2 = DeobUtils.HasInteger(decryptStringMethod' -2);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals11) &&  				CheckTypeFields(fields11)) {  				return "1.1 - 1.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals11) &&  				CheckTypeFields(fields11)) {  				return "1.1 - 1.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals13) &&  				CheckTypeFields(fields13)) {  				return "1.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals13) &&  				CheckTypeFields(fields13)) {  				return "1.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals14) &&  				CheckTypeFields(fields14)) {  				return "1.4 - 2.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals14) &&  				CheckTypeFields(fields14)) {  				return "1.4 - 2.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).Exactly(locals24) &&  				CheckTypeFields(fields24)) {  				return "2.4 - 2.5";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals26) &&  				CheckTypeFields(fields26)) {  				return "2.6";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals27) &&  				CheckTypeFields(fields27)) {  				return "2.7";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).Exactly(locals28) &&  				CheckTypeFields(fields28)) {  				return "2.8";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals29) &&  				CheckTypeFields(fields29)) {  				return "2.9";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals29) &&  				CheckTypeFields(fields29)) {  				return "2.9";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals30) &&  				CheckTypeFields(fields30)) {  				return "3.0";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals30) &&  				CheckTypeFields(fields30)) {  				return "3.0";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals31) &&  				CheckTypeFields(fields31)) {  				return "3.1";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals31) &&  				CheckTypeFields(fields31)) {  				return "3.1";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals32) &&  				CheckTypeFields(fields32)) {  				return "3.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).Exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).Exactly(locals32) &&  				CheckTypeFields(fields32)) {  				return "3.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  				var fields33 = new string[] {  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.IO.BinaryReader"'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					decryptStringType.NestedTypes[0].FullName'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3.29 - 3.3.57 (BETA)";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  				var fields33 = new string[] {  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.IO.BinaryReader"'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					decryptStringType.NestedTypes[0].FullName'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3.29 - 3.3.57 (BETA)";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33) &&  					CheckTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals33_149 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).Exactly(locals33_149) &&  					CheckTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals35 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals35) &&  					CheckTypeFields2(fields35)) {  					return "3.5 - 4.2";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields43 = new string[] {  					GetNestedTypeName(0)'  					GetNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					GetNestedTypeName(2)'  				};  				var locals43 = CreateLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					FindEnumeratorName(decryptStringMethod)'  					GetNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals43 = CreateLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.IsMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).Exactly(olocals43) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).All(locals43) &&  					CheckTypeFields2(fields43)) {  					return "4.3";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,GetNestedType,The following statement contains a magic number: if (n == 0) {  				foreach (var nested in type.NestedTypes) {  					if (nested.NestedTypes.Count == 1)  						return nested;  				}  			}  			else if (n == 1) {  				foreach (var nested in type.NestedTypes) {  					if (nested.IsEnum)  						continue;  					if (nested.NestedTypes.Count != 0)  						continue;  					return nested;  				}  			}  			else if (n == 2) {  				foreach (var nested in type.NestedTypes) {  					if (nested.IsEnum)  						return nested;  				}  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Find,The following statement contains a magic number: foreach (var tmp in module.Resources) {  				var resource = tmp as EmbeddedResource;  				if (resource == null)  					continue;  				if (!resource.Name.String.EndsWith(".resources"' StringComparison.Ordinal))  					continue;  				string ns' name;  				SplitTypeName(resource.Name.String.Substring(0' resource.Name.String.Length - 10)' out ns' out name);  				var type = new TypeRefUser(module' ns' name' module).Resolve();  				if (type == null)  					continue;  				if (!CheckDecrypterType(type))  					continue;    				encryptedResource = resource;  				decrypterType = type;  				break;  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: if (pkt == null || pkt.Length == 0)  				pkt = new byte[8];
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: for (int i = 0' j = 0' ki = 0; i < decryptedData.Length; i++) {  				ki = (ki + 1) % (KEY_LEN - 1);  				j = (j + encryptedData[ki] + pkt[i % 8]) % (KEY_LEN - 1);  				var tmp = encryptedData[j];  				encryptedData[j] = encryptedData[ki];  				encryptedData[ki] = tmp;  				decryptedData[i] = (byte)(encryptedData[KEY_LEN + i] ^ encryptedData[(encryptedData[j] + encryptedData[ki]) % (KEY_LEN - 1)]);  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundGoliathAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,CheckProxyMethod,The following statement contains a magic number: if (instrs.Count < 7)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,CheckProxyMethod,The following statement contains a magic number: if (index + 2 > instrs.Count)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (dict == null || dict.GenericArguments.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.IsMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.Remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.IsMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.Remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.IsMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.Remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: return mainType.Detected ? 150 : 0;
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: if (mainType.Detected) {  				if (staticMethodsDecrypter.Detected) {  					staticMethodsDecrypter.Decrypt();  					RemoveObfuscatorJunk(staticMethodsDecrypter);  				}  				else if (dynamicMethodsRestorer != null) {  					Logger.v("Runtime file versions:");  					Logger.Instance.Indent();  					bool emailMe = false;  					foreach (var info in mainType.RuntimeFileInfos) {  						var version = info.GetVersion();  						emailMe |= version == null && System.IO.File.Exists(info.PathName);  						emailMe |= version != null && version == new Version(1' 0' 7' 0);  						Logger.v("Version: {0} ({1})"' version == null ? "UNKNOWN" : version.ToString()' info.PathName);  					}  					Logger.Instance.DeIndent();  					if (emailMe)  						Logger.n("**** Email me this program! de4dot@gmail.com");    					dynamicMethodsRestorer.Decrypt();  					RemoveObfuscatorJunk(dynamicMethodsRestorer);  				}  				else  					Logger.w("New ILProtector version. Can't decrypt methods (yet)");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (reflectionProtectModule.Assembly.GetName().Version < new Version(2' 0' 12' 0)) {  				return CreateDecrypterV1_0_7_0() ??  					CreateDecrypterV2_0_0_0() ??  					CreateDecrypterV2_0_8_0() ??  					CreateDecrypterV2_0_8_5() ??  					CreateDecrypterV2_0_9_0();  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (reflectionProtectModule.Assembly.GetName().Version < new Version(2' 0' 12' 0)) {  				return CreateDecrypterV1_0_7_0() ??  					CreateDecrypterV2_0_0_0() ??  					CreateDecrypterV2_0_8_0() ??  					CreateDecrypterV2_0_8_5() ??  					CreateDecrypterV2_0_9_0();  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_0(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_0(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_0(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_3(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_3(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 12' 3))  				return new DecrypterV2_0_12_3(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 13' 0))  				return new DecrypterV2_0_13_0(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 13' 0))  				return new DecrypterV2_0_13_0(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 13' 1))  				return new DecrypterV2_0_13_1(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version(2' 0' 13' 1))  				return new DecrypterV2_0_13_1(this);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,PatchRuntimeInternal,The following statement contains a magic number: var patchInfos = IntPtr.Size == 4 ? patchInfos32 : patchInfos64;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: p += IntPtr.Size * 3;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: p += 8 + IntPtr.Size * 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: p += 8 + IntPtr.Size * 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: p += IntPtr.Size * 3;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: pGetILBytes = new IntPtr(p + IntPtr.Size * 39);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterBaseV2_0_12_x,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterBaseV2_0_12_x,The following statement contains a magic number: pDecryptCallback = new IntPtr(p + IntPtr.Size * 40);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: byte* pam = *(byte**)(p + IntPtr.Size * 2);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: p = *(byte**)(p + ((Environment.Version.Major - 2) / 2 * IntPtr.Size));
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: p = *(byte**)(p + ((Environment.Version.Major - 2) / 2 * IntPtr.Size));
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: p += IntPtr.Size * 8 + 0x18;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: p = *(byte**)(p + IntPtr.Size * 16 + 0x18);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: byte* pd = p + IntPtr.Size * 2;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: p = *(byte**)(p + IntPtr.Size * 13);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,DecrypterV2_0_13_0_Base,The following statement contains a magic number: if (IntPtr.Size == 4)  					*(IntPtr*)(p + 0x2B * IntPtr.Size) = Marshal.GetFunctionPointerForDelegate(ignoreDelegate);
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetModuleHandle,The following statement contains a magic number: if (!GetModuleHandleEx(4' new IntPtr(addr)' out hModule))  					throw new ApplicationException("GetModuleHandleEx() failed");
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetAddr,The following statement contains a magic number: if (IntPtr.Size == 4) {  					for (int i = 0; i < 20; i++' p++) {  						if (*p == 0xA1)  							return *(byte**)(p + 1);  					}  				}  				else {  					for (int i = 0; i < 20; i++' p++)  						if (*p == 0x4C && p[1] == 0x8B && p[2] == 0x15)  							return p + 7 + *(int*)(p + 3);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,LookUp,The following statement contains a magic number: int f2 = IntPtr.Size * 2;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,LookUp,The following statement contains a magic number: int f3 = IntPtr.Size * 3;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,LookUp,The following statement contains a magic number: int f4 = IntPtr.Size * 4;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,LookUp,The following statement contains a magic number: int f5 = IntPtr.Size * 5 + 1;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0_Base,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,GetCallerMethodAsILByteArray,The following statement contains a magic number: flags = 2;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The following statement contains a magic number: if (IntPtr.Size == 4) {  					var del = (InitCode32Delegate)Marshal.GetDelegateForFunctionPointer(CodeAllocator.Allocate(initCode_x86)' typeof(InitCode32Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd' ba + 0x00012500);  				}  				else {  					var del = (InitCode64Delegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + 0x00014CF0)' typeof(InitCode64Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The following statement contains a magic number: if (IntPtr.Size == 4) {  					var del = (InitCode32Delegate)Marshal.GetDelegateForFunctionPointer(CodeAllocator.Allocate(initCode_x86)' typeof(InitCode32Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd' ba + 0x00012500);  				}  				else {  					var del = (InitCode64Delegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + 0x00014CF0)' typeof(InitCode64Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_0,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The following statement contains a magic number: if (IntPtr.Size == 4) {  					var del = (InitCode32Delegate)Marshal.GetDelegateForFunctionPointer(CodeAllocator.Allocate(initCode_x86)' typeof(InitCode32Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd' ba + 0x00012500);  				}  				else {  					var del = (InitCode64Delegate)Marshal.GetDelegateForFunctionPointer(new IntPtr(ba + 0x00014CF0)' typeof(InitCode64Delegate));  					del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd);  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The following statement contains a magic number: int rva = IntPtr.Size == 4 ? 0x00013650 : 0x00016B50;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV2_0_13_1,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,InitCode,The following statement contains a magic number: del(pppam' pm' new IntPtr(IntPtr.Size * 4)' pd);
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypterService,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypterService.cs,DecryptMethods,The following statement contains a magic number: using (var decrypter = new DynamicMethodsDecrypter(obfModule' reflObfModule)) {  				decrypter.Initialize();    				var infos = new List<DecryptedMethodInfo>();    				for (int i = 0; i < methodIds.Count; i += 2)  					infos.Add(decrypter.Decrypt(methodIds[i]' (uint)methodIds[i + 1]));    				hasDelegateTypeFlag = decrypter.MethodReaderHasDelegateTypeFlag;    				return infos;  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MainType.cs,CheckMethod,The following statement contains a magic number: if (methods.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.ILProtector,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MainType.cs,CheckMethod,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  				return false;
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,ReadExceptionHandler,The following statement contains a magic number: var eh = new ExceptionHandler((ExceptionHandlerType)(reader.Read7BitEncodedUInt32() & 7));
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,DecrypterV100,The following statement contains a magic number: this.startOffset = 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,DecrypterV100,The following statement contains a magic number: this.decryptionKeyMod = 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,Create,The following statement contains a magic number: if (reader.Length < 12)  					return null;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV105,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,Create,The following statement contains a magic number: if (!Utils.Compare(reader.ReadBytes(8)' ilpPublicKeyToken))  					return null;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,Create,The following statement contains a magic number: try {  					int keyXorOffs7 = (ReadByteAt(reader' 0) ^ ReadByteAt(reader' 2)) + 2;  					reader.Position = keyXorOffs7 + (ReadByteAt(reader' 1) ^ ReadByteAt(reader' keyXorOffs7));    					int sha1DataLen = reader.Read7BitEncodedInt32() + 0x80;  					int keyXorOffs6 = (int)reader.Position;  					int encryptedOffs = (int)reader.Position + sha1DataLen;  					var sha1Data = reader.ReadBytes(sha1DataLen);  					uint crc32 = CRC32.CheckSum(sha1Data);    					reader.Position = reader.Length - 0x18;  					uint origCrc32 = reader.ReadUInt32();  					if (crc32 != origCrc32)  						return null;    					var key0 = DeobUtils.Sha1Sum(sha1Data);			// 1.0.6.0  					var key6 = GetKey(reader' key0' keyXorOffs6);	// 1.0.6.6  					var key7 = GetKey(reader' key0' keyXorOffs7);	// 1.0.6.7  					return new DecrypterV106(key0' key6' key7' encryptedOffs);  				}  				catch (IOException) {  					return null;  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ILProtector\StaticMethodsDecrypter.cs,Create,The following statement contains a magic number: try {  					int keyXorOffs7 = (ReadByteAt(reader' 0) ^ ReadByteAt(reader' 2)) + 2;  					reader.Position = keyXorOffs7 + (ReadByteAt(reader' 1) ^ ReadByteAt(reader' keyXorOffs7));    					int sha1DataLen = reader.Read7BitEncodedInt32() + 0x80;  					int keyXorOffs6 = (int)reader.Position;  					int encryptedOffs = (int)reader.Position + sha1DataLen;  					var sha1Data = reader.ReadBytes(sha1DataLen);  					uint crc32 = CRC32.CheckSum(sha1Data);    					reader.Position = reader.Length - 0x18;  					uint origCrc32 = reader.ReadUInt32();  					if (crc32 != origCrc32)  						return null;    					var key0 = DeobUtils.Sha1Sum(sha1Data);			// 1.0.6.0  					var key6 = GetKey(reader' key0' keyXorOffs6);	// 1.0.6.6  					var key7 = GetKey(reader' key0' keyXorOffs7);	// 1.0.6.7  					return new DecrypterV106(key0' key6' key7' encryptedOffs);  				}  				catch (IOException) {  					return null;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CryptDecrypter,The following statement contains a magic number: if (key.Length <= 8)  				throw new ArgumentException("Invalid size"' "key");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (encrypted.Length % 8 != 0)  				throw new ArgumentException("encrypted");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: var key2 = CreateKey(key' 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: int count = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = Decrypt(buf' key1' true);  				buf = Decrypt(buf' key2' false);  				buf = Decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = Decrypt(buf' key1' true);  				buf = Decrypt(buf' key2' false);  				buf = Decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = Decrypt(buf' key1' true);  				buf = Decrypt(buf' key2' false);  				buf = Decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.Extract(0' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(32' 32));  					bits.Set(32' oldBits);  					bits.Set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.Extract(32' 32);  					var tmp = Decrypt(oldBits.Clone()' key.Extract(ki' 48));  					tmp.Xor(bits.Extract(0' 32));  					bits.Set(0' oldBits);  					bits.Set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: var sboxByteBits = new byte[32];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.FromBytes(sbox' index' 4).CopyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: byte[] newKey = new byte[16 * 6];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: byte[] newKey = new byte[16 * 6];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: byte[] tmpData = new byte[28 * 2];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: byte[] tmpData = new byte[28 * 2];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				int rolCount = rots[i];  				key1.Rol(rolCount);  				key2.Rol(rolCount);  				Bits.FromByteBits(key1.ByteBits' key2.ByteBits).Transpose(pc2).ToBits(newKey' i * 6);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				int rolCount = rots[i];  				key1.Rol(rolCount);  				key2.Rol(rolCount);  				Bits.FromByteBits(key1.ByteBits' key2.ByteBits).Transpose(pc2).ToBits(newKey' i * 6);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: var tmpKey = new byte[8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key1 = Bits.FromByteBits(bits.ByteBits' 0' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key2 = Bits.FromByteBits(bits.ByteBits' 28' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key2 = Bits.FromByteBits(bits.ByteBits' 28' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,FromBytes,The following statement contains a magic number: return FromBytes(bytes' 0' bytes.Length * 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,ToByteBits,The following statement contains a magic number: for (int i = 0; i < numBits; i++) {  					int j = i / 8;  					int k = i & 7;  					byteBits[i] = (byte)(((bytes[index + j] >> k) & 1) != 0 ? 1 : 0);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,ToByteBits,The following statement contains a magic number: for (int i = 0; i < numBits; i++) {  					int j = i / 8;  					int k = i & 7;  					byteBits[i] = (byte)(((bytes[index + j] >> k) & 1) != 0 ? 1 : 0);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,ToBits,The following statement contains a magic number: var bits = new byte[(byteBits.Length + 7) / 8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,ToBits,The following statement contains a magic number: var bits = new byte[(byteBits.Length + 7) / 8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,ToBits,The following statement contains a magic number: for (int i = 0; i < bits.Length; i++) {  					byte val = 0;  					for (int j = i * 8' k = 1; j < byteBits.Length; j++' k <<= 1) {  						if (byteBits[j] != 0)  							val |= (byte)k;  					}  					bits[i] = val;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: if (key.Length != 32)  				throw new ArgumentException("Invalid key size"' "key");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: this.key = new uint[8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  				throw new ArgumentException("Invalid data length"' "encrypted");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: int count = decrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				Decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					Decrypt(x' y' out x' out y);  				WriteUInt32(decrypted' i * 8' x);  				WriteUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data[index + 1] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data[index + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data[index + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data[index + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data[index + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt(x + key[2]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt(y + key[3]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt(x + key[4]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt(y + key[5]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt(x + key[6]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt(y + key[7]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= Decrypt(x + key[7]);  				x ^= Decrypt(y + key[6]);  				y ^= Decrypt(x + key[5]);  				x ^= Decrypt(y + key[4]);  				y ^= Decrypt(x + key[3]);  				x ^= Decrypt(y + key[2]);  				y ^= Decrypt(x + key[1]);  				x ^= Decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: return Ror(x' 21);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,DeobfuscatorInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DeobfuscatorInfo,The following statement contains a magic number: stringCodePage = new IntOption(null' MakeArgName("cp")' "String code page"' 936);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (mainType.Detected)  				val = 150;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,Find,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors(module' 3)) {  				if (CheckCctor(cctor))  					break;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,GetPinvokeList,The following statement contains a magic number: if (list.Count != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  				if (fileData[usHeapOffset] == 0 || fileData[usHeapOffset] == 1) {  					usHeapOffset++;  					continue;  				}    				int usHeapOffsetOrig = usHeapOffset;  				int stringDataLength = DeobUtils.ReadVariableLengthInt32(fileData' ref usHeapOffset);  				int usHeapOffsetString = usHeapOffset;  				int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  				for (int i = 0; i < encryptedLength; i++) {  					byte k = mcKey.ReadByte(mcKeyOffset++ % 0x2000);  					fileData[usHeapOffset] = Rolb((byte)(fileData[usHeapOffset] ^ k)' 3);  					usHeapOffset++;  				}    				try {  					Logger.v("Decrypted string: {0}"' Utils.ToCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1)));  				}  				catch {  					Logger.v("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  				}    				usHeapOffset++;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  				if (fileData[usHeapOffset] == 0 || fileData[usHeapOffset] == 1) {  					usHeapOffset++;  					continue;  				}    				int usHeapOffsetOrig = usHeapOffset;  				int stringDataLength = DeobUtils.ReadVariableLengthInt32(fileData' ref usHeapOffset);  				int usHeapOffsetString = usHeapOffset;  				int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  				for (int i = 0; i < encryptedLength; i++) {  					byte k = mcKey.ReadByte(mcKeyOffset++ % 0x2000);  					fileData[usHeapOffset] = Rolb((byte)(fileData[usHeapOffset] ^ k)' 3);  					usHeapOffset++;  				}    				try {  					Logger.v("Decrypted string: {0}"' Utils.ToCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1)));  				}  				catch {  					Logger.v("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  				}    				usHeapOffset++;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Rolb,The following statement contains a magic number: return (byte)((b << n) | (b >> (8 - n)));
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,GetStructSize,The following statement contains a magic number: foreach (var info in EncryptionInfos.McKey8C0h) {  					if (magicLo == info.MagicLo && magicHi == info.MagicHi)  						return 0xC + 6 * ENCRYPTED_DATA_INFO_SIZE;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,GetStructSize,The following statement contains a magic number: return 0xC + 3 * ENCRYPTED_DATA_INFO_SIZE;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: int numMethods = ReadInt32(0) ^ ReadInt32(4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: uint offset = 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,InitializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = ReadEncryptedUInt32(offset);  					uint totalSize = ReadEncryptedUInt32(offset + 4);  					uint methodInstructionRva = ReadEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = ReadEncryptedInt16(offset2 + 1);  						uint dataOffset = ReadEncryptedUInt32(offset2 + 3);  						uint encryptedSize = ReadEncryptedUInt32(offset2 + 7);  						uint realSize = ReadEncryptedUInt32(offset2 + 11);  						if (j >= 3 && dataOffset == xorKey && encryptedSize == xorKey) {  							encryptedDataInfos[j] = null;  							continue;  						}  						if (j == 1)  							exOffset = ReadEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = Decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = CopyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = CopyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					CopyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.Verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v2,The following statement contains a magic number: return Decrypt1(encrypted' 6' 6' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v2,The following statement contains a magic number: return Decrypt1(encrypted' 6' 6' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v3,The following statement contains a magic number: return Decrypt1(encrypted' 6' 0' 0x1000);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v4,The following statement contains a magic number: return Decrypt1(encrypted' 5' 5' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v4,The following statement contains a magic number: return Decrypt1(encrypted' 5' 5' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v5,The following statement contains a magic number: return Decrypt1(encrypted' 9' 9' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v5,The following statement contains a magic number: return Decrypt1(encrypted' 9' 9' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt1_v9,The following statement contains a magic number: return Decrypt1(encrypted' 9' 0x13' 0x400);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2_v2,The following statement contains a magic number: return Decrypt2(encrypted' 0x00FA + 9);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2_v4,The following statement contains a magic number: return Decrypt2(encrypted' 0x00FA + 7);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  					throw new ApplicationException("Invalid encryption #2 length");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: uint key4 = mcKey.ReadUInt32(offset + 4 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: uint key4 = mcKey.ReadUInt32(offset + 4 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: uint key5 = mcKey.ReadUInt32(offset + 5 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: uint key5 = mcKey.ReadUInt32(offset + 5 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: byte[] decrypted = new byte[encrypted.Length & ~7];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: int loopCount = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3_v4,The following statement contains a magic number: return Decrypt3(encrypted' 0x015E + 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3_v5,The following statement contains a magic number: return Decrypt3(encrypted' 0x015E + 7);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  					throw new ApplicationException("Invalid encryption #3 length");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: uint key0 = mcKey.ReadUInt32(offset + 0 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: uint key3 = mcKey.ReadUInt32(offset + 3 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: uint key3 = mcKey.ReadUInt32(offset + 3 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: byte[] decrypted = new byte[encrypted.Length & ~7];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: int loopCount = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4_v3,The following statement contains a magic number: return Decrypt4(encrypted' 5' 0' 0x2000);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4_v8,The following statement contains a magic number: return Decrypt4(encrypted' 9' 9' 0x100);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4_v8,The following statement contains a magic number: return Decrypt4(encrypted' 9' 9' 0x100);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: var decrypted = new byte[encrypted.Length / 3 * 2 + 1];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: var decrypted = new byte[encrypted.Length / 3 * 2 + 1];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: int count = encrypted.Length / 3;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.ReadByte(ki + 1);  					byte k2 = mcKey.ReadByte(ki + 2);  					byte k3 = mcKey.ReadByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) | ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt4,The following statement contains a magic number: if ((encrypted.Length % 3) != 0)  					decrypted[j] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt5,The following statement contains a magic number: return CryptDecrypter.Decrypt(mcKey.ReadBytes(0x0032' 15)' encrypted);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt6,The following statement contains a magic number: return Decrypter6.Decrypt(mcKey.ReadBytes(0x0096' 32)' encrypted);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt8_v5,The following statement contains a magic number: return Decrypt8(encrypted' 7' 7' 0x600);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt8_v5,The following statement contains a magic number: return Decrypt8(encrypted' 7' 7' 0x600);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt8,The following statement contains a magic number: for (int i = 0; i < encrypted.Length; i++) {  					int b = mcKey.ReadByte(ki++) ^ encrypted[i];  					decrypted[i] = (byte)((b << 4) | (b >> 4));  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt8,The following statement contains a magic number: for (int i = 0; i < encrypted.Length; i++) {  					int b = mcKey.ReadByte(ki++) ^ encrypted[i];  					decrypted[i] = (byte)((b << 4) | (b >> 4));  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9_v10,The following statement contains a magic number: return Decrypt9(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9_v10,The following statement contains a magic number: return Decrypt9(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9_v13,The following statement contains a magic number: return Decrypt9(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9_v13,The following statement contains a magic number: return Decrypt9(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9,The following statement contains a magic number: for (int i = 0; ; ) {  					byte b' k;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					b = encrypted[i];  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					ki++;  					i++;  					if (ki >= keyEnd) ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9,The following statement contains a magic number: for (int i = 0; ; ) {  					byte b' k;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					b = encrypted[i];  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					ki++;  					i++;  					if (ki >= keyEnd) ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9,The following statement contains a magic number: for (int i = 0; ; ) {  					byte b' k;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					b = encrypted[i];  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					ki++;  					i++;  					if (ki >= keyEnd) ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt9,The following statement contains a magic number: for (int i = 0; ; ) {  					byte b' k;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					k = mcKey.ReadByte(ki++);  					b = encrypted[i];  					b ^= k;  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					i++;  					if (ki >= keyEnd) ki = keyReset;    					if (i >= encrypted.Length) break;  					b = encrypted[i];  					b = (byte)((b << 4) | (b >> 4));  					decrypted[i] = b;  					ki++;  					i++;  					if (ki >= keyEnd) ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt10,The following statement contains a magic number: int halfSize = enc.Length / 2;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt10,The following statement contains a magic number: for (int i = enc.Length - 2; i >= halfSize; i--)  					dest[i] = (byte)(enc[i] ^ dest[i + 1]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11_v1,The following statement contains a magic number: return Decrypt11(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11_v1,The following statement contains a magic number: return Decrypt11(encrypted' 5' 5' 0x510);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following statement contains a magic number: for (int i = 0' ki = keyStart; i < encrypted.Length; i++' ki++) {  					if (ki >= keyEnd)  						ki = keyStart;    					byte b;  					switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,GetBlowfishKey,The following statement contains a magic number: var key = new byte[100];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.ReadUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.ReadByte(ki));  					ki = Add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = Decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.ReadUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.ReadByte(ki));  					ki = Add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = Decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.ReadUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.ReadByte(ki));  					ki = Add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = Decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.ReadUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.ReadByte(ki));  					ki = Add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = Decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (version != Version.Unknown)  				val += 100;
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.Types.Count != 2)  				return Version.Unknown;
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.OffsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.DecompressOld(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.OffsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.OffsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.Decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.OffsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.DecompressOld(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.OffsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.OffsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.Decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.OffsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.DecompressOld(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.OffsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.OffsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.Decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U4,The following statement contains a magic number: return (_n_^=1)!=0?(uint)(_p_[_i_]&0xF):(uint)(_p_[_i_++]>>4);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_)!=0?((_p_[_i_]>>4)|(_p_[_i_+1]<<4)):_p_[_i_]));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_)!=0?((_p_[_i_]>>4)|(_p_[_i_+1]<<4)):_p_[_i_]));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_)!=0?((_p_[_i_]>>4)|((ushort)(GET_LE16(_p_'_i_+1))<<4)):GET_LE16(_p_'_i_));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_)!=0?((_p_[_i_]>>4)|((ushort)(GET_LE16(_p_'_i_+1))<<4)):GET_LE16(_p_'_i_));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: int srcIndex = 3;
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: while (dstIndex < decompressedLen) {  				int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);  				if (partLen < 0x800000) {  					Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);  					srcIndex += partLen;  					dstIndex += partLen;  				}  				else {  					partLen &= 0x7FFFFF;  					int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  					if (decompressedLen2 == 0)  						return null;  					dstIndex += decompressedLen2;  					srcIndex += partLen;  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: while (dstIndex < decompressedLen) {  				int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);  				if (partLen < 0x800000) {  					Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);  					srcIndex += partLen;  					dstIndex += partLen;  				}  				else {  					partLen &= 0x7FFFFF;  					int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  					if (decompressedLen2 == 0)  						return null;  					dstIndex += decompressedLen2;  					srcIndex += partLen;  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int stringId = ldci4.GetLdcI4Value();    				var call = instrs[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(decrypter.Method' calledMethod))  					continue;    				var stsfld = instrs[i + 2];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as FieldDef;  				if (field == null)  					continue;    				return new StringInfo(field' stringId);  			}
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int stringId = ldci4.GetLdcI4Value();    				var call = instrs[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(decrypter.Method' calledMethod))  					continue;    				var stsfld = instrs[i + 2];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as FieldDef;  				if (field == null)  					continue;    				return new StringInfo(field' stringId);  			}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: DeobUtils.XteaDecrypt(ref v0' ref v1' key' 32);
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: for (int i = 1; i + 1 < decrypted.Length; i += 2) {  					v0 = reader.ReadUInt32();  					v1 = reader.ReadUInt32();  					DeobUtils.XteaDecrypt(ref v0' ref v1' key' 32);  					decrypted[i] = v0;  					decrypted[i + 1] = v1;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,DecryptInternal,The following statement contains a magic number: for (int i = 1; i + 1 < decrypted.Length; i += 2) {  					v0 = reader.ReadUInt32();  					v1 = reader.ReadUInt32();  					DeobUtils.XteaDecrypt(ref v0' ref v1' key' 32);  					decrypted[i] = v0;  					decrypted[i + 1] = v1;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var mul = instrs[i];  					if (mul.OpCode.Code != Code.Mul)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var sub = instrs[i + 2];  					if (sub.OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var mul = instrs[i];  					if (mul.OpCode.Code != Code.Mul)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var sub = instrs[i + 2];  					if (sub.OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitKey,The following statement contains a magic number: reader.BaseStream.Position = reader.BaseStream.Length - 48;
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitKey,The following statement contains a magic number: key = new uint[4];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,Decrypt,The following statement contains a magic number: reader.BaseStream.Position = reader.BaseStream.Length + (stringId * 4 - fileDispl);
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitKey,The following statement contains a magic number: reader.BaseStream.Position = baseOffs - 16;
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitKey,The following statement contains a magic number: key = new uint[4];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,InitializeBaseOffs,The following statement contains a magic number: while (true) {  					if (reader.Read(buf' 0' buf.Length) != buf.Length)  						throw new ApplicationException("Could not read");    					for (int bi = buf.Length - 1; bi > magic.Length; ) {  						int mi = magic.Length - 1;  						if (buf[bi--] != magic[mi--] ||  							buf[bi] != magic[mi--])  							continue;  						while (true) {  							if (buf[--bi] != magic[mi--])  								break;  							if (mi == -1)  								return reader.BaseStream.Position - buf.Length + bi;  						}  					}    					reader.BaseStream.Position -= buf.Length * 2 - 0x20;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,Decrypt,The following statement contains a magic number: reader.BaseStream.Position = baseOffs + stringId * 4 - fileDispl;
Magic Number,de4dot.code.deobfuscators.Skater_NET,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.Remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.Remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.Remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.Add(field' decrypter.Decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.Add(field' decrypter.Decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.Add(field' decrypter.Decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.Add(field' decrypter.Decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.Add(field' decrypter.Decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,CheckMethodV1,The following statement contains a magic number: var key = passwordBytes.GetBytes(16);
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,CheckMethodV1,The following statement contains a magic number: var iv = passwordBytes.GetBytes(8);
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: var saltAry = new byte[(int)Math.Round((double)s2.Length / 2 - 1) + 1];
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  				int result;  				if (!int.TryParse(s2.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  					return null;  				saltAry[i] = (byte)result;  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  				int result;  				if (!int.TryParse(s2.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  					return null;  				saltAry[i] = (byte)result;  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (ints.Length % 3 != 0)  					throw new ApplicationException("Invalid encrypted string");
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: var sb = new StringBuilder(ints.Length / 3);
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,InitInfos,The following statement contains a magic number: if (strings.Length % 2 == 1)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,InitInfos,The following statement contains a magic number: for (int i = 0; i < strings.Length; i += 2) {  				var info = EmbeddedAssemblyInfo.Create(module' strings[i]' strings[i + 1]);  				if (info == null)  					return false;  				list.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: var type1 = sig.Params.Count < 2 ? "" : sig.Params[1].GetFullName();
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (memoryManagerInfo.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundSmartAssemblyAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 6)  				return;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by SmartAssembly") {  				ObfuscatorName = "SmartAssembly 5.0/5.1";  				approxVersion = new Version(5' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = CheckTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (HasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = CheckTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (HasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = CheckTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (HasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = CheckTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (HasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,CheckTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  				return 2;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,CheckTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  				return 2;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GetTypeIdAttribute,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				counter++;  				var cattrs = type.CustomAttributes;  				if (cattrs.Count == 0)  					return null;    				var attrs2 = new Dictionary<TypeDef' bool>();  				foreach (var cattr in cattrs) {  					if (!DotNetUtils.IsMethod(cattr.Constructor as IMethod' "System.Void"' "(System.Int32)"))  						continue;  					var attrType = cattr.AttributeType as TypeDef;  					if (attrType == null)  						continue;  					if (attrs != null && !attrs.ContainsKey(attrType))  						continue;  					attrs2[attrType] = true;  				}  				attrs = attrs2;    				if (attrs.Count == 0)  					return null;  				if (attrs.Count == 1 && counter >= 30)  					break;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitStringDecrypterInfos,The following statement contains a magic number: while (initd.Count != stringDecrypterInfos.Count) {  				StringDecrypterInfo initdInfo = null;  				for (int i = 0; i < 2; i++) {  					foreach (var info in stringDecrypterInfos) {  						if (initd.ContainsKey(info))  							continue;  						if (info.Initialize(this' DeobfuscatedFile)) {  							resourceDecrypterInfo.SetSimpleZipType(info.SimpleZipTypeMethod' DeobfuscatedFile);  							initdInfo = info;  							break;  						}  					}  					if (initdInfo != null)  						break;    					assemblyResolverInfo.FindTypes();  					resourceResolverInfo.FindTypes();  					DecryptResources();  				}    				if (initdInfo == null)  					break;    				initd[initdInfo] = true;  				InitStringDecrypter(initdInfo);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,IsBigType,The following statement contains a magic number: if (type.Methods.Count < 50)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,IsBigType,The following statement contains a magic number: if (type.Fields.Count > 3)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,MemoryManagerInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\MemoryManagerInfo.cs,CheckMemoryManagerType,The following statement contains a magic number: if (fields != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count > 10)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  				simpleDeobfuscator.Deobfuscate(cctor);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs[2].OpCode != OpCodes.Ret)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.IsMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.GetMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.IsMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.IsMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.IsMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.GetMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.IsMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.IsMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.GetInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.IsMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.GetMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.IsMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.IsMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: byte encryption = (byte)(headerMagic >> 24);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return Decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: var desList = new List<byte[]>(2);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: var aesList = new List<byte[]>(2);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.GetField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.IsMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.GetField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.IsMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.GetField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.IsMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (desList.Count >= 2) {  				DES_Key = desList[desList.Count - 2];  				DES_IV  = desList[desList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (desList.Count >= 2) {  				DES_Key = desList[desList.Count - 2];  				DES_IV  = desList[desList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (aesList.Count >= 2) {  				AES_Key = aesList[aesList.Count - 2];  				AES_IV  = aesList[aesList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (aesList.Count >= 2) {  				AES_Key = aesList[aesList.Count - 2];  				AES_IV  = aesList[aesList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypter.cs,Decrypt,The following statement contains a magic number: switch (StringDecrypterInfo.DecrypterVersion) {  			case StringDecrypterVersion.V1:  				// Some weird problem with 1.x decrypted strings. They all have a \x01 char at the end.  				var buf = Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData' index' len));  				if (buf.Length % 2 != 0)  					Array.Resize(ref buf' buf.Length - 1);  				return Encoding.Unicode.GetString(buf);    			case StringDecrypterVersion.V2:  				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData' index' len)));    			default:  				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.UTF8.GetString(decryptedData' index' len)));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  				MethodDef initMethod;  				if (decrypterVersion == StringDecrypterVersion.V3)  					initMethod = cctor;  				else if (decrypterVersion == StringDecrypterVersion.V2)  					initMethod = stringDecrypterMethod;  				else  					initMethod = stringDecrypterMethod;    				stringOffset = 0;  				if (decrypterVersion != StringDecrypterVersion.V1) {  					if (CallsGetPublicKeyToken(initMethod)) {  						var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKeyToken);  						if (!PublicKeyBase.IsNullOrEmpty2(pkt)) {  							for (int i = 0; i < pkt.Data.Length - 1; i += 2)  								stringOffset ^= ((int)pkt.Data[i] << 8) + pkt.Data[i + 1];  						}  					}    					if (DeobUtils.HasInteger(initMethod' 0xFFFFFF) &&  						DeobUtils.HasInteger(initMethod' 0xFFFF)) {  						stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32() & 0xFFFFFF) - 1) % 0xFFFF;  					}  				}  			}  			else {  				var offsetVal = FindOffsetValue(cctor);  				if (offsetVal == null)  					throw new ApplicationException("Could not find string offset");  				stringOffset = offsetVal.Value;  				decrypterVersion = StringDecrypterVersion.V4;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  				MethodDef initMethod;  				if (decrypterVersion == StringDecrypterVersion.V3)  					initMethod = cctor;  				else if (decrypterVersion == StringDecrypterVersion.V2)  					initMethod = stringDecrypterMethod;  				else  					initMethod = stringDecrypterMethod;    				stringOffset = 0;  				if (decrypterVersion != StringDecrypterVersion.V1) {  					if (CallsGetPublicKeyToken(initMethod)) {  						var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKeyToken);  						if (!PublicKeyBase.IsNullOrEmpty2(pkt)) {  							for (int i = 0; i < pkt.Data.Length - 1; i += 2)  								stringOffset ^= ((int)pkt.Data[i] << 8) + pkt.Data[i + 1];  						}  					}    					if (DeobUtils.HasInteger(initMethod' 0xFFFFFF) &&  						DeobUtils.HasInteger(initMethod' 0xFFFF)) {  						stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32() & 0xFFFFFF) - 1) % 0xFFFF;  					}  				}  			}  			else {  				var offsetVal = FindOffsetValue(cctor);  				if (offsetVal == null)  					throw new ApplicationException("Could not find string offset");  				stringOffset = offsetVal.Value;  				decrypterVersion = StringDecrypterVersion.V4;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindOffsetField,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldsfld = instructions[i];  				if (ldsfld.OpCode.Code != Code.Ldsfld)  					continue;  				var field = ldsfld.Operand as IField;  				if (field == null || field.FieldSig.GetFieldType().GetElementType() != ElementType.String)  					continue;  				if (!new SigComparer().Equals(stringsEncodingClass' field.DeclaringType))  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.IsMethod(calledMethod' "System.Int32"' "(System.String)"))  					continue;    				return field;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindOffsetValue,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldstr = instructions[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var stringVal = ldstr.Operand as string;  				if (stringVal == null)  					continue;    				var stsfld = instructions[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as IField;  				if (field == null || fields.Find(field) != offsetField)  					continue;    				int value;  				if (!int.TryParse(stringVal' System.Globalization.NumberStyles.Integer' null' out value))  					continue;    				return value;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindSimpleZipTypeMethod,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var call = instructions[i];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (!DotNetUtils.IsMethod(calledMethod' "System.Byte[]"' "(System.Byte[])"))  					continue;    				var stsfld = instructions[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as IField;  				if (field == null || field.FieldSig.GetFieldType().GetFullName() != "System.Byte[]")  					continue;  				if (!new SigComparer().Equals(stringsEncodingClass' field.DeclaringType))  					continue;    				return calledMethod;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.Remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.Remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.Remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The following statement contains a magic number: if (!instrs[index].IsBrfalse()) {  				if (instrs[index].OpCode.Code != Code.Pop)  					return false;  				instr = instrs[index + 1];  				if (!instr.IsLdloc() || Instr.GetLocalVar(locals' instr) != loc0)  					return false;  				if (!instrs[index + 2].IsBrfalse())  					return false;    				tamperBlocks.type = Type.V1;  				tamperBlocks.first = new BlockInfo {  					Block = block'  					Start = start'  					End = end'  				};  			}  			else {  				tamperBlocks.type = Type.V2;  				tamperBlocks.first = new BlockInfo {  					Block = block'  					Start = start'  					End = end'  				};    				block = block.FallThrough;  				if (block == null)  					return false;  				instrs = block.Instructions;  				index = 0;  				instr = instrs[index];  				if (!instr.IsLdloc() || Instr.GetLocalVar(locals' instr) != loc0)  					return false;  				if (!instrs[index + 1].IsBrfalse())  					return false;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindBadBlock,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundSpicesAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)Read32(data' 1);  				decompressedLength = (int)Read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)Read32(data' 1);  				decompressedLength = (int)Read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)Read32(data' 1);  				decompressedLength = (int)Read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)Read32(data' 1);  				decompressedLength = (int)Read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)Read32(data' 1);  				decompressedLength = (int)Read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,IsWinFormType,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				var baseType = type.BaseType;  				if (baseType == null)  					break;  				if (baseType.FullName == "System.Object" ||  					baseType.FullName == "System.ValueType")  					return false;  				// Speed up common cases  				if (baseType.FullName == "System.Windows.Forms.Control" ||  					baseType.FullName == "System.Windows.Forms.Form" ||  					baseType.FullName == "System.Windows.Forms.UserControl")  					return true;  				var resolvedBaseType = baseType.ResolveTypeDef();  				if (resolvedBaseType == null)  					break;  				type = resolvedBaseType;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,Ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasNestedTypes || type.HasInterfaces)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (type.Fields.Count < 2 || type.Fields.Count > 3)  					continue;  				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  					continue;  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (HasInstanceMethods(type))  					continue;  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				FieldDef encryptedDataFieldTmp;  				StringDataFlags stringDataFlagsTmp;  				if (!CheckCctor(cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  					continue;    				if (!InitializeDecrypterInfos(type))  					continue;    				encryptedDataField = encryptedDataFieldTmp;  				stringDataFlags = stringDataFlagsTmp;  				decrypterType = type;  				return;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasNestedTypes || type.HasInterfaces)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (type.Fields.Count < 2 || type.Fields.Count > 3)  					continue;  				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  					continue;  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (HasInstanceMethods(type))  					continue;  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				FieldDef encryptedDataFieldTmp;  				StringDataFlags stringDataFlagsTmp;  				if (!CheckCctor(cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  					continue;    				if (!InitializeDecrypterInfos(type))  					continue;    				encryptedDataField = encryptedDataFieldTmp;  				stringDataFlags = stringDataFlagsTmp;  				decrypterType = type;  				return;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;    				var instrs = DotNetUtils.GetInstructions(instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs == null)  					continue;    				var newarr = instrs[0];  				if (newarr.Operand.ToString() != "System.Byte")  					continue;    				var field = instrs[2].Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					continue;    				int index = i + 1 + instrs.Count;  				if (index < instructions.Count && instructions[index].OpCode.Code == Code.Call)  					flags = GetStringDataFlags(instructions[index].Operand as MethodDef);    				compressedDataField = field;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Get3DesKeyIv,The following statement contains a magic number: if (arrays.Count != 1 && arrays.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!CheckClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!CheckClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!CheckClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!CheckClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!CheckClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!CheckClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundXenocodeAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,IsTypeWithThousandsOfMethods,The following statement contains a magic number: if (type.Methods.Count < 100)  				return false;
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasFields)  					continue;  				if (type.Methods.Count < 1 || type.Methods.Count > 3)  					continue;  				if (type.HasProperties || type.HasEvents)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.IsMethod(m' "System.String"' "(System.String'System.Int32)")) {  						method = m;  						continue;  					}  					method = null;  					break;  				}  				if (method == null || method.Body == null)  					continue;    				bool foundConstant = false;  				foreach (var instr in method.Body.Instructions) {  					if (instr.IsLdcI4() && instr.GetLdcI4Value() == STRING_DECRYPTER_KEY_CONST) {  						foundConstant = true;  						break;  					}  				}  				if (!foundConstant)  					continue;    				stringDecrypterType = type;  				stringDecrypterMethod = method;  				break;  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: int newLen = es.Length / 4;
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.renamer.asmmodules,MPropertyDef,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\PropertyDef.cs,IsItemProperty,The following statement contains a magic number: if (SetMethod != null && SetMethod.VisibleParameterCount >= 2)  				return true;
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.HasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))  							continue;  						CreatePropertyGetter(propName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))  							continue;  						CreatePropertySetter(propName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.HasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))  							continue;  						CreatePropertyGetter(propName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidPropertyName(propName))  							continue;  						CreatePropertySetter(propName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.IsVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Property != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal))  						CreatePropertyGetter(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal))  						CreatePropertySetter(methodName.Substring(4)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.IsVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Property != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal))  						CreatePropertyGetter(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal))  						CreatePropertySetter(methodName.Substring(4)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.HasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))  							continue;  						CreateEventAdder(eventName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(7);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))  							continue;  						CreateEventRemover(eventName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.HasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))  							continue;  						CreateEventAdder(eventName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(7);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.Type(method.Owner).NameChecker.IsValidEventName(eventName))  							continue;  						CreateEventRemover(eventName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.IsVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Event != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal))  						CreateEventAdder(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal))  						CreateEventRemover(methodName.Substring(7)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.IsVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Event != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal))  						CreateEventAdder(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal))  						CreateEventRemover(methodName.Substring(7)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,GetScopeType,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  				var nls = typeSig as NonLeafSig;  				if (nls == null)  					break;  				typeSig = nls.Next;  			}
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Body == null)  					continue;    				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var call = instrs[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null)  						continue;    					int ldstrIndex;  					switch (calledMethod.FullName) {  					case "System.String System.Resources.ResourceManager::GetString(System.String'System.Globalization.CultureInfo)":  					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)":  					case "System.Object System.Resources.ResourceManager::GetObject(System.String'System.Globalization.CultureInfo)":  						ldstrIndex = i - 2;  						break;    					case "System.String System.Resources.ResourceManager::GetString(System.String)":  					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":  					case "System.Object System.Resources.ResourceManager::GetObject(System.String)":  						ldstrIndex = i - 1;  						break;    					default:  						continue;  					}    					Instruction ldstr = null;  					string name = null;  					if (ldstrIndex >= 0)  						ldstr = instrs[ldstrIndex];  					if (ldstr == null || (name = ldstr.Operand as string) == null) {  						Logger.w("Could not find string argument to method {0}"' calledMethod);  						continue;  					}    					RenameInfo info;  					if (!nameToInfo.TryGetValue(name' out info))  						continue;	// should not be renamed    					ldstr.Operand = info.newName;  					Logger.v("Renamed resource key {0} => {1}"' Utils.ToCsharpString(info.element.Name)' Utils.ToCsharpString(info.newName));  					info.element.Name = info.newName;  					info.foundInCode = true;  				}  			}
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,CreatePrefixFromStringData,The following statement contains a magic number: data = data.Substring(0' Math.Min(data.Length' 100));
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceKeysRenamer.cs,CreatePrefixFromStringData,The following statement contains a magic number: if (sb.Length <= 3)  				return CreateDefaultName();
Magic Number,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: nameToResource = new Dictionary<string' Resource>(module.ModuleDefMD.Resources.Count * 3' StringComparer.Ordinal);
Magic Number,de4dot.code.renamer,ResourceRenamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: foreach (var resource in module.ModuleDefMD.Resources) {  				var name = resource.Name.String;  				nameToResource[name] = resource;  				if (name.EndsWith(".g.resources"))  					nameToResource[name.Substring(0' name.Length - 12)] = resource;  				int index = name.LastIndexOf('.');  				if (index > 0)  					nameToResource[name.Substring(0' index)] = resource;  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,IsEventHandler,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  				return false;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var fieldName = ldstr.Operand as string;  					if (fieldName == null || !checker.IsValidFieldName(fieldName))  						continue;    					var instr = instructions[i - 2];  					IField fieldRef = null;  					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  						var calledMethod = instr.Operand as IMethod;  						if (calledMethod == null)  							continue;  						var calledMethodDef = ourMethods.Find(calledMethod);  						if (calledMethodDef == null)  							continue;  						fieldRef = GetFieldRef(calledMethodDef.MethodDef);    						var propDef = calledMethodDef.Property;  						if (propDef == null)  							continue;    						memberInfos.Property(propDef).suggestedName = fieldName;  						fieldName = "_" + fieldName;  					}  					else if (instr.OpCode.Code == Code.Ldfld) {  						fieldRef = instr.Operand as IField;  					}    					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.Find(fieldRef);  					if (fieldDef == null)  						continue;  					var fieldInfo = memberInfos.Field(fieldDef);    					if (fieldInfo.renamed)  						continue;    					fieldInfo.suggestedName = variableNameState.GetNewFieldName(fieldInfo.oldName' new NameCreator2(fieldName));  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var fieldName = ldstr.Operand as string;  					if (fieldName == null || !checker.IsValidFieldName(fieldName))  						continue;    					var instr = instructions[i - 2];  					IField fieldRef = null;  					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  						var calledMethod = instr.Operand as IMethod;  						if (calledMethod == null)  							continue;  						var calledMethodDef = ourMethods.Find(calledMethod);  						if (calledMethodDef == null)  							continue;  						fieldRef = GetFieldRef(calledMethodDef.MethodDef);    						var propDef = calledMethodDef.Property;  						if (propDef == null)  							continue;    						memberInfos.Property(propDef).suggestedName = fieldName;  						fieldName = "_" + fieldName;  					}  					else if (instr.OpCode.Code == Code.Ldfld) {  						fieldRef = instr.Operand as IField;  					}    					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.Find(fieldRef);  					if (fieldDef == null)  						continue;  					var fieldInfo = memberInfos.Field(fieldDef);    					if (fieldInfo.renamed)  						continue;    					fieldInfo.suggestedName = variableNameState.GetNewFieldName(fieldInfo.oldName' new NameCreator2(fieldName));  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,GetVbHandler,The following statement contains a magic number: eventName = addMethod.Name.String.Substring(4);
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,GetVbHandler,The following statement contains a magic number: if (eventName != removeMethod.Name.String.Substring(7))  				return null;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,FindEventCall,The following statement contains a magic number: if (callvirt < 2)  				return false;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,FindEventCall,The following statement contains a magic number: var ldfld = instructions[callvirt - 2];
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 0; i < instructions.Count - 6; i++) {  					// We're looking for this code pattern:  					//	ldarg.0  					//	ldfld field  					//	ldarg.0  					//	ldftn method / ldarg.0 + ldvirtftn  					//	newobj event_handler_ctor  					//	callvirt add_SomeEvent    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					var ldfld = instructions[index++];  					if (ldfld.OpCode.Code != Code.Ldfld)  						continue;  					var fieldRef = ldfld.Operand as IField;  					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.Find(fieldRef);  					if (fieldDef == null)  						continue;    					if (instructions[index++].GetParameterIndex() != 0)  						continue;    					IMethod methodRef;  					var instr = instructions[index + 1];  					if (instr.OpCode.Code == Code.Ldvirtftn) {  						if (!IsThisOrDup(instructions[index++]))  							continue;  						var ldvirtftn = instructions[index++];  						methodRef = ldvirtftn.Operand as IMethod;  					}  					else {  						var ldftn = instructions[index++];  						if (ldftn.OpCode.Code != Code.Ldftn)  							continue;  						methodRef = ldftn.Operand as IMethod;  					}  					if (methodRef == null)  						continue;  					var handlerMethod = ourMethods.Find(methodRef);  					if (handlerMethod == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!IsEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addHandler = call.Operand as IMethod;  					if (addHandler == null)  						continue;  					if (!Utils.StartsWith(addHandler.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addHandler.Name.String.Substring(4);  					if (!checker.IsValidEventName(eventName))  						continue;    					memberInfos.Method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.Field(fieldDef).newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 0; i < instructions.Count - 6; i++) {  					// We're looking for this code pattern:  					//	ldarg.0  					//	ldfld field  					//	ldarg.0  					//	ldftn method / ldarg.0 + ldvirtftn  					//	newobj event_handler_ctor  					//	callvirt add_SomeEvent    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					var ldfld = instructions[index++];  					if (ldfld.OpCode.Code != Code.Ldfld)  						continue;  					var fieldRef = ldfld.Operand as IField;  					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.Find(fieldRef);  					if (fieldDef == null)  						continue;    					if (instructions[index++].GetParameterIndex() != 0)  						continue;    					IMethod methodRef;  					var instr = instructions[index + 1];  					if (instr.OpCode.Code == Code.Ldvirtftn) {  						if (!IsThisOrDup(instructions[index++]))  							continue;  						var ldvirtftn = instructions[index++];  						methodRef = ldvirtftn.Operand as IMethod;  					}  					else {  						var ldftn = instructions[index++];  						if (ldftn.OpCode.Code != Code.Ldftn)  							continue;  						methodRef = ldftn.Operand as IMethod;  					}  					if (methodRef == null)  						continue;  					var handlerMethod = ourMethods.Find(methodRef);  					if (handlerMethod == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!IsEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addHandler = call.Operand as IMethod;  					if (addHandler == null)  						continue;  					if (!Utils.StartsWith(addHandler.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addHandler.Name.String.Substring(4);  					if (!checker.IsValidEventName(eventName))  						continue;    					memberInfos.Method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.Field(fieldDef).newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var method = methodDef.MethodDef;  				var instructions = method.Body.Instructions;  				for (int i = 0; i < instructions.Count - 5; i++) {  					// ldarg.0  					// ldarg.0 / dup  					// ldarg.0 / dup  					// ldvirtftn handler  					// newobj event handler ctor  					// call add_Xyz    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					if (!IsThisOrDup(instructions[index++]))  						continue;  					IMethod handler;  					if (instructions[index].OpCode.Code == Code.Ldftn) {  						handler = instructions[index++].Operand as IMethod;  					}  					else {  						if (!IsThisOrDup(instructions[index++]))  							continue;  						var instr = instructions[index++];  						if (instr.OpCode.Code != Code.Ldvirtftn)  							continue;  						handler = instr.Operand as IMethod;  					}  					if (handler == null)  						continue;  					var handlerDef = ourMethods.Find(handler);  					if (handlerDef == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!IsEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addMethod = call.Operand as IMethod;  					if (addMethod == null)  						continue;  					if (!Utils.StartsWith(addMethod.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addMethod.Name.String.Substring(4);  					if (!checker.IsValidEventName(eventName))  						continue;    					memberInfos.Method(handlerDef).suggestedName = string.Format("{0}_{1}"' newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var method = methodDef.MethodDef;  				var instructions = method.Body.Instructions;  				for (int i = 0; i < instructions.Count - 5; i++) {  					// ldarg.0  					// ldarg.0 / dup  					// ldarg.0 / dup  					// ldvirtftn handler  					// newobj event handler ctor  					// call add_Xyz    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					if (!IsThisOrDup(instructions[index++]))  						continue;  					IMethod handler;  					if (instructions[index].OpCode.Code == Code.Ldftn) {  						handler = instructions[index++].Operand as IMethod;  					}  					else {  						if (!IsThisOrDup(instructions[index++]))  							continue;  						var instr = instructions[index++];  						if (instr.OpCode.Code != Code.Ldvirtftn)  							continue;  						handler = instr.Operand as IMethod;  					}  					if (handler == null)  						continue;  					var handlerDef = ourMethods.Find(handler);  					if (handlerDef == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!IsEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addMethod = call.Operand as IMethod;  					if (addMethod == null)  						continue;  					if (!Utils.StartsWith(addMethod.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addMethod.Name.String.Substring(4);  					if (!checker.IsValidEventName(eventName))  						continue;    					memberInfos.Method(handlerDef).suggestedName = string.Format("{0}_{1}"' newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var className = ldstr.Operand as string;  					if (className == null)  						continue;    					if (instructions[i - 2].GetParameterIndex() != 0)  						continue;    					FindInitializeComponentMethod(type' methodDef);  					return className;  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!IsWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var className = ldstr.Operand as string;  					if (className == null)  						continue;    					if (instructions[i - 2].GetParameterIndex() != 0)  						continue;    					FindInitializeComponentMethod(type' methodDef);  					return className;  				}  			}
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceReader.cs,Read,The following statement contains a magic number: if (version != 2)  				throw new ResourceReaderException(string.Format("Invalid resource version: {0}"' version));
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceReader.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7;
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceReader.cs,Read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7;
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The following statement contains a magic number: writer.Write(2);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The following statement contains a magic number: if (extraBytes != 8) {  				for (int i = 0; i < extraBytes; i++)  					writer.Write((byte)'X');  			}
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Write,The following statement contains a magic number: writer.Write((int)writer.BaseStream.Position + (int)nameOffsetStream.Length + 4);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,WriteUInt32,The following statement contains a magic number: while (value >= 0x80) {  				writer.Write((byte)(value | 0x80));  				value >>= 7;  			}
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\resources\ResourceWriter.cs,Hash,The following statement contains a magic number: foreach (var c in key)  				val = ((val << 5) + val) ^ (uint)c;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  				// We can defer the modulo operation:  				// s1 maximally grows from 65521 to 65521 + 255 * 3800  				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  				int n = 3800;  				if (n > count) {  					n = count;  				}  				count -= n;  				while (--n >= 0) {  					s1 = s1 + (uint)(buffer[offset++] & 0xff);  					s2 = s2 + s1;  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  				throw new SharpZipBaseException("Header checksum illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (DEFLATED << 8)) {  				throw new SharpZipBaseException("Compression Method unknown");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) { // Dictionary flag?  				mode = DECODE_BLOCKS;  			} else {  				mode = DECODE_DICT;  				neededBits = 32;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int blockType;  					if (!ReadHeader(ref isLastBlock' out blockType)) {  						return false;  					}  					switch (blockType){  						case STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + blockType);  					}  					return true;  				  				case DECODE_STORED_LEN1:  					if (!DecodeStoredLength()) {  						return false;  					}  					mode = DECODE_STORED;  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,ReadHeader,The following statement contains a magic number: int type = input.PeekBits(3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,ReadHeader,The following statement contains a magic number: input.DropBits(3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits(16)) < 0) {  				return false;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: int nlen = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  				// bits_in_buffer may only be 0 or a multiple of 8  				throw new InvalidOperationException("Bit buffer is not byte aligned!");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  				// We always want an even number of bytes in input' see peekBits  				buffer_ = (uint)(window_[windowStart_++] & 0xff);  				bitsInBuffer_ = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  				// We always want an even number of bytes in input' see PeekBits  				buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);  				bitsInBuffer_ += 8;  			}
Missing Default,de4dot.code,MethodPrinter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodPrinter.cs,InitTargets,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.ShortInlineBrTarget:  				case OperandType.InlineBrTarget:  					SetTarget(instr.Operand as Instruction);  					break;    				case OperandType.InlineSwitch:  					foreach (var targetInstr in (Instruction[])instr.Operand)  						SetTarget(targetInstr);  					break;  				}
Missing Default,de4dot.code,MethodReturnValueInliner,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\MethodReturnValueInliner.cs,FixIntArg,The following switch statement is missing a default case: switch (type.ElementType) {  			case ElementType.Boolean: return value != 0;  			case ElementType.Char: return (char)value;  			case ElementType.I1: return (sbyte)value;  			case ElementType.U1: return (byte)value;  			case ElementType.I2: return (short)value;  			case ElementType.U2: return (ushort)value;  			case ElementType.I4: return (int)value;  			case ElementType.U4: return (uint)value;  			case ElementType.I8: return (long)value;  			case ElementType.U8: return (ulong)value;  			}
Missing Default,de4dot.code.deobfuscators,ArrayFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Newarr:  				case Code.Newobj:  					goto done;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stsfld:  				case Code.Stfld:  					if (emulator.Peek() == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  						goto done;  					break;  				}
Missing Default,de4dot.code.deobfuscators,ExceptionLoggerRemover,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,Find,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  						case Code.Call:  						case Code.Calli:  						case Code.Callvirt:  							calls++;  							callInstr = instr;  							break;  						}
Missing Default,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,IsCallMethod,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  				case Code.Ldarga:  				case Code.Ldarga_S:  					if (instr.GetParameterIndex() != loadIndex)  						return false;  					loadIndex++;  					continue;  				}
Missing Default,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\RandomNameChecker.cs,HasVowel,The following switch statement is missing a default case: switch (c) {  				case 'A':  				case 'a':  				case 'E':  				case 'e':  				case 'I':  				case 'i':  				case 'O':  				case 'o':  				case 'U':  				case 'u':  				case 'Y':  				case 'y':  					return true;  				}
Missing Default,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (stringDecrypter.TheVersion) {  				case StringDecrypter.Version.V30: return "v3.0 - v3.5";  				case StringDecrypter.Version.V36: return "v3.6 - v4.1";  				}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreatorType,The following switch statement is missing a default case: switch (field.FullName) {  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":  					numCalls++;  					break;  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":  					numCallvirts++;  					break;  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":  					numNewobjs++;  					break;  				}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Find,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.Silverlight:  				FindSilverlight();  				break;    			case FrameworkType.Desktop:  			case FrameworkType.CompactFramework:  				if (!module.IsClr1x) {  					if (FindDesktopOrCompactFramework())  						break;  				}  				FindDesktopOrCompactFrameworkV1();  				break;  			}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.Desktop:  				if (!module.IsClr1x) {  					if (constants.Count == 2) {  						desEncryptedFlag = (byte)constants[0];  						deflatedFlag = (byte)constants[1];  						return true;  					}  				}  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.Silverlight:  				if (constants.Count == 1) {  					bitwiseNotEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.CompactFramework:  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;  			}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,Find,The following switch statement is missing a default case: switch (frameworkType) {  				case FrameworkType.Desktop:  					result = FindDesktop(method);  					break;  				case FrameworkType.Silverlight:  					result = FindSilverlight(method);  					break;  				case FrameworkType.CompactFramework:  					result = FindCompactFramework(method);  					break;  				}
Missing Default,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (stringDecrypter.Version) {  			case StringDecrypter.DecrypterVersion.V1_3:  				if (DetectMethodProxyObfuscation())  					return DeobfuscatorInfo.THE_NAME + " 3.5";  				return DeobfuscatorInfo.THE_NAME + " 1.x-3.x";  			case StringDecrypter.DecrypterVersion.V4_0:  				return DeobfuscatorInfo.THE_NAME + " 4.0";  			case StringDecrypter.DecrypterVersion.V4_1:  				return DeobfuscatorInfo.THE_NAME + " 4.1";  			}
Missing Default,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,CheckFields,The following switch statement is missing a default case: switch (field.FieldSig.GetFieldType().GetFullName()) {  				case "System.Char[]":  					foundCharAry = true;  					break;  				case "System.String[]":  					foundStringAry = true;  					break;  				}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,UpdateModuleRefs,The following switch statement is missing a default case: switch (method.ImplMap.Name.String) {  					case "nr_nli":  					case "nr_startup":  						moduleRefs.Add(method.ImplMap.Module);  						break;  					}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (numIntPtrSizeCompares) {  					case 7:  					case 9: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 10:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (numIntPtrSizeCompares) {  					case 6:  					case 8: return DeobfuscatorInfo.THE_NAME + " 4.5";  					case 9:  						if (!hasSymmetricAlgorithm)  							return DeobfuscatorInfo.THE_NAME + " 4.6";  						if (hasCatchString)  							return DeobfuscatorInfo.THE_NAME + " 4.7";  						return DeobfuscatorInfo.THE_NAME + " 4.8";  					}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,OnWriterEvent,The following switch statement is missing a default case: switch (evt) {  			case ModuleWriterEvent.Begin:  				// The decrypter assumes RVAs are unique so don't share any method bodies  				writer.TheOptions.ShareMethodBodies = false;  				break;    			case ModuleWriterEvent.MDBeginAddResources:  				methodsDecrypter.PrepareEncryptNativeMethods(writer);  				break;    			case ModuleWriterEvent.BeginWriteChunks:  				methodsDecrypter.EncryptNativeMethods(writer);  				break;  			}
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,EfUtils,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\EfUtils.cs,GetNextStore,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stelem:  				case Code.Stelem_I:  				case Code.Stelem_I1:  				case Code.Stelem_I2:  				case Code.Stelem_I4:  				case Code.Stelem_I8:  				case Code.Stelem_R4:  				case Code.Stelem_R8:  				case Code.Stelem_Ref:  				case Code.Stfld:  				case Code.Stind_I:  				case Code.Stind_I1:  				case Code.Stind_I2:  				case Code.Stind_I4:  				case Code.Stind_I8:  				case Code.Stind_R4:  				case Code.Stind_R8:  				case Code.Stind_Ref:  				case Code.Stloc:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Stloc_S:  				case Code.Stobj:  				case Code.Stsfld:  					return instr;  				}
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,CreateLocalsArray,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.CompactFramework:  				removeLocals = removeLocals_cf;  				break;  			}
Missing Default,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Decrypt11,The following switch statement is missing a default case: switch (i % 3) {  					case 0:  						dest[i] = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						break;    					case 1:  						b = (byte)(encrypted[i] ^ mcKey.ReadByte(ki));  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;    					case 2:  						b = encrypted[i];  						dest[i] = (byte)((b << 4) | (b >> 4));  						break;  					}
Missing Default,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following switch statement is missing a default case: switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}
Missing Default,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,FindSpicesAttributes,The following switch statement is missing a default case: switch (type.FullName) {  				case "NineRays.Decompiler.NotDecompile":  				case "NineRays.Obfuscator.Evaluation":  				case "NineRays.Obfuscator.SoftwareWatermarkAttribute":  					AddAttributeToBeRemoved(type' "Obfuscator attribute");  					foundSpicesAttribute = true;  					break;  				}
Missing Default,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,FindXenocodeAttribute,The following switch statement is missing a default case: switch (type.FullName) {  				case "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode":  				case "Xenocode.Client.Attributes.AssemblyAttributes.SuppressDisassembly":  				case "Xenocode.User.Attributes.AssemblyAttributes.ProcessedByXenoCode":  				case "Xenocode.User.Attributes.AssemblyAttributes.SuppressDisassembly":  					AddAttributeToBeRemoved(type' "Obfuscator attribute");  					foundXenocodeAttribute = true;  					break;  				}
Missing Default,de4dot.code.renamer.asmmodules,MemberRefFinder,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\asmmodules\MemberRefFinder.cs,Add,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.InlineTok:  				case OperandType.InlineType:  				case OperandType.InlineMethod:  				case OperandType.InlineField:  					Push(instr.Operand);  					break;    				case OperandType.InlineSig:  					Add(instr.Operand as CallingConventionSig);  					break;    				case OperandType.InlineVar:  				case OperandType.ShortInlineVar:  					var local = instr.Operand as Local;  					if (local != null) {  						Add(local);  						break;  					}  					var arg = instr.Operand as Parameter;  					if (arg != null) {  						Add(arg);  						break;  					}  					break;  				}
Missing Default,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,CreateEvent,The following switch statement is missing a default case: switch (methodType) {  			case EventMethodType.Adder:  				CreateEventAdder(newEventName' methodDef);  				break;  			case EventMethodType.Remover:  				CreateEventRemover(newEventName' methodDef);  				break;  			}
Missing Default,de4dot.code.renamer,Renamer,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\Renamer.cs,PrepareRenameVirtualMethods,The following switch statement is missing a default case: switch (group.Methods[0].MethodDef.Name.String) {  				case "Invoke":  				case "BeginInvoke":  				case "EndInvoke":  					return;  				}
Missing Default,de4dot.code.renamer,TypeInfo,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\renamer\TypeInfo.cs,CanRenameMethod,The following switch statement is missing a default case: switch (methodInfo.oldName) {  					case "BeginInvoke":  					case "EndInvoke":  					case "Invoke":  						return false;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}
