Implementation smell,Namespace,Class,File,Method,Description
Long Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,The method has 110 lines of code.
Long Method,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,CreateTypeSigName,The method has 202 lines of code.
Long Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,The method has 108 lines of code.
Long Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,The method has 128 lines of code.
Long Method,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SignatureReader.cs,ReadType,The method has 112 lines of code.
Long Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The method has 101 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The method has 158 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The method has 152 lines of code.
Long Method,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The method has 237 lines of code.
Long Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,The method has 161 lines of code.
Long Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The method has 117 lines of code.
Long Method,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The method has 103 lines of code.
Long Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,The method has 104 lines of code.
Complex Method,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,CanAccess,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,GetTypeAccess,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetName,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToTypeSig,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetCorLibTypeSig,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,IsFriendAssemblyOf,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,AssemblyNameComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyNameComparer.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AssemblyNameComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyNameComparer.cs,CompareClosest,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,Resolve,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,ConstantUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetElementType,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CustomAttributeReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,CustomAttributeReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CustomAttributeReader.cs,ReadFieldOrPropType,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,CreateTypeSigName,Cyclomatic complexity of the method is 51
Complex Method,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,GetDefinitionAssembly,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,GetScope,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,ImportInternal,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 38
Complex Method,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet,ReflectionExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ReflectionExtensions.cs,GetElementType2,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,Resolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Resolver.cs,Resolve,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,Resolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Resolver.cs,GetDeclaringType,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 29
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,EqualsResolutionScope,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,EqualsImplementation,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,EqualsScope,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,DeclaringTypeEquals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SignatureReader.cs,ReadType,Cyclomatic complexity of the method is 52
Complex Method,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,Remove,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,GetClassSize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,FindMethodImplMethod,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,InitializeProperty,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,InitializeEvent,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,DynamicMethodBodyReader,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageCall,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\InstructionPrinter.cs,AddOperandString,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\InstructionPrinter.cs,EscapeString,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOperand,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,InitializeInternal,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,InitializeHotStreams,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.MD,DotNetFile,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetFile.cs,Load,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,InitializeInternal,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetFieldRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetMethodRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetEventRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetPropertyRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,FindAllRows,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,InitializeInverseGenericParamOwnerRidList,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,InitializeNestedClassesDictionary,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,VerifyValue,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,Cyclomatic complexity of the method is 41
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,TryWriteEnumUnderlyingTypeValue,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteFieldOrPropType,Cyclomatic complexity of the method is 23
Complex Method,dnlib.DotNet.Writer,MaxStackCalculator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,Cyclomatic complexity of the method is 48
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,InitializeTypeDefsAndMemberDefs,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,WriteTypeDefAndMemberDefCustomAttributes,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,SortTables,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,WriteMethodBodies,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,AddMDTokenProvider,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,GetConstantValueAsByteArray,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,GetHeaps,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOperand,Cyclomatic complexity of the method is 19
Complex Method,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,OnMetaDataEvent,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateVTableFixups,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,NormalMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NormalMetaData.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,GetAllTypeDefs,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,CreateEmptyTableRows,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,ReUseDeletedParamRows,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,FindMemberDefs,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.Writer,SignatureWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,Populate,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,Cyclomatic complexity of the method is 10
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Error,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Error,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Error,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Warning,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Warning,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Warning,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Info,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Info,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Info,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Verbose,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Verbose,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,Verbose,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,VeryVerbose,The method has 5 parameters. Parameters: logger' sender' message' arg1' arg2
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,VeryVerbose,The method has 6 parameters. Parameters: logger' sender' message' arg1' arg2' arg3
Long Parameter List,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,VeryVerbose,The method has 7 parameters. Parameters: logger' sender' message' arg1' arg2' arg3' arg4
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The method has 5 parameters. Parameters: genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The method has 5 parameters. Parameters: genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argType1' argType2
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 6 parameters. Parameters: callingConvention' genParamCount' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argTypes' paramsAfterSentinel
Long Parameter List,dnlib.DotNet,PropertySig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters. Parameters: hasThis' retType' argType1' argType2' argType3
Long Parameter List,dnlib.DotNet,PropertySig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters. Parameters: callingConvention' genParamCount' retType' argTypes' paramsAfterSentinel
Long Parameter List,dnlib.DotNet,ExportedTypeUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ExportedType.cs,ExportedTypeUser,The method has 6 parameters. Parameters: module' typeDefId' typeNamespace' typeName' flags' implementation
Long Parameter List,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,MethodFullName,The method has 5 parameters. Parameters: declaringType' name' methodSig' typeGenArgs' methodGenArgs
Long Parameter List,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,MethodFullName,The method has 5 parameters. Parameters: declaringType' name' methodSig' typeGenArgs' methodGenArgs
Long Parameter List,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,FullName,The method has 5 parameters. Parameters: typeSig' isReflection' helper' typeGenArgs' methodGenArgs
Long Parameter List,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,InitializeEvent,The method has 5 parameters. Parameters: evt' addMethod' invokeMethod' removeMethod' otherMethods
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The method has 8 parameters. Parameters: opResolver' code' exceptions' parameters' flags' maxStack' codeSize' localVarSigTok
Long Parameter List,dnlib.DotNet.Emit,OpCode,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The method has 7 parameters. Parameters: name' code' operandType' flowControl' opCodeType' push' pop
Long Parameter List,dnlib.DotNet.MD,HotStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,Create,The method has 5 parameters. Parameters: version' imageStream' streamHeader' fullStream' baseOffset
Long Parameter List,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawModuleRow,The method has 5 parameters. Parameters: Generation' Name' Mvid' EncId' EncBaseId
Long Parameter List,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawTypeDefRow,The method has 6 parameters. Parameters: Flags' Name' Namespace' Extends' FieldList' MethodList
Long Parameter List,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawMethodRow,The method has 6 parameters. Parameters: RVA' ImplFlags' Flags' Name' Signature' ParamList
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRow,The method has 9 parameters. Parameters: HashAlgId' MajorVersion' MinorVersion' BuildNumber' RevisionNumber' Flags' PublicKey' Name' Locale
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRefRow,The method has 9 parameters. Parameters: MajorVersion' MinorVersion' BuildNumber' RevisionNumber' Flags' PublicKeyOrToken' Name' Locale' HashValue
Long Parameter List,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawExportedTypeRow,The method has 5 parameters. Parameters: Flags' TypeDefId' TypeName' TypeNamespace' Implementation
Long Parameter List,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,RawGenericParamRow,The method has 5 parameters. Parameters: Number' Flags' Owner' Name' Kind
Long Parameter List,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,Create,The method has 5 parameters. Parameters: module' constants' methodBodies' netResources' options
Long Parameter List,dnlib.DotNet.Writer,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaData.cs,MetaData,The method has 5 parameters. Parameters: module' constants' methodBodies' netResources' options
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,InitializeEnhancedStrongNameSigning,The method has 5 parameters. Parameters: module' signatureKey' signaturePubKey' identityKey' identityPubKey
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CalculateRvasAndFileOffsets,The method has 5 parameters. Parameters: chunks' offset' rva' fileAlignment' sectionAlignment
Long Parameter List,dnlib.DotNet.Writer,NormalMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NormalMetaData.cs,NormalMetaData,The method has 5 parameters. Parameters: module' constants' methodBodies' netResources' options
Long Parameter List,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,PreserveTokensMetaData,The method has 5 parameters. Parameters: module' constants' methodBodies' netResources' options
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,MapViewOfFile,The method has 5 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap
Long Parameter List,dnlib.Threading,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\Threading\Extensions.cs,Iterate,The method has 5 parameters. Parameters: list' startIndex' endIndex' reverseOrder' handler
Long Identifier,dnlib.DotNet,DummyLogger,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ILogger.cs,,The length of the parameter ThrowModuleWriterExceptionOnErrorInstance is 41.
Long Identifier,dnlib.DotNet,FieldEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,FieldEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,MethodEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,MethodEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,PropertyEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,PropertyEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet,EventEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveCompareDeclaringTypes is 36.
Long Identifier,dnlib.DotNet,EventEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,,The length of the parameter CaseInsensitiveDontCompareDeclaringTypes is 40.
Long Identifier,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriter.cs,,The length of the parameter DEFAULT_DEBUGDIRECTORY_ALIGNMENT is 32.
Long Identifier,dnlib.DotNet.Writer,ModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriter.cs,,The length of the parameter DEFAULT_IMPORTDIRECTORY_ALIGNMENT is 33.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_METHODBODIES_ALIGNMENT is 30.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_NETRESOURCES_ALIGNMENT is 30.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_WIN32_RESOURCES_ALIGNMENT is 33.
Long Identifier,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,,The length of the parameter DEFAULT_STRONGNAMESIG_ALIGNMENT is 31.
Long Identifier,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,,The length of the parameter RESOURCE_DATA_HEADER_ALIGNMENT is 30.
Long Identifier,dnlib.PE,PEImage,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\PEImage.cs,,The length of the parameter USE_MEMORY_LAYOUT_WITH_MAPPED_FILES is 35.
Long Statement,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,IsSameAssembly,The length of the statement  "			return new AssemblyNameComparer(AssemblyNameComparerFlags.All).Equals(new AssemblyNameInfo(asm1)' new AssemblyNameInfo(asm2)); " is 126.
Long Statement,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetCorLibTypeSig,The length of the statement  "			return self.GetCorLibTypeSig(UTF8String.ToSystemStringOrEmpty(@namespace)' UTF8String.ToSystemStringOrEmpty(name)' defAsm); " is 123.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException(string.Format("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' fileName)); " is 132.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException(string.Format("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString())); " is 141.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException(string.Format("{0} (addr: {1:X8}) is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString()' addr.ToInt64())); " is 172.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException(string.Format("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString())); " is 141.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "					throw new BadImageFormatException(string.Format("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString())); " is 141.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,UpdateOrCreateAssemblySignatureKeyAttribute,The length of the statement  "			ca.ConstructorArguments[0] = new CAArgument(manifestModule.CorLibTypes.String' new UTF8String(signaturePubKey.ToString())); " is 123.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var owner = manifestModule.UpdateRowId(new TypeRefUser(manifestModule' "System.Reflection"' "AssemblySignatureKeyAttribute"' manifestModule.CorLibTypes.AssemblyRef)); " is 166.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var methodSig = MethodSig.CreateInstance(manifestModule.CorLibTypes.Void' manifestModule.CorLibTypes.String' manifestModule.CorLibTypes.String); " is 144.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "			var ctor = manifestModule.UpdateRowId(new MemberRefUser(manifestModule' MethodDef.InstanceConstructorName' methodSig' owner)); " is 126.
Long Statement,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Module already has an assembly. Remove it from that assembly before adding it to this assembly."); " is 135.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' PreFindAssemblies(assembly' sourceModule' false)' moduleContext); " is 132.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' FindAssemblies(assembly' sourceModule' false)' moduleContext); " is 129.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "				resolvedAssembly = FindClosestAssembly(assembly' resolvedAssembly' PostFindAssemblies(assembly' sourceModule' false)' moduleContext); " is 133.
Long Statement,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,FindClosestAssembly,The length of the statement  "					if (asm != null && asmComparer.CompareClosest(assembly' new AssemblyNameInfo(closest)' new AssemblyNameInfo(asm)) == 1) { " is 121.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.Generic' genParamCount' retType' argType1' argType2); " is 120.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.Generic' genParamCount' retType' argType1' argType2' argType3); " is 130.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType); " is 128.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1); " is 138.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1' argType2); " is 148.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1' argType2' argType3); " is 158.
Long Statement,dnlib.DotNet,MethodSig,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argTypes); " is 138.
Long Statement,dnlib.DotNet,GenericParam,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\GenericParam.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Generic param constraint is already owned by another generic param. Set Owner to null first."); " is 132.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,The length of the statement  "				var git = new GenericInstSig(ImportAsTypeSig(type.GetGenericTypeDefinition()) as ClassOrValueTypeSig' (uint)typeGenArgs.Length); " is 128.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "				return module.UpdateRowId(new TypeRefUser(module' type.Namespace ?? string.Empty' type.Name ?? string.Empty' CreateScopeReference(type))); " is 138.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "			return module.UpdateRowId(new TypeRefUser(module' string.Empty' type.Name ?? string.Empty' CreateTypeRef2(type.DeclaringType))); " is 128.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,CreateScopeReference,The length of the statement  "			return module.UpdateRowId(new AssemblyRefUser(asmName.Name' asmName.Version' PublicKeyBase.CreatePublicKeyToken(pkt)' asmName.CultureInfo.Name)); " is 145.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,ImportInternal,The length of the statement  "					method = module.UpdateRowId(new MemberRefUser(module' methodBase.Name' CreateMethodSig(origMethod)' Import(methodBase.DeclaringType))); " is 135.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,The length of the statement  "			return ImportAsTypeSig(p.ParameterType' p.GetRequiredCustomModifiers()' p.GetOptionalCustomModifiers()' declaringType.MustTreatTypeAsGenericInstType(p.ParameterType)); " is 167.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,GetModuleParent,The length of the statement  "				UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(module2.Assembly.GetName().Name' StringComparison.OrdinalIgnoreCase); " is 122.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "				result = module.UpdateRowId(new TypeRefUser(module' type.Namespace' type.Name' CreateScopeReference(type.DefinitionAssembly' type.Module))); " is 140.
Long Statement,dnlib.DotNet,Importer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "				result = module.UpdateRowId(new TypeRefUser(module' type.Namespace' type.Name' CreateScopeReference(type.DefinitionAssembly' type.Module))); " is 140.
Long Statement,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list."); " is 120.
Long Statement,dnlib.DotNet,ModuleDefUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,CreateModuleType,The length of the statement  "			type.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass; " is 121.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listModuleDefMD = new SimpleLazyList<ModuleDefMD2>(ts.ModuleTable.Rows' rid2 => rid2 == 1 ? this : new ModuleDefMD2(this' rid2)); " is 129.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listInterfaceImplMD = new SimpleLazyList<InterfaceImplMD>(ts.InterfaceImplTable.Rows' rid2 => new InterfaceImplMD(this' rid2)); " is 127.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listFieldMarshalMD = new SimpleLazyList<FieldMarshalMD>(ts.FieldMarshalTable.Rows' rid2 => new FieldMarshalMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listDeclSecurityMD = new SimpleLazyList<DeclSecurityMD>(ts.DeclSecurityTable.Rows' rid2 => new DeclSecurityMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listStandAloneSigMD = new SimpleLazyList<StandAloneSigMD>(ts.StandAloneSigTable.Rows' rid2 => new StandAloneSigMD(this' rid2)); " is 127.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listExportedTypeMD = new SimpleLazyList<ExportedTypeMD>(ts.ExportedTypeTable.Rows' rid2 => new ExportedTypeMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listManifestResourceMD = new SimpleLazyList<ManifestResourceMD>(ts.ManifestResourceTable.Rows' rid2 => new ManifestResourceMD(this' rid2)); " is 139.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listGenericParamMD = new SimpleLazyList<GenericParamMD>(ts.GenericParamTable.Rows' rid2 => new GenericParamMD(this' rid2)); " is 123.
Long Statement,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "			listGenericParamConstraintMD = new SimpleLazyList<GenericParamConstraintMD>(ts.GenericParamConstraintTable.Rows' rid2 => new GenericParamConstraintMD(this' rid2)); " is 163.
Long Statement,dnlib.DotNet,ReflectionExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ReflectionExtensions.cs,IsSZArray,The length of the statement  "			var prop = self.GetType().GetProperty("IsSzArray"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,dnlib.DotNet,LinkedResource,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Resource.cs,ToString,The length of the statement  "			return string.Format("{0} - file: {1}"' UTF8String.ToSystemStringOrEmpty(Name)' UTF8String.ToSystemStringOrEmpty(FileName)); " is 124.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals_Names,The length of the statement  "				return UTF8String.ToSystemStringOrEmpty(a).Equals(UTF8String.ToSystemStringOrEmpty(b)' StringComparison.OrdinalIgnoreCase); " is 123.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "				hash = HASHCODE_MAGIC_ET_GENERICINST + GetHashCode(a.GetGenericTypeDefinition()) + GetHashCode(a.GetGenericArguments()); " is 120.
Long Statement,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken' new PublicKeyToken(bAsmName.GetPublicKeyToken()))) && " is 134.
Long Statement,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,FindStaticConstructor,The length of the statement  "			return Methods.ExecuteLocked<MethodDef' object' MethodDef>(null' (tsList' arg) => FindStaticConstructor_NoMethodsLock()); " is 121.
Long Statement,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,OnAdd,The length of the statement  "				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list."); " is 120.
Long Statement,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,Create,The length of the statement  "			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok) " is 147.
Long Statement,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The length of the statement  "			return CreateCilBody(opResolver' MemoryImageStream.Create(code)' exceptions == null ? null : MemoryImageStream.Create(exceptions)' parameters); " is 143.
Long Statement,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The length of the statement  "			var createdMethod = tb.CreateType().GetMethod(METHOD_NAME' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 179.
Long Statement,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET40,The length of the statement  "			var createdMethod = tb.CreateType().GetMethod(METHOD_NAME' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 179.
Long Statement,dnlib.DotNet.MD,DotNetFile,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The length of the statement  "				var cor20Header = new ImageCor20Header(cor20HeaderStream = peImage.CreateStream(dotNetDir.VirtualAddress' 0x48)' verify); " is 121.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			maxPresentTables = (majorVersion == 1 && minorVersion == 0) ? (int)Table.NestedClass + 1 : (int)Table.GenericParamConstraint + 1; " is 129.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.AssemblyProcessor] = new TableInfo(Table.AssemblyProcessor' "AssemblyProcessor"' new ColumnInfo[] { " is 121.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.AssemblyRefProcessor] = new TableInfo(Table.AssemblyRefProcessor' "AssemblyRefProcessor"' new ColumnInfo[] { " is 130.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "			tableInfos[(int)Table.GenericParamConstraint] = new TableInfo(Table.GenericParamConstraint' "GenericParamConstraint"' new ColumnInfo[] { " is 136.
Long Statement,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The length of the statement  "				if ((ca.ConstructorArguments != null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments != null && ca.NamedArguments.Count > 0)) " is 137.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,CreateRawSections,The length of the statement  "				newSection.chunk = new BinaryReaderChunk(peImage.CreateStream(peSection.VirtualAddress' sectionSize)' peSection.VirtualSize); " is 125.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "			CalculateRvasAndFileOffsets(chunks' 0' 0' peImage.ImageNTHeaders.OptionalHeader.FileAlignment' peImage.ImageNTHeaders.OptionalHeader.SectionAlignment); " is 151.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The length of the statement  "			var sectionSizes = new SectionSizes(fileAlignment' sectionAlignment' headerSection.GetVirtualSize()' () => GetSectionSizeInfos()); " is 130.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,ToWriterOffset,The length of the statement  "				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,ReUseDeletedMethodRows,The length of the statement  "				mrow.Flags = (ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract); " is 158.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,ReUseDeletedParamRows,The length of the statement  "					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract)' " is 145.
Long Statement,dnlib.PE,PEInfo,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\PEInfo.cs,ToImageSectionHeader,The length of the statement  "				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Complex Conditional,dnlib.DotNet,AccessChecker,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AccessChecker.cs,CanAccess,The conditional expression  "mr.Name == "Get" || mr.Name == "Set" || mr.Name == "Address" || mr.Name == MethodDef.InstanceConstructorName"  is complex.
Complex Conditional,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The conditional expression  "peeked == '*' || peeked == ''' || peeked == '-' || char.IsDigit((char)peeked)"  is complex.
Complex Conditional,dnlib.DotNet.MD,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaDataHeader.cs,MetaDataHeader,The conditional expression  "verify && !((majorVersion == 1 && minorVersion == 1) || (majorVersion == 0 && minorVersion >= 19))"  is complex.
Complex Conditional,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The conditional expression  "(ca.ConstructorArguments != null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments != null && ca.NamedArguments.Count > 0)"  is complex.
Complex Conditional,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The conditional expression  "c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F"  is complex.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,FindExactAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,FindClosestAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,GetDirs,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,GetModulePrivateSearchPaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,AddSilverlightDirs,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,UTF8String,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\UTF8String.cs,ConvertFromUTF8,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.MD,HotTableStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.MD,HotTableStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Writer,ModuleWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,DeleteFileNoThrow,The method has an empty catch block.
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetPrimitiveSize,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  			case ElementType.I1:  			case ElementType.U1:  				return 1;    			case ElementType.Char:  			case ElementType.I2:  			case ElementType.U2:  				return 2;    			case ElementType.I4:  			case ElementType.U4:  			case ElementType.R4:  				return 4;    			case ElementType.I8:  			case ElementType.U8:  			case ElementType.R8:  				return 8;    			case ElementType.Ptr:  			case ElementType.FnPtr:  			case ElementType.I:  			case ElementType.U:  				return ptrSize;    			default:  				return -1;  			}
Magic Number,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetNonNestedTypeRefScope,The following statement contains a magic number: i < 100
Magic Number,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: sig == null || sig.Params.Count != 2
Magic Number,dnlib.DotNet,AssemblyDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: ca.ConstructorArguments.Count != 2
Magic Number,dnlib.DotNet,AssemblyHash,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyHash.cs,CreatePublicKeyToken,The following statement contains a magic number: byte[] pkt = new byte[8];
Magic Number,dnlib.DotNet,AssemblyRefUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR10,The following statement contains a magic number: return new AssemblyRefUser("mscorlib"' new Version(1' 0' 3300' 0)' new PublicKeyToken("b77a5c561934e089"));
Magic Number,dnlib.DotNet,AssemblyRefUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR11,The following statement contains a magic number: return new AssemblyRefUser("mscorlib"' new Version(1' 0' 5000' 0)' new PublicKeyToken("b77a5c561934e089"));
Magic Number,dnlib.DotNet,AssemblyRefUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR20,The following statement contains a magic number: return new AssemblyRefUser("mscorlib"' new Version(2' 0' 0' 0)' new PublicKeyToken("b77a5c561934e089"));
Magic Number,dnlib.DotNet,AssemblyRefUser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR40,The following statement contains a magic number: return new AssemblyRefUser("mscorlib"' new Version(4' 0' 0' 0)' new PublicKeyToken("b77a5c561934e089"));
Magic Number,dnlib.DotNet,AssemblyResolver,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyResolver.cs,FindAssembliesModuleSearchPaths,The following statement contains a magic number: i < 2
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,ConstantMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  			case ElementType.Boolean:  				if (data == null || data.Length < 1)  					return false;  				return BitConverter.ToBoolean(data' 0);    			case ElementType.Char:  				if (data == null || data.Length < 2)  					return (char)0;  				return BitConverter.ToChar(data' 0);    			case ElementType.I1:  				if (data == null || data.Length < 1)  					return (sbyte)0;  				return (sbyte)data[0];    			case ElementType.U1:  				if (data == null || data.Length < 1)  					return (byte)0;  				return data[0];    			case ElementType.I2:  				if (data == null || data.Length < 2)  					return (short)0;  				return BitConverter.ToInt16(data' 0);    			case ElementType.U2:  				if (data == null || data.Length < 2)  					return (ushort)0;  				return BitConverter.ToUInt16(data' 0);    			case ElementType.I4:  				if (data == null || data.Length < 4)  					return (int)0;  				return BitConverter.ToInt32(data' 0);    			case ElementType.U4:  				if (data == null || data.Length < 4)  					return (uint)0;  				return BitConverter.ToUInt32(data' 0);    			case ElementType.I8:  				if (data == null || data.Length < 8)  					return (long)0;  				return BitConverter.ToInt64(data' 0);    			case ElementType.U8:  				if (data == null || data.Length < 8)  					return (ulong)0;  				return BitConverter.ToUInt64(data' 0);    			case ElementType.R4:  				if (data == null || data.Length < 4)  					return (float)0;  				return BitConverter.ToSingle(data' 0);    			case ElementType.R8:  				if (data == null || data.Length < 8)  					return (double)0;  				return BitConverter.ToDouble(data' 0);    			case ElementType.String:  				if (data == null)  					return string.Empty;  				return Encoding.Unicode.GetString(data' 0' data.Length / 2 * 2);    			case ElementType.Class:  				return null;    			default:  				return null;  			}
Magic Number,dnlib.DotNet,FieldDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,FieldDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,GenericParamMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\GenericParam.cs,Initialize,The following statement contains a magic number: kind.ReadOriginalValue = () => {  				if (readerModule.TablesStream.GenericParamTable.TableInfo.Columns.Count != 5)  					return null;  				InitializeRawRow_NoLock();  				return readerModule.ResolveTypeDefOrRef(rawRow.Kind);  			};
Magic Number,dnlib.DotNet,ImplMap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ImplMap.cs,GetDllName,The following statement contains a magic number: return dllName.Substring(0' dllName.Length - 4);
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return GetPointerSize(4);
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 8;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: switch (flags & (ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred)) {  			case 0:  				// Machine and ILOnly flag should be checked  				break;    			case ComImageFlags._32BitPreferred:  				// Illegal  				break;    			case ComImageFlags._32BitRequired:  				// x86 image (32-bit process)  				return 4;    			case ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred:  				// Platform neutral but prefers to be 32-bit  				return defaultPointerSize;  			}
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ModuleDefMD,The following statement contains a magic number: this.Cor20HeaderRuntimeVersion = (uint)(MetaData.ImageCor20Header.MajorRuntimeVersion << 16) | MetaData.ImageCor20Header.MinorRuntimeVersion;
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The following statement contains a magic number: i < 64
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: offset + 3 <= offset || offset + 3 >= resources.Size
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: offset + 3 <= offset || offset + 3 >= resources.Size
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length
Magic Number,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SigComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,SignatureReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\SignatureReader.cs,ReadType,The following statement contains a magic number: switch ((ElementType)reader.ReadByte()) {  			case ElementType.Void:		result = corLibTypes.Void; break;  			case ElementType.Boolean:	result = corLibTypes.Boolean; break;  			case ElementType.Char:		result = corLibTypes.Char; break;  			case ElementType.I1:		result = corLibTypes.SByte; break;  			case ElementType.U1:		result = corLibTypes.Byte; break;  			case ElementType.I2:		result = corLibTypes.Int16; break;  			case ElementType.U2:		result = corLibTypes.UInt16; break;  			case ElementType.I4:		result = corLibTypes.Int32; break;  			case ElementType.U4:		result = corLibTypes.UInt32; break;  			case ElementType.I8:		result = corLibTypes.Int64; break;  			case ElementType.U8:		result = corLibTypes.UInt64; break;  			case ElementType.R4:		result = corLibTypes.Single; break;  			case ElementType.R8:		result = corLibTypes.Double; break;  			case ElementType.String:	result = corLibTypes.String; break;  			case ElementType.TypedByRef:result = corLibTypes.TypedReference; break;  			case ElementType.I:			result = corLibTypes.IntPtr; break;  			case ElementType.U:			result = corLibTypes.UIntPtr; break;  			case ElementType.Object:	result = corLibTypes.Object; break;    			case ElementType.Ptr:		result = new PtrSig(ReadType()); break;  			case ElementType.ByRef:		result = new ByRefSig(ReadType()); break;  			case ElementType.ValueType:	result = new ValueTypeSig(ReadTypeDefOrRef()); break;  			case ElementType.Class:		result = new ClassSig(ReadTypeDefOrRef()); break;  			case ElementType.FnPtr:		result = new FnPtrSig(ReadSig()); break;  			case ElementType.SZArray:	result = new SZArraySig(ReadType()); break;  			case ElementType.CModReqd:	result = new CModReqdSig(ReadTypeDefOrRef()' ReadType()); break;  			case ElementType.CModOpt:	result = new CModOptSig(ReadTypeDefOrRef()' ReadType()); break;  			case ElementType.Sentinel:	result = new SentinelSig(); break;  			case ElementType.Pinned:	result = new PinnedSig(ReadType()); break;    			case ElementType.Var:  				if (!reader.ReadCompressedUInt32(out num))  					break;  				result = new GenericVar(num);  				break;    			case ElementType.MVar:  				if (!reader.ReadCompressedUInt32(out num))  					break;  				result = new GenericMVar(num);  				break;    			case ElementType.ValueArray:  				nextType = ReadType();  				if (!reader.ReadCompressedUInt32(out num))  					break;  				result = new ValueArraySig(nextType' num);  				break;    			case ElementType.Module:  				if (!reader.ReadCompressedUInt32(out num))  					break;  				result = new ModuleSig(num' ReadType());  				break;    			case ElementType.GenericInst:  				nextType = ReadType();  				if (!reader.ReadCompressedUInt32(out num))  					break;  				var genericInstSig = new GenericInstSig(nextType as ClassOrValueTypeSig' num);  				var args = genericInstSig.GenericArguments;  				for (uint i = 0; i < num; i++)  					args.Add(ReadType());  				result = genericInstSig;  				break;    			case ElementType.Array:  				nextType = ReadType();  				uint rank;  				if (!reader.ReadCompressedUInt32(out rank))  					break;  				if (rank == 0) {  					result = new ArraySig(nextType' rank);  					break;  				}  				if (!reader.ReadCompressedUInt32(out num))  					break;  				var sizes = new List<uint>((int)num);  				for (uint i = 0; i < num; i++) {  					uint size;  					if (!reader.ReadCompressedUInt32(out size))  						goto exit;  					sizes.Add(size);  				}  				if (!reader.ReadCompressedUInt32(out num))  					break;  				var lowerBounds = new List<int>((int)num);  				for (uint i = 0; i < num; i++) {  					int size;  					if (!reader.ReadCompressedInt32(out size))  						goto exit;  					lowerBounds.Add(size);  				}  				result = new ArraySig(nextType' rank' sizes' lowerBounds);  				break;    			case ElementType.Internal:  				IntPtr address;  				if (IntPtr.Size == 4)  					address = new IntPtr(reader.ReadInt32());  				else  					address = new IntPtr(reader.ReadInt64());  				result = helper.ConvertRTInternalAddress(address);  				break;    			case ElementType.End:  			case ElementType.R:  			default:  				result = null;  				break;  			}
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: reader.ReadByte() != 6
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: reader.ReadByte() != 2
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse(4);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: modulus = reader.ReadBytesReverse((int)(bitLength / 8));
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write((byte)6);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write((byte)2);
Magic Number,dnlib.DotNet,StrongNamePublicKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write(modulus.Length * 8);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: reader.ReadByte() != 7
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: reader.ReadByte() != 2
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse(4);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: int len8 = (int)(bitLength / 8);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: int len16 = (int)(bitLength / 16);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write((byte)7);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write((byte)2);
Magic Number,dnlib.DotNet,StrongNameKey,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write(modulus.Length * 8);
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position += 6;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 2;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: i < 4
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: const int imageDirsSize = 16 * 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: const int imageDirsSize = 16 * 8;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer[4 * 8 + i] = 0;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer[4 * 8 + i] = 0;
Magic Number,dnlib.DotNet,StrongNameSigner,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: i < 8
Magic Number,dnlib.DotNet,TypeDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,FindOrCreateStaticConstructor,The following statement contains a magic number: body.MaxStack = 8;
Magic Number,dnlib.DotNet,TypeDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeDef.cs,FindMethodImplMethod,The following statement contains a magic number: i < 10
Magic Number,dnlib.DotNet,TypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadUInt32,The following statement contains a magic number: uint newVal = val * 10 + (uint)(c - '0');
Magic Number,dnlib.DotNet,TypeRef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeRef.cs,GetNonNestedTypeRef,The following statement contains a magic number: i < 1000
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: var chars = new char[bytes.Length * 2];
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: chars[j++] = ToHexChar(b >> 4' upper);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: 0 <= val && val <= 9
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: return (char)(val - 10 + (upper ? (int)'A' : (int)'a'));
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: hexString.Length % 2 != 0
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: var bytes = new byte[hexString.Length / 2];
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes[i / 2] = (byte)((upper << 4) | lower);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes[i / 2] = (byte)((upper << 4) | lower);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'a';
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'A';
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: int count = Math.Min(a.Length / 2' 20);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: int count = Math.Min(a.Length / 2' 20);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash ^= a[i] | ((uint)a[j] << 8);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 2;
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet,Utils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: uint sign = (uint)value >> 31;
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: this.vtables = ThreadSafeListCreator.Create<VTable>((int)info.Size / 8);
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: int slotSize = vtable.Is64Bit ? 8 : 4;
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: int slotSize = vtable.Is64Bit ? 8 : 4;
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: slotSize == 8
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: reader.Position + 8 <= endPos && reader.CanRead(8)
Magic Number,dnlib.DotNet,VTableFixups,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: reader.Position + 8 <= endPos && reader.CanRead(8)
Magic Number,dnlib.DotNet.Emit,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Code.cs,ToOpCode,The following statement contains a magic number: int hi = (ushort)code >> 8;
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,CreateExceptionHandlers,The following statement contains a magic number: int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
Magic Number,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,ReadToken,The following statement contains a magic number: switch (token >> 24) {  			case 0x02:  				return ImportType(rid);    			case 0x04:  				return ImportField(rid);    			case 0x06:  			case 0x0A:  				return ImportMethod(rid);    			case 0x11:  				return ImportSignature(rid);    			case 0x70:  				return Resolve(rid) as string;    			default:  				return null;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (opCode.OperandType) {  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineSig:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  				return opCode.Size + 4;    			case OperandType.InlineI8:  			case OperandType.InlineR:  				return opCode.Size + 8;    			case OperandType.InlineNone:  			case OperandType.InlinePhi:  			default:  				return opCode.Size;    			case OperandType.InlineSwitch:  				var targets = Operand as IList<Instruction>;  				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);    			case OperandType.InlineVar:  				return opCode.Size + 2;    			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineVar:  				return opCode.Size + 1;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  			case StackBehaviour.Push0:  				break;    			case StackBehaviour.Push1:  			case StackBehaviour.Pushi:  			case StackBehaviour.Pushi8:  			case StackBehaviour.Pushr4:  			case StackBehaviour.Pushr8:  			case StackBehaviour.Pushref:  				pushes++;  				break;    			case StackBehaviour.Push1_push1:  				pushes += 2;  				break;    			case StackBehaviour.Varpush:	// only call' calli' callvirt which are handled elsewhere  			default:  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  			case StackBehaviour.Pop0:  				break;    			case StackBehaviour.Pop1:  			case StackBehaviour.Popi:  			case StackBehaviour.Popref:  				pops++;  				break;    			case StackBehaviour.Pop1_pop1:  			case StackBehaviour.Popi_pop1:  			case StackBehaviour.Popi_popi:  			case StackBehaviour.Popi_popi8:  			case StackBehaviour.Popi_popr4:  			case StackBehaviour.Popi_popr8:  			case StackBehaviour.Popref_pop1:  			case StackBehaviour.Popref_popi:  				pops += 2;  				break;    			case StackBehaviour.Popi_popi_popi:  			case StackBehaviour.Popref_popi_popi:  			case StackBehaviour.Popref_popi_popi8:  			case StackBehaviour.Popref_popi_popr4:  			case StackBehaviour.Popref_popi_popr8:  			case StackBehaviour.Popref_popi_popref:  			case StackBehaviour.Popref_popi_pop1:  				pops += 3;  				break;    			case StackBehaviour.PopAll:  				pops = -1;  				break;    			case StackBehaviour.Varpop:	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  				if (hasReturnValue)  					pops++;  				break;    			default:  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  			case StackBehaviour.Pop0:  				break;    			case StackBehaviour.Pop1:  			case StackBehaviour.Popi:  			case StackBehaviour.Popref:  				pops++;  				break;    			case StackBehaviour.Pop1_pop1:  			case StackBehaviour.Popi_pop1:  			case StackBehaviour.Popi_popi:  			case StackBehaviour.Popi_popi8:  			case StackBehaviour.Popi_popr4:  			case StackBehaviour.Popi_popr8:  			case StackBehaviour.Popref_pop1:  			case StackBehaviour.Popref_popi:  				pops += 2;  				break;    			case StackBehaviour.Popi_popi_popi:  			case StackBehaviour.Popref_popi_popi:  			case StackBehaviour.Popref_popi_popi8:  			case StackBehaviour.Popref_popi_popr4:  			case StackBehaviour.Popref_popi_popr8:  			case StackBehaviour.Popref_popi_popref:  			case StackBehaviour.Popref_popi_pop1:  				pops += 3;  				break;    			case StackBehaviour.PopAll:  				pops = -1;  				break;    			case StackBehaviour.Varpop:	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  				if (hasReturnValue)  					pops++;  				break;    			default:  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldc_I4_M1:return -1;  			case Code.Ldc_I4_0:	return 0;  			case Code.Ldc_I4_1:	return 1;  			case Code.Ldc_I4_2:	return 2;  			case Code.Ldc_I4_3:	return 3;  			case Code.Ldc_I4_4:	return 4;  			case Code.Ldc_I4_5:	return 5;  			case Code.Ldc_I4_6:	return 6;  			case Code.Ldc_I4_7:	return 7;  			case Code.Ldc_I4_8:	return 8;  			case Code.Ldc_I4_S:	return (sbyte)Operand;  			case Code.Ldc_I4:	return (int)Operand;  			default:  				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}"' this));  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (parameter != null)  					return parameter.Index;  				break;  			}
Magic Number,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (parameter != null)  					return parameter.Index;  				break;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  			case 2:  			case 6:  				// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  				flags = 2;  				maxStack = 8;  				codeSize = (uint)(b >> 2);  				localVarSigTok = 0;  				break;    			case 3:  				// Fat header. Can have locals and exception handlers  				flags = (ushort)((reader.ReadByte() << 8) | b);  				uint headerSize = (uint)flags >> 12;  				maxStack = reader.ReadUInt16();  				codeSize = reader.ReadUInt32();  				localVarSigTok = reader.ReadUInt32();    				// The CLR allows the code to start inside the method header. But if it does'  				// the CLR doesn't read any exceptions.  				reader.Position += -12 + headerSize * 4;  				if (headerSize < 3)  					flags &= 0xFFF7;  				break;    			default:  				return false;  			}
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: (flags & 8) == 0
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadFatExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((ehReader.ReadUInt32() >> 8) / 24);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadFatExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((ehReader.ReadUInt32() >> 8) / 24);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadSmallExceptionHandlers,The following statement contains a magic number: int num = GetNumberOfExceptionHandlers((uint)ehReader.ReadByte() / 12);
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadSmallExceptionHandlers,The following statement contains a magic number: ehReader.Position += 2;
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReader.cs,CreateCilBody,The following statement contains a magic number: bool initLocals = flags == 2 || (flags & 0x10) != 0;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,GetInstruction,The following statement contains a magic number: int i = (lo + hi) / 2;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadInlineSwitch,The following statement contains a magic number: long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadInlineSwitch,The following statement contains a magic number: long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The following statement contains a magic number: int maxStack = 8;
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetTypeNET45,The following statement contains a magic number: setMethodBodyMethodInfo.Invoke(mb' new object[5] { code' maxStack' locals' null' null });
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: return new byte[] {  					0x07'  					0x01'  					(byte)ElementType.Internal'  					(byte)mtValue'  					(byte)(mtValue >> 8)'  					(byte)(mtValue >> 16)'  					(byte)(mtValue >> 24)'  				};
Magic Number,dnlib.DotNet.Emit,MethodTableToTypeConverter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodTableToTypeConverter.cs,GetLocalSignature,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: instructions.IterateAll((list' index' instr) => {  				Parameter arg;  				Local local;  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (arg.Index == 0) {  						instr.OpCode = OpCodes.Ldarg_0;  						instr.Operand = null;  					}  					else if (arg.Index == 1) {  						instr.OpCode = OpCodes.Ldarg_1;  						instr.Operand = null;  					}  					else if (arg.Index == 2) {  						instr.OpCode = OpCodes.Ldarg_2;  						instr.Operand = null;  					}  					else if (arg.Index == 3) {  						instr.OpCode = OpCodes.Ldarg_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarg_S;  					break;    				case Code.Ldarga:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldarga_S;  					break;    				case Code.Ldc_I4:  					if (!(instr.Operand is int))  						break;  					int i4 = (int)instr.Operand;  					switch (i4) {  					case 0:  						instr.OpCode = OpCodes.Ldc_I4_0;  						instr.Operand = null;  						break;    					case 1:  						instr.OpCode = OpCodes.Ldc_I4_1;  						instr.Operand = null;  						break;    					case 2:  						instr.OpCode = OpCodes.Ldc_I4_2;  						instr.Operand = null;  						break;    					case 3:  						instr.OpCode = OpCodes.Ldc_I4_3;  						instr.Operand = null;  						break;    					case 4:  						instr.OpCode = OpCodes.Ldc_I4_4;  						instr.Operand = null;  						break;    					case 5:  						instr.OpCode = OpCodes.Ldc_I4_5;  						instr.Operand = null;  						break;    					case 6:  						instr.OpCode = OpCodes.Ldc_I4_6;  						instr.Operand = null;  						break;    					case 7:  						instr.OpCode = OpCodes.Ldc_I4_7;  						instr.Operand = null;  						break;    					case 8:  						instr.OpCode = OpCodes.Ldc_I4_8;  						instr.Operand = null;  						break;    					case -1:  						instr.OpCode = OpCodes.Ldc_I4_M1;  						instr.Operand = null;  						break;    					default:  						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  							instr.OpCode = OpCodes.Ldc_I4_S;  							instr.Operand = (sbyte)i4;  						}  						break;  					}  					break;    				case Code.Ldloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Ldloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Ldloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Ldloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Ldloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloc_S;  					break;    				case Code.Ldloca:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Ldloca_S;  					break;    				case Code.Starg:  					arg = instr.Operand as Parameter;  					if (arg == null)  						break;  					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Starg_S;  					break;    				case Code.Stloc:  					local = instr.Operand as Local;  					if (local == null)  						break;  					if (local.Index == 0) {  						instr.OpCode = OpCodes.Stloc_0;  						instr.Operand = null;  					}  					else if (local.Index == 1) {  						instr.OpCode = OpCodes.Stloc_1;  						instr.Operand = null;  					}  					else if (local.Index == 2) {  						instr.OpCode = OpCodes.Stloc_2;  						instr.Operand = null;  					}  					else if (local.Index == 3) {  						instr.OpCode = OpCodes.Stloc_3;  						instr.Operand = null;  					}  					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  						instr.OpCode = OpCodes.Stloc_S;  					break;  				}  			});
Magic Number,dnlib.DotNet.Emit,OpCode,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The following statement contains a magic number: ((ushort)code >> 8) == 0
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  			case 1: return reader.ReadByte();  			case 2: return reader.ReadUInt16();  			case 4: return reader.ReadUInt32();  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  			case 1: return reader.ReadByte();  			case 2: return reader.ReadUInt16();  			case 4: return reader.ReadUInt32();  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  			case 1: writer.Write((byte)value); break;  			case 2: writer.Write((ushort)value); break;  			case 4: writer.Write(value); break;  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,ColumnInfo,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  			case 1: writer.Write((byte)value); break;  			case 2: writer.Write((ushort)value); break;  			case 4: writer.Write(value); break;  			default: throw new InvalidOperationException("Invalid column size");  			}
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetPointerSize,The following statement contains a magic number: return 8;
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetPointerSize,The following statement contains a magic number: return 4;
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,InitializeHotStreams,The following statement contains a magic number: bool is64Bit = GetPointerSize() == 8;
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetFieldRidList,The following statement contains a magic number: return GetRidList(tablesStream.TypeDefTable' typeDefRid' 4' tablesStream.FieldTable);
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetMethodRidList,The following statement contains a magic number: return GetRidList(tablesStream.TypeDefTable' typeDefRid' 5' tablesStream.MethodTable);
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetParamRidList,The following statement contains a magic number: return GetRidList(tablesStream.MethodTable' methodRid' 5' tablesStream.ParamTable);
Magic Number,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,BinarySearch,The following statement contains a magic number: uint rid = (ridLo + ridHi) / 2;
Magic Number,dnlib.DotNet.MD,DotNetFile,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The following statement contains a magic number: var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
Magic Number,dnlib.DotNet.MD,DotNetFile,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The following statement contains a magic number: cor20Header.MetaData.Size < 16
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return rowCounts[table] > 0xFFFF ? 4 : 2;
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return rowCounts[table] > 0xFFFF ? 4 : 2;
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Module] = new TableInfo(Table.Module' "Module"' new ColumnInfo[] {  				new ColumnInfo(0' "Generation"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Mvid"' ColumnSize.GUID)'  				new ColumnInfo(3' "EncId"' ColumnSize.GUID)'  				new ColumnInfo(4' "EncBaseId"' ColumnSize.GUID)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeRef] = new TableInfo(Table.TypeRef' "TypeRef"' new ColumnInfo[] {  				new ColumnInfo(0' "ResolutionScope"' ColumnSize.ResolutionScope)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef' "TypeDef"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Namespace"' ColumnSize.Strings)'  				new ColumnInfo(3' "Extends"' ColumnSize.TypeDefOrRef)'  				new ColumnInfo(4' "FieldList"' ColumnSize.Field)'  				new ColumnInfo(5' "MethodList"' ColumnSize.Method)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Field] = new TableInfo(Table.Field' "Field"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Signature"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Method] = new TableInfo(Table.Method' "Method"' new ColumnInfo[] {  				new ColumnInfo(0' "RVA"' ColumnSize.UInt32)'  				new ColumnInfo(1' "ImplFlags"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(3' "Name"' ColumnSize.Strings)'  				new ColumnInfo(4' "Signature"' ColumnSize.Blob)'  				new ColumnInfo(5' "ParamList"' ColumnSize.Param)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Param] = new TableInfo(Table.Param' "Param"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Sequence"' ColumnSize.UInt16)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MemberRef] = new TableInfo(Table.MemberRef' "MemberRef"' new ColumnInfo[] {  				new ColumnInfo(0' "Class"' ColumnSize.MemberRefParent)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Signature"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Constant] = new TableInfo(Table.Constant' "Constant"' new ColumnInfo[] {  				new ColumnInfo(0' "Type"' ColumnSize.Byte)'  				new ColumnInfo(1' "Parent"' ColumnSize.HasConstant)'  				new ColumnInfo(2' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.CustomAttribute] = new TableInfo(Table.CustomAttribute' "CustomAttribute"' new ColumnInfo[] {  				new ColumnInfo(0' "Parent"' ColumnSize.HasCustomAttribute)'  				new ColumnInfo(1' "Type"' ColumnSize.CustomAttributeType)'  				new ColumnInfo(2' "Value"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.DeclSecurity] = new TableInfo(Table.DeclSecurity' "DeclSecurity"' new ColumnInfo[] {  				new ColumnInfo(0' "Action"' ColumnSize.Int16)'  				new ColumnInfo(1' "Parent"' ColumnSize.HasDeclSecurity)'  				new ColumnInfo(2' "PermissionSet"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ClassLayout] = new TableInfo(Table.ClassLayout' "ClassLayout"' new ColumnInfo[] {  				new ColumnInfo(0' "PackingSize"' ColumnSize.UInt16)'  				new ColumnInfo(1' "ClassSize"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Parent"' ColumnSize.TypeDef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Event] = new TableInfo(Table.Event' "Event"' new ColumnInfo[] {  				new ColumnInfo(0' "EventFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "EventType"' ColumnSize.TypeDefOrRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Property] = new TableInfo(Table.Property' "Property"' new ColumnInfo[] {  				new ColumnInfo(0' "PropFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "Type"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MethodSemantics] = new TableInfo(Table.MethodSemantics' "MethodSemantics"' new ColumnInfo[] {  				new ColumnInfo(0' "Semantic"' ColumnSize.UInt16)'  				new ColumnInfo(1' "Method"' ColumnSize.Method)'  				new ColumnInfo(2' "Association"' ColumnSize.HasSemantic)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.MethodImpl] = new TableInfo(Table.MethodImpl' "MethodImpl"' new ColumnInfo[] {  				new ColumnInfo(0' "Class"' ColumnSize.TypeDef)'  				new ColumnInfo(1' "MethodBody"' ColumnSize.MethodDefOrRef)'  				new ColumnInfo(2' "MethodDeclaration"' ColumnSize.MethodDefOrRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap' "ImplMap"' new ColumnInfo[] {  				new ColumnInfo(0' "MappingFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MemberForwarded"' ColumnSize.MemberForwarded)'  				new ColumnInfo(2' "ImportName"' ColumnSize.Strings)'  				new ColumnInfo(3' "ImportScope"' ColumnSize.ModuleRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap' "ImplMap"' new ColumnInfo[] {  				new ColumnInfo(0' "MappingFlags"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MemberForwarded"' ColumnSize.MemberForwarded)'  				new ColumnInfo(2' "ImportName"' ColumnSize.Strings)'  				new ColumnInfo(3' "ImportScope"' ColumnSize.ModuleRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly' "Assembly"' new ColumnInfo[] {  				new ColumnInfo(0' "HashAlgId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(3' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(5' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(6' "PublicKey"' ColumnSize.Blob)'  				new ColumnInfo(7' "Name"' ColumnSize.Strings)'  				new ColumnInfo(8' "Locale"' ColumnSize.Strings)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyOS] = new TableInfo(Table.AssemblyOS' "AssemblyOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  				new ColumnInfo(0' "MajorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(1' "MinorVersion"' ColumnSize.UInt16)'  				new ColumnInfo(2' "BuildNumber"' ColumnSize.UInt16)'  				new ColumnInfo(3' "RevisionNumber"' ColumnSize.UInt16)'  				new ColumnInfo(4' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(5' "PublicKeyOrToken"' ColumnSize.Blob)'  				new ColumnInfo(6' "Name"' ColumnSize.Strings)'  				new ColumnInfo(7' "Locale"' ColumnSize.Strings)'  				new ColumnInfo(8' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(3' "AssemblyRef"' ColumnSize.AssemblyRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  				new ColumnInfo(0' "OSPlatformId"' ColumnSize.UInt32)'  				new ColumnInfo(1' "OSMajorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(2' "OSMinorVersion"' ColumnSize.UInt32)'  				new ColumnInfo(3' "AssemblyRef"' ColumnSize.AssemblyRef)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.File] = new TableInfo(Table.File' "File"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Name"' ColumnSize.Strings)'  				new ColumnInfo(2' "HashValue"' ColumnSize.Blob)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType' "ExportedType"' new ColumnInfo[] {  				new ColumnInfo(0' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(1' "TypeDefId"' ColumnSize.UInt32)'  				new ColumnInfo(2' "TypeName"' ColumnSize.Strings)'  				new ColumnInfo(3' "TypeNamespace"' ColumnSize.Strings)'  				new ColumnInfo(4' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  				new ColumnInfo(0' "Offset"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  				new ColumnInfo(3' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  				new ColumnInfo(0' "Offset"' ColumnSize.UInt32)'  				new ColumnInfo(1' "Flags"' ColumnSize.UInt32)'  				new ColumnInfo(2' "Name"' ColumnSize.Strings)'  				new ColumnInfo(3' "Implementation"' ColumnSize.Implementation)'  			});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam' "GenericParam"' new ColumnInfo[] {  					new ColumnInfo(0' "Number"' ColumnSize.UInt16)'  					new ColumnInfo(1' "Flags"' ColumnSize.UInt16)'  					new ColumnInfo(2' "Owner"' ColumnSize.TypeOrMethodDef)'  					new ColumnInfo(3' "Name"' ColumnSize.Strings)'  					new ColumnInfo(4' "Kind"' ColumnSize.TypeDefOrRef)'  				});
Magic Number,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetFieldRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.TypeDefTable' typeDefRid' 4' tablesStream.FieldTable);
Magic Number,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetMethodRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.TypeDefTable' typeDefRid' 5' tablesStream.MethodTable);
Magic Number,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,GetParamRidList,The following statement contains a magic number: var list = GetRidList(tablesStream.MethodTable' methodRid' 5' tablesStream.ParamTable);
Magic Number,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,BinarySearch,The following statement contains a magic number: uint rid = (ridLo + ridHi) / 2;
Magic Number,dnlib.DotNet.MD,SortedTable,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,BinarySearch,The following statement contains a magic number: int curr = (lo + hi) / 2;
Magic Number,dnlib.DotNet.MD,GuidStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\GuidStream.cs,IsValidIndex,The following statement contains a magic number: return index == 0 || (index <= 0x10000000 && IsValidOffset((index - 1) * 16' 16));
Magic Number,dnlib.DotNet.MD,GuidStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\GuidStream.cs,IsValidIndex,The following statement contains a magic number: return index == 0 || (index <= 0x10000000 && IsValidOffset((index - 1) * 16' 16));
Magic Number,dnlib.DotNet.MD,GuidStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\GuidStream.cs,Read,The following statement contains a magic number: var reader = GetReader_NoLock((index - 1) * 16);
Magic Number,dnlib.DotNet.MD,GuidStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\GuidStream.cs,Read,The following statement contains a magic number: return new Guid(reader.ReadBytes(16));
Magic Number,dnlib.DotNet.MD,HotHeapStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,BinarySearch,The following statement contains a magic number: uint index = (lo + hi) / 2;
Magic Number,dnlib.DotNet.MD,HotHeapStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,BinarySearch,The following statement contains a magic number: uint val = reader.ReadUInt32At(posRids + index * 4);
Magic Number,dnlib.DotNet.MD,HotHeapStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,Initialize,The following statement contains a magic number: posIndexes = (baseOffset - (reader.ReadInt32() & ~3)) & mask;
Magic Number,dnlib.DotNet.MD,HotHeapStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,Initialize,The following statement contains a magic number: numRids = ridsOffset / 4;
Magic Number,dnlib.DotNet.MD,HotHeapStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,Initialize,The following statement contains a magic number: posRids = (baseOffset - numRids * 4) & mask;
Magic Number,dnlib.DotNet.MD,HotHeapStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,Initialize,The following statement contains a magic number: numRids = ridsOffset / 4;
Magic Number,dnlib.DotNet.MD,HotHeapStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotHeapStream.cs,GetBlobOffset,The following statement contains a magic number: dataOffset = posData + reader.ReadUInt32At((posIndexes + index * 4) & offsetMask);
Magic Number,dnlib.DotNet.MD,HotStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,CreateHotHeapStreams2,The following statement contains a magic number: offs + 8 <= endOffset - 8
Magic Number,dnlib.DotNet.MD,HotStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,CreateHotHeapStreams2,The following statement contains a magic number: offs + 8 <= endOffset - 8
Magic Number,dnlib.DotNet.MD,HotStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotTableBaseOffset,The following statement contains a magic number: return endOffset - 8 - HotTableStream.HOT_HEAP_DIR_SIZE - fullStream.ReadUInt32At(endOffset - 8);
Magic Number,dnlib.DotNet.MD,HotStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotTableBaseOffset,The following statement contains a magic number: return endOffset - 8 - HotTableStream.HOT_HEAP_DIR_SIZE - fullStream.ReadUInt32At(endOffset - 8);
Magic Number,dnlib.DotNet.MD,HotStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - (fullStream.ReadUInt32At(endOffset - 8 + 4) & ~3);
Magic Number,dnlib.DotNet.MD,HotStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - (fullStream.ReadUInt32At(endOffset - 8 + 4) & ~3);
Magic Number,dnlib.DotNet.MD,HotStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - (fullStream.ReadUInt32At(endOffset - 8 + 4) & ~3);
Magic Number,dnlib.DotNet.MD,HotStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - (fullStream.ReadUInt32At(endOffset - 8 + 4) & ~3);
Magic Number,dnlib.DotNet.MD,HotStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,ReadHotHeapDirectory,The following statement contains a magic number: hotHeapOffs = dirBaseOffs - (reader.ReadUInt32() & ~3);
Magic Number,dnlib.DotNet.MD,HotStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - fullStream.ReadUInt32At(endOffset - 8 + 4);
Magic Number,dnlib.DotNet.MD,HotStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - fullStream.ReadUInt32At(endOffset - 8 + 4);
Magic Number,dnlib.DotNet.MD,HotStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotStream.cs,GetHotHeapDirectoryBaseOffset,The following statement contains a magic number: return endOffset - 8 - fullStream.ReadUInt32At(endOffset - 8 + 4);
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The following statement contains a magic number: fullStream.Position = baseOffset + 4 + i * 4;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The following statement contains a magic number: fullStream.Position = baseOffset + 4 + i * 4;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,GetRowOffset,The following statement contains a magic number: fullStream.Position = header.posTable1 + (rid & header.mask) * 2;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The following statement contains a magic number: fullStream.Position = baseOffset + 4 + i * 4;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,Initialize,The following statement contains a magic number: fullStream.Position = baseOffset + 4 + i * 4;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,GetRowOffset,The following statement contains a magic number: fullStream.Position = header.posTable1 + (rid & header.mask) * 2;
Magic Number,dnlib.DotNet.MD,HotTableStreamCLR40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\HotTableStream.cs,GetRowOffset,The following statement contains a magic number: index = fullStream.ReadUInt16At(header.posIndexes + index * 2);
Magic Number,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,GetGenericParamRidList,The following statement contains a magic number: return FindAllRows(tablesStream.GenericParamTable' 2' codedToken);
Magic Number,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,GetMethodSemanticsRidList,The following statement contains a magic number: return FindAllRowsUnsorted(tablesStream.MethodSemanticsTable' 2' codedToken);
Magic Number,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,GetClassLayoutRid,The following statement contains a magic number: var list = FindAllRowsUnsorted(tablesStream.ClassLayoutTable' 2' typeDefRid);
Magic Number,dnlib.DotNet.MD,MetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaData.cs,InitializeInverseGenericParamOwnerRidList,The following statement contains a magic number: var ownerCol = gpTable.TableInfo.Columns[2];
Magic Number,dnlib.DotNet.MD,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\MetaDataHeader.cs,MetaDataHeader,The following statement contains a magic number: verify && !((majorVersion == 1 && minorVersion == 1) || (majorVersion == 0 && minorVersion >= 19))
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,rol,The following statement contains a magic number: return (int)((val << shift) | (val >> (32 - shift)));
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation +  				rol(obj.Name' 3) +  				rol(obj.Mvid' 7) +  				rol(obj.EncId' 11) +  				rol(obj.EncBaseId' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation +  				rol(obj.Name' 3) +  				rol(obj.Mvid' 7) +  				rol(obj.EncId' 11) +  				rol(obj.EncBaseId' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation +  				rol(obj.Name' 3) +  				rol(obj.Mvid' 7) +  				rol(obj.EncId' 11) +  				rol(obj.EncBaseId' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation +  				rol(obj.Name' 3) +  				rol(obj.Mvid' 7) +  				rol(obj.EncId' 11) +  				rol(obj.EncBaseId' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.ResolutionScope +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.ResolutionScope +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7) +  				rol(obj.Extends' 11) +  				rol(obj.FieldList' 15) +  				rol(obj.MethodList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7) +  				rol(obj.Extends' 11) +  				rol(obj.FieldList' 15) +  				rol(obj.MethodList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7) +  				rol(obj.Extends' 11) +  				rol(obj.FieldList' 15) +  				rol(obj.MethodList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7) +  				rol(obj.Extends' 11) +  				rol(obj.FieldList' 15) +  				rol(obj.MethodList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Namespace' 7) +  				rol(obj.Extends' 11) +  				rol(obj.FieldList' 15) +  				rol(obj.MethodList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Signature' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.Signature' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.ImplFlags' 3) +  				rol(obj.Flags' 7) +  				rol(obj.Name' 11) +  				rol(obj.Signature' 15) +  				rol(obj.ParamList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.ImplFlags' 3) +  				rol(obj.Flags' 7) +  				rol(obj.Name' 11) +  				rol(obj.Signature' 15) +  				rol(obj.ParamList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.ImplFlags' 3) +  				rol(obj.Flags' 7) +  				rol(obj.Name' 11) +  				rol(obj.Signature' 15) +  				rol(obj.ParamList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.ImplFlags' 3) +  				rol(obj.Flags' 7) +  				rol(obj.Name' 11) +  				rol(obj.Signature' 15) +  				rol(obj.ParamList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.ImplFlags' 3) +  				rol(obj.Flags' 7) +  				rol(obj.Name' 11) +  				rol(obj.Signature' 15) +  				rol(obj.ParamList' 19);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Sequence' 3) +  				rol(obj.Name' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Sequence' 3) +  				rol(obj.Name' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class +  				rol(obj.Interface' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class +  				rol(obj.Name' 3) +  				rol(obj.Signature' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class +  				rol(obj.Name' 3) +  				rol(obj.Signature' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type +  				rol(obj.Padding' 3) +  				rol(obj.Parent' 7) +  				rol(obj.Value' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type +  				rol(obj.Padding' 3) +  				rol(obj.Parent' 7) +  				rol(obj.Value' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type +  				rol(obj.Padding' 3) +  				rol(obj.Parent' 7) +  				rol(obj.Value' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent +  				rol(obj.Type' 3) +  				rol(obj.Value' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent +  				rol(obj.Type' 3) +  				rol(obj.Value' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent +  				rol(obj.NativeType' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Action +  				rol(obj.Parent' 3) +  				rol(obj.PermissionSet' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Action +  				rol(obj.Parent' 3) +  				rol(obj.PermissionSet' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PackingSize +  				rol(obj.ClassSize' 3) +  				rol(obj.Parent' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PackingSize +  				rol(obj.ClassSize' 3) +  				rol(obj.Parent' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OffSet +  				rol(obj.Field' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent +  				rol(obj.EventList' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.EventFlags +  				rol(obj.Name' 3) +  				rol(obj.EventType' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.EventFlags +  				rol(obj.Name' 3) +  				rol(obj.EventType' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent +  				rol(obj.PropertyList' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PropFlags +  				rol(obj.Name' 3) +  				rol(obj.Type' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PropFlags +  				rol(obj.Name' 3) +  				rol(obj.Type' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Semantic +  				rol(obj.Method' 3) +  				rol(obj.Association' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Semantic +  				rol(obj.Method' 3) +  				rol(obj.Association' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class +  				rol(obj.MethodBody' 3) +  				rol(obj.MethodDeclaration' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class +  				rol(obj.MethodBody' 3) +  				rol(obj.MethodDeclaration' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags +  				rol(obj.MemberForwarded' 3) +  				rol(obj.ImportName' 7) +  				rol(obj.ImportScope' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags +  				rol(obj.MemberForwarded' 3) +  				rol(obj.ImportName' 7) +  				rol(obj.ImportScope' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags +  				rol(obj.MemberForwarded' 3) +  				rol(obj.ImportName' 7) +  				rol(obj.ImportScope' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA +  				rol(obj.Field' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Token +  				rol(obj.FuncCode' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId +  				rol(obj.MajorVersion' 3) +  				rol(obj.MinorVersion' 7) +  				rol(obj.BuildNumber' 11) +  				rol(obj.RevisionNumber' 15) +  				rol(obj.Flags' 19) +  				rol(obj.PublicKey' 23) +  				rol(obj.Name' 27) +  				rol(obj.Locale' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId +  				rol(obj.OSMajorVersion' 3) +  				rol(obj.OSMinorVersion' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId +  				rol(obj.OSMajorVersion' 3) +  				rol(obj.OSMinorVersion' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion +  				rol(obj.MinorVersion' 3) +  				rol(obj.BuildNumber' 7) +  				rol(obj.RevisionNumber' 11) +  				rol(obj.Flags' 15) +  				rol(obj.PublicKeyOrToken' 19) +  				rol(obj.Name' 23) +  				rol(obj.Locale' 27) +  				rol(obj.HashValue' 31);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Processor +  				rol(obj.AssemblyRef' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId +  				rol(obj.OSMajorVersion' 3) +  				rol(obj.OSMinorVersion' 7) +  				rol(obj.AssemblyRef' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId +  				rol(obj.OSMajorVersion' 3) +  				rol(obj.OSMinorVersion' 7) +  				rol(obj.AssemblyRef' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId +  				rol(obj.OSMajorVersion' 3) +  				rol(obj.OSMinorVersion' 7) +  				rol(obj.AssemblyRef' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.HashValue' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.Name' 3) +  				rol(obj.HashValue' 7);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.TypeDefId' 3) +  				rol(obj.TypeName' 7) +  				rol(obj.TypeNamespace' 11) +  				rol(obj.Implementation' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.TypeDefId' 3) +  				rol(obj.TypeName' 7) +  				rol(obj.TypeNamespace' 11) +  				rol(obj.Implementation' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.TypeDefId' 3) +  				rol(obj.TypeName' 7) +  				rol(obj.TypeNamespace' 11) +  				rol(obj.Implementation' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags +  				rol(obj.TypeDefId' 3) +  				rol(obj.TypeName' 7) +  				rol(obj.TypeNamespace' 11) +  				rol(obj.Implementation' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset +  				rol(obj.Flags' 3) +  				rol(obj.Name' 7) +  				rol(obj.Implementation' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset +  				rol(obj.Flags' 3) +  				rol(obj.Name' 7) +  				rol(obj.Implementation' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset +  				rol(obj.Flags' 3) +  				rol(obj.Name' 7) +  				rol(obj.Implementation' 11);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.NestedClass +  				rol(obj.EnclosingClass' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number +  				rol(obj.Flags' 3) +  				rol(obj.Owner' 7) +  				rol(obj.Name' 11) +  				rol(obj.Kind' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number +  				rol(obj.Flags' 3) +  				rol(obj.Owner' 7) +  				rol(obj.Name' 11) +  				rol(obj.Kind' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number +  				rol(obj.Flags' 3) +  				rol(obj.Owner' 7) +  				rol(obj.Name' 11) +  				rol(obj.Kind' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number +  				rol(obj.Flags' 3) +  				rol(obj.Owner' 7) +  				rol(obj.Name' 11) +  				rol(obj.Kind' 15);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Method +  				rol(obj.Instantiation' 3);
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Owner +  				rol(obj.Constraint' 3);
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Generation;  			case 1: return Name;  			case 2: return Mvid;  			case 3: return EncId;  			case 4: return EncBaseId;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Generation;  			case 1: return Name;  			case 2: return Mvid;  			case 3: return EncId;  			case 4: return EncBaseId;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Generation;  			case 1: return Name;  			case 2: return Mvid;  			case 3: return EncId;  			case 4: return EncBaseId;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Generation = (ushort)value; break;  			case 1: Name = value; break;  			case 2: Mvid = value; break;  			case 3: EncId = value; break;  			case 4: EncBaseId = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Generation = (ushort)value; break;  			case 1: Name = value; break;  			case 2: Mvid = value; break;  			case 3: EncId = value; break;  			case 4: EncBaseId = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawModuleRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Generation = (ushort)value; break;  			case 1: Name = value; break;  			case 2: Mvid = value; break;  			case 3: EncId = value; break;  			case 4: EncBaseId = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawTypeRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return ResolutionScope;  			case 1: return Name;  			case 2: return Namespace;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawTypeRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: ResolutionScope = value; break;  			case 1: Name = value; break;  			case 2: Namespace = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return Namespace;  			case 3: return Extends;  			case 4: return FieldList;  			case 5: return MethodList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return Namespace;  			case 3: return Extends;  			case 4: return FieldList;  			case 5: return MethodList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return Namespace;  			case 3: return Extends;  			case 4: return FieldList;  			case 5: return MethodList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return Namespace;  			case 3: return Extends;  			case 4: return FieldList;  			case 5: return MethodList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: Name = value; break;  			case 2: Namespace = value; break;  			case 3: Extends = value; break;  			case 4: FieldList = value; break;  			case 5: MethodList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: Name = value; break;  			case 2: Namespace = value; break;  			case 3: Extends = value; break;  			case 4: FieldList = value; break;  			case 5: MethodList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: Name = value; break;  			case 2: Namespace = value; break;  			case 3: Extends = value; break;  			case 4: FieldList = value; break;  			case 5: MethodList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: Name = value; break;  			case 2: Namespace = value; break;  			case 3: Extends = value; break;  			case 4: FieldList = value; break;  			case 5: MethodList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawFieldRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return Signature;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawFieldRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = (ushort)value; break;  			case 1: Name = value; break;  			case 2: Signature = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return RVA;  			case 1: return ImplFlags;  			case 2: return Flags;  			case 3: return Name;  			case 4: return Signature;  			case 5: return ParamList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return RVA;  			case 1: return ImplFlags;  			case 2: return Flags;  			case 3: return Name;  			case 4: return Signature;  			case 5: return ParamList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return RVA;  			case 1: return ImplFlags;  			case 2: return Flags;  			case 3: return Name;  			case 4: return Signature;  			case 5: return ParamList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return RVA;  			case 1: return ImplFlags;  			case 2: return Flags;  			case 3: return Name;  			case 4: return Signature;  			case 5: return ParamList;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: RVA = value; break;  			case 1: ImplFlags = (ushort)value; break;  			case 2: Flags = (ushort)value; break;  			case 3: Name = value; break;  			case 4: Signature = value; break;  			case 5: ParamList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: RVA = value; break;  			case 1: ImplFlags = (ushort)value; break;  			case 2: Flags = (ushort)value; break;  			case 3: Name = value; break;  			case 4: Signature = value; break;  			case 5: ParamList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: RVA = value; break;  			case 1: ImplFlags = (ushort)value; break;  			case 2: Flags = (ushort)value; break;  			case 3: Name = value; break;  			case 4: Signature = value; break;  			case 5: ParamList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: RVA = value; break;  			case 1: ImplFlags = (ushort)value; break;  			case 2: Flags = (ushort)value; break;  			case 3: Name = value; break;  			case 4: Signature = value; break;  			case 5: ParamList = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Sequence;  			case 2: return Name;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = (ushort)value; break;  			case 1: Sequence = (ushort)value; break;  			case 2: Name = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMemberRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Class;  			case 1: return Name;  			case 2: return Signature;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMemberRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Class = value; break;  			case 1: Name = value; break;  			case 2: Signature = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawConstantRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Type;  			case 1: return Parent;  			case 2: return Value;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawConstantRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Type = (byte)value; break;  			case 1: Parent = value; break;  			case 2: Value = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawCustomAttributeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Parent;  			case 1: return Type;  			case 2: return Value;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawCustomAttributeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Parent = value; break;  			case 1: Type = value; break;  			case 2: Value = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawDeclSecurityRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return (uint)(int)Action;  			case 1: return Parent;  			case 2: return PermissionSet;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawDeclSecurityRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Action = (short)value; break;  			case 1: Parent = value; break;  			case 2: PermissionSet = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawClassLayoutRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return PackingSize;  			case 1: return ClassSize;  			case 2: return Parent;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawClassLayoutRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: PackingSize = (ushort)value; break;  			case 1: ClassSize = value; break;  			case 2: Parent = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawEventRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return EventFlags;  			case 1: return Name;  			case 2: return EventType;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawEventRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: EventFlags = (ushort)value; break;  			case 1: Name = value; break;  			case 2: EventType = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawPropertyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return PropFlags;  			case 1: return Name;  			case 2: return Type;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawPropertyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: PropFlags = (ushort)value; break;  			case 1: Name = value; break;  			case 2: Type = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodSemanticsRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Semantic;  			case 1: return Method;  			case 2: return Association;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodSemanticsRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Semantic = (ushort)value; break;  			case 1: Method = value; break;  			case 2: Association = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawMethodImplRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Class;  			case 1: return MethodBody;  			case 2: return MethodDeclaration;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawMethodImplRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Class = value; break;  			case 1: MethodBody = value; break;  			case 2: MethodDeclaration = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawImplMapRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MappingFlags;  			case 1: return MemberForwarded;  			case 2: return ImportName;  			case 3: return ImportScope;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawImplMapRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MappingFlags;  			case 1: return MemberForwarded;  			case 2: return ImportName;  			case 3: return ImportScope;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawImplMapRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MappingFlags = (ushort)value; break;  			case 1: MemberForwarded = value; break;  			case 2: ImportName = value; break;  			case 3: ImportScope = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawImplMapRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MappingFlags = (ushort)value; break;  			case 1: MemberForwarded = value; break;  			case 2: ImportName = value; break;  			case 3: ImportScope = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return HashAlgId;  			case 1: return MajorVersion;  			case 2: return MinorVersion;  			case 3: return BuildNumber;  			case 4: return RevisionNumber;  			case 5: return Flags;  			case 6: return PublicKey;  			case 7: return Name;  			case 8: return Locale;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: HashAlgId = value; break;  			case 1: MajorVersion = (ushort)value; break;  			case 2: MinorVersion = (ushort)value; break;  			case 3: BuildNumber = (ushort)value; break;  			case 4: RevisionNumber = (ushort)value; break;  			case 5: Flags = value; break;  			case 6: PublicKey = value; break;  			case 7: Name = value; break;  			case 8: Locale = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return OSPlatformId;  			case 1: return OSMajorVersion;  			case 2: return OSMinorVersion;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: OSPlatformId = value; break;  			case 1: OSMajorVersion = value; break;  			case 2: OSMinorVersion = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return MajorVersion;  			case 1: return MinorVersion;  			case 2: return BuildNumber;  			case 3: return RevisionNumber;  			case 4: return Flags;  			case 5: return PublicKeyOrToken;  			case 6: return Name;  			case 7: return Locale;  			case 8: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: MajorVersion = (ushort)value; break;  			case 1: MinorVersion = (ushort)value; break;  			case 2: BuildNumber = (ushort)value; break;  			case 3: RevisionNumber = (ushort)value; break;  			case 4: Flags = value; break;  			case 5: PublicKeyOrToken = value; break;  			case 6: Name = value; break;  			case 7: Locale = value; break;  			case 8: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return OSPlatformId;  			case 1: return OSMajorVersion;  			case 2: return OSMinorVersion;  			case 3: return AssemblyRef;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return OSPlatformId;  			case 1: return OSMajorVersion;  			case 2: return OSMinorVersion;  			case 3: return AssemblyRef;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: OSPlatformId = value; break;  			case 1: OSMajorVersion = value; break;  			case 2: OSMinorVersion = value; break;  			case 3: AssemblyRef = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: OSPlatformId = value; break;  			case 1: OSMajorVersion = value; break;  			case 2: OSMinorVersion = value; break;  			case 3: AssemblyRef = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawFileRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return Name;  			case 2: return HashValue;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawFileRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: Name = value; break;  			case 2: HashValue = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return TypeDefId;  			case 2: return TypeName;  			case 3: return TypeNamespace;  			case 4: return Implementation;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return TypeDefId;  			case 2: return TypeName;  			case 3: return TypeNamespace;  			case 4: return Implementation;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Flags;  			case 1: return TypeDefId;  			case 2: return TypeName;  			case 3: return TypeNamespace;  			case 4: return Implementation;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: TypeDefId = value; break;  			case 2: TypeName = value; break;  			case 3: TypeNamespace = value; break;  			case 4: Implementation = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: TypeDefId = value; break;  			case 2: TypeName = value; break;  			case 3: TypeNamespace = value; break;  			case 4: Implementation = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Flags = value; break;  			case 1: TypeDefId = value; break;  			case 2: TypeName = value; break;  			case 3: TypeNamespace = value; break;  			case 4: Implementation = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Offset;  			case 1: return Flags;  			case 2: return Name;  			case 3: return Implementation;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Offset;  			case 1: return Flags;  			case 2: return Name;  			case 3: return Implementation;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Offset = value; break;  			case 1: Flags = value; break;  			case 2: Name = value; break;  			case 3: Implementation = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Offset = value; break;  			case 1: Flags = value; break;  			case 2: Name = value; break;  			case 3: Implementation = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Number;  			case 1: return Flags;  			case 2: return Owner;  			case 3: return Name;  			case 4: return Kind;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Number;  			case 1: return Flags;  			case 2: return Owner;  			case 3: return Name;  			case 4: return Kind;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  			case 0: return Number;  			case 1: return Flags;  			case 2: return Owner;  			case 3: return Name;  			case 4: return Kind;  			default: return 0;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Number = (ushort)value; break;  			case 1: Flags = (ushort)value; break;  			case 2: Owner = value; break;  			case 3: Name = value; break;  			case 4: Kind = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Number = (ushort)value; break;  			case 1: Flags = (ushort)value; break;  			case 2: Owner = value; break;  			case 3: Name = value; break;  			case 4: Kind = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  			case 0: Number = (ushort)value; break;  			case 1: Flags = (ushort)value; break;  			case 2: Owner = value; break;  			case 3: Name = value; break;  			case 4: Kind = value; break;  			default: break;  			}
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\StreamHeader.cs,StreamHeader,The following statement contains a magic number: this.name = ReadString(reader' 32' verify);
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + ((i + 1 + 3) & ~3);
Magic Number,dnlib.DotNet.MD,StreamHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + ((i + 1 + 3) & ~3);
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: var sizes = new uint[64];
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: i < 64
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,IsSorted,The following statement contains a magic number: (uint)index >= 64
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadModuleRow,The following statement contains a magic number: return new RawModuleRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadModuleRow,The following statement contains a magic number: return new RawModuleRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadModuleRow,The following statement contains a magic number: return new RawModuleRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadTypeRefRow,The following statement contains a magic number: return new RawTypeRefRow(columns[0].Read(reader)'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadTypeDefRow,The following statement contains a magic number: return new RawTypeDefRow(reader.ReadUInt32()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadTypeDefRow,The following statement contains a magic number: return new RawTypeDefRow(reader.ReadUInt32()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadTypeDefRow,The following statement contains a magic number: return new RawTypeDefRow(reader.ReadUInt32()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadTypeDefRow,The following statement contains a magic number: return new RawTypeDefRow(reader.ReadUInt32()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadFieldRow,The following statement contains a magic number: return new RawFieldRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMethodRow,The following statement contains a magic number: return new RawMethodRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMethodRow,The following statement contains a magic number: return new RawMethodRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMethodRow,The following statement contains a magic number: return new RawMethodRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[3].Read(reader)'  				columns[4].Read(reader)'  				columns[5].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadParamRow,The following statement contains a magic number: return new RawParamRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMemberRefRow,The following statement contains a magic number: return new RawMemberRefRow(columns[0].Read(reader)'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadConstantRow,The following statement contains a magic number: return new RawConstantRow(reader.ReadByte()'  				reader.ReadByte()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadCustomAttributeRow,The following statement contains a magic number: return new RawCustomAttributeRow(columns[0].Read(reader)'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadDeclSecurityRow,The following statement contains a magic number: return new RawDeclSecurityRow(reader.ReadInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadClassLayoutRow,The following statement contains a magic number: return new RawClassLayoutRow(reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadEventRow,The following statement contains a magic number: return new RawEventRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadPropertyRow,The following statement contains a magic number: return new RawPropertyRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMethodSemanticsRow,The following statement contains a magic number: return new RawMethodSemanticsRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadMethodImplRow,The following statement contains a magic number: return new RawMethodImplRow(columns[0].Read(reader)'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadImplMapRow,The following statement contains a magic number: return new RawImplMapRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadImplMapRow,The following statement contains a magic number: return new RawImplMapRow(reader.ReadUInt16()'  				columns[1].Read(reader)'  				columns[2].Read(reader)'  				columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRow,The following statement contains a magic number: return new RawAssemblyRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRow,The following statement contains a magic number: return new RawAssemblyRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRow,The following statement contains a magic number: return new RawAssemblyRow(reader.ReadUInt32()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRefRow,The following statement contains a magic number: return new RawAssemblyRefRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[5].Read(reader)'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRefRow,The following statement contains a magic number: return new RawAssemblyRefRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[5].Read(reader)'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRefRow,The following statement contains a magic number: return new RawAssemblyRefRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[5].Read(reader)'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRefRow,The following statement contains a magic number: return new RawAssemblyRefRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt16()'  				reader.ReadUInt32()'  				columns[5].Read(reader)'  				columns[6].Read(reader)'  				columns[7].Read(reader)'  				columns[8].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadAssemblyRefOSRow,The following statement contains a magic number: return new RawAssemblyRefOSRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadFileRow,The following statement contains a magic number: return new RawFileRow(reader.ReadUInt32()'  				columns[1].Read(reader)'  				columns[2].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadExportedTypeRow,The following statement contains a magic number: return new RawExportedTypeRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadExportedTypeRow,The following statement contains a magic number: return new RawExportedTypeRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadExportedTypeRow,The following statement contains a magic number: return new RawExportedTypeRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadManifestResourceRow,The following statement contains a magic number: return new RawManifestResourceRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[2].Read(reader)'  				columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadManifestResourceRow,The following statement contains a magic number: return new RawManifestResourceRow(reader.ReadUInt32()'  				reader.ReadUInt32()'  				columns[2].Read(reader)'  				columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: return new RawGenericParamRow(reader.ReadUInt16()'  					reader.ReadUInt16()'  					columns[2].Read(reader)'  					columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: return new RawGenericParamRow(reader.ReadUInt16()'  					reader.ReadUInt16()'  					columns[2].Read(reader)'  					columns[3].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: columns.Count == 4
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: return new RawGenericParamRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: return new RawGenericParamRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,TablesStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\TablesStream.cs,ReadGenericParamRow,The following statement contains a magic number: return new RawGenericParamRow(reader.ReadUInt16()'  				reader.ReadUInt16()'  				columns[2].Read(reader)'  				columns[3].Read(reader)'  				columns[4].Read(reader));
Magic Number,dnlib.DotNet.MD,USStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\USStream.cs,Read,The following statement contains a magic number: return reader.ReadString((int)(length / 2));
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\GuidHeap.cs,GetRawLength,The following statement contains a magic number: return (uint)guids.Count * 16;
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\GuidHeap.cs,WriteToImpl,The following statement contains a magic number: offset += 16;
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\GuidHeap.cs,GetRawDataSize,The following statement contains a magic number: return 16;
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\GuidHeap.cs,SetRawData,The following statement contains a magic number: rawData == null || rawData.Length != 16
Magic Number,dnlib.DotNet.Writer,GuidHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\GuidHeap.cs,GetAllRawData,The following statement contains a magic number: offset += 16;
Magic Number,dnlib.DotNet.Writer,HotHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotHeap.cs,SetOffset,The following statement contains a magic number: offset += hotPools.Count * 8;
Magic Number,dnlib.DotNet.Writer,HotHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotHeap.cs,SetOffset,The following statement contains a magic number: rva += (uint)hotPools.Count * 8;
Magic Number,dnlib.DotNet.Writer,HotHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotHeap.cs,SetOffset,The following statement contains a magic number: offset += 8;
Magic Number,dnlib.DotNet.Writer,HotHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotHeap.cs,SetOffset,The following statement contains a magic number: rva += 8;
Magic Number,dnlib.DotNet.Writer,HotHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotHeap.cs,WriteToImpl,The following statement contains a magic number: offs += (uint)hotPools.Count * 8;
Magic Number,dnlib.DotNet.Writer,HotPool20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += ((uint)dataList.Length - 1) * 4;
Magic Number,dnlib.DotNet.Writer,HotPool20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += (uint)dataList.Length * 4;
Magic Number,dnlib.DotNet.Writer,HotPool20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += 3 * 4;
Magic Number,dnlib.DotNet.Writer,HotPool20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += 3 * 4;
Magic Number,dnlib.DotNet.Writer,HotPool40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += (uint)dataList.Length * 4;
Magic Number,dnlib.DotNet.Writer,HotPool40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += (uint)dataList.Length * 4;
Magic Number,dnlib.DotNet.Writer,HotPool40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += 3 * 4;
Magic Number,dnlib.DotNet.Writer,HotPool40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotPool.cs,SetOffsetImpl,The following statement contains a magic number: offs += 3 * 4;
Magic Number,dnlib.DotNet.Writer,HotTable,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotTable.cs,CalculateShift,The following statement contains a magic number: return maxBits - 8;
Magic Number,dnlib.DotNet.Writer,HotTable,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotTable.cs,CalculateShift,The following statement contains a magic number: maxBits >= 16
Magic Number,dnlib.DotNet.Writer,HotTable20,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotTable.cs,CalculatePartialTableLength,The following statement contains a magic number: len += (uint)(firstLevelTable.Length * 2);
Magic Number,dnlib.DotNet.Writer,HotTable40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotTable.cs,CalculatePartialTableLength,The following statement contains a magic number: len += (uint)(firstLevelTable.Length * 2);
Magic Number,dnlib.DotNet.Writer,HotTable40,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\HotTable.cs,CalculatePartialTableLength,The following statement contains a magic number: len += (uint)(partialData.Count * 2);
Magic Number,dnlib.DotNet.Writer,ImportAddressTable,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ImportAddressTable.cs,GetFileLength,The following statement contains a magic number: return 8;
Magic Number,dnlib.DotNet.Writer,ImportDirectory,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ImportDirectory.cs,SetOffset,The following statement contains a magic number: length += 8;
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row2.Value);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Mvid);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.EncId);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[4].Write(writer' row.EncBaseId);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Namespace);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Namespace);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.Extends);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[4].Write(writer' row.FieldList);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[5].Write(writer' row.MethodList);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Signature);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[4].Write(writer' row.Signature);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[5].Write(writer' row.ParamList);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Signature);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Value);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Value);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.PermissionSet);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Parent);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.EventType);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Type);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Association);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.MethodDeclaration);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.ImportName);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.ImportScope);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[6].Write(writer' row.PublicKey);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[7].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[8].Write(writer' row.Locale);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[5].Write(writer' row.PublicKeyOrToken);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[6].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[7].Write(writer' row.Locale);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[8].Write(writer' row.HashValue);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.AssemblyRef);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.HashValue);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.TypeName);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.TypeNamespace);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[4].Write(writer' row.Implementation);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.Implementation);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: bool useKindColumn = cols.Count >= 5;
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[2].Write(writer' row.Owner);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[3].Write(writer' row.Name);
Magic Number,dnlib.DotNet.Writer,MDTableWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols[4].Write(writer' row.Kind);
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = 16;
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp(length' 4);
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length += 4;
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length += 8;
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp(length' 4);
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.Write(Utils.AlignUp(s.Length' 4));
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeros(Utils.AlignUp(s.Length' 4) - s.Length);
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: s.Length > 32
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeros(Utils.AlignUp(s.Length' 4) - s.Length);
Magic Number,dnlib.DotNet.Writer,MethodBody,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: this.isTiny = (code[0] & 3) == 2;
Magic Number,dnlib.DotNet.Writer,MethodBody,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: this.isTiny = (code[0] & 3) == 2;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,GetFullMethodBody,The following statement contains a magic number: int padding = Utils.AlignUp(code.Length' 4) - code.Length;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatHeader,The following statement contains a magic number: return codeSize > 0x3F ||  					exceptionHandlers.Count > 0 ||  					cilBody.HasVariables ||  					maxStack > 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: flags |= 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: code = new byte[12 + codeSize];
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.Write((byte)((codeSize << 2) | 2));
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.Write((byte)((codeSize << 2) | 2));
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatExceptionClauses,The following statement contains a magic number: exceptionHandlers.Count > 20
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0xFF - 4) / 12;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: const int maxExceptionHandlers = (0xFF - 4) / 12;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetMaxStack,The following statement contains a magic number: maxStack += 8;
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteInlineBrTarget,The following statement contains a magic number: uint displ = GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(writer) + 4);
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: MetaDataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 10;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = dataDirOffset + 2 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = dataDirOffset + 2 * 8;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = cor20Offset + 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.BaseStream.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.BaseStream.Position += 4;
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt64,The following statement contains a magic number: writer.BaseStream.Position += 8;
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NetResources.cs,Add,The following statement contains a magic number: length = Utils.AlignUp(length + 4 + (uint)rawData.Length' alignment);
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset(offset + 4' rva + 4);
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset(offset + 4' rva + 4);
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: uint len = 4 + resource.GetFileLength();
Magic Number,dnlib.DotNet.Writer,NetResources,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\NetResources.cs,WriteTo,The following statement contains a magic number: rva2 += 4 + resourceData.GetFileLength();
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PEHeaders.cs,SetOffset,The following statement contains a magic number: length += 4 + 0x14;
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write(options.MajorOperatingSystemVersion ?? 4);
Magic Number,dnlib.DotNet.Writer,PEHeaders,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write(options.MajorSubsystemVersion ?? 4);
Magic Number,dnlib.DotNet.Writer,PESection,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\PESection.cs,WriteHeaderTo,The following statement contains a magic number: writer.Write(Encoding.UTF8.GetBytes(Name + "\0\0\0\0\0\0\0\0")' 0' 8);
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\RelocDirectory.cs,GetFileLength,The following statement contains a magic number: return 12;
Magic Number,dnlib.DotNet.Writer,RelocDirectory,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\RelocDirectory.cs,WriteTo,The following statement contains a magic number: writer.Write(12);
Magic Number,dnlib.DotNet.Writer,StartupStub,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: padding = rva.AlignUp(4) - rva + 2;
Magic Number,dnlib.DotNet.Writer,StartupStub,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: padding = rva.AlignUp(4) - rva + 2;
Magic Number,dnlib.DotNet.Writer,StartupStub,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: length = padding + 6;
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: majorVersion = options.MajorVersion ?? 2;
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: ((majorVersion << 8) | minorVersion) <= 0x100
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length = 24;
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);
Magic Number,dnlib.DotNet.Writer,TablesHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += 4;
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,Populate,The following statement contains a magic number: int stringLen = (int)len / 2;
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The following statement contains a magic number: writer.WriteCompressedUInt32((uint)s.Length * 2 + 1);
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,WriteString,The following statement contains a magic number: c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,GetRawDataSize,The following statement contains a magic number: return Utils.GetCompressedUInt32Length((uint)data.Length * 2 + 1) + data.Length * 2 + 1;
Magic Number,dnlib.DotNet.Writer,USHeap,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\USHeap.cs,GetRawDataSize,The following statement contains a magic number: return Utils.GetCompressedUInt32Length((uint)data.Length * 2 + 1) + data.Length * 2 + 1;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: bytes.Length / 2 > ushort.MaxValue
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: writer.Write((ushort)(bytes.Length / 2));
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: offset += 2 + (uint)bytes.Length;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16;
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadChar,The following statement contains a magic number: byte[] bytes = new byte[2];
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadChar,The following statement contains a magic number: int x = decoder.GetChars(bytes' 0' twoBytes ? 2 : 1' chars' 0);
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadDecimal,The following statement contains a magic number: var bits = new int[4] {  				reader.ReadInt32()'	// lo  				reader.ReadInt32()'	// mid  				reader.ReadInt32()'	// hi  				reader.ReadInt32()'	// flags  			};
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: val = (uint)(((b & 0x3F) << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: pos + 3 < pos || pos + 3 >= len
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: pos + 3 < pos || pos + 3 >= len
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: val = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  					(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: val = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  					(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedUInt32,The following statement contains a magic number: val = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  					(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x3F) << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: pos + 3 < pos || pos + 3 >= len
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: pos + 3 < pos || pos + 3 >= len
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  						(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  						(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,ReadCompressedInt32,The following statement contains a magic number: uint tmp = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |  						(reader.ReadByte() << 8) | reader.ReadByte());
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,Read7BitEncodedUInt32,The following statement contains a magic number: bits += 7;
Magic Number,dnlib.IO,IOExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\FileOffset.cs,Read7BitEncodedUInt32,The following statement contains a magic number: i < 5
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt16,The following statement contains a magic number: return (short)(data[position++] | (data[position++] << 8));
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(data[position++] | (data[position++] << 8));
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: position + 3 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: position + 3 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24));
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24));
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data[position++] |  					(data[position++] << 8) |  					(data[position++] << 16) |  					(data[position++] << 24));
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: position + 7 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data[position++] |  					((long)data[position++] << 8) |  					((long)data[position++] << 16) |  					((long)data[position++] << 24) |  					((long)data[position++] << 32) |  					((long)data[position++] << 40) |  					((long)data[position++] << 48) |  					((long)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: position + 7 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data[position++] |  					((ulong)data[position++] << 8) |  					((ulong)data[position++] << 16) |  					((ulong)data[position++] << 24) |  					((ulong)data[position++] << 32) |  					((ulong)data[position++] << 40) |  					((ulong)data[position++] << 48) |  					((ulong)data[position++] << 56);
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadSingle,The following statement contains a magic number: position + 3 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadSingle,The following statement contains a magic number: position += 4;
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadDouble,The following statement contains a magic number: position + 7 >= dataEnd
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadDouble,The following statement contains a magic number: position += 8;
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: position + chars * 2 < position || (chars != 0 && position + chars * 2 - 1 >= dataEnd)
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: position + chars * 2 < position || (chars != 0 && position + chars * 2 - 1 >= dataEnd)
Magic Number,dnlib.IO,MemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: array[i] = (char)(data[position++] | (data[position++] << 8));
Magic Number,dnlib.IO,MemoryMappedFileStreamCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,MemoryMappedFileStreamCreator,The following statement contains a magic number: var fileSize = ((long)sizeHi << 32) | sizeLo;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt16,The following statement contains a magic number: currentAddr += 2;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt16,The following statement contains a magic number: currentAddr += 2;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt32,The following statement contains a magic number: currentAddr + 3 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt32,The following statement contains a magic number: currentAddr += 4;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: currentAddr + 3 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: currentAddr += 4;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt64,The following statement contains a magic number: currentAddr + 7 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt64,The following statement contains a magic number: currentAddr += 8;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: currentAddr + 7 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: currentAddr += 8;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadSingle,The following statement contains a magic number: currentAddr + 3 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadSingle,The following statement contains a magic number: currentAddr += 4;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadDouble,The following statement contains a magic number: currentAddr + 7 >= endAddr
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadDouble,The following statement contains a magic number: currentAddr += 8;
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: IntPtr.Size == 4 && (uint)chars > (uint)int.MaxValue
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: currentAddr + chars * 2 < currentAddr || (chars != 0 && currentAddr + chars * 2 - 1 >= endAddr)
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: currentAddr + chars * 2 < currentAddr || (chars != 0 && currentAddr + chars * 2 - 1 >= endAddr)
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: currentAddr += chars * 2;
Magic Number,dnlib.PE,ImageNTHeaders,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\ImageNTHeaders.cs,CreateImageOptionalHeader,The following statement contains a magic number: reader.Position -= 2;
Magic Number,dnlib.PE,ImageOptionalHeader32,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\ImageOptionalHeader32.cs,ImageOptionalHeader32,The following statement contains a magic number: len + 8 <= totalSize
Magic Number,dnlib.PE,ImageOptionalHeader64,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\ImageOptionalHeader64.cs,ImageOptionalHeader64,The following statement contains a magic number: len + 8 <= totalSize
Magic Number,dnlib.PE,ImageSectionHeader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\ImageSectionHeader.cs,ImageSectionHeader,The following statement contains a magic number: this.name = reader.ReadBytes(8);
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: i += 2;
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: checkSum = (ushort)(checkSum + (checkSum >> 16));
Magic Number,dnlib.PE,PEExtensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\IPEImage.cs,CalculatePECheckSum,The following statement contains a magic number: return (uint)cks + (uint)(cks >> 32);
Magic Number,dnlib.PE,PEImage,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\PE\PEImage.cs,Initialize,The following statement contains a magic number: win32Resources.ReadOriginalValue = () => {  				var dataDir = peInfo.ImageNTHeaders.OptionalHeader.DataDirectories[2];  				if (dataDir.VirtualAddress == 0 || dataDir.Size == 0)  					return null;  				return new Win32ResourcesPE(this);  			};
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: depth > MAX_DIR_DEPTH || !reader.CanRead(16)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: !reader.CanRead(total * 8)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: !reader.CanRead(2)
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: int sizeInBytes = size * 2;
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\W32Resources\ResourceDirectory.cs,ReadResourceData,The following statement contains a magic number: reader.CanRead(16)
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,GetCorLibTypeSig,The following switch statement is missing a default case: switch (name) {  			case "Void":	return self.Void;  			case "Boolean":	return self.Boolean;  			case "Char":	return self.Char;  			case "SByte":	return self.SByte;  			case "Byte":	return self.Byte;  			case "Int16":	return self.Int16;  			case "UInt16":	return self.UInt16;  			case "Int32":	return self.Int32;  			case "UInt32":	return self.UInt32;  			case "Int64":	return self.Int64;  			case "UInt64":	return self.UInt64;  			case "Single":	return self.Single;  			case "Double":	return self.Double;  			case "String":	return self.String;  			case "TypedReference": return self.TypedReference;  			case "IntPtr":	return self.IntPtr;  			case "UIntPtr":	return self.UIntPtr;  			case "Object":	return self.Object;  			}
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,The following switch statement is missing a default case: switch ((flags & MethodImplAttributes.CodeTypeMask)) {  			case MethodImplAttributes.IL: sb.Append("IL"); break;  			case MethodImplAttributes.Native: sb.Append("Native"); break;  			case MethodImplAttributes.OPTIL: sb.Append("OPTIL"); break;  			case MethodImplAttributes.Runtime: sb.Append("Runtime"); break;  			}
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,The following switch statement is missing a default case: switch ((flags & PInvokeAttributes.CharSetMask)) {  			case PInvokeAttributes.CharSetNotSpec: sb.Append("CharSetNotSpec"); break;  			case PInvokeAttributes.CharSetAnsi: sb.Append("CharSetAnsi"); break;  			case PInvokeAttributes.CharSetUnicode: sb.Append("CharSetUnicode"); break;  			case PInvokeAttributes.CharSetAuto: sb.Append("CharSetAuto"); break;  			}
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,The following switch statement is missing a default case: switch ((flags & TypeAttributes.VisibilityMask)) {  			case TypeAttributes.NotPublic: sb.Append("NotPublic"); break;  			case TypeAttributes.Public: sb.Append("Public"); break;  			case TypeAttributes.NestedPublic: sb.Append("NestedPublic"); break;  			case TypeAttributes.NestedPrivate: sb.Append("NestedPrivate"); break;  			case TypeAttributes.NestedFamily: sb.Append("NestedFamily"); break;  			case TypeAttributes.NestedAssembly: sb.Append("NestedAssembly"); break;  			case TypeAttributes.NestedFamANDAssem: sb.Append("NestedFamANDAssem"); break;  			case TypeAttributes.NestedFamORAssem: sb.Append("NestedFamORAssem"); break;  			}
Missing Default,dnlib.DotNet,Extensions,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,The following switch statement is missing a default case: switch ((flags & TypeAttributes.StringFormatMask)) {  			case TypeAttributes.AnsiClass: sb.Append(" | AnsiClass"); break;  			case TypeAttributes.UnicodeClass: sb.Append(" | UnicodeClass"); break;  			case TypeAttributes.AutoClass: sb.Append(" | AutoClass"); break;  			case TypeAttributes.CustomFormatClass: sb.Append(" | CustomFormatClass"); break;  			}
Missing Default,dnlib.DotNet,FullNameCreator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\FullNameCreator.cs,AddIdentifier,The following switch statement is missing a default case: switch (c) {  					case ''':  					case '+':  					case '&':  					case '*':  					case '[':  					case ']':  					case '\\':  						sb.Append('\\');  						break;  					}
Missing Default,dnlib.DotNet,ModuleDef,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following switch statement is missing a default case: switch (flags & (ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred)) {  			case 0:  				// Machine and ILOnly flag should be checked  				break;    			case ComImageFlags._32BitPreferred:  				// Illegal  				break;    			case ComImageFlags._32BitRequired:  				// x86 image (32-bit process)  				return 4;    			case ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred:  				// Platform neutral but prefers to be 32-bit  				return defaultPointerSize;  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Module:			return ResolveModule(rid);  			case Table.TypeRef:			return ResolveTypeRef(rid);  			case Table.TypeDef:			return ResolveTypeDef(rid);  			case Table.Field:			return ResolveField(rid);  			case Table.Method:			return ResolveMethod(rid);  			case Table.Param:			return ResolveParam(rid);  			case Table.InterfaceImpl:	return ResolveInterfaceImpl(rid);  			case Table.MemberRef:		return ResolveMemberRef(rid);  			case Table.Constant:		return ResolveConstant(rid);  			case Table.FieldMarshal:	return ResolveFieldMarshal(rid);  			case Table.DeclSecurity:	return ResolveDeclSecurity(rid);  			case Table.ClassLayout:		return ResolveClassLayout(rid);  			case Table.StandAloneSig:	return ResolveStandAloneSig(rid);  			case Table.Event:			return ResolveEvent(rid);  			case Table.Property:		return ResolveProperty(rid);  			case Table.ModuleRef:		return ResolveModuleRef(rid);  			case Table.TypeSpec:		return ResolveTypeSpec(rid);  			case Table.ImplMap:			return ResolveImplMap(rid);  			case Table.Assembly:		return ResolveAssembly(rid);  			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);  			case Table.File:			return ResolveFile(rid);  			case Table.ExportedType:	return ResolveExportedType(rid);  			case Table.ManifestResource:return ResolveManifestResource(rid);  			case Table.GenericParam:	return ResolveGenericParam(rid);  			case Table.MethodSpec:		return ResolveMethodSpec(rid);  			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasConstant,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Param:	return ResolveParam(rid);  			case Table.Property:return ResolveProperty(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.Field:		return ResolveField(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.Param:		return ResolveParam(rid);  			case Table.InterfaceImpl: return ResolveInterfaceImpl(rid);  			case Table.MemberRef:	return ResolveMemberRef(rid);  			case Table.Module:		return ResolveModule(rid);  			case Table.DeclSecurity:return ResolveDeclSecurity(rid);  			case Table.Property:	return ResolveProperty(rid);  			case Table.Event:		return ResolveEvent(rid);  			case Table.StandAloneSig: return ResolveStandAloneSig(rid);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid);  			case Table.Assembly:	return ResolveAssembly(rid);  			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);  			case Table.File:		return ResolveFile(rid);  			case Table.ExportedType:return ResolveExportedType(rid);  			case Table.ManifestResource: return ResolveManifestResource(rid);  			case Table.GenericParam:return ResolveGenericParam(rid);  			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid);  			case Table.MethodSpec:	return ResolveMethodSpec(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasFieldMarshal,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Param:	return ResolveParam(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasDeclSecurity,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.Method:		return ResolveMethod(rid);  			case Table.Assembly:	return ResolveAssembly(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberRefParent,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:		return ResolveTypeDef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.Method:		return ResolveMethod(rid);  			case Table.TypeSpec:	return ResolveTypeSpec(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasSemantic,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Event:		return ResolveEvent(rid);  			case Table.Property:	return ResolveProperty(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMethodDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.MemberRef:	return ResolveMemberRef(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberForwarded,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:	return ResolveField(rid);  			case Table.Method:	return ResolveMethod(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveImplementation,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.File:			return ResolveFile(rid);  			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);  			case Table.ExportedType:	return ResolveExportedType(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveCustomAttributeType,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Method:		return ResolveMethod(rid);  			case Table.MemberRef:	return ResolveMemberRef(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveResolutionScope,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Module:		return ResolveModule(rid);  			case Table.ModuleRef:	return ResolveModuleRef(rid);  			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);  			case Table.TypeRef:		return ResolveTypeRef(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeOrMethodDef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:	return ResolveTypeDef(rid);  			case Table.Method:	return ResolveMethod(rid);  			}
Missing Default,dnlib.DotNet,ModuleDefMD,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.Field:  				var fieldRow = TablesStream.ReadFieldRow(rid);  				if (fieldRow == null)  					break;  				return BlobStream.Read(fieldRow.Signature);    			case Table.Method:  				var methodRow = TablesStream.ReadMethodRow(rid);  				if (methodRow == null)  					break;  				return BlobStream.Read(methodRow.Signature);    			case Table.MemberRef:  				var mrRow = TablesStream.ReadMemberRefRow(rid);  				if (mrRow == null)  					break;  				return BlobStream.Read(mrRow.Signature);    			case Table.Constant:  				var constRow = TablesStream.ReadConstantRow(rid);  				if (constRow == null)  					break;  				return BlobStream.Read(constRow.Value);    			case Table.CustomAttribute:  				var caRow = TablesStream.ReadCustomAttributeRow(rid);  				if (caRow == null)  					break;  				return BlobStream.Read(caRow.Value);    			case Table.FieldMarshal:  				var fmRow = TablesStream.ReadFieldMarshalRow(rid);  				if (fmRow == null)  					break;  				return BlobStream.Read(fmRow.NativeType);    			case Table.DeclSecurity:  				var dsRow = TablesStream.ReadDeclSecurityRow(rid);  				if (dsRow == null)  					break;  				return BlobStream.Read(dsRow.PermissionSet);    			case Table.StandAloneSig:  				var sasRow = TablesStream.ReadStandAloneSigRow(rid);  				if (sasRow == null)  					break;  				return BlobStream.Read(sasRow.Signature);    			case Table.Property:  				var propRow = TablesStream.ReadPropertyRow(rid);  				if (propRow == null)  					break;  				return BlobStream.Read(propRow.Type);    			case Table.TypeSpec:  				var tsRow = TablesStream.ReadTypeSpecRow(rid);  				if (tsRow == null)  					break;  				return BlobStream.Read(tsRow.Signature);    			case Table.Assembly:  				var asmRow = TablesStream.ReadAssemblyRow(rid);  				if (asmRow == null)  					break;  				return BlobStream.Read(asmRow.PublicKey);    			case Table.AssemblyRef:  				// HashValue is also in the #Blob but the user has to read it some other way  				var asmRefRow = TablesStream.ReadAssemblyRefRow(rid);  				if (asmRefRow == null)  					break;  				return BlobStream.Read(asmRefRow.PublicKeyOrToken);    			case Table.File:  				var fileRow = TablesStream.ReadFileRow(rid);  				if (fileRow == null)  					break;  				return BlobStream.Read(fileRow.HashValue);    			case Table.MethodSpec:  				var msRow = TablesStream.ReadMethodSpecRow(rid);  				if (msRow == null)  					break;  				return BlobStream.Read(msRow.Instantiation);  			}
Missing Default,dnlib.DotNet,ReflectionTypeNameParser,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,The following switch statement is missing a default case: switch (key.ToUpperInvariant()) {  				case "VERSION":  					asmRef.Version = Utils.ParseVersion(value);  					break;    				case "PUBLICKEY":  					if (value.Equals("null"' StringComparison.OrdinalIgnoreCase))  						asmRef.PublicKeyOrToken = new PublicKey();  					else  						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKey(Utils.ParseBytes(value));  					break;    				case "PUBLICKEYTOKEN":  					if (value.Equals("null"' StringComparison.OrdinalIgnoreCase))  						asmRef.PublicKeyOrToken = new PublicKeyToken();  					else  						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKeyToken(Utils.ParseBytes(value));  					break;    				case "CULTURE":  					if (value.Equals("neutral"' StringComparison.OrdinalIgnoreCase))  						asmRef.Culture = UTF8String.Empty;  					else  						asmRef.Culture = value;  					break;  				}
Missing Default,dnlib.DotNet.Emit,DynamicMethodBodyReader,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\DynamicMethodBodyReader.cs,ResolveTypeDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable(token)) {  			case Table.TypeDef:  			case Table.TypeRef:  			case Table.TypeSpec:  				return ImportType(rid);  			}
Missing Default,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following switch statement is missing a default case: switch (value) {  			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();  			case 0: return OpCodes.Ldc_I4_0.ToInstruction();  			case 1: return OpCodes.Ldc_I4_1.ToInstruction();  			case 2: return OpCodes.Ldc_I4_2.ToInstruction();  			case 3: return OpCodes.Ldc_I4_3.ToInstruction();  			case 4: return OpCodes.Ldc_I4_4.ToInstruction();  			case 5: return OpCodes.Ldc_I4_5.ToInstruction();  			case 6: return OpCodes.Ldc_I4_6.ToInstruction();  			case 7: return OpCodes.Ldc_I4_7.ToInstruction();  			case 8: return OpCodes.Ldc_I4_8.ToInstruction();  			}
Missing Default,dnlib.DotNet.Emit,Instruction,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following switch statement is missing a default case: switch (OpCode.Code) {  			case Code.Ldarg_0: return 0;  			case Code.Ldarg_1: return 1;  			case Code.Ldarg_2: return 2;  			case Code.Ldarg_3: return 3;    			case Code.Ldarga:  			case Code.Ldarga_S:  			case Code.Ldarg:  			case Code.Ldarg_S:  				var parameter = Operand as Parameter;  				if (parameter != null)  					return parameter.Index;  				break;  			}
Missing Default,dnlib.DotNet.Emit,MethodBodyReaderBase,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,FixBranches,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.InlineBrTarget:  				case OperandType.ShortInlineBrTarget:  					instr.Operand = GetInstruction((uint)instr.Operand);  					break;    				case OperandType.InlineSwitch:  					var uintTargets = (IList<uint>)instr.Operand;  					var targets = new Instruction[uintTargets.Count];  					for (int i = 0; i < uintTargets.Count; i++)  						targets[i] = GetInstruction(uintTargets[i]);  					instr.Operand = targets;  					break;  				}
Missing Default,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Beq_S:  					instr.OpCode = OpCodes.Beq;  					break;    				case Code.Bge_S:  					instr.OpCode = OpCodes.Bge;  					break;    				case Code.Bge_Un_S:  					instr.OpCode = OpCodes.Bge_Un;  					break;    				case Code.Bgt_S:  					instr.OpCode = OpCodes.Bgt;  					break;    				case Code.Bgt_Un_S:  					instr.OpCode = OpCodes.Bgt_Un;  					break;    				case Code.Ble_S:  					instr.OpCode = OpCodes.Ble;  					break;    				case Code.Ble_Un_S:  					instr.OpCode = OpCodes.Ble_Un;  					break;    				case Code.Blt_S:  					instr.OpCode = OpCodes.Blt;  					break;    				case Code.Blt_Un_S:  					instr.OpCode = OpCodes.Blt_Un;  					break;    				case Code.Bne_Un_S:  					instr.OpCode = OpCodes.Bne_Un;  					break;    				case Code.Br_S:  					instr.OpCode = OpCodes.Br;  					break;    				case Code.Brfalse_S:  					instr.OpCode = OpCodes.Brfalse;  					break;    				case Code.Brtrue_S:  					instr.OpCode = OpCodes.Brtrue;  					break;    				case Code.Ldarg_0:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 0);  					break;    				case Code.Ldarg_1:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 1);  					break;    				case Code.Ldarg_2:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 2);  					break;    				case Code.Ldarg_3:  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = ReadList(parameters' 3);  					break;    				case Code.Ldarg_S:  					instr.OpCode = OpCodes.Ldarg;  					break;    				case Code.Ldarga_S:  					instr.OpCode = OpCodes.Ldarga;  					break;    				case Code.Ldc_I4_0:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 0;  					break;    				case Code.Ldc_I4_1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 1;  					break;    				case Code.Ldc_I4_2:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 2;  					break;    				case Code.Ldc_I4_3:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 3;  					break;    				case Code.Ldc_I4_4:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 4;  					break;    				case Code.Ldc_I4_5:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 5;  					break;    				case Code.Ldc_I4_6:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 6;  					break;    				case Code.Ldc_I4_7:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 7;  					break;    				case Code.Ldc_I4_8:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = 8;  					break;    				case Code.Ldc_I4_M1:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = -1;  					break;    				case Code.Ldc_I4_S:  					instr.OpCode = OpCodes.Ldc_I4;  					instr.Operand = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldloc_0:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Ldloc_1:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Ldloc_2:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Ldloc_3:  					instr.OpCode = OpCodes.Ldloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Ldloc_S:  					instr.OpCode = OpCodes.Ldloc;  					break;    				case Code.Ldloca_S:  					instr.OpCode = OpCodes.Ldloca;  					break;    				case Code.Leave_S:  					instr.OpCode = OpCodes.Leave;  					break;    				case Code.Starg_S:  					instr.OpCode = OpCodes.Starg;  					break;    				case Code.Stloc_0:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 0);  					break;    				case Code.Stloc_1:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 1);  					break;    				case Code.Stloc_2:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 2);  					break;    				case Code.Stloc_3:  					instr.OpCode = OpCodes.Stloc;  					instr.Operand = ReadList(locals' 3);  					break;    				case Code.Stloc_S:  					instr.OpCode = OpCodes.Stloc;  					break;  				}
Missing Default,dnlib.DotNet.Emit,MethodUtils,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyBranches,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Beq_S:	instr.OpCode = OpCodes.Beq; break;  				case Code.Bge_S:	instr.OpCode = OpCodes.Bge; break;  				case Code.Bgt_S:	instr.OpCode = OpCodes.Bgt; break;  				case Code.Ble_S:	instr.OpCode = OpCodes.Ble; break;  				case Code.Blt_S:	instr.OpCode = OpCodes.Blt; break;  				case Code.Bne_Un_S:	instr.OpCode = OpCodes.Bne_Un; break;  				case Code.Bge_Un_S:	instr.OpCode = OpCodes.Bge_Un; break;  				case Code.Bgt_Un_S:	instr.OpCode = OpCodes.Bgt_Un; break;  				case Code.Ble_Un_S:	instr.OpCode = OpCodes.Ble_Un; break;  				case Code.Blt_Un_S:	instr.OpCode = OpCodes.Blt_Un; break;  				case Code.Br_S:		instr.OpCode = OpCodes.Br; break;  				case Code.Brfalse_S:instr.OpCode = OpCodes.Brfalse; break;  				case Code.Brtrue_S:	instr.OpCode = OpCodes.Brtrue; break;  				case Code.Leave_S:	instr.OpCode = OpCodes.Leave; break;  				}
Missing Default,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,InitializeInternal,The following switch statement is missing a default case: switch (sh.Name) {  					case "#Strings":  						if (stringsStream == null) {  							stringsStream = new StringsStream(imageStream' sh);  							imageStream = null;  							newAllStreams.Add(stringsStream);  							continue;  						}  						break;    					case "#US":  						if (usStream == null) {  							usStream = new USStream(imageStream' sh);  							imageStream = null;  							newAllStreams.Add(usStream);  							continue;  						}  						break;    					case "#Blob":  						if (blobStream == null) {  							blobStream = new BlobStream(imageStream' sh);  							imageStream = null;  							newAllStreams.Add(blobStream);  							continue;  						}  						break;    					case "#GUID":  						if (guidStream == null) {  							guidStream = new GuidStream(imageStream' sh);  							imageStream = null;  							newAllStreams.Add(guidStream);  							continue;  						}  						break;    					case "#~":  						if (tablesStream == null) {  							tablesStream = new TablesStream(imageStream' sh);  							imageStream = null;  							newAllStreams.Add(tablesStream);  							continue;  						}  						break;    					case "#!":  						if (hotStreams == null)  							hotStreams = new List<HotStream>();  						fullStream = peImage.CreateFullStream();  						hotStream = HotStream.Create(hotHeapVersion' imageStream' sh' fullStream' fileOffset);  						fullStream = null;  						hotStreams.Add(hotStream);  						newAllStreams.Add(hotStream);  						hotStream = null;  						imageStream = null;  						continue;  					}
Missing Default,dnlib.DotNet.MD,CompressedMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\CompressedMetaData.cs,InitializeHotStreams,The following switch statement is missing a default case: switch (hotHeap.HeapType) {  					case HeapType.Strings:  						if (hotStrings == null) {  							hotHeap.Initialize(offsetMask);  							hotStrings = hotHeap;  						}  						break;    					case HeapType.Guid:  						if (hotGuid == null) {  							hotHeap.Initialize(offsetMask);  							hotGuid = hotHeap;  						}  						break;    					case HeapType.Blob:  						if (hotBlob == null) {  							hotHeap.Initialize(offsetMask);  							hotBlob = hotHeap;  						}  						break;    					case HeapType.US:  						if (hotUs == null) {  							hotHeap.Initialize(offsetMask);  							hotUs = hotHeap;  						}  						break;  					}
Missing Default,dnlib.DotNet.MD,DotNetTableSizes,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following switch statement is missing a default case: switch (columnSize) {  				case ColumnSize.Byte:	return 1;  				case ColumnSize.Int16:	return 2;  				case ColumnSize.UInt16:	return 2;  				case ColumnSize.Int32:	return 4;  				case ColumnSize.UInt32:	return 4;  				case ColumnSize.Strings:return bigStrings ? 4 : 2;  				case ColumnSize.GUID:	return bigGuid ? 4 : 2;  				case ColumnSize.Blob:	return bigBlob ? 4 : 2;  				}
Missing Default,dnlib.DotNet.MD,ENCMetaData,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\MD\ENCMetaData.cs,InitializeInternal,The following switch statement is missing a default case: switch (sh.Name.ToUpperInvariant()) {  					case "#STRINGS":  						if (stringsStream == null) {  							stringsStream = new StringsStream(imageStream' sh);  							imageStream = null;  							allStreams.Add(stringsStream);  							continue;  						}  						break;    					case "#US":  						if (usStream == null) {  							usStream = new USStream(imageStream' sh);  							imageStream = null;  							allStreams.Add(usStream);  							continue;  						}  						break;    					case "#BLOB":  						if (blobStream == null) {  							blobStream = new BlobStream(imageStream' sh);  							imageStream = null;  							allStreams.Add(blobStream);  							continue;  						}  						break;    					case "#GUID":  						if (guidStream == null) {  							guidStream = new GuidStream(imageStream' sh);  							imageStream = null;  							allStreams.Add(guidStream);  							continue;  						}  						break;    					case "#-":  						if (tablesStream == null) {  							tablesStream = new TablesStream(imageStream' sh);  							imageStream = null;  							allStreams.Add(tablesStream);  							continue;  						}  						break;  					}
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(o.GetType())) {  			case TypeCode.Boolean:  				result = (bool)o ? 1UL : 0UL;  				return true;    			case TypeCode.Char:  				result = (ushort)(char)o;  				return true;    			case TypeCode.SByte:  				result = (ulong)(sbyte)o;  				return true;    			case TypeCode.Byte:  				result = (byte)o;  				return true;    			case TypeCode.Int16:  				result = (ulong)(short)o;  				return true;    			case TypeCode.UInt16:  				result = (ushort)o;  				return true;    			case TypeCode.Int32:  				result = (ulong)(int)o;  				return true;    			case TypeCode.UInt32:  				result = (uint)o;  				return true;    			case TypeCode.Int64:  				result = (ulong)(long)o;  				return true;    			case TypeCode.UInt64:  				result = (ulong)o;  				return true;    			case TypeCode.Single:  				result = (ulong)(float)o;  				return true;    			case TypeCode.Double:  				result = (ulong)(double)o;  				return true;  			}
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode(o.GetType())) {  			case TypeCode.Boolean:  				result = (bool)o ? 1 : 0;  				return true;    			case TypeCode.Char:  				result = (ushort)(char)o;  				return true;    			case TypeCode.SByte:  				result = (sbyte)o;  				return true;    			case TypeCode.Byte:  				result = (byte)o;  				return true;    			case TypeCode.Int16:  				result = (short)o;  				return true;    			case TypeCode.UInt16:  				result = (ushort)o;  				return true;    			case TypeCode.Int32:  				result = (int)o;  				return true;    			case TypeCode.UInt32:  				result = (uint)o;  				return true;    			case TypeCode.Int64:  				result = (long)o;  				return true;    			case TypeCode.UInt64:  				result = (ulong)o;  				return true;    			case TypeCode.Single:  				result = (float)o;  				return true;    			case TypeCode.Double:  				result = (double)o;  				return true;  			}
Missing Default,dnlib.DotNet.Writer,MaxStackCalculator,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,The following switch statement is missing a default case: switch (instr.OpCode.FlowControl) {  				case FlowControl.Branch:  					WriteStack(instr.Operand as Instruction' stack);  					resetStack = true;  					break;    				case FlowControl.Call:  					if (instr.OpCode.Code == Code.Jmp)  						resetStack = true;  					break;    				case FlowControl.Cond_Branch:  					if (instr.OpCode.Code == Code.Switch) {  						var targets = instr.Operand as IList<Instruction>;  						if (targets != null) {  							foreach (var target in targets)  								WriteStack(target' stack);  						}  					}  					else  						WriteStack(instr.Operand as Instruction' stack);  					break;    				case FlowControl.Return:  				case FlowControl.Throw:  					resetStack = true;  					break;  				}
Missing Default,dnlib.IO,BinaryReaderStream,D:\research\architectureSmells\repos1\telerik_justdecompile-plugins\De4dot.JustDecompile\De4dot\sources\dnlib\src\IO\BinaryReaderStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  			case SeekOrigin.Begin:	Position = offset; break;  			case SeekOrigin.Current:Position += offset; break;  			case SeekOrigin.End:	Position = Length + offset; break;  			}
