Implementation smell,Namespace,Class,File,Method,Description
Long Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The method has 214 lines of code.
Long Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The method has 110 lines of code.
Complex Method,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,Cyclomatic complexity of the method is 24
Complex Method,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,Cyclomatic complexity of the method is 8
Complex Method,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,load,Cyclomatic complexity of the method is 8
Complex Method,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreq,Cyclomatic complexity of the method is 10
Complex Method,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,normProb,Cyclomatic complexity of the method is 8
Complex Method,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,Cyclomatic complexity of the method is 11
Complex Method,CommandLine,LongOptionParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,CommandLine,OptionGroupParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,CommandLine,CommandLineParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,DoParseArguments,Cyclomatic complexity of the method is 8
Complex Method,CommandLine.Text,MultiLineTextAttribute,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddToHelpText,Cyclomatic complexity of the method is 12
Complex Method,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AutoBuild,Cyclomatic complexity of the method is 8
Complex Method,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,RenderParsingErrorsText,Cyclomatic complexity of the method is 10
Complex Method,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddOption,Cyclomatic complexity of the method is 16
Complex Method,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddLine,Cyclomatic complexity of the method is 8
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ParseNewLine,Cyclomatic complexity of the method is 10
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,Cyclomatic complexity of the method is 58
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,Cyclomatic complexity of the method is 19
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleParseError,Cyclomatic complexity of the method is 14
Complex Method,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleMissingField,Cyclomatic complexity of the method is 9
Long Parameter List,CommandLine.Text,MultiLineTextAttribute,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,MultiLineTextAttribute,The method has 5 parameters.
Long Parameter List,CommandLine.Text,AssemblyLicenseAttribute,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AssemblyLicenseAttribute,The method has 5 parameters.
Long Parameter List,CommandLine.Text,AssemblyUsageAttribute,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AssemblyUsageAttribute,The method has 5 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CachedCsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CachedCsvReader.CsvBindingList.cs,CachedCsvReader,The method has 7 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CachedCsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CachedCsvReader.CsvBindingList.cs,CachedCsvReader,The method has 8 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,CsvReader,The method has 7 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,CsvReader,The method has 8 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,CopyFieldToArray,The method has 5 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetBytes,The method has 5 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetChars,The method has 5 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,MalformedCsvException,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\Exceptions\MalformedCsvException.cs,MalformedCsvException,The method has 5 parameters.
Long Parameter List,LumenWorks.Framework.IO.Csv,MissingFieldCsvException,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\Exceptions\MissingFieldCsvException.cs,MissingFieldCsvException,The method has 5 parameters.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,loadSimilarity,The length of the statement  "	Console.WriteLine ("Pairs={0}; Pairs found={1}; Inconsistent pairs={2}"' _relationsCount' usedPairsNum' inconsistPairsNum); " is 123.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,tryAddSim,The length of the statement  "		//if (this[target][relatum].sim != 0) Console.Write("Duplicate relation: ({0}'{1}'{2}?={3})\n"' target' relatum' this[target][relatum].sim' sim); " is 145.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRfreq,The length of the statement  "				Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key); " is 142.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,getMedian,The length of the statement  "	double median = (size % 2 != 0) ? (double)sortedPNumbers [mid] : ((double)sortedPNumbers [mid] + (double)sortedPNumbers [mid - 1]) / 2; " is 135.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRnum,The length of the statement  "				Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key); " is 142.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreqRnum,The length of the statement  "				Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key); " is 142.
Long Statement,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreqRnum,The length of the statement  "			relatum.Value.sim = (2 * meanBranchesNum / (targetRnum + relatumRnum)) * (relatum.Value.sim / (targetProb + relatumProb)); " is 122.
Long Statement,CommandLine,OptionInfo,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,SetValueScalar,The length of the statement  "				_property.SetValue (options' Convert.ChangeType (value' _property.PropertyType' Thread.CurrentThread.CurrentCulture)' null); " is 124.
Long Statement,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AutoBuild,The length of the statement  "		throw new InvalidOperationException ("HelpText::AutoBuild() requires that you define AssemblyInformationalVersionAttribute."); " is 126.
Long Statement,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,ToString,The length of the statement  "	var builder = new StringBuilder (GetLength (_heading) + GetLength (_copyright) + GetLength (_preOptionsHelp) + GetLength (_optionsHelp) + extraLength); " is 151.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,IsWhiteSpace,The length of the statement  "			return (System.Globalization.CharUnicodeInfo.GetUnicodeCategory (c) == System.Globalization.UnicodeCategory.SpaceSeparator); " is 124.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The length of the statement  "			throw new ArgumentOutOfRangeException ("field"' field' string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' field)); " is 147.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The length of the statement  "						else if (c == _escape && (_escape != _quote || (pos + 1 < _bufferLength && _buffer [pos + 1] == _quote) || (pos + 1 == _bufferLength && _reader.Peek () == _quote))) { " is 166.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The length of the statement  "							HandleParseError (new MalformedCsvException (GetCurrentRawData ()' _nextFieldStart' Math.Max (0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 148.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The length of the statement  "						HandleParseError (new MalformedCsvException (GetCurrentRawData ()' _nextFieldStart' Math.Max (0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 148.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The length of the statement  "	HandleParseError (new MalformedCsvException (GetCurrentRawData ()' _nextFieldStart' Math.Max (0' _currentRecordIndex)' index)' ref _nextFieldStart); " is 148.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleParseError,The length of the statement  "			throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionInvalidInsideParseErrorEvent' e.Action)' e.Error); " is 165.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleParseError,The length of the statement  "			throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionNotSupported' e.Action)' e.Error); " is 145.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleParseError,The length of the statement  "		throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' ExceptionMessage.ParseErrorActionNotSupported' _defaultParseErrorAction)' error); " is 159.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleMissingField,The length of the statement  "		throw new ArgumentOutOfRangeException ("fieldIndex"' fieldIndex' string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' fieldIndex)); " is 162.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleMissingField,The length of the statement  "			HandleParseError (new MissingFieldCsvException (GetCurrentRawData ()' currentPosition' Math.Max (0' _currentRecordIndex)' fieldIndex)' ref currentPosition); " is 156.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,HandleMissingField,The length of the statement  "			throw new NotSupportedException (string.Format (CultureInfo.InvariantCulture' ExceptionMessage.MissingFieldActionNotSupported' _missingFieldAction)); " is 149.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,CopyFieldToArray,The length of the statement  "		throw new ArgumentOutOfRangeException ("field"' field' string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' field)); " is 147.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetFieldType,The length of the statement  "		throw new ArgumentOutOfRangeException ("i"' i' string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' i)); " is 135.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetName,The length of the statement  "		throw new ArgumentOutOfRangeException ("i"' i' string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldIndexOutOfRange' i)); " is 135.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetOrdinal,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' ExceptionMessage.FieldHeaderNotFound' name)' "name"); " is 127.
Long Statement,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,Dispose,The length of the statement  "			// Dispose-time code should also set references of all owned objects to null' after disposing them. This will allow the referenced objects to be garbage collected even if not all references to the "parent" are released. It may be a significant memory consumption win if the referenced objects are large' such as big arrays' collections' etc.  " is 341.
Complex Conditional,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The conditional expression  "wrongAlpha || wrongBeta || wrongInput || wrongCfreq"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The conditional expression  "c == _escape && (_escape != _quote || (pos + 1 < _bufferLength && _buffer [pos + 1] == _quote) || (pos + 1 == _bufferLength && _reader.Peek () == _quote))"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The conditional expression  "!_eof && !delimiterSkipped && (initializing || index == _fieldCount - 1)"  is complex.
Complex Conditional,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadField,The conditional expression  "!delimiterSkipped && !_eof && !(_eol || IsNewLine (_nextFieldStart))"  is complex.
Virtual Method Call from Constructor,AuthecoConsole,Command2,F:\newReposMay17\cental_PatternSim\rank\src\Command2.cs,Command2,The constructor "Command2" calls a virtual method "init".
Empty Catch Block,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,Dispose,The method has an empty catch block.
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,init,The following statement contains a magic number: alpha = 15;  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,init,The following statement contains a magic number: beta = 2;  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The following statement contains a magic number: switch (norm) {  case 1:  	relations.rerankEfreq ();  	break;  case 2:  	relations.rerankEfreqRfreq (alpha);  	break;  case 3:  	relations.rerankEfreqRnum (beta);  	break;  case 4:  	relations.rerankEfreqCfreq (corpusFreq' beta);  	break;  case 5:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	break;  case 6:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	relations.multiplyPnum (patternSqrt);  	break;  default:  	Console.WriteLine ("Unknown reranking type '{0}' -- using 1 (Efreq)."' norm);  	relations.rerankEfreq ();  	break;  }  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The following statement contains a magic number: switch (norm) {  case 1:  	relations.rerankEfreq ();  	break;  case 2:  	relations.rerankEfreqRfreq (alpha);  	break;  case 3:  	relations.rerankEfreqRnum (beta);  	break;  case 4:  	relations.rerankEfreqCfreq (corpusFreq' beta);  	break;  case 5:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	break;  case 6:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	relations.multiplyPnum (patternSqrt);  	break;  default:  	Console.WriteLine ("Unknown reranking type '{0}' -- using 1 (Efreq)."' norm);  	relations.rerankEfreq ();  	break;  }  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The following statement contains a magic number: switch (norm) {  case 1:  	relations.rerankEfreq ();  	break;  case 2:  	relations.rerankEfreqRfreq (alpha);  	break;  case 3:  	relations.rerankEfreqRnum (beta);  	break;  case 4:  	relations.rerankEfreqCfreq (corpusFreq' beta);  	break;  case 5:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	break;  case 6:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	relations.multiplyPnum (patternSqrt);  	break;  default:  	Console.WriteLine ("Unknown reranking type '{0}' -- using 1 (Efreq)."' norm);  	relations.rerankEfreq ();  	break;  }  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The following statement contains a magic number: switch (norm) {  case 1:  	relations.rerankEfreq ();  	break;  case 2:  	relations.rerankEfreqRfreq (alpha);  	break;  case 3:  	relations.rerankEfreqRnum (beta);  	break;  case 4:  	relations.rerankEfreqCfreq (corpusFreq' beta);  	break;  case 5:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	break;  case 6:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	relations.multiplyPnum (patternSqrt);  	break;  default:  	Console.WriteLine ("Unknown reranking type '{0}' -- using 1 (Efreq)."' norm);  	relations.rerankEfreq ();  	break;  }  
Magic Number,AuthecoConsole,PatternSimRerankCommand,F:\newReposMay17\cental_PatternSim\rank\src\ConcreteCommands.cs,run,The following statement contains a magic number: switch (norm) {  case 1:  	relations.rerankEfreq ();  	break;  case 2:  	relations.rerankEfreqRfreq (alpha);  	break;  case 3:  	relations.rerankEfreqRnum (beta);  	break;  case 4:  	relations.rerankEfreqCfreq (corpusFreq' beta);  	break;  case 5:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	break;  case 6:  	relations.rerankEfreqCfreqRnum (corpusFreq' beta);  	relations.multiplyPnum (patternSqrt);  	break;  default:  	Console.WriteLine ("Unknown reranking type '{0}' -- using 1 (Efreq)."' norm);  	relations.rerankEfreq ();  	break;  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	try {  		fields = line.Split (';');  		if (idFormat && fields.Length >= 3) {  			// Loading entry in "id;term;freq" format  			if (!this.ContainsKey (fields [1])) {  				this.Add (fields [1].Trim ()' new int[] {  					int.Parse (fields [0])'  					int.Parse (fields [2])  				});  			} else {  				//Console.WriteLine("Duplicate term: {0}"' line);  			}  		} else if (fields.Length >= 2) {  			// Loading entry in "term;freq" format  			word = fields [0].Trim ();  			if (!this.ContainsKey (word)) {  				this.Add (word' new int[] {  					id++'  					int.Parse (fields [1])  				});  			} else {  				//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  				duplicateNum++;  				this [word] [1] += int.Parse (fields [1]);  			}  		}  	} catch (Exception exc) {  		Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  		errorNum++;  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	try {  		fields = line.Split (';');  		if (idFormat && fields.Length >= 3) {  			// Loading entry in "id;term;freq" format  			if (!this.ContainsKey (fields [1])) {  				this.Add (fields [1].Trim ()' new int[] {  					int.Parse (fields [0])'  					int.Parse (fields [2])  				});  			} else {  				//Console.WriteLine("Duplicate term: {0}"' line);  			}  		} else if (fields.Length >= 2) {  			// Loading entry in "term;freq" format  			word = fields [0].Trim ();  			if (!this.ContainsKey (word)) {  				this.Add (word' new int[] {  					id++'  					int.Parse (fields [1])  				});  			} else {  				//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  				duplicateNum++;  				this [word] [1] += int.Parse (fields [1]);  			}  		}  	} catch (Exception exc) {  		Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  		errorNum++;  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	try {  		fields = line.Split (';');  		if (idFormat && fields.Length >= 3) {  			// Loading entry in "id;term;freq" format  			if (!this.ContainsKey (fields [1])) {  				this.Add (fields [1].Trim ()' new int[] {  					int.Parse (fields [0])'  					int.Parse (fields [2])  				});  			} else {  				//Console.WriteLine("Duplicate term: {0}"' line);  			}  		} else if (fields.Length >= 2) {  			// Loading entry in "term;freq" format  			word = fields [0].Trim ();  			if (!this.ContainsKey (word)) {  				this.Add (word' new int[] {  					id++'  					int.Parse (fields [1])  				});  			} else {  				//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  				duplicateNum++;  				this [word] [1] += int.Parse (fields [1]);  			}  		}  	} catch (Exception exc) {  		Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  		errorNum++;  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: try {  	fields = line.Split (';');  	if (idFormat && fields.Length >= 3) {  		// Loading entry in "id;term;freq" format  		if (!this.ContainsKey (fields [1])) {  			this.Add (fields [1].Trim ()' new int[] {  				int.Parse (fields [0])'  				int.Parse (fields [2])  			});  		} else {  			//Console.WriteLine("Duplicate term: {0}"' line);  		}  	} else if (fields.Length >= 2) {  		// Loading entry in "term;freq" format  		word = fields [0].Trim ();  		if (!this.ContainsKey (word)) {  			this.Add (word' new int[] {  				id++'  				int.Parse (fields [1])  			});  		} else {  			//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  			duplicateNum++;  			this [word] [1] += int.Parse (fields [1]);  		}  	}  } catch (Exception exc) {  	Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  	errorNum++;  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: try {  	fields = line.Split (';');  	if (idFormat && fields.Length >= 3) {  		// Loading entry in "id;term;freq" format  		if (!this.ContainsKey (fields [1])) {  			this.Add (fields [1].Trim ()' new int[] {  				int.Parse (fields [0])'  				int.Parse (fields [2])  			});  		} else {  			//Console.WriteLine("Duplicate term: {0}"' line);  		}  	} else if (fields.Length >= 2) {  		// Loading entry in "term;freq" format  		word = fields [0].Trim ();  		if (!this.ContainsKey (word)) {  			this.Add (word' new int[] {  				id++'  				int.Parse (fields [1])  			});  		} else {  			//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  			duplicateNum++;  			this [word] [1] += int.Parse (fields [1]);  		}  	}  } catch (Exception exc) {  	Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  	errorNum++;  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: try {  	fields = line.Split (';');  	if (idFormat && fields.Length >= 3) {  		// Loading entry in "id;term;freq" format  		if (!this.ContainsKey (fields [1])) {  			this.Add (fields [1].Trim ()' new int[] {  				int.Parse (fields [0])'  				int.Parse (fields [2])  			});  		} else {  			//Console.WriteLine("Duplicate term: {0}"' line);  		}  	} else if (fields.Length >= 2) {  		// Loading entry in "term;freq" format  		word = fields [0].Trim ();  		if (!this.ContainsKey (word)) {  			this.Add (word' new int[] {  				id++'  				int.Parse (fields [1])  			});  		} else {  			//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  			duplicateNum++;  			this [word] [1] += int.Parse (fields [1]);  		}  	}  } catch (Exception exc) {  	Console.WriteLine ("Error when loading line '{0}': '{1}'."' line' exc.Message);  	errorNum++;  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: if (idFormat && fields.Length >= 3) {  	// Loading entry in "id;term;freq" format  	if (!this.ContainsKey (fields [1])) {  		this.Add (fields [1].Trim ()' new int[] {  			int.Parse (fields [0])'  			int.Parse (fields [2])  		});  	} else {  		//Console.WriteLine("Duplicate term: {0}"' line);  	}  } else if (fields.Length >= 2) {  	// Loading entry in "term;freq" format  	word = fields [0].Trim ();  	if (!this.ContainsKey (word)) {  		this.Add (word' new int[] {  			id++'  			int.Parse (fields [1])  		});  	} else {  		//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  		duplicateNum++;  		this [word] [1] += int.Parse (fields [1]);  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: if (idFormat && fields.Length >= 3) {  	// Loading entry in "id;term;freq" format  	if (!this.ContainsKey (fields [1])) {  		this.Add (fields [1].Trim ()' new int[] {  			int.Parse (fields [0])'  			int.Parse (fields [2])  		});  	} else {  		//Console.WriteLine("Duplicate term: {0}"' line);  	}  } else if (fields.Length >= 2) {  	// Loading entry in "term;freq" format  	word = fields [0].Trim ();  	if (!this.ContainsKey (word)) {  		this.Add (word' new int[] {  			id++'  			int.Parse (fields [1])  		});  	} else {  		//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  		duplicateNum++;  		this [word] [1] += int.Parse (fields [1]);  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: if (idFormat && fields.Length >= 3) {  	// Loading entry in "id;term;freq" format  	if (!this.ContainsKey (fields [1])) {  		this.Add (fields [1].Trim ()' new int[] {  			int.Parse (fields [0])'  			int.Parse (fields [2])  		});  	} else {  		//Console.WriteLine("Duplicate term: {0}"' line);  	}  } else if (fields.Length >= 2) {  	// Loading entry in "term;freq" format  	word = fields [0].Trim ();  	if (!this.ContainsKey (word)) {  		this.Add (word' new int[] {  			id++'  			int.Parse (fields [1])  		});  	} else {  		//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  		duplicateNum++;  		this [word] [1] += int.Parse (fields [1]);  	}  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: if (!this.ContainsKey (fields [1])) {  	this.Add (fields [1].Trim ()' new int[] {  		int.Parse (fields [0])'  		int.Parse (fields [2])  	});  } else {  	//Console.WriteLine("Duplicate term: {0}"' line);  }  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: this.Add (fields [1].Trim ()' new int[] {  	int.Parse (fields [0])'  	int.Parse (fields [2])  });  
Magic Number,AuthecoLib,IVocabulary,F:\newReposMay17\cental_PatternSim\rank\src\IVocabulary.cs,IVocabulary,The following statement contains a magic number: if (fields.Length >= 2) {  	// Loading entry in "term;freq" format  	word = fields [0].Trim ();  	if (!this.ContainsKey (word)) {  		this.Add (word' new int[] {  			id++'  			int.Parse (fields [1])  		});  	} else {  		//Console.WriteLine ("Duplicate terms: '{0}' and '{1}'"' word' fields [0]);  		duplicateNum++;  		this [word] [1] += int.Parse (fields [1]);  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,load,The following statement contains a magic number: using (CsvReader csv = new CsvReader (new StreamReader (input' Encoding.UTF8)' true' ';')) {  	int fieldCount = csv.FieldCount;  	//string[] headers = csv.GetFieldHeaders();  	// Read file with relations line by line  	while (csv.ReadNextRecord ()) {  		// Try to add an entry  		try {  			// Read the fields                          			target = csv [TARGET_FIELD].Trim ().ToLower ();  			relatum = csv [RELATUM_FIELD].Trim ().ToLower ();  			sim = (double.TryParse (csv [SUM_FIELD]' out sim) ? sim : 0);  			patterns = 0;  			for (int i = PATTERN_FIRST_FIELD; i < fieldCount; i++) {  				patternN = (int.TryParse (csv [i]' out patternN) ? patternN : 0);  				if (patternN > 0)  					patterns++;  			}  			// Add the word pair to the dictionary  			this.add (target' relatum' sim' patterns);  			// We assume that the input file contains symmetric relations                       			//Console.WriteLine("{0}\t{1}\t{2}\t{3}"' target' relatum' sim' patterns);  			if (addSymmetric)  				this.add (relatum' target' sim' patterns);  		} catch (Exception exc) {  			Console.WriteLine ("{0}\t{1}"' csv [0] + ";" + csv [1] + ";" + csv [2]' exc.Message);  		}  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,load,The following statement contains a magic number: while (csv.ReadNextRecord ()) {  	// Try to add an entry  	try {  		// Read the fields                          		target = csv [TARGET_FIELD].Trim ().ToLower ();  		relatum = csv [RELATUM_FIELD].Trim ().ToLower ();  		sim = (double.TryParse (csv [SUM_FIELD]' out sim) ? sim : 0);  		patterns = 0;  		for (int i = PATTERN_FIRST_FIELD; i < fieldCount; i++) {  			patternN = (int.TryParse (csv [i]' out patternN) ? patternN : 0);  			if (patternN > 0)  				patterns++;  		}  		// Add the word pair to the dictionary  		this.add (target' relatum' sim' patterns);  		// We assume that the input file contains symmetric relations                       		//Console.WriteLine("{0}\t{1}\t{2}\t{3}"' target' relatum' sim' patterns);  		if (addSymmetric)  			this.add (relatum' target' sim' patterns);  	} catch (Exception exc) {  		Console.WriteLine ("{0}\t{1}"' csv [0] + ";" + csv [1] + ";" + csv [2]' exc.Message);  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,load,The following statement contains a magic number: try {  	// Read the fields                          	target = csv [TARGET_FIELD].Trim ().ToLower ();  	relatum = csv [RELATUM_FIELD].Trim ().ToLower ();  	sim = (double.TryParse (csv [SUM_FIELD]' out sim) ? sim : 0);  	patterns = 0;  	for (int i = PATTERN_FIRST_FIELD; i < fieldCount; i++) {  		patternN = (int.TryParse (csv [i]' out patternN) ? patternN : 0);  		if (patternN > 0)  			patterns++;  	}  	// Add the word pair to the dictionary  	this.add (target' relatum' sim' patterns);  	// We assume that the input file contains symmetric relations                       	//Console.WriteLine("{0}\t{1}\t{2}\t{3}"' target' relatum' sim' patterns);  	if (addSymmetric)  		this.add (relatum' target' sim' patterns);  } catch (Exception exc) {  	Console.WriteLine ("{0}\t{1}"' csv [0] + ";" + csv [1] + ";" + csv [2]' exc.Message);  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,load,The following statement contains a magic number: Console.WriteLine ("{0}\t{1}"' csv [0] + ";" + csv [1] + ";" + csv [2]' exc.Message);  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,randomTermInteractive,The following statement contains a magic number: while (true) {  	// Read a term  	Console.Write ("\nEnter term:");  	string term = Console.ReadLine ();  	if (!_shuffledVocabulary.Contains (term)) {  		Console.WriteLine ("Warning: term {0} is not in the vocabulary."' term);  	}  	// Generate random word unrelated with the term  	List<string> randomlist = getRandomWords (term);  	for (int i = 0; i < Math.Min (randomlist.Count' 20); i++) {  		Console.WriteLine (randomlist [i]);  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,randomTermInteractive,The following statement contains a magic number: for (int i = 0; i < Math.Min (randomlist.Count' 20); i++) {  	Console.WriteLine (randomlist [i]);  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRfreq,The following statement contains a magic number: foreach (var target in this) {  	foreach (var relatum in target.Value) {  		if (relationsFreq.ContainsKey (target.Key) && relationsFreq.ContainsKey (relatum.Key)) {  			targetRfreq = relationsFreq [target.Key];  			relatumRfreq = relationsFreq [relatum.Key];  		} else if (relationsFreq.ContainsKey (target.Key)) {  			Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  			targetRfreq = relationsFreq [target.Key];  			relatumRfreq = targetRfreq;  		} else {  			Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  			targetRfreq = prevRfreq;  			relatumRfreq = prevRfreq;  		}  		relatum.Value.sim = 2 * alpha * relatum.Value.sim / (targetRfreq + relatumRfreq);  		prevRfreq = targetRfreq;  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRfreq,The following statement contains a magic number: foreach (var relatum in target.Value) {  	if (relationsFreq.ContainsKey (target.Key) && relationsFreq.ContainsKey (relatum.Key)) {  		targetRfreq = relationsFreq [target.Key];  		relatumRfreq = relationsFreq [relatum.Key];  	} else if (relationsFreq.ContainsKey (target.Key)) {  		Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  		targetRfreq = relationsFreq [target.Key];  		relatumRfreq = targetRfreq;  	} else {  		Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  		targetRfreq = prevRfreq;  		relatumRfreq = prevRfreq;  	}  	relatum.Value.sim = 2 * alpha * relatum.Value.sim / (targetRfreq + relatumRfreq);  	prevRfreq = targetRfreq;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRfreq,The following statement contains a magic number: relatum.Value.sim = 2 * alpha * relatum.Value.sim / (targetRfreq + relatumRfreq);  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRnum,The following statement contains a magic number: foreach (var target in this) {  	foreach (var relatum in target.Value) {  		if (relationsNum.ContainsKey (target.Key) && relationsNum.ContainsKey (relatum.Key)) {  			targetRnum = relationsNum [target.Key];  			relatumRnum = relationsNum [relatum.Key];  		} else if (relationsNum.ContainsKey (target.Key)) {  			Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  			targetRnum = relationsNum [target.Key];  			relatumRnum = targetRnum;  		} else {  			Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  			targetRnum = prevRnum;  			relatumRnum = prevRnum;  		}  		relatum.Value.sim = 2 * meanNums * relatum.Value.sim / (targetRnum + relatumRnum);  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRnum,The following statement contains a magic number: foreach (var relatum in target.Value) {  	if (relationsNum.ContainsKey (target.Key) && relationsNum.ContainsKey (relatum.Key)) {  		targetRnum = relationsNum [target.Key];  		relatumRnum = relationsNum [relatum.Key];  	} else if (relationsNum.ContainsKey (target.Key)) {  		Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  		targetRnum = relationsNum [target.Key];  		relatumRnum = targetRnum;  	} else {  		Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  		targetRnum = prevRnum;  		relatumRnum = prevRnum;  	}  	relatum.Value.sim = 2 * meanNums * relatum.Value.sim / (targetRnum + relatumRnum);  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqRnum,The following statement contains a magic number: relatum.Value.sim = 2 * meanNums * relatum.Value.sim / (targetRnum + relatumRnum);  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 1) {  	double targetFreq = 0;  	double relatumFreq = 0;  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetFreq = (corpusFreq.ContainsKey (target.Key) ? corpusFreq [target.Key] [IVocabulary.FREQ] : meanFreq);  			relatumFreq = (corpusFreq.ContainsKey (relatum.Key) ? corpusFreq [relatum.Key] [IVocabulary.FREQ] : meanFreq);  			if (corpusFreq.ContainsKey (relatum.Key) || corpusFreq.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetFreq + relatumFreq);  		}  	}  } else if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 1) {  	double targetFreq = 0;  	double relatumFreq = 0;  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetFreq = (corpusFreq.ContainsKey (target.Key) ? corpusFreq [target.Key] [IVocabulary.FREQ] : meanFreq);  			relatumFreq = (corpusFreq.ContainsKey (relatum.Key) ? corpusFreq [relatum.Key] [IVocabulary.FREQ] : meanFreq);  			if (corpusFreq.ContainsKey (relatum.Key) || corpusFreq.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetFreq + relatumFreq);  		}  	}  } else if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 1) {  	double targetFreq = 0;  	double relatumFreq = 0;  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetFreq = (corpusFreq.ContainsKey (target.Key) ? corpusFreq [target.Key] [IVocabulary.FREQ] : meanFreq);  			relatumFreq = (corpusFreq.ContainsKey (relatum.Key) ? corpusFreq [relatum.Key] [IVocabulary.FREQ] : meanFreq);  			if (corpusFreq.ContainsKey (relatum.Key) || corpusFreq.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetFreq + relatumFreq);  		}  	}  } else if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 2 || type == 3) {  	double targetProb = 0;  	double relatumProb = 0;  	double meanProb = meanFreq / corpusFreq.getTokensNum ();  	var corpusProb = corpusFreq.getProb ();  	this.normProb ();  	foreach (var target in this) {  		foreach (var relatum in target.Value) {  			targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  			relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  			if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  				missingWordsNum++;  			relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  			if (type == 3)  				relatum.Value.sim = -Math.Log (relatum.Value.sim);  		}  	}  } else {  	Console.WriteLine ("Error: wrong type of normalization.");  	return;  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: foreach (var target in this) {  	foreach (var relatum in target.Value) {  		targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  		relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  		if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  			missingWordsNum++;  		relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  		if (type == 3)  			relatum.Value.sim = -Math.Log (relatum.Value.sim);  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: foreach (var relatum in target.Value) {  	targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  	relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  	if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  		missingWordsNum++;  	relatum.Value.sim = relatum.Value.sim / (targetProb + relatumProb);  	if (type == 3)  		relatum.Value.sim = -Math.Log (relatum.Value.sim);  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreq,The following statement contains a magic number: if (type == 3)  	relatum.Value.sim = -Math.Log (relatum.Value.sim);  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreqRnum,The following statement contains a magic number: foreach (var target in this) {  	foreach (var relatum in target.Value) {  		targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  		relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  		if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  			missingWordsNum++;  		if (relationsNum.ContainsKey (target.Key) && relationsNum.ContainsKey (relatum.Key)) {  			targetRnum = relationsNum [target.Key];  			relatumRnum = relationsNum [relatum.Key];  		} else if (relationsNum.ContainsKey (target.Key)) {  			Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  			targetRnum = relationsNum [target.Key];  			relatumRnum = targetRnum;  		} else {  			Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  			targetRnum = prevRnum;  			relatumRnum = prevRnum;  		}  		relatum.Value.sim = (2 * meanBranchesNum / (targetRnum + relatumRnum)) * (relatum.Value.sim / (targetProb + relatumProb));  	}  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreqRnum,The following statement contains a magic number: foreach (var relatum in target.Value) {  	targetProb = (corpusProb.ContainsKey (target.Key) ? corpusProb [target.Key] : meanProb);  	relatumProb = (corpusProb.ContainsKey (relatum.Key) ? corpusProb [relatum.Key] : meanProb);  	if (corpusProb.ContainsKey (relatum.Key) || corpusProb.ContainsKey (target.Key))  		missingWordsNum++;  	if (relationsNum.ContainsKey (target.Key) && relationsNum.ContainsKey (relatum.Key)) {  		targetRnum = relationsNum [target.Key];  		relatumRnum = relationsNum [relatum.Key];  	} else if (relationsNum.ContainsKey (target.Key)) {  		Console.WriteLine ("Warning: Input file is not symmetric for word '{0}'. Reranking may be wrong."' relatum.Key);  		targetRnum = relationsNum [target.Key];  		relatumRnum = targetRnum;  	} else {  		Console.WriteLine ("Error: can not compute relation frequency for the words '{0}' and {1}. Reranking may be wrong."' target.Key' relatum.Key);  		targetRnum = prevRnum;  		relatumRnum = prevRnum;  	}  	relatum.Value.sim = (2 * meanBranchesNum / (targetRnum + relatumRnum)) * (relatum.Value.sim / (targetProb + relatumProb));  }  
Magic Number,AuthecoLib,RelationsCollection,F:\newReposMay17\cental_PatternSim\rank\src\RelationsCollection.cs,rerankEfreqCfreqRnum,The following statement contains a magic number: relatum.Value.sim = (2 * meanBranchesNum / (targetRnum + relatumRnum)) * (relatum.Value.sim / (targetProb + relatumProb));  
Magic Number,CommandLine,LongOptionParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,Parse,The following statement contains a magic number: if (!option.IsBoolean) {  	if (parts.Length == 1 && (argumentEnumerator.IsLast || !ArgumentParser.IsInputValue (argumentEnumerator.Next)))  		return ParserState.Failure;  	if (parts.Length == 2) {  		if (!option.IsArray) {  			valueSetting = option.SetValue (parts [1]' options);  			if (!valueSetting)  				this.DefineOptionThatViolatesFormat (option);  			return ArgumentParser.BooleanToParserState (valueSetting);  		}  		ArgumentParser.EnsureOptionAttributeIsArrayCompatible (option);  		var items = ArgumentParser.GetNextInputValues (argumentEnumerator);  		items.Insert (0' parts [1]);  		valueSetting = option.SetValue (items' options);  		if (!valueSetting)  			this.DefineOptionThatViolatesFormat (option);  		return ArgumentParser.BooleanToParserState (valueSetting);  	} else {  		if (!option.IsArray) {  			valueSetting = option.SetValue (argumentEnumerator.Next' options);  			if (!valueSetting)  				this.DefineOptionThatViolatesFormat (option);  			return ArgumentParser.BooleanToParserState (valueSetting' true);  		}  		ArgumentParser.EnsureOptionAttributeIsArrayCompatible (option);  		var items = ArgumentParser.GetNextInputValues (argumentEnumerator);  		valueSetting = option.SetValue (items' options);  		if (!valueSetting)  			this.DefineOptionThatViolatesFormat (option);  		//return ArgumentParser.BooleanToParserState(valueSetting' true);  		return ArgumentParser.BooleanToParserState (valueSetting);  	}  }  
Magic Number,CommandLine,LongOptionParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,Parse,The following statement contains a magic number: if (parts.Length == 2) {  	if (!option.IsArray) {  		valueSetting = option.SetValue (parts [1]' options);  		if (!valueSetting)  			this.DefineOptionThatViolatesFormat (option);  		return ArgumentParser.BooleanToParserState (valueSetting);  	}  	ArgumentParser.EnsureOptionAttributeIsArrayCompatible (option);  	var items = ArgumentParser.GetNextInputValues (argumentEnumerator);  	items.Insert (0' parts [1]);  	valueSetting = option.SetValue (items' options);  	if (!valueSetting)  		this.DefineOptionThatViolatesFormat (option);  	return ArgumentParser.BooleanToParserState (valueSetting);  } else {  	if (!option.IsArray) {  		valueSetting = option.SetValue (argumentEnumerator.Next' options);  		if (!valueSetting)  			this.DefineOptionThatViolatesFormat (option);  		return ArgumentParser.BooleanToParserState (valueSetting' true);  	}  	ArgumentParser.EnsureOptionAttributeIsArrayCompatible (option);  	var items = ArgumentParser.GetNextInputValues (argumentEnumerator);  	valueSetting = option.SetValue (items' options);  	if (!valueSetting)  		this.DefineOptionThatViolatesFormat (option);  	//return ArgumentParser.BooleanToParserState(valueSetting' true);  	return ArgumentParser.BooleanToParserState (valueSetting);  }  
Magic Number,CommandLine,LongOptionParser,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,Parse,The following statement contains a magic number: if (parts.Length == 2)  	return ParserState.Failure;  
Magic Number,CommandLine,OptionMap,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLine.cs,OptionMap,The following statement contains a magic number: _map = new Dictionary<string' OptionInfo> (capacity * 2' comparer);  
Magic Number,CommandLine.Text,CopyrightInfo,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,CopyrightInfo,The following statement contains a magic number: _builder = new StringBuilder (CopyrightWord.Length + author.Length + (4 * years.Length) + extraLength);  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,DefaultParsingErrorsHandler,The following statement contains a magic number: if (options.InternalLastPostParsingState.Errors.Count > 0) {  	var errors = current.RenderParsingErrorsText (options' 2);  	// indent with two spaces  	if (!string.IsNullOrEmpty (errors)) {  		current.AddPreOptionsLine (string.Concat (Environment.NewLine' current.SentenceBuilder.ErrorsHeadingText));  		//current.AddPreOptionsLine(errors);  		var lines = errors.Split (new string[] {  			Environment.NewLine  		}' StringSplitOptions.None);  		foreach (var line in lines) {  			current.AddPreOptionsLine (line);  		}  	}  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddOption,The following statement contains a magic number: if (!string.IsNullOrEmpty (option.HelpText)) {  	do {  		int wordBuffer = 0;  		var words = option.HelpText.Split (new[] {  			' '  		});  		for (int i = 0; i < words.Length; i++) {  			if (words [i].Length < (widthOfHelpText - wordBuffer)) {  				_optionsHelp.Append (words [i]);  				wordBuffer += words [i].Length;  				if ((widthOfHelpText - wordBuffer) > 1 && i != words.Length - 1) {  					_optionsHelp.Append (" ");  					wordBuffer++;  				}  			} else if (words [i].Length >= widthOfHelpText && wordBuffer == 0) {  				_optionsHelp.Append (words [i].Substring (0' widthOfHelpText));  				wordBuffer = widthOfHelpText;  				break;  			} else {  				break;  			}  		}  		option.HelpText = option.HelpText.Substring (Math.Min (wordBuffer' option.HelpText.Length)).Trim ();  		if (option.HelpText.Length > 0) {  			_optionsHelp.Append (Environment.NewLine);  			_optionsHelp.Append (new string (' '' maxLength + 6));  		}  	} while (option.HelpText.Length > widthOfHelpText);  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddOption,The following statement contains a magic number: do {  	int wordBuffer = 0;  	var words = option.HelpText.Split (new[] {  		' '  	});  	for (int i = 0; i < words.Length; i++) {  		if (words [i].Length < (widthOfHelpText - wordBuffer)) {  			_optionsHelp.Append (words [i]);  			wordBuffer += words [i].Length;  			if ((widthOfHelpText - wordBuffer) > 1 && i != words.Length - 1) {  				_optionsHelp.Append (" ");  				wordBuffer++;  			}  		} else if (words [i].Length >= widthOfHelpText && wordBuffer == 0) {  			_optionsHelp.Append (words [i].Substring (0' widthOfHelpText));  			wordBuffer = widthOfHelpText;  			break;  		} else {  			break;  		}  	}  	option.HelpText = option.HelpText.Substring (Math.Min (wordBuffer' option.HelpText.Length)).Trim ();  	if (option.HelpText.Length > 0) {  		_optionsHelp.Append (Environment.NewLine);  		_optionsHelp.Append (new string (' '' maxLength + 6));  	}  } while (option.HelpText.Length > widthOfHelpText);  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddOption,The following statement contains a magic number: if (option.HelpText.Length > 0) {  	_optionsHelp.Append (Environment.NewLine);  	_optionsHelp.Append (new string (' '' maxLength + 6));  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,AddOption,The following statement contains a magic number: _optionsHelp.Append (new string (' '' maxLength + 6));  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: foreach (BaseOptionAttribute option in optionList) {  	int optionLength = 0;  	bool hasShort = option.HasShortName;  	bool hasLong = option.HasLongName;  	if (hasShort) {  		optionLength += option.ShortName.Length;  		if (AddDashesToOption)  			++optionLength;  	}  	if (hasLong) {  		optionLength += option.LongName.Length;  		if (AddDashesToOption)  			optionLength += 2;  	}  	if (hasShort && hasLong) {  		optionLength += 2;  		// "' "  	}  	length = Math.Max (length' optionLength);  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: foreach (BaseOptionAttribute option in optionList) {  	int optionLength = 0;  	bool hasShort = option.HasShortName;  	bool hasLong = option.HasLongName;  	if (hasShort) {  		optionLength += option.ShortName.Length;  		if (AddDashesToOption)  			++optionLength;  	}  	if (hasLong) {  		optionLength += option.LongName.Length;  		if (AddDashesToOption)  			optionLength += 2;  	}  	if (hasShort && hasLong) {  		optionLength += 2;  		// "' "  	}  	length = Math.Max (length' optionLength);  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: if (hasLong) {  	optionLength += option.LongName.Length;  	if (AddDashesToOption)  		optionLength += 2;  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: if (AddDashesToOption)  	optionLength += 2;  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: optionLength += 2;  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: if (hasShort && hasLong) {  	optionLength += 2;  	// "' "  }  
Magic Number,CommandLine.Text,HelpText,F:\newReposMay17\cental_PatternSim\rank\src\lib\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: optionLength += 2;  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: if (!_initialized) {  	_buffer = new char[_bufferSize];  	// will be replaced if and when headers are read  	_fieldHeaders = new string[0];  	if (!ReadBuffer ())  		return false;  	if (!SkipEmptyAndCommentedLines (ref _nextFieldStart))  		return false;  	// Keep growing _fields array until the last field has been found  	// and then resize it to its final correct size  	_fieldCount = 0;  	_fields = new string[16];  	while (ReadField (_fieldCount' true' false) != null) {  		if (_parseErrorFlag) {  			_fieldCount = 0;  			Array.Clear (_fields' 0' _fields.Length);  			_parseErrorFlag = false;  			_nextFieldIndex = 0;  		} else {  			_fieldCount++;  			if (_fieldCount == _fields.Length)  				Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  		}  	}  	// _fieldCount contains the last field index' but it must contains the field count'  	// so increment by 1  	_fieldCount++;  	if (_fields.Length != _fieldCount)  		Array.Resize<string> (ref _fields' _fieldCount);  	_initialized = true;  	// If headers are present' call ReadNextRecord again  	if (_hasHeaders) {  		// Don't count first record as it was the headers  		_currentRecordIndex = -1;  		_firstRecordInCache = false;  		_fieldHeaders = new string[_fieldCount];  		_fieldHeaderIndexes = new Dictionary<string' int> (_fieldCount' _fieldHeaderComparer);  		for (int i = 0; i < _fields.Length; i++) {  			string headerName = _fields [i];  			if (string.IsNullOrEmpty (headerName) || headerName.Trim ().Length == 0)  				headerName = this.DefaultHeaderName + i.ToString ();  			_fieldHeaders [i] = headerName;  			_fieldHeaderIndexes.Add (headerName' i);  		}  		// Proceed to first record  		if (!onlyReadHeaders) {  			// Calling again ReadNextRecord() seems to be simpler'   			// but in fact would probably cause many subtle bugs because a derived class does not expect a recursive behavior  			// so simply do what is needed here and no more.  			if (!SkipEmptyAndCommentedLines (ref _nextFieldStart))  				return false;  			Array.Clear (_fields' 0' _fields.Length);  			_nextFieldIndex = 0;  			_eol = false;  			_currentRecordIndex++;  			return true;  		}  	} else {  		if (onlyReadHeaders) {  			_firstRecordInCache = true;  			_currentRecordIndex = -1;  		} else {  			_firstRecordInCache = false;  			_currentRecordIndex = 0;  		}  	}  } else {  	if (skipToNextLine)  		SkipToNextLine (ref _nextFieldStart);  	else if (_currentRecordIndex > -1 && !_missingFieldFlag) {  		// If not already at end of record' move there  		if (!_eol && !_eof) {  			if (!_supportsMultiline)  				SkipToNextLine (ref _nextFieldStart);  			else {  				// a dirty trick to handle the case where extra fields are present  				while (ReadField (_nextFieldIndex' true' true) != null) {  				}  			}  		}  	}  	if (!_firstRecordInCache && !SkipEmptyAndCommentedLines (ref _nextFieldStart))  		return false;  	if (_hasHeaders || !_firstRecordInCache)  		_eol = false;  	// Check to see if the first record is in cache.  	// This can happen when initializing a reader with no headers  	// because one record must be read to get the field count automatically  	if (_firstRecordInCache)  		_firstRecordInCache = false;  	else {  		Array.Clear (_fields' 0' _fields.Length);  		_nextFieldIndex = 0;  	}  	_missingFieldFlag = false;  	_parseErrorFlag = false;  	_currentRecordIndex++;  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: if (!_initialized) {  	_buffer = new char[_bufferSize];  	// will be replaced if and when headers are read  	_fieldHeaders = new string[0];  	if (!ReadBuffer ())  		return false;  	if (!SkipEmptyAndCommentedLines (ref _nextFieldStart))  		return false;  	// Keep growing _fields array until the last field has been found  	// and then resize it to its final correct size  	_fieldCount = 0;  	_fields = new string[16];  	while (ReadField (_fieldCount' true' false) != null) {  		if (_parseErrorFlag) {  			_fieldCount = 0;  			Array.Clear (_fields' 0' _fields.Length);  			_parseErrorFlag = false;  			_nextFieldIndex = 0;  		} else {  			_fieldCount++;  			if (_fieldCount == _fields.Length)  				Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  		}  	}  	// _fieldCount contains the last field index' but it must contains the field count'  	// so increment by 1  	_fieldCount++;  	if (_fields.Length != _fieldCount)  		Array.Resize<string> (ref _fields' _fieldCount);  	_initialized = true;  	// If headers are present' call ReadNextRecord again  	if (_hasHeaders) {  		// Don't count first record as it was the headers  		_currentRecordIndex = -1;  		_firstRecordInCache = false;  		_fieldHeaders = new string[_fieldCount];  		_fieldHeaderIndexes = new Dictionary<string' int> (_fieldCount' _fieldHeaderComparer);  		for (int i = 0; i < _fields.Length; i++) {  			string headerName = _fields [i];  			if (string.IsNullOrEmpty (headerName) || headerName.Trim ().Length == 0)  				headerName = this.DefaultHeaderName + i.ToString ();  			_fieldHeaders [i] = headerName;  			_fieldHeaderIndexes.Add (headerName' i);  		}  		// Proceed to first record  		if (!onlyReadHeaders) {  			// Calling again ReadNextRecord() seems to be simpler'   			// but in fact would probably cause many subtle bugs because a derived class does not expect a recursive behavior  			// so simply do what is needed here and no more.  			if (!SkipEmptyAndCommentedLines (ref _nextFieldStart))  				return false;  			Array.Clear (_fields' 0' _fields.Length);  			_nextFieldIndex = 0;  			_eol = false;  			_currentRecordIndex++;  			return true;  		}  	} else {  		if (onlyReadHeaders) {  			_firstRecordInCache = true;  			_currentRecordIndex = -1;  		} else {  			_firstRecordInCache = false;  			_currentRecordIndex = 0;  		}  	}  } else {  	if (skipToNextLine)  		SkipToNextLine (ref _nextFieldStart);  	else if (_currentRecordIndex > -1 && !_missingFieldFlag) {  		// If not already at end of record' move there  		if (!_eol && !_eof) {  			if (!_supportsMultiline)  				SkipToNextLine (ref _nextFieldStart);  			else {  				// a dirty trick to handle the case where extra fields are present  				while (ReadField (_nextFieldIndex' true' true) != null) {  				}  			}  		}  	}  	if (!_firstRecordInCache && !SkipEmptyAndCommentedLines (ref _nextFieldStart))  		return false;  	if (_hasHeaders || !_firstRecordInCache)  		_eol = false;  	// Check to see if the first record is in cache.  	// This can happen when initializing a reader with no headers  	// because one record must be read to get the field count automatically  	if (_firstRecordInCache)  		_firstRecordInCache = false;  	else {  		Array.Clear (_fields' 0' _fields.Length);  		_nextFieldIndex = 0;  	}  	_missingFieldFlag = false;  	_parseErrorFlag = false;  	_currentRecordIndex++;  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: _fields = new string[16];  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: while (ReadField (_fieldCount' true' false) != null) {  	if (_parseErrorFlag) {  		_fieldCount = 0;  		Array.Clear (_fields' 0' _fields.Length);  		_parseErrorFlag = false;  		_nextFieldIndex = 0;  	} else {  		_fieldCount++;  		if (_fieldCount == _fields.Length)  			Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  	}  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: if (_parseErrorFlag) {  	_fieldCount = 0;  	Array.Clear (_fields' 0' _fields.Length);  	_parseErrorFlag = false;  	_nextFieldIndex = 0;  } else {  	_fieldCount++;  	if (_fieldCount == _fields.Length)  		Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: if (_fieldCount == _fields.Length)  	Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,ReadNextRecord,The following statement contains a magic number: Array.Resize<string> (ref _fields' (_fieldCount + 1) * 2);  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columnNames.Length; i++) {  	schemaRow [1] = columnNames [i];  	// Base column name  	schemaRow [4] = columnNames [i];  	// Column name  	schemaRow [5] = i;  	// Column ordinal  	schema.Rows.Add (schemaRow);  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columnNames.Length; i++) {  	schemaRow [1] = columnNames [i];  	// Base column name  	schemaRow [4] = columnNames [i];  	// Column name  	schemaRow [5] = i;  	// Column ordinal  	schema.Rows.Add (schemaRow);  }  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetSchemaTable,The following statement contains a magic number: schemaRow [4] = columnNames [i];  
Magic Number,LumenWorks.Framework.IO.Csv,CsvReader,F:\newReposMay17\cental_PatternSim\rank\src\lib\LumenWorks.Framework.IO\Csv\CsvReader.DataReaderValidations.cs,GetSchemaTable,The following statement contains a magic number: schemaRow [5] = i;  
