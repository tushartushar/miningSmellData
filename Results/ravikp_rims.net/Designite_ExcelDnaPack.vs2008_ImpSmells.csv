Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The method has 379 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The method has 138 lines of code.
Long Method,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,Main,The method has 104 lines of code.
Long Method,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The method has 121 lines of code.
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 23
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,Cyclomatic complexity of the method is 13
Complex Method,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 16
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 80
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 26
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,FillDistancesPrices,Cyclomatic complexity of the method is 11
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 36
Complex Method,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,Main,Cyclomatic complexity of the method is 18
Complex Method,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,Cyclomatic complexity of the method is 29
Long Parameter List,SevenZip,ICoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\ICoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters.
Long Statement,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The length of the statement  "		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The length of the statement  "			UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,ReadMatchDistances,The length of the statement  "			lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes); " is 121.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetRepLen1Price,The length of the statement  "	return _isRepG0 [state.Index].GetPrice0 () + _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 (); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosLenPrice,The length of the statement  "		price = _posSlotPrices [(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2 (pos)] + _alignPrices [pos & Base.kAlignMask]; " is 124.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "	_optimum [1].Price = _isMatch [(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _previousByte).GetPrice (!_state.IsCharState ()' matchByte' currentByte); " is 214.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "		UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte); " is 244.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "				UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 (); " is 162.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 433.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 366.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "			_posSlotPrices [st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 126.
Long Statement,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,Main,The length of the statement  "			Console.Write ("Existing output .xll file " + xllOutputPath + "could not be deleted. (Perhaps loaded in Excel?)\r\n\r\nExiting ExcelDnaPack."); " is 143.
Long Statement,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The length of the statement  "			string name = Path.GetFileNameWithoutExtension (path).ToUpperInvariant () + "_" + lastPackIndex++ + Path.GetExtension (path).ToUpperInvariant (); " is 145.
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,CRC,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	if ((r & 1) != 0)  		r = (r >> 1) ^ kPoly;  	else  		r >>= 1;  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ b)] ^ (_value >> 8);  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  	_value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZip,CRC,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\CRC.cs,Update,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: kNumHashDirectBytes = 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 2 + 1;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  	throw new Exception ();  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  	_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Create,The following statement contains a magic number: if (hs > (1 << 24))  	hs >>= 1;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch2 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  		distances [offset++] = maxLen = 2;  		distances [offset++] = _pos - curMatch2 - 1;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  	distances [offset++] = maxLen = 2;  	distances [offset++] = _pos - curMatch2 - 1;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 == curMatch2)  	offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 3;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (offset != 0 && curMatch2 == curMatch) {  	offset -= 2;  	maxLen = kStartMaxLen;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks (_son' _cyclicBufferSize * 2' subValue);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  	m_DictionarySize = dictionarySize;  	m_DictionarySizeCheck = Math.Max (m_DictionarySize' 1);  	uint blockSize = Math.Max (m_DictionarySizeCheck' (1 << 12));  	m_OutWindow.Create (blockSize);  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  	// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  	// while(nowPos64 < next)  	{  		uint posState = (uint)nowPos64 & m_PosStateMask;  		if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			byte b;  			byte prevByte = m_OutWindow.GetByte (0);  			if (!state.IsCharState ())  				b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  			else  				b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  			m_OutWindow.PutByte (b);  			state.UpdateChar ();  			nowPos64++;  		}  		else {  			uint len;  			if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  				if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  					if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  						state.UpdateShortRep ();  						m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  						nowPos64++;  						continue;  					}  				}  				else {  					UInt32 distance;  					if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  						distance = rep1;  					}  					else {  						if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  							distance = rep2;  						else {  							distance = rep3;  							rep3 = rep2;  						}  						rep2 = rep1;  					}  					rep1 = rep0;  					rep0 = distance;  				}  				len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  				state.UpdateRep ();  			}  			else {  				rep3 = rep2;  				rep2 = rep1;  				rep1 = rep0;  				len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  				state.UpdateMatch ();  				uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  				if (posSlot >= Base.kStartPosModelIndex) {  					int numDirectBits = (int)((posSlot >> 1) - 1);  					rep0 = ((2 | (posSlot & 1)) << numDirectBits);  					if (posSlot < Base.kEndPosModelIndex)  						rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  					else {  						rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  						rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  					}  				}  				else  					rep0 = posSlot;  			}  			if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  				if (rep0 == 0xFFFFFFFF)  					break;  				throw new DataErrorException ();  			}  			m_OutWindow.CopyBlock (rep0' len);  			nowPos64 += len;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  	byte b;  	byte prevByte = m_OutWindow.GetByte (0);  	if (!state.IsCharState ())  		b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  	else  		b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  	m_OutWindow.PutByte (b);  	state.UpdateChar ();  	nowPos64++;  }  else {  	uint len;  	if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  		if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  				state.UpdateShortRep ();  				m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  				nowPos64++;  				continue;  			}  		}  		else {  			UInt32 distance;  			if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  				distance = rep1;  			}  			else {  				if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  					distance = rep2;  				else {  					distance = rep3;  					rep3 = rep2;  				}  				rep2 = rep1;  			}  			rep1 = rep0;  			rep0 = distance;  		}  		len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  		state.UpdateRep ();  	}  	else {  		rep3 = rep2;  		rep2 = rep1;  		rep1 = rep0;  		len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  		state.UpdateMatch ();  		uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  		if (posSlot >= Base.kStartPosModelIndex) {  			int numDirectBits = (int)((posSlot >> 1) - 1);  			rep0 = ((2 | (posSlot & 1)) << numDirectBits);  			if (posSlot < Base.kEndPosModelIndex)  				rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  			else {  				rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  				rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  			}  		}  		else  			rep0 = posSlot;  	}  	if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  		if (rep0 == 0xFFFFFFFF)  			break;  		throw new DataErrorException ();  	}  	m_OutWindow.CopyBlock (rep0' len);  	nowPos64 += len;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  	if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  		if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			state.UpdateShortRep ();  			m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  			nowPos64++;  			continue;  		}  	}  	else {  		UInt32 distance;  		if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			distance = rep1;  		}  		else {  			if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  				distance = rep2;  			else {  				distance = rep3;  				rep3 = rep2;  			}  			rep2 = rep1;  		}  		rep1 = rep0;  		rep0 = distance;  	}  	len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  	state.UpdateRep ();  }  else {  	rep3 = rep2;  	rep2 = rep1;  	rep1 = rep0;  	len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  	state.UpdateMatch ();  	uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  	if (posSlot >= Base.kStartPosModelIndex) {  		int numDirectBits = (int)((posSlot >> 1) - 1);  		rep0 = ((2 | (posSlot & 1)) << numDirectBits);  		if (posSlot < Base.kEndPosModelIndex)  			rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  		else {  			rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  			rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  		}  	}  	else  		rep0 = posSlot;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int numDirectBits = (int)((posSlot >> 1) - 1);  	rep0 = ((2 | (posSlot & 1)) << numDirectBits);  	if (posSlot < Base.kEndPosModelIndex)  		rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  	else {  		rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  		rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  	}  }  else  	rep0 = posSlot;  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: rep0 = ((2 | (posSlot & 1)) << numDirectBits);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {  	UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  	for (UInt32 j = 0; j < k; j++' c++)  		g_FastPos [c] = slotFast;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  	return g_FastPos [pos];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinderType == EMatchFinderType.BT2)  	numHashBytes = 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0) {  	lenRes = _matchDistances [numDistancePairs - 2];  	if (lenRes == _numFastBytes)  		lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances [numDistancePairs - 2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0) {  	price = _isRepG0 [state.Index].GetPrice0 ();  	price += _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  }  else {  	price = _isRepG0 [state.Index].GetPrice1 ();  	if (repIndex == 1)  		price += _isRepG1 [state.Index].GetPrice0 ();  	else {  		price += _isRepG1 [state.Index].GetPrice1 ();  		price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 1)  	price += _isRepG1 [state.Index].GetPrice0 ();  else {  	price += _isRepG1 [state.Index].GetPrice1 ();  	price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2) {  	backRes = 0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2) {  	backRes = _optimum [1].BackPrev;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs2 = reps [2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs3 = reps [3];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  	_optimum [len--].Price = kIfinityPrice;  while (len >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (repLen < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (len > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (; ; len++) {  	UInt32 distance = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  	Optimal optimum = _optimum [len];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = distance + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (len == _matchDistances [offs]) {  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len == _matchDistances [offs]) {  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs2 = reps [2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs3 = reps [3];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (!nextIsChar && matchByte != currentByte) {  	// try Literal + rep0  	UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateChar ();  		UInt32 posStateNext = (position + 1) & _posStateMask;  		UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  		{  			UInt32 offset = cur + 1 + lenTest2;  			while (lenEnd < offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = false;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateChar ();  	UInt32 posStateNext = (position + 1) & _posStateMask;  	UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  	{  		UInt32 offset = cur + 1 + lenTest2;  		while (lenEnd < offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = false;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	while (lenEnd < cur + lenTest)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = repIndex;  		optimum.Prev1IsChar = false;  	}  }  while (--lenTest >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateRep ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		// for(; lenTest2 >= 2; lenTest2--)  		{  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = repIndex;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateRep ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	// for(; lenTest2 >= 2; lenTest2--)  	{  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = repIndex;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  	;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (startLen > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateMatch ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = curBack + Base.kNumRepDistances;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateMatch ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	UInt32 offset = lenTest + 1 + lenTest2;  	while (lenEnd < cur + offset)  		_optimum [++lenEnd].Price = kIfinityPrice;  	curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  	optimum = _optimum [cur + offset];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur + lenTest + 1;  		optimum.BackPrev = 0;  		optimum.Prev1IsChar = true;  		optimum.Prev2 = true;  		optimum.PosPrev2 = cur;  		optimum.BackPrev2 = curBack + Base.kNumRepDistances;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 0) {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  	if (len == 1)  		_isRep0Long [complexState].Encode (_rangeEncoder' 0);  	else  		_isRep0Long [complexState].Encode (_rangeEncoder' 1);  }  else {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 1)  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  	else {  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  		_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 1)  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  else {  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  	_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	UInt32 posReduced = pos - baseVal;  	if (posSlot < Base.kEndPosModelIndex)  		RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  	else {  		_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  		_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  		_alignPriceCount++;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_matchPriceCount >= (1 << 7))  	FillDistancesPrices ();  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  	_finished = false;  	finished = false;  	return;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {  	UInt32 posSlot = GetPosSlot (i);  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	tempPrices [i] = BitTreeEncoder.ReverseGetPrice (_posEncoders' baseVal - posSlot - 1' footerBits' i - baseVal);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: _distTableSize = (UInt32)dicLogSize * 2;  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Compress,The following statement contains a magic number: outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZip.Compression.LZMA,SevenZipHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\SevenZipHelper.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	ShiftLow ();  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: do {  	Stream.WriteByte ((byte)(temp + (Low >> 32)));  	temp = 0xFF;  }  while (--_cacheSize != 0);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte ((byte)(temp + (Low >> 32)));  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--) {  	Range >>= 1;  	if (((v >> i) & 1) == 1)  		Low += Range;  	if (Range < kTopValue) {  		Range <<= 8;  		ShiftLow ();  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: if (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue) {  	encoder.Range <<= 8;  	encoder.ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: foreach (Reference rf in refs) {  	if (rf.Pack) {  		string path = null;  		if (rf.Path != null) {  			if (rf.Path.StartsWith ("packed:")) {  				break;  			}  			path = dna.ResolvePath (rf.Path);  			Console.WriteLine ("  ~~> Assembly path {0} resolved to {1}."' rf.Path' path);  		}  		if (path == null && rf.Name != null) {  			// Try Load as as last resort (and opportunity to load by FullName)  			try {  				#pragma  				Assembly ass = Assembly.LoadWithPartialName (rf.Name);  				#pragma  				if (ass != null) {  					path = ass.Location;  					Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  				}  			}  			catch (Exception e) {  				Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  			}  		}  		if (path == null) {  			Console.WriteLine ("  ~~> Reference with Path: {0} and Name: {1} not found."' rf.Path' rf.Name);  			break;  		}  		// It worked!  		string packedName = ru.AddAssembly (path);  		if (packedName != null) {  			rf.Path = "packed:" + packedName;  		}  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: foreach (Reference rf in refs) {  	if (rf.Pack) {  		string path = null;  		if (rf.Path != null) {  			if (rf.Path.StartsWith ("packed:")) {  				break;  			}  			path = dna.ResolvePath (rf.Path);  			Console.WriteLine ("  ~~> Assembly path {0} resolved to {1}."' rf.Path' path);  		}  		if (path == null && rf.Name != null) {  			// Try Load as as last resort (and opportunity to load by FullName)  			try {  				#pragma  				Assembly ass = Assembly.LoadWithPartialName (rf.Name);  				#pragma  				if (ass != null) {  					path = ass.Location;  					Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  				}  			}  			catch (Exception e) {  				Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  			}  		}  		if (path == null) {  			Console.WriteLine ("  ~~> Reference with Path: {0} and Name: {1} not found."' rf.Path' rf.Name);  			break;  		}  		// It worked!  		string packedName = ru.AddAssembly (path);  		if (packedName != null) {  			rf.Path = "packed:" + packedName;  		}  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: if (rf.Pack) {  	string path = null;  	if (rf.Path != null) {  		if (rf.Path.StartsWith ("packed:")) {  			break;  		}  		path = dna.ResolvePath (rf.Path);  		Console.WriteLine ("  ~~> Assembly path {0} resolved to {1}."' rf.Path' path);  	}  	if (path == null && rf.Name != null) {  		// Try Load as as last resort (and opportunity to load by FullName)  		try {  			#pragma  			Assembly ass = Assembly.LoadWithPartialName (rf.Name);  			#pragma  			if (ass != null) {  				path = ass.Location;  				Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  			}  		}  		catch (Exception e) {  			Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  		}  	}  	if (path == null) {  		Console.WriteLine ("  ~~> Reference with Path: {0} and Name: {1} not found."' rf.Path' rf.Name);  		break;  	}  	// It worked!  	string packedName = ru.AddAssembly (path);  	if (packedName != null) {  		rf.Path = "packed:" + packedName;  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: if (rf.Pack) {  	string path = null;  	if (rf.Path != null) {  		if (rf.Path.StartsWith ("packed:")) {  			break;  		}  		path = dna.ResolvePath (rf.Path);  		Console.WriteLine ("  ~~> Assembly path {0} resolved to {1}."' rf.Path' path);  	}  	if (path == null && rf.Name != null) {  		// Try Load as as last resort (and opportunity to load by FullName)  		try {  			#pragma  			Assembly ass = Assembly.LoadWithPartialName (rf.Name);  			#pragma  			if (ass != null) {  				path = ass.Location;  				Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  			}  		}  		catch (Exception e) {  			Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  		}  	}  	if (path == null) {  		Console.WriteLine ("  ~~> Reference with Path: {0} and Name: {1} not found."' rf.Path' rf.Name);  		break;  	}  	// It worked!  	string packedName = ru.AddAssembly (path);  	if (packedName != null) {  		rf.Path = "packed:" + packedName;  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: if (path == null && rf.Name != null) {  	// Try Load as as last resort (and opportunity to load by FullName)  	try {  		#pragma  		Assembly ass = Assembly.LoadWithPartialName (rf.Name);  		#pragma  		if (ass != null) {  			path = ass.Location;  			Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  		}  	}  	catch (Exception e) {  		Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: if (path == null && rf.Name != null) {  	// Try Load as as last resort (and opportunity to load by FullName)  	try {  		#pragma  		Assembly ass = Assembly.LoadWithPartialName (rf.Name);  		#pragma  		if (ass != null) {  			path = ass.Location;  			Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  		}  	}  	catch (Exception e) {  		Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  	}  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: try {  	#pragma  	Assembly ass = Assembly.LoadWithPartialName (rf.Name);  	#pragma  	if (ass != null) {  		path = ass.Location;  		Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  	}  }  catch (Exception e) {  	Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  }  
Magic Number,ExcelDnaPack,PackProgram,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDnaPack\PackProgram.cs,PackDnaLibrary,The following statement contains a magic number: try {  	#pragma  	Assembly ass = Assembly.LoadWithPartialName (rf.Name);  	#pragma  	if (ass != null) {  		path = ass.Location;  		Console.WriteLine ("  ~~> Assembly {0} 'Load'ed from location {1}."' rf.Name' path);  	}  }  catch (Exception e) {  	Console.WriteLine ("  ~~> Assembly {0} not 'Load'ed. Exception: {1}"' rf.Name' e);  }  
