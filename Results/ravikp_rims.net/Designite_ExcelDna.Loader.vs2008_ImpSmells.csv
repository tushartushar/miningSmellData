Implementation smell,Namespace,Class,File,Method,Description
Long Method,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 155 lines of code.
Long Method,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The method has 256 lines of code.
Long Method,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The method has 123 lines of code.
Long Method,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,The method has 133 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo4,The method has 237 lines of code.
Long Method,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo12,The method has 236 lines of code.
Complex Method,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 16
Complex Method,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 20
Complex Method,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 53
Complex Method,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 33
Complex Method,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 8
Complex Method,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,Cyclomatic complexity of the method is 22
Complex Method,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,SetAttributeInfo,Cyclomatic complexity of the method is 15
Complex Method,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodDelegate,Cyclomatic complexity of the method is 11
Complex Method,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,XlParameterInfo,Cyclomatic complexity of the method is 8
Complex Method,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo4,Cyclomatic complexity of the method is 30
Complex Method,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo12,Cyclomatic complexity of the method is 30
Long Parameter List,SevenZip,ICoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\ICoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters.
Long Parameter List,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,AddCommandMenu,The method has 6 parameters.
Long Parameter List,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,CreateExcelReference,The method has 5 parameters.
Long Parameter List,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,ExcelReferenceAddReference,The method has 5 parameters.
Long Statement,ExcelDna.Loader,AssemblyManager,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The length of the statement  "		throw new ArgumentOutOfRangeException ("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file) and 2 (Image) are valid."); " is 136.
Long Statement,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,Dispose,The length of the statement  "	// Debug.Print("Disposing XlObjectArray12Marshaler with id {0} for thread {1}"' id' System.Threading.Thread.CurrentThread.ManagedThreadId); " is 139.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,Bind,The length of the statement  "	UnhandledExceptionHandler = integrationType.GetMethod ("HandleUnhandledException"' BindingFlags.Static | BindingFlags.NonPublic); " is 129.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoOpen,The length of the statement  "	integrationType.InvokeMember ("DnaLibraryAutoOpen"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryAutoClose,The length of the statement  "	integrationType.InvokeMember ("DnaLibraryAutoClose"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 145.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DnaLibraryGetName,The length of the statement  "	return (string)integrationType.InvokeMember ("DnaLibraryGetName"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 158.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllRegisterServer,The length of the statement  "	return (HRESULT)integrationType.InvokeMember ("DllRegisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 159.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllUnregisterServer,The length of the statement  "	return (HRESULT)integrationType.InvokeMember ("DllUnregisterServer"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 161.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The length of the statement  "	result = (HRESULT)integrationType.InvokeMember ("DllGetClassObject"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' args); " is 161.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllCanUnloadNow,The length of the statement  "	return (HRESULT)integrationType.InvokeMember ("DllCanUnloadNow"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 157.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,InitializeIntegration,The length of the statement  "	integrationType.InvokeMember ("Initialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { " is 144.
Long Statement,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DeInitializeIntegration,The length of the statement  "	integrationType.InvokeMember ("DeInitialize"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' null); " is 138.
Long Statement,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,GetCurrentSheetId12,The length of the statement  "		// CONSIDER: As a small optimisation' we could combine the two calls the xlFree. But then we'd have to manage an array here. " is 124.
Long Statement,ExcelDna.Loader,XlStringReturnMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "		Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback); " is 143.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The length of the statement  "		Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback); " is 143.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The length of the statement  "			r = IntegrationMarshalHelpers.CreateExcelReference (pAreas [0].RowFirst' pAreas [0].RowLast' pAreas [0].ColumnFirst' pAreas [0].ColumnLast' pOper->refValue.SheetId); " is 165.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The length of the statement  "				IntegrationMarshalHelpers.ExcelReferenceAddReference (r' pAreas [i].RowFirst' pAreas [i].RowLast' pAreas [i].ColumnFirst' pAreas [i].ColumnLast); " is 145.
Long Statement,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The length of the statement  "		sref = IntegrationMarshalHelpers.CreateExcelReference (pOper->srefValue.Reference.RowFirst' pOper->srefValue.Reference.RowLast' pOper->srefValue.Reference.ColumnFirst' pOper->srefValue.Reference.ColumnLast' sheetId/*Current sheet (not Active sheet!)*/); " is 253.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "					Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback); " is 143.
Long Statement,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The length of the statement  "		int cbNativeReferences = numReferenceOpers * sizeof(ushort) + numReferences * Marshal.SizeOf (typeof(XlOper.XlRectangle)); " is 122.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,Bind,The length of the statement  "	excelReferenceGetRectangleCount = excelReferenceType.GetMethod ("GetRectangleCount"' BindingFlags.NonPublic | BindingFlags.Instance); " is 133.
Long Statement,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,Bind,The length of the statement  "	excelReferenceGetRectangles = excelReferenceType.GetMethod ("GetRectangles"' BindingFlags.NonPublic | BindingFlags.Instance); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "	Debug.Print ("Initialize - in sandbox AppDomain with Id: {0}' running on thread: {1}"' AppDomain.CurrentDomain.Id' Thread.CurrentThread.ManagedThreadId); " is 153.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The length of the statement  "	// File.AppendAllText(Path.ChangeExtension(pathXll' ".log")' string.Format("{0:u} XlAddIn.Initialize OK\r\n"' DateTime.Now)); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	MethodInfo tryExcelImplMethod = typeof(XlCallImpl).GetMethod ("TryExcelImpl"' BindingFlags.Static | BindingFlags.Public); " is 121.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	integrationType.InvokeMember ("SetTryExcelImpl"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { " is 149.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	MethodInfo registerMethodsMethod = typeof(XlAddIn).GetMethod ("RegisterMethods"' BindingFlags.Static | BindingFlags.Public); " is 124.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	integrationType.InvokeMember ("SetRegisterMethods"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { " is 152.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	MethodInfo getResourceBytesMethod = typeof(AssemblyManager).GetMethod ("GetResourceBytes"' BindingFlags.Static | BindingFlags.NonPublic); " is 137.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,LoadIntegration,The length of the statement  "	integrationType.InvokeMember ("SetGetResourceBytesDelegate"' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod' null' null' new object[] { " is 161.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "	Debug.Print ("AppDomain Id: " + AppDomain.CurrentDomain.Id + " (Default: " + AppDomain.CurrentDomain.IsDefaultAppDomain () + ")"); " is 130.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "		string alertMessage = string.Format ("A problem occurred while an add-in was being initialized (InitializeIntegration failed).\r\nThe add-in is built with ExcelDna and is being loaded from {0}"' pathXll); " is 204.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The length of the statement  "		XlCallImpl.TryExcelImpl (XlCallImpl.xlcAlert' out xlCallResult/*Ignored*/' alertMessage' 3/* Only OK Button' Warning Icon*/); " is 125.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The length of the statement  "		Debug.Print ("Register - XllPath={0}' ProcName={1}' FunctionType={2}' MethodName={3} - Result={4}"' registerParameters [0]' registerParameters [1]' registerParameters [2]' registerParameters [3]' xlCallResult); " is 210.
Long Statement,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,UnregisterMethods,The length of the statement  "			XlCallImpl.TryExcelImpl (XlCallImpl.xlfRegister' out xlCallResult' pathXll' "xlAutoRemove"' "J"' mi.Name' IntegrationMarshalHelpers.GetExcelMissingValue ()' 0); " is 160.
Long Statement,ExcelDna.Loader,AppDomainHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,CreateFullTrustSandbox,The length of the statement  "		AppDomain sandbox = AppDomain.CreateDomain ("FullTrustSandbox(" + AppDomain.CurrentDomain.FriendlyName + ")"' null' sandboxAppDomainSetup' pset); " is 145.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateDelegateType,The length of the statement  "	typeBuilder = modBuilder.DefineType ("f" + Index++ + "Delegate"' TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed' typeof(System.MulticastDelegate)); " is 169.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateDelegateType,The length of the statement  "	ConstructorBuilder constructorBuilder = typeBuilder.DefineConstructor (MethodAttributes.RTSpecialName | MethodAttributes.HideBySig | MethodAttributes.Public' CallingConventions.Standard' new Type[] { " is 199.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateDelegateType,The length of the statement  "	methodBuilder = typeBuilder.DefineMethod ("Invoke"' MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual' IsCommand ? typeof(void) : ReturnType.DelegateParamType' // What here for macro? null or Void ? " is 255.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodDelegate,The length of the statement  "	DynamicMethod wrapper = new DynamicMethod (string.Format ("Wrapped_f{0}_{1}"' Index' targetMethod.Name)' IsCommand ? typeof(void) : ReturnType.DelegateParamType' paramTypes' typeof(object)' true); " is 196.
Long Statement,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,ConvertToXlMethodInfos,The length of the statement  "	assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly (new AssemblyName ("ExcelDna.DynamicDelegateAssembly")' AssemblyBuilderAccess.Run/*AndSave*/); " is 158.
Complex Conditional,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterMenu,The conditional expression  "mi.MenuName != null && mi.MenuName != "" && mi.MenuText != null && mi.MenuText != """  is complex.
Complex Conditional,ExcelDna.Loader,XlMethodInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlMethodInfo.cs,CreateMethodDelegate,The conditional expression  "IsExceptionSafe && Array.TrueForAll (Parameters' delegate (XlParameterInfo pi) {  	return pi.BoxedValueType == null;  }) && (IsCommand || ReturnType.BoxedValueType == null)"  is complex.
Empty Catch Block,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,FetchExcel12EntryPt,The method has an empty catch block.
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  	m_DictionarySize = dictionarySize;  	m_DictionarySizeCheck = Math.Max (m_DictionarySize' 1);  	uint blockSize = Math.Max (m_DictionarySizeCheck' (1 << 12));  	m_OutWindow.Create (blockSize);  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  	// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  	// while(nowPos64 < next)  	{  		uint posState = (uint)nowPos64 & m_PosStateMask;  		if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			byte b;  			byte prevByte = m_OutWindow.GetByte (0);  			if (!state.IsCharState ())  				b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  			else  				b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  			m_OutWindow.PutByte (b);  			state.UpdateChar ();  			nowPos64++;  		}  		else {  			uint len;  			if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  				if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  					if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  						state.UpdateShortRep ();  						m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  						nowPos64++;  						continue;  					}  				}  				else {  					UInt32 distance;  					if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  						distance = rep1;  					}  					else {  						if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  							distance = rep2;  						else {  							distance = rep3;  							rep3 = rep2;  						}  						rep2 = rep1;  					}  					rep1 = rep0;  					rep0 = distance;  				}  				len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  				state.UpdateRep ();  			}  			else {  				rep3 = rep2;  				rep2 = rep1;  				rep1 = rep0;  				len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  				state.UpdateMatch ();  				uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  				if (posSlot >= Base.kStartPosModelIndex) {  					int numDirectBits = (int)((posSlot >> 1) - 1);  					rep0 = ((2 | (posSlot & 1)) << numDirectBits);  					if (posSlot < Base.kEndPosModelIndex)  						rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  					else {  						rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  						rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  					}  				}  				else  					rep0 = posSlot;  			}  			if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  				if (rep0 == 0xFFFFFFFF)  					break;  				throw new DataErrorException ();  			}  			m_OutWindow.CopyBlock (rep0' len);  			nowPos64 += len;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  	byte b;  	byte prevByte = m_OutWindow.GetByte (0);  	if (!state.IsCharState ())  		b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  	else  		b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  	m_OutWindow.PutByte (b);  	state.UpdateChar ();  	nowPos64++;  }  else {  	uint len;  	if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  		if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  				state.UpdateShortRep ();  				m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  				nowPos64++;  				continue;  			}  		}  		else {  			UInt32 distance;  			if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  				distance = rep1;  			}  			else {  				if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  					distance = rep2;  				else {  					distance = rep3;  					rep3 = rep2;  				}  				rep2 = rep1;  			}  			rep1 = rep0;  			rep0 = distance;  		}  		len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  		state.UpdateRep ();  	}  	else {  		rep3 = rep2;  		rep2 = rep1;  		rep1 = rep0;  		len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  		state.UpdateMatch ();  		uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  		if (posSlot >= Base.kStartPosModelIndex) {  			int numDirectBits = (int)((posSlot >> 1) - 1);  			rep0 = ((2 | (posSlot & 1)) << numDirectBits);  			if (posSlot < Base.kEndPosModelIndex)  				rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  			else {  				rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  				rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  			}  		}  		else  			rep0 = posSlot;  	}  	if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  		if (rep0 == 0xFFFFFFFF)  			break;  		throw new DataErrorException ();  	}  	m_OutWindow.CopyBlock (rep0' len);  	nowPos64 += len;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  	if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  		if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			state.UpdateShortRep ();  			m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  			nowPos64++;  			continue;  		}  	}  	else {  		UInt32 distance;  		if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			distance = rep1;  		}  		else {  			if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  				distance = rep2;  			else {  				distance = rep3;  				rep3 = rep2;  			}  			rep2 = rep1;  		}  		rep1 = rep0;  		rep0 = distance;  	}  	len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  	state.UpdateRep ();  }  else {  	rep3 = rep2;  	rep2 = rep1;  	rep1 = rep0;  	len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  	state.UpdateMatch ();  	uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  	if (posSlot >= Base.kStartPosModelIndex) {  		int numDirectBits = (int)((posSlot >> 1) - 1);  		rep0 = ((2 | (posSlot & 1)) << numDirectBits);  		if (posSlot < Base.kEndPosModelIndex)  			rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  		else {  			rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  			rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  		}  	}  	else  		rep0 = posSlot;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int numDirectBits = (int)((posSlot >> 1) - 1);  	rep0 = ((2 | (posSlot & 1)) << numDirectBits);  	if (posSlot < Base.kEndPosModelIndex)  		rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  	else {  		rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  		rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  	}  }  else  	rep0 = posSlot;  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,Code,The following statement contains a magic number: rep0 = ((2 | (posSlot & 1)) << numDirectBits);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	ShiftLow ();  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: do {  	Stream.WriteByte ((byte)(temp + (Low >> 32)));  	temp = 0xFF;  }  while (--_cacheSize != 0);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte ((byte)(temp + (Low >> 32)));  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--) {  	Range >>= 1;  	if (((v >> i) & 1) == 1)  		Low += Range;  	if (Range < kTopValue) {  		Range <<= 8;  		ShiftLow ();  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: if (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue) {  	encoder.Range <<= 8;  	encoder.ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\..\Lzma\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,ExcelDna.Loader,AssemblyManager,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The following statement contains a magic number: if (type == 0) {  	typeName = "ASSEMBLY";  }  else if (type == 1) {  	typeName = "DNA";  }  else if (type == 2) {  	typeName = "IMAGE";  }  else {  	throw new ArgumentOutOfRangeException ("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file) and 2 (Image) are valid.");  }  
Magic Number,ExcelDna.Loader,AssemblyManager,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The following statement contains a magic number: if (type == 1) {  	typeName = "DNA";  }  else if (type == 2) {  	typeName = "IMAGE";  }  else {  	throw new ArgumentOutOfRangeException ("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file) and 2 (Image) are valid.");  }  
Magic Number,ExcelDna.Loader,AssemblyManager,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,GetResourceBytes,The following statement contains a magic number: if (type == 2) {  	typeName = "IMAGE";  }  else {  	throw new ArgumentOutOfRangeException ("type"' "Unknown resource type. Only types 0 (Assembly)' 1 (Dna file) and 2 (Image) are valid.");  }  
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,ExcelDna.Loader,ResourceHelper,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\AssemblyManager.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);  
Magic Number,ExcelDna.Loader,XlDoubleArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1") {  	if (instance1 == null) {  		instance1 = new XlDoubleArray12Marshaler (1);  	}  	return instance1;  }  else if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlDoubleArray12Marshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlDoubleArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlDoubleArray12Marshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlDoubleArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (instance2 == null)  	instance2 = new XlDoubleArray12Marshaler (2);  
Magic Number,ExcelDna.Loader,XlDoubleArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: instance2 = new XlDoubleArray12Marshaler (2);  
Magic Number,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1") {  	if (instance1 == null) {  		instance1 = new XlObjectArray12Marshaler (1);  	}  	return instance1;  }  else if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlObjectArray12Marshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlObjectArray12Marshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: if (instance2 == null)  	instance2 = new XlObjectArray12Marshaler (2);  
Magic Number,ExcelDna.Loader,XlObjectArray12Marshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal12.cs,GetInstance,The following statement contains a magic number: instance2 = new XlObjectArray12Marshaler (2);  
Magic Number,ExcelDna.Loader,IntegrationHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\IntegrationHelpers.cs,DllGetClassObject,The following statement contains a magic number: ppunk = (IntPtr)args [2];  
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: if (XlAddIn.XlCallVersion < 12) {  	return TryExcelImpl4 (xlFunction' out result' parameters);  }  
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: if (Excel12v == null) {  	FetchExcel12EntryPt ();  	if (Excel12v == null) {  		result = null;  		return 32;  		/*XlCall.XlReturn.XlReturnFailed*/}  }  
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: if (Excel12v == null) {  	result = null;  	return 32;  	/*XlCall.XlReturn.XlReturnFailed*/}  
Magic Number,ExcelDna.Loader,XlCallImpl,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCallImpl.cs,TryExcelImpl,The following statement contains a magic number: return 32;  
Magic Number,ExcelDna.Loader,XlStringReturnMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: fixed (char* psrc = str) {  	// Support for system codepage by hmd  	//int written = Encoding.ASCII.GetBytes(psrc' charCount' pdest->Data' 255);  	Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  	int written = enc.GetBytes (psrc' charCount' pdest->Data' 255);  	pdest->Length = (byte)written;  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1") {  	if (instance1 == null)  		instance1 = new XlDoubleArrayMarshaler (1);  	return instance1;  }  else if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlDoubleArrayMarshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlDoubleArrayMarshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (instance2 == null)  	instance2 = new XlDoubleArrayMarshaler (2);  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: instance2 = new XlDoubleArrayMarshaler (2);  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1) {  	double[] doubles = (double[])ManagedObj;  	rows = 1;  	allColumns = doubles.Length;  	columns = (ushort)Math.Min (allColumns' ushort.MaxValue);  	fixed (double* src = doubles) {  		AllocateFPAndCopy (src' rows' columns' allColumns);  	}  }  else if (rank == 2) {  	double['] doubles = (double['])ManagedObj;  	rows = (ushort)Math.Min (doubles.GetLength (0)' ushort.MaxValue);  	allColumns = doubles.GetLength (1);  	columns = (ushort)Math.Min (allColumns' ushort.MaxValue);  	fixed (double* src = doubles) {  		AllocateFPAndCopy (src' rows' columns' allColumns);  	}  }  else {  	throw new InvalidOperationException ("Damaged XlDoubleArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 2) {  	double['] doubles = (double['])ManagedObj;  	rows = (ushort)Math.Min (doubles.GetLength (0)' ushort.MaxValue);  	allColumns = doubles.GetLength (1);  	columns = (ushort)Math.Min (allColumns' ushort.MaxValue);  	fixed (double* src = doubles) {  		AllocateFPAndCopy (src' rows' columns' allColumns);  	}  }  else {  	throw new InvalidOperationException ("Damaged XlDoubleArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1) {  	double[] array;  	if (pFP->Columns == 1) {  		// Take the one and only column as the array  		array = new double[pFP->Rows];  	}  	else {  		// Take only the first row of the array.  		array = new double[pFP->Columns];  	}  	// Copy works for either case' due to in-memory layout!  	fixed (double* dest = array) {  		CopyDoubles (pFP->Values' dest' array.Length);  	}  	result = array;  }  else if (rank == 2) {  	double['] array = new double[pFP->Rows' pFP->Columns];  	fixed (double* dest = array) {  		CopyDoubles (pFP->Values' dest' array.Length);  	}  	result = array;  }  else {  	Debug.Fail ("Damaged XlDoubleArrayMarshaler rank");  	throw new InvalidOperationException ("Damaged XlDoubleArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlDoubleArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 2) {  	double['] array = new double[pFP->Rows' pFP->Columns];  	fixed (double* dest = array) {  		CopyDoubles (pFP->Values' dest' array.Length);  	}  	result = array;  }  else {  	Debug.Fail ("Damaged XlDoubleArrayMarshaler rank");  	throw new InvalidOperationException ("Damaged XlDoubleArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type) {  case XlType.XlTypeNumber:  	managed = pOper->numValue;  	break;  case XlType.XlTypeString:  	XlString* pString = pOper->pstrValue;  	// Support for system codepage by hmd  	// managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);  	Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  	managed = new string ((sbyte*)pString->Data' 0' pString->Length' enc);  	break;  case XlType.XlTypeBoolean:  	managed = pOper->boolValue == 1;  	break;  case XlType.XlTypeError:  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (pOper->errValue);  	break;  case XlType.XlTypeMissing:  	// DOCUMENT: Changed in version 0.17.  	// managed = System.Reflection.Missing.Value;  	managed = IntegrationMarshalHelpers.GetExcelMissingValue ();  	break;  case XlType.XlTypeEmpty:  	// DOCUMENT: Changed in version 0.17.  	// managed = null;  	managed = IntegrationMarshalHelpers.GetExcelEmptyValue ();  	break;  case XlType.XlTypeArray:  	int rows = pOper->arrayValue.Rows;  	int columns = pOper->arrayValue.Columns;  	object['] array = new object[rows' columns];  	XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  	for (int i = 0; i < rows; i++) {  		for (int j = 0; j < columns; j++) {  			int pos = i * columns + j;  			array [i' j] = MarshalNativeToManaged ((IntPtr)(opers + pos));  		}  	}  	managed = array;  	break;  case XlType.XlTypeInt:  	managed = (double)pOper->intValue;  	// int16 in XlOper // always return double  	break;  case XlType.XlTypeReference:  	object /*ExcelReference*/r;  	if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero) {  		r = IntegrationMarshalHelpers.CreateExcelReference (0' 0' 0' 0' pOper->refValue.SheetId);  	}  	else {  		ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  		XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));  		r = IntegrationMarshalHelpers.CreateExcelReference (pAreas [0].RowFirst' pAreas [0].RowLast' pAreas [0].ColumnFirst' pAreas [0].ColumnLast' pOper->refValue.SheetId);  		for (int i = 1; i < numAreas; i++) {  			IntegrationMarshalHelpers.ExcelReferenceAddReference (r' pAreas [i].RowFirst' pAreas [i].RowLast' pAreas [i].ColumnFirst' pAreas [i].ColumnLast);  		}  	}  	managed = r;  	break;  case XlType.XlTypeSReference:  	IntPtr sheetId = XlCallImpl.GetCurrentSheetId4 ();  	object /*ExcelReference*/sref;  	sref = IntegrationMarshalHelpers.CreateExcelReference (pOper->srefValue.Reference.RowFirst' pOper->srefValue.Reference.RowLast' pOper->srefValue.Reference.ColumnFirst' pOper->srefValue.Reference.ColumnLast' sheetId/*Current sheet (not Active sheet!)*/);  	managed = sref;  	break;  case 0:  	// We get type == 0 when a long (>255 char) string is embedded in an array.  	// To be consistent with the string handling' we set the value to #VALUE  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  	break;  default:  	// Unexpected !? (BigData perhaps - How did it get here?)  	// We do #VALUE here too' rather than set to null.  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  	break;  }  
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: switch (type) {  case XlType.XlTypeNumber:  	managed = pOper->numValue;  	break;  case XlType.XlTypeString:  	XlString* pString = pOper->pstrValue;  	// Support for system codepage by hmd  	// managed = new string((sbyte*)pString->Data' 0' pString->Length' Encoding.ASCII);  	Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  	managed = new string ((sbyte*)pString->Data' 0' pString->Length' enc);  	break;  case XlType.XlTypeBoolean:  	managed = pOper->boolValue == 1;  	break;  case XlType.XlTypeError:  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (pOper->errValue);  	break;  case XlType.XlTypeMissing:  	// DOCUMENT: Changed in version 0.17.  	// managed = System.Reflection.Missing.Value;  	managed = IntegrationMarshalHelpers.GetExcelMissingValue ();  	break;  case XlType.XlTypeEmpty:  	// DOCUMENT: Changed in version 0.17.  	// managed = null;  	managed = IntegrationMarshalHelpers.GetExcelEmptyValue ();  	break;  case XlType.XlTypeArray:  	int rows = pOper->arrayValue.Rows;  	int columns = pOper->arrayValue.Columns;  	object['] array = new object[rows' columns];  	XlOper* opers = (XlOper*)pOper->arrayValue.pOpers;  	for (int i = 0; i < rows; i++) {  		for (int j = 0; j < columns; j++) {  			int pos = i * columns + j;  			array [i' j] = MarshalNativeToManaged ((IntPtr)(opers + pos));  		}  	}  	managed = array;  	break;  case XlType.XlTypeInt:  	managed = (double)pOper->intValue;  	// int16 in XlOper // always return double  	break;  case XlType.XlTypeReference:  	object /*ExcelReference*/r;  	if (pOper->refValue.pMultiRef == (XlOper.XlMultiRef*)IntPtr.Zero) {  		r = IntegrationMarshalHelpers.CreateExcelReference (0' 0' 0' 0' pOper->refValue.SheetId);  	}  	else {  		ushort numAreas = *(ushort*)pOper->refValue.pMultiRef;  		XlOper.XlRectangle* pAreas = (XlOper.XlRectangle*)((uint)pOper->refValue.pMultiRef + sizeof(ushort));  		r = IntegrationMarshalHelpers.CreateExcelReference (pAreas [0].RowFirst' pAreas [0].RowLast' pAreas [0].ColumnFirst' pAreas [0].ColumnLast' pOper->refValue.SheetId);  		for (int i = 1; i < numAreas; i++) {  			IntegrationMarshalHelpers.ExcelReferenceAddReference (r' pAreas [i].RowFirst' pAreas [i].RowLast' pAreas [i].ColumnFirst' pAreas [i].ColumnLast);  		}  	}  	managed = r;  	break;  case XlType.XlTypeSReference:  	IntPtr sheetId = XlCallImpl.GetCurrentSheetId4 ();  	object /*ExcelReference*/sref;  	sref = IntegrationMarshalHelpers.CreateExcelReference (pOper->srefValue.Reference.RowFirst' pOper->srefValue.Reference.RowLast' pOper->srefValue.Reference.ColumnFirst' pOper->srefValue.Reference.ColumnLast' sheetId/*Current sheet (not Active sheet!)*/);  	managed = sref;  	break;  case 0:  	// We get type == 0 when a long (>255 char) string is embedded in an array.  	// To be consistent with the string handling' we set the value to #VALUE  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  	break;  default:  	// Unexpected !? (BigData perhaps - How did it get here?)  	// We do #VALUE here too' rather than set to null.  	managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  	break;  }  
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  
Magic Number,ExcelDna.Loader,XlObjectMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: managed = IntegrationMarshalHelpers.GetExcelErrorObject (15/* ExcelErrorValue */);  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "1") {  	if (instance1 == null)  		instance1 = new XlObjectArrayMarshaler (1);  	return instance1;  }  else if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlObjectArrayMarshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (marshalCookie == "2") {  	if (instance2 == null)  		instance2 = new XlObjectArrayMarshaler (2);  	return instance2;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: if (instance2 == null)  	instance2 = new XlObjectArrayMarshaler (2);  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,GetInstance,The following statement contains a magic number: instance2 = new XlObjectArrayMarshaler (2);  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 1) {  	object[] objects = (object[])ManagedObj;  	rows = 1;  	rowBase = 0;  	allColumns = objects.Length;  	columns = (ushort)Math.Min (objects.Length' ushort.MaxValue);  	columnBase = objects.GetLowerBound (0);  }  else if (rank == 2) {  	object['] objects = (object['])ManagedObj;  	rows = (ushort)Math.Min (objects.GetLength (0)' ushort.MaxValue);  	rowBase = objects.GetLowerBound (0);  	allColumns = objects.GetLength (1);  	columns = (ushort)Math.Min (objects.GetLength (1)' ushort.MaxValue);  	columnBase = objects.GetLowerBound (1);  }  else {  	throw new InvalidOperationException ("Damaged XlObjectArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rank == 2) {  	object['] objects = (object['])ManagedObj;  	rows = (ushort)Math.Min (objects.GetLength (0)' ushort.MaxValue);  	rowBase = objects.GetLowerBound (0);  	allColumns = objects.GetLength (1);  	columns = (ushort)Math.Min (objects.GetLength (1)' ushort.MaxValue);  	columnBase = objects.GetLowerBound (1);  }  else {  	throw new InvalidOperationException ("Damaged XlObjectArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++) {  	// Get the right object out of the array  	object obj;  	if (rank == 1) {  		obj = ((object[])ManagedObj) [columnBase + i];  	}  	else {  		int row = i / allColumns;  		int column = i % allColumns;  		obj = ((object['])ManagedObj) [rowBase + row' columnBase + column];  	}  	// Get the right pOper  	pOper = (XlOper*)pNative + i + 1;  	// Set up the oper from the object  	if (obj is double) {  		pOper->numValue = (double)obj;  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is string) {  		// We count all of the string lengths'   		string str = (string)obj;  		cbNativeStrings += Math.Min (str.Length' 255) + 1;  		// mark the Oper as a string' and  		// later allocate memory and return to fix pointers  		pOper->xlType = XlType.XlTypeString;  	}  	else if (obj is DateTime) {  		pOper->numValue = ((DateTime)obj).ToOADate ();  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  		pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  		pOper->xlType = XlType.XlTypeError;  	}  	else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  		pOper->xlType = XlType.XlTypeMissing;  	}  	else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  		pOper->xlType = XlType.XlTypeEmpty;  	}  	else if (obj is bool) {  		pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  		pOper->xlType = XlType.XlTypeBoolean;  	}  	else if (obj is short) {  		pOper->numValue = (double)((short)obj);  		// int16 in XlOper  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is ushort) {  		pOper->numValue = (double)((ushort)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is int) {  		pOper->numValue = (double)((int)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is decimal) {  		pOper->numValue = (double)((decimal)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  		pOper->xlType = XlType.XlTypeReference;  		// First we count all of these'   		// later allocate memory and return to fix pointers  		numReferenceOpers++;  		numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  		// ((ExcelReference)obj).InnerReferences.Count;  	}  	else if (obj is object[]) {  		XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  		nestedInstances.Add (m);  		XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  		pOper->xlType = XlType.XlTypeArray;  		pOper->arrayValue.Rows = pNested->arrayValue.Rows;  		pOper->arrayValue.Columns = pNested->arrayValue.Columns;  		pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  	}  	else if (obj is object[']) {  		XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  		nestedInstances.Add (m);  		XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  		pOper->xlType = XlType.XlTypeArray;  		pOper->arrayValue.Rows = pNested->arrayValue.Rows;  		pOper->arrayValue.Columns = pNested->arrayValue.Columns;  		pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  	}  	else if (obj is System.Reflection.Missing) {  		pOper->xlType = XlType.XlTypeMissing;  	}  	else if (obj == null) {  		// DOCUMENT: I return Empty for nulls inside the Array'   		// which is not consistent with what happens in other settings.  		// In particular not consistent with the results of the XlObjectMarshaler  		// (which is not called when a null is returned'  		// and interpreted as ExcelErrorNum in Excel)  		// This works well for xlSet though.  		// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  		// and return ErrNum here  		pOper->xlType = XlType.XlTypeEmpty;  	}  	else {  		// Default error return  		pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  		pOper->xlType = XlType.XlTypeError;  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++) {  	// Get the right object out of the array  	object obj;  	if (rank == 1) {  		obj = ((object[])ManagedObj) [columnBase + i];  	}  	else {  		int row = i / allColumns;  		int column = i % allColumns;  		obj = ((object['])ManagedObj) [rowBase + row' columnBase + column];  	}  	// Get the right pOper  	pOper = (XlOper*)pNative + i + 1;  	// Set up the oper from the object  	if (obj is double) {  		pOper->numValue = (double)obj;  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is string) {  		// We count all of the string lengths'   		string str = (string)obj;  		cbNativeStrings += Math.Min (str.Length' 255) + 1;  		// mark the Oper as a string' and  		// later allocate memory and return to fix pointers  		pOper->xlType = XlType.XlTypeString;  	}  	else if (obj is DateTime) {  		pOper->numValue = ((DateTime)obj).ToOADate ();  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  		pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  		pOper->xlType = XlType.XlTypeError;  	}  	else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  		pOper->xlType = XlType.XlTypeMissing;  	}  	else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  		pOper->xlType = XlType.XlTypeEmpty;  	}  	else if (obj is bool) {  		pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  		pOper->xlType = XlType.XlTypeBoolean;  	}  	else if (obj is short) {  		pOper->numValue = (double)((short)obj);  		// int16 in XlOper  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is ushort) {  		pOper->numValue = (double)((ushort)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is int) {  		pOper->numValue = (double)((int)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (obj is decimal) {  		pOper->numValue = (double)((decimal)obj);  		pOper->xlType = XlType.XlTypeNumber;  	}  	else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  		pOper->xlType = XlType.XlTypeReference;  		// First we count all of these'   		// later allocate memory and return to fix pointers  		numReferenceOpers++;  		numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  		// ((ExcelReference)obj).InnerReferences.Count;  	}  	else if (obj is object[]) {  		XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  		nestedInstances.Add (m);  		XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  		pOper->xlType = XlType.XlTypeArray;  		pOper->arrayValue.Rows = pNested->arrayValue.Rows;  		pOper->arrayValue.Columns = pNested->arrayValue.Columns;  		pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  	}  	else if (obj is object[']) {  		XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  		nestedInstances.Add (m);  		XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  		pOper->xlType = XlType.XlTypeArray;  		pOper->arrayValue.Rows = pNested->arrayValue.Rows;  		pOper->arrayValue.Columns = pNested->arrayValue.Columns;  		pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  	}  	else if (obj is System.Reflection.Missing) {  		pOper->xlType = XlType.XlTypeMissing;  	}  	else if (obj == null) {  		// DOCUMENT: I return Empty for nulls inside the Array'   		// which is not consistent with what happens in other settings.  		// In particular not consistent with the results of the XlObjectMarshaler  		// (which is not called when a null is returned'  		// and interpreted as ExcelErrorNum in Excel)  		// This works well for xlSet though.  		// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  		// and return ErrNum here  		pOper->xlType = XlType.XlTypeEmpty;  	}  	else {  		// Default error return  		pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  		pOper->xlType = XlType.XlTypeError;  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is double) {  	pOper->numValue = (double)obj;  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is string) {  	// We count all of the string lengths'   	string str = (string)obj;  	cbNativeStrings += Math.Min (str.Length' 255) + 1;  	// mark the Oper as a string' and  	// later allocate memory and return to fix pointers  	pOper->xlType = XlType.XlTypeString;  }  else if (obj is DateTime) {  	pOper->numValue = ((DateTime)obj).ToOADate ();  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is double) {  	pOper->numValue = (double)obj;  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is string) {  	// We count all of the string lengths'   	string str = (string)obj;  	cbNativeStrings += Math.Min (str.Length' 255) + 1;  	// mark the Oper as a string' and  	// later allocate memory and return to fix pointers  	pOper->xlType = XlType.XlTypeString;  }  else if (obj is DateTime) {  	pOper->numValue = ((DateTime)obj).ToOADate ();  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is string) {  	// We count all of the string lengths'   	string str = (string)obj;  	cbNativeStrings += Math.Min (str.Length' 255) + 1;  	// mark the Oper as a string' and  	// later allocate memory and return to fix pointers  	pOper->xlType = XlType.XlTypeString;  }  else if (obj is DateTime) {  	pOper->numValue = ((DateTime)obj).ToOADate ();  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is string) {  	// We count all of the string lengths'   	string str = (string)obj;  	cbNativeStrings += Math.Min (str.Length' 255) + 1;  	// mark the Oper as a string' and  	// later allocate memory and return to fix pointers  	pOper->xlType = XlType.XlTypeString;  }  else if (obj is DateTime) {  	pOper->numValue = ((DateTime)obj).ToOADate ();  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: cbNativeStrings += Math.Min (str.Length' 255) + 1;  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is DateTime) {  	pOper->numValue = ((DateTime)obj).ToOADate ();  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (IntegrationMarshalHelpers.IsExcelErrorObject (obj)) {  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelErrorGetValue (obj);  	pOper->xlType = XlType.XlTypeError;  }  else if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (IntegrationMarshalHelpers.IsExcelMissingObject (obj)) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (IntegrationMarshalHelpers.IsExcelEmptyObject (obj)) {  	pOper->xlType = XlType.XlTypeEmpty;  }  else if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is bool) {  	pOper->boolValue = (bool)obj ? (ushort)1 : (ushort)0;  	pOper->xlType = XlType.XlTypeBoolean;  }  else if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is short) {  	pOper->numValue = (double)((short)obj);  	// int16 in XlOper  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is ushort) {  	pOper->numValue = (double)((ushort)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is int) {  	pOper->numValue = (double)((int)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is decimal) {  	pOper->numValue = (double)((decimal)obj);  	pOper->xlType = XlType.XlTypeNumber;  }  else if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (IntegrationMarshalHelpers.IsExcelReferenceObject (obj)) {  	pOper->xlType = XlType.XlTypeReference;  	// First we count all of these'   	// later allocate memory and return to fix pointers  	numReferenceOpers++;  	numReferences += IntegrationMarshalHelpers.ExcelReferenceGetRectangleCount (obj);  	// ((ExcelReference)obj).InnerReferences.Count;  }  else if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is object[]) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (1);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (obj is object[']) {  	XlObjectArrayMarshaler m = new XlObjectArrayMarshaler (2);  	nestedInstances.Add (m);  	XlOper* pNested = (XlOper*)m.MarshalManagedToNative (obj);  	pOper->xlType = XlType.XlTypeArray;  	pOper->arrayValue.Rows = pNested->arrayValue.Rows;  	pOper->arrayValue.Columns = pNested->arrayValue.Columns;  	pOper->arrayValue.pOpers = pNested->arrayValue.pOpers;  }  else if (obj is System.Reflection.Missing) {  	pOper->xlType = XlType.XlTypeMissing;  }  else if (obj == null) {  	// DOCUMENT: I return Empty for nulls inside the Array'   	// which is not consistent with what happens in other settings.  	// In particular not consistent with the results of the XlObjectMarshaler  	// (which is not called when a null is returned'  	// and interpreted as ExcelErrorNum in Excel)  	// This works well for xlSet though.  	// CONSIDER: Create an ExcelEmpty type to allow this to be more explicit'  	// and return ErrNum here  	pOper->xlType = XlType.XlTypeEmpty;  }  else {  	// Default error return  	pOper->errValue = (ushort)IntegrationMarshalHelpers.ExcelError_ExcelErrorValue;  	pOper->xlType = XlType.XlTypeError;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (cbNativeStrings > 0) {  	// Allocate room for all the strings  	pNativeStrings = Marshal.AllocCoTaskMem (cbNativeStrings);  	// Go through the Opers and set each string  	byte* pCurrent = (byte*)pNativeStrings;  	for (int i = 0; i < rows * columns; i++) {  		// Get the corresponding oper  		pOper = (XlOper*)pNative + i + 1;  		if (pOper->xlType == XlType.XlTypeString) {  			// Get the string from the managed array  			string str;  			if (rank == 1) {  				str = (string)((object[])ManagedObj) [i];  			}  			else {  				int row = i / allColumns;  				int column = i % allColumns;  				str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  			}  			XlString* pXlString = (XlString*)pCurrent;  			pOper->pstrValue = pXlString;  			int charCount = Math.Min (str.Length' 255);  			fixed (char* psrc = str) {  				// Write the data and length to the XlString  				// Support for system codepage by hmd  				// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  				Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  				int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  				pXlString->Length = (byte)written;  				// Increment pointer within allocated memory  				pCurrent += written + 1;  			}  		}  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (cbNativeStrings > 0) {  	// Allocate room for all the strings  	pNativeStrings = Marshal.AllocCoTaskMem (cbNativeStrings);  	// Go through the Opers and set each string  	byte* pCurrent = (byte*)pNativeStrings;  	for (int i = 0; i < rows * columns; i++) {  		// Get the corresponding oper  		pOper = (XlOper*)pNative + i + 1;  		if (pOper->xlType == XlType.XlTypeString) {  			// Get the string from the managed array  			string str;  			if (rank == 1) {  				str = (string)((object[])ManagedObj) [i];  			}  			else {  				int row = i / allColumns;  				int column = i % allColumns;  				str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  			}  			XlString* pXlString = (XlString*)pCurrent;  			pOper->pstrValue = pXlString;  			int charCount = Math.Min (str.Length' 255);  			fixed (char* psrc = str) {  				// Write the data and length to the XlString  				// Support for system codepage by hmd  				// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  				Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  				int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  				pXlString->Length = (byte)written;  				// Increment pointer within allocated memory  				pCurrent += written + 1;  			}  		}  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++) {  	// Get the corresponding oper  	pOper = (XlOper*)pNative + i + 1;  	if (pOper->xlType == XlType.XlTypeString) {  		// Get the string from the managed array  		string str;  		if (rank == 1) {  			str = (string)((object[])ManagedObj) [i];  		}  		else {  			int row = i / allColumns;  			int column = i % allColumns;  			str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  		}  		XlString* pXlString = (XlString*)pCurrent;  		pOper->pstrValue = pXlString;  		int charCount = Math.Min (str.Length' 255);  		fixed (char* psrc = str) {  			// Write the data and length to the XlString  			// Support for system codepage by hmd  			// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  			Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  			int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  			pXlString->Length = (byte)written;  			// Increment pointer within allocated memory  			pCurrent += written + 1;  		}  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: for (int i = 0; i < rows * columns; i++) {  	// Get the corresponding oper  	pOper = (XlOper*)pNative + i + 1;  	if (pOper->xlType == XlType.XlTypeString) {  		// Get the string from the managed array  		string str;  		if (rank == 1) {  			str = (string)((object[])ManagedObj) [i];  		}  		else {  			int row = i / allColumns;  			int column = i % allColumns;  			str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  		}  		XlString* pXlString = (XlString*)pCurrent;  		pOper->pstrValue = pXlString;  		int charCount = Math.Min (str.Length' 255);  		fixed (char* psrc = str) {  			// Write the data and length to the XlString  			// Support for system codepage by hmd  			// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  			Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  			int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  			pXlString->Length = (byte)written;  			// Increment pointer within allocated memory  			pCurrent += written + 1;  		}  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (pOper->xlType == XlType.XlTypeString) {  	// Get the string from the managed array  	string str;  	if (rank == 1) {  		str = (string)((object[])ManagedObj) [i];  	}  	else {  		int row = i / allColumns;  		int column = i % allColumns;  		str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  	}  	XlString* pXlString = (XlString*)pCurrent;  	pOper->pstrValue = pXlString;  	int charCount = Math.Min (str.Length' 255);  	fixed (char* psrc = str) {  		// Write the data and length to the XlString  		// Support for system codepage by hmd  		// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  		Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  		int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  		pXlString->Length = (byte)written;  		// Increment pointer within allocated memory  		pCurrent += written + 1;  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (pOper->xlType == XlType.XlTypeString) {  	// Get the string from the managed array  	string str;  	if (rank == 1) {  		str = (string)((object[])ManagedObj) [i];  	}  	else {  		int row = i / allColumns;  		int column = i % allColumns;  		str = (string)((object['])ManagedObj) [rowBase + row' columnBase + column];  	}  	XlString* pXlString = (XlString*)pCurrent;  	pOper->pstrValue = pXlString;  	int charCount = Math.Min (str.Length' 255);  	fixed (char* psrc = str) {  		// Write the data and length to the XlString  		// Support for system codepage by hmd  		// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  		Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  		int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  		pXlString->Length = (byte)written;  		// Increment pointer within allocated memory  		pCurrent += written + 1;  	}  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: fixed (char* psrc = str) {  	// Write the data and length to the XlString  	// Support for system codepage by hmd  	// int written = Encoding.ASCII.GetBytes(psrc' charCount' pXlString->Data' 255);  	Encoding enc = Encoding.GetEncoding (ASCIIEncoding.Default.CodePage' EncoderFallback.ReplacementFallback' DecoderFallback.ReplacementFallback);  	int written = enc.GetBytes (psrc' charCount' pXlString->Data' 255);  	pXlString->Length = (byte)written;  	// Increment pointer within allocated memory  	pCurrent += written + 1;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v) {  	// For big allocations' ensure that Excel allows us to free the memory  	if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  		pOper->xlType |= XlType.XlBitDLLFree;  	// We are done  	return pNative;  }  else {  	// For the Excel4v call' we need to return an array  	// which will contain the pointers to the Opers.  	int cbOperPointers = columns * Marshal.SizeOf (typeof(XlOper*));  	pOperPointers = Marshal.AllocCoTaskMem (cbOperPointers);  	XlOper** pOpers = (XlOper**)pOperPointers;  	for (int i = 0; i < columns; i++) {  		pOpers [i] = (XlOper*)pNative + i + 1;  	}  	return pOperPointers;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v) {  	// For big allocations' ensure that Excel allows us to free the memory  	if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  		pOper->xlType |= XlType.XlBitDLLFree;  	// We are done  	return pNative;  }  else {  	// For the Excel4v call' we need to return an array  	// which will contain the pointers to the Opers.  	int cbOperPointers = columns * Marshal.SizeOf (typeof(XlOper*));  	pOperPointers = Marshal.AllocCoTaskMem (cbOperPointers);  	XlOper** pOpers = (XlOper**)pOperPointers;  	for (int i = 0; i < columns; i++) {  		pOpers [i] = (XlOper*)pNative + i + 1;  	}  	return pOperPointers;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (!isExcel4v) {  	// For big allocations' ensure that Excel allows us to free the memory  	if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  		pOper->xlType |= XlType.XlBitDLLFree;  	// We are done  	return pNative;  }  else {  	// For the Excel4v call' we need to return an array  	// which will contain the pointers to the Opers.  	int cbOperPointers = columns * Marshal.SizeOf (typeof(XlOper*));  	pOperPointers = Marshal.AllocCoTaskMem (cbOperPointers);  	XlOper** pOpers = (XlOper**)pOperPointers;  	for (int i = 0; i < columns; i++) {  		pOpers [i] = (XlOper*)pNative + i + 1;  	}  	return pOperPointers;  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  	pOper->xlType |= XlType.XlBitDLLFree;  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  	pOper->xlType |= XlType.XlBitDLLFree;  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalManagedToNative,The following statement contains a magic number: if (rows * columns * 16 + cbNativeStrings + numReferences * 8 > 65535)  	pOper->xlType |= XlType.XlBitDLLFree;  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 1) {  	if (managed == null || !(managed is object['])) {  		return new object[1] {  			managed  		};  	}  	else// managed is object[']: turn first row (or column) into object[]  	 {  		object[] array;  		object['] all = (object['])managed;  		int rows = all.GetLength (0);  		int columns = all.GetLength (1);  		if (columns == 1) {  			// Take the one and only column as the array  			array = new object[rows];  			for (int i = 0; i < rows; i++) {  				array [i] = all [i' 0];  			}  		}  		else {  			// Take first row only  			array = new object[columns];  			for (int j = 0; j < columns; j++) {  				array [j] = all [0' j];  			}  		}  		return array;  	}  }  else if (rank == 2) {  	if (managed == null || !(managed is object['])) {  		return new object['] {  			{  				managed  			}  		};  	}  	else// managed is object[']  	 {  		return managed;  	}  }  else {  	Debug.Fail ("Damaged XlObjectArrayMarshaler rank");  	throw new InvalidOperationException ("Damaged XlObjectArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,XlObjectArrayMarshaler,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,MarshalNativeToManaged,The following statement contains a magic number: if (rank == 2) {  	if (managed == null || !(managed is object['])) {  		return new object['] {  			{  				managed  			}  		};  	}  	else// managed is object[']  	 {  		return managed;  	}  }  else {  	Debug.Fail ("Damaged XlObjectArrayMarshaler rank");  	throw new InvalidOperationException ("Damaged XlObjectArrayMarshaler rank");  }  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference,The following statement contains a magic number: for (int i = 0; i < rectCount; i++) {  	pRectangles [i].RowFirst = (ushort)rects [i] [0];  	pRectangles [i].RowLast = (ushort)rects [i] [1];  	pRectangles [i].ColumnFirst = (byte)rects [i] [2];  	pRectangles [i].ColumnLast = (byte)rects [i] [3];  }  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference,The following statement contains a magic number: for (int i = 0; i < rectCount; i++) {  	pRectangles [i].RowFirst = (ushort)rects [i] [0];  	pRectangles [i].RowLast = (ushort)rects [i] [1];  	pRectangles [i].ColumnFirst = (byte)rects [i] [2];  	pRectangles [i].ColumnLast = (byte)rects [i] [3];  }  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference,The following statement contains a magic number: pRectangles [i].ColumnFirst = (byte)rects [i] [2];  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference,The following statement contains a magic number: pRectangles [i].ColumnLast = (byte)rects [i] [3];  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference12,The following statement contains a magic number: for (int i = 0; i < rectCount; i++) {  	pRectangles [i].RowFirst = rects [i] [0];  	pRectangles [i].RowLast = rects [i] [1];  	pRectangles [i].ColumnFirst = rects [i] [2];  	pRectangles [i].ColumnLast = rects [i] [3];  }  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference12,The following statement contains a magic number: for (int i = 0; i < rectCount; i++) {  	pRectangles [i].RowFirst = rects [i] [0];  	pRectangles [i].RowLast = rects [i] [1];  	pRectangles [i].ColumnFirst = rects [i] [2];  	pRectangles [i].ColumnLast = rects [i] [3];  }  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference12,The following statement contains a magic number: pRectangles [i].ColumnFirst = rects [i] [2];  
Magic Number,ExcelDna.Loader,IntegrationMarshalHelpers,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlCustomMarshal.cs,SetExcelReference12,The following statement contains a magic number: pRectangles [i].ColumnLast = rects [i] [3];  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: if (pXlAddInExportInfo->ExportInfoVersion != 5) {  	Debug.Print ("ExportInfoVersion not supported.");  	return false;  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: try {  	XlAddIn.xlCallVersion = XlCallImpl.XLCallVer () / 256;  }  catch (Exception e) {  	Debug.WriteLine ("XlAddIn: XLCallVer Exception: " + e);  	// CONSIDER: Is this right / needed ?  	// As a test for the HPC support' I ignore error here and just assume we are under new Excel.  	// This will cause the common error here to get pushed to later ...  	XlAddIn.xlCallVersion = 12;  	// return false;  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: try {  	XlAddIn.xlCallVersion = XlCallImpl.XLCallVer () / 256;  }  catch (Exception e) {  	Debug.WriteLine ("XlAddIn: XLCallVer Exception: " + e);  	// CONSIDER: Is this right / needed ?  	// As a test for the HPC support' I ignore error here and just assume we are under new Excel.  	// This will cause the common error here to get pushed to later ...  	XlAddIn.xlCallVersion = 12;  	// return false;  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: XlAddIn.xlCallVersion = XlCallImpl.XLCallVer () / 256;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,Initialize,The following statement contains a magic number: XlAddIn.xlCallVersion = 12;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The following statement contains a magic number: try {  	Debug.WriteLine ("In XlAddIn.XlAutoOpen");  	if (_opened) {  		DeInitializeIntegration ();  	}  	object xlCallResult;  	XlCallImpl.TryExcelImpl (XlCallImpl.xlcMessage' out xlCallResult/*Ignore*/' true' "Registering library " + pathXll);  	InitializeIntegration ();  	// InitializeIntegration has loaded the DnaLibrary  	IntegrationHelpers.DnaLibraryAutoOpen ();  	_opened = true;  	result = 1;  	// All is OK  }  catch (Exception e) {  	// TODO: What to do here - maybe prefer Trace...?  	Debug.WriteLine ("ExcelDna.Loader.XlAddin.XlAutoOpen. Exception during Integration load: " + e.ToString ());  	string alertMessage = string.Format ("A problem occurred while an add-in was being initialized (InitializeIntegration failed).\r\nThe add-in is built with ExcelDna and is being loaded from {0}"' pathXll);  	object xlCallResult;  	XlCallImpl.TryExcelImpl (XlCallImpl.xlcAlert' out xlCallResult/*Ignored*/' alertMessage' 3/* Only OK Button' Warning Icon*/);  	result = 0;  }  finally {  	// Clear the status bar message  	object xlCallResult;  	XlCallImpl.TryExcelImpl (XlCallImpl.xlcMessage' out xlCallResult/*Ignored*/' false);  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,XlAutoOpen,The following statement contains a magic number: XlCallImpl.TryExcelImpl (XlCallImpl.xlcAlert' out xlCallResult/*Ignored*/' alertMessage' 3/* Only OK Button' Warning Icon*/);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (!mi.IsMacroType && mi.IsThreadSafe && XlAddIn.xlCallVersion >= 12)  	functionType += "$";  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (argumentNames.Length > 255)  	argumentNames = argumentNames.Substring (0' 255);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (argumentNames.Length > 255)  	argumentNames = argumentNames.Substring (0' 255);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: argumentNames = argumentNames.Substring (0' 255);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (showDescriptions) {  	numArgumentDescriptions = Math.Min (argumentDescriptions.Length' maxDescriptions);  	numArguments = 10 + numArgumentDescriptions;  }  else {  	numArgumentDescriptions = 0;  	numArguments = 9;  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (showDescriptions) {  	numArgumentDescriptions = Math.Min (argumentDescriptions.Length' maxDescriptions);  	numArguments = 10 + numArgumentDescriptions;  }  else {  	numArgumentDescriptions = 0;  	numArguments = 9;  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: numArguments = 10 + numArgumentDescriptions;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: numArguments = 9;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [2] = functionType;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [3] = mi.Name;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [4] = argumentNames;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [5] = mi.IsCommand ? 2 /*macro*/: (mi.IsHidden ? 0 : 1);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [5] = mi.IsCommand ? 2 /*macro*/: (mi.IsHidden ? 0 : 1);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [6] = mi.Category;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [7] = mi.ShortCut;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [8] = helpTopic;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (showDescriptions) {  	registerParameters [9] = functionDescription;  	for (int k = 0; k < numArgumentDescriptions; k++) {  		registerParameters [10 + k] = argumentDescriptions [k];  	}  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: if (showDescriptions) {  	registerParameters [9] = functionDescription;  	for (int k = 0; k < numArgumentDescriptions; k++) {  		registerParameters [10 + k] = argumentDescriptions [k];  	}  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [9] = functionDescription;  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: for (int k = 0; k < numArgumentDescriptions; k++) {  	registerParameters [10 + k] = argumentDescriptions [k];  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: registerParameters [10 + k] = argumentDescriptions [k];  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: try {  	object xlCallResult;  	XlCallImpl.TryExcelImpl (XlCallImpl.xlfRegister' out xlCallResult' registerParameters);  	Debug.Print ("Register - XllPath={0}' ProcName={1}' FunctionType={2}' MethodName={3} - Result={4}"' registerParameters [0]' registerParameters [1]' registerParameters [2]' registerParameters [3]' xlCallResult);  	if (xlCallResult is double) {  		mi.RegisterId = (double)xlCallResult;  		registeredMethods.Add (mi);  		if (mi.IsCommand) {  			RegisterMenu (mi);  		}  	}  	else {  		// TODO: What to do here? LogDisplay??  		Debug.Print ("Registration Error! - Register call failed for method {0}"' mi.Name);  	}  }  catch (Exception e) {  	// TODO: What to do here? LogDisplay??  	Debug.WriteLine ("Registration Error! - " + e.Message);  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: try {  	object xlCallResult;  	XlCallImpl.TryExcelImpl (XlCallImpl.xlfRegister' out xlCallResult' registerParameters);  	Debug.Print ("Register - XllPath={0}' ProcName={1}' FunctionType={2}' MethodName={3} - Result={4}"' registerParameters [0]' registerParameters [1]' registerParameters [2]' registerParameters [3]' xlCallResult);  	if (xlCallResult is double) {  		mi.RegisterId = (double)xlCallResult;  		registeredMethods.Add (mi);  		if (mi.IsCommand) {  			RegisterMenu (mi);  		}  	}  	else {  		// TODO: What to do here? LogDisplay??  		Debug.Print ("Registration Error! - Register call failed for method {0}"' mi.Name);  	}  }  catch (Exception e) {  	// TODO: What to do here? LogDisplay??  	Debug.WriteLine ("Registration Error! - " + e.Message);  }  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: Debug.Print ("Register - XllPath={0}' ProcName={1}' FunctionType={2}' MethodName={3} - Result={4}"' registerParameters [0]' registerParameters [1]' registerParameters [2]' registerParameters [3]' xlCallResult);  
Magic Number,ExcelDna.Loader,XlAddIn,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlAddIn.cs,RegisterXlMethod,The following statement contains a magic number: Debug.Print ("Register - XllPath={0}' ProcName={1}' FunctionType={2}' MethodName={3} - Result={4}"' registerParameters [0]' registerParameters [1]' registerParameters [2]' registerParameters [3]' xlCallResult);  
Magic Number,ExcelDna.Loader,XlParameterInfo,C:\repos\ravikp_rims.net\lib\ExcelDna-0.29\Source\ExcelDna.Loader\XlParameterInfo.cs,SetTypeInfo,The following statement contains a magic number: if (XlAddIn.XlCallVersion < 12) {  	SetTypeInfo4 (type' isReturnType' isExceptionSafe);  }  else {  	SetTypeInfo12 (type' isReturnType' isExceptionSafe);  }  
