Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Sharpduino,ArduinoMega,C:\repos\thutch_sharpduino\Sharpduino\ArduinoMega.cs,SetPinMode,Cyclomatic complexity of the method is 9
Complex Method,Sharpduino,ArduinoUno,C:\repos\thutch_sharpduino\Sharpduino\ArduinoUno.cs,SetPinMode,Cyclomatic complexity of the method is 9
Complex Method,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,AdvanceInitialization,Cyclomatic complexity of the method is 32
Complex Method,Sharpduino.Base,FirmataEmptyBase,C:\repos\thutch_sharpduino\Sharpduino\Base\FirmataEmptyBase.cs,HandleByte,Cyclomatic complexity of the method is 8
Complex Method,Sharpduino.Handlers,AnalogMappingMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\AnalogMappingMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 12
Complex Method,Sharpduino.Handlers,AnalogMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\AnalogMessageHandler.cs,Handle,Cyclomatic complexity of the method is 13
Complex Method,Sharpduino.Handlers,CapabilityMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\CapabilityMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 18
Complex Method,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 24
Complex Method,Sharpduino.Handlers,PinStateMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\PinStateMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 22
Complex Method,Sharpduino.Handlers,ProtocolVersionMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\ProtocolVersionMessageHandler.cs,Handle,Cyclomatic complexity of the method is 16
Complex Method,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,CanHandle,Cyclomatic complexity of the method is 8
Complex Method,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 24
Complex Method,Sharpduino.Handlers,SysexStringMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexStringMessageHandler.cs,HandleByte,Cyclomatic complexity of the method is 11
Complex Method,Sharpduino.Handlers,DigitalMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\DigitalMessageHandler.cs,Handle,Cyclomatic complexity of the method is 13
Long Parameter List,Sharpduino.SerialProviders,ComPortProvider,C:\repos\thutch_sharpduino\Sharpduino\SerialProviders\ComPortProvider.cs,ComPortProvider,The method has 5 parameters.
Long Parameter List,Sharpduino.SerialProviders,EnhancedSerialPort,C:\repos\thutch_sharpduino\Sharpduino\SerialProviders\EnhancedSerialPort.cs,EnhancedSerialPort,The method has 5 parameters.
Long Statement,Sharpduino.Base,FirmataBase,C:\repos\thutch_sharpduino\Sharpduino\Base\FirmataBase.cs,AddBasicMessageCreators,The length of the statement  "	messageCreators.ForEach (t => MessageCreators [t.BaseType.GetGenericArguments () [0]] = (IMessageCreator)Activator.CreateInstance (t)); " is 135.
Long Statement,Sharpduino.Base,MessageBroker,C:\repos\thutch_sharpduino\Sharpduino\Base\MessageBroker.cs,Subscribe,The length of the statement  "	var interfaces = handler.GetType ().GetInterfaces ().Where (x => typeof(IHandle).IsAssignableFrom (x) && x.IsGenericType); " is 122.
Long Statement,Sharpduino.Base,MessageBroker,C:\repos\thutch_sharpduino\Sharpduino\Base\MessageBroker.cs,UnSubscribe,The length of the statement  "	var interfaces = handler.GetType ().GetInterfaces ().Where (x => typeof(IHandle).IsAssignableFrom (x) && x.IsGenericType); " is 122.
Long Statement,Sharpduino.Handlers,PinStateMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\PinStateMessageHandler.cs,HandleByte,The length of the statement  "				throw new MessageHandlerException (BaseExceptionMessage + "There was no state in the message for pin " + message.PinNo); " is 120.
Magic Number,Sharpduino,ArduinoMega,C:\repos\thutch_sharpduino\Sharpduino\ArduinoMega.cs,SetDO,The following statement contains a magic number: previousValues [(int)pinNum % 8] = newValue;  
Magic Number,Sharpduino,ArduinoUno,C:\repos\thutch_sharpduino\Sharpduino\ArduinoUno.cs,SetDO,The following statement contains a magic number: previousValues [(int)pin % 8] = newValue;  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,AdvanceInitialization,The following statement contains a magic number: switch (currentInitState) {  case InitializationStages.QueryProtocolVersion:  	// This is the first inistialization stage  	// Stop any previous reports  	StopReports ();  	base.SendMessage (new ProtocolVersionRequestMessage ());  	break;  case InitializationStages.QueryFirmwareVersion:  	base.SendMessage (new QueryFirmwareMessage ());  	break;  case InitializationStages.QueryCapabilities:  	// Clear the pins' as we will be receiving new ones  	Pins.Clear ();  	AnalogPins.Clear ();  	// Send the message to get the capabilities  	base.SendMessage (new QueryCapabilityMessage ());  	break;  case InitializationStages.QueryAnalogMappings:  	base.SendMessage (new AnalogMappingQueryMessage ());  	break;  case InitializationStages.QueryPinStates:  	for (int i = 0; i < Pins.Count; i++) {  		base.SendMessage (new PinStateQueryMessage {  			Pin = (byte)i  		});  	}  	break;  case InitializationStages.StartReports:  	var portsCount = (byte)Math.Ceiling (Pins.Count / 8.0);  	for (byte i = 0; i < portsCount; i++) {  		base.SendMessage (new ToggleDigitalReportMessage () {  			Port = i'  			ShouldBeEnabled = true  		});  	}  	for (byte i = 0; i < AnalogPins.Count; i++) {  		base.SendMessage (new ToggleAnalogReportMessage () {  			Pin = i'  			ShouldBeEnabled = true  		});  	}  	// There is no callback for the above messages so advance anyway                      	OnInitialized ();  	break;  case InitializationStages.FullyInitialized:  	// Do nothing we are finished with the initialization  	break;  default:  	throw new ArgumentOutOfRangeException ("stage");  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,Handle,The following statement contains a magic number: for (int i = 0; i < message.PinMappings.Count; i++) {  	// If we have an analog pin  	if (message.PinMappings [i] != 127) {  		// Put the corresponding pin to the analog pins dictionary  		// this is a reference' so any changes to the primary object  		// will be reflected here too.  		AnalogPins.Add (Pins [i]);  	}  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,Handle,The following statement contains a magic number: if (message.PinMappings [i] != 127) {  	// Put the corresponding pin to the analog pins dictionary  	// this is a reference' so any changes to the primary object  	// will be reflected here too.  	AnalogPins.Add (Pins [i]);  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,Handle,The following statement contains a magic number: for (byte i = 0; i < 8; i++) {  	Pins [i + pinStart].CurrentValue = message.PinStates [i] ? 1 : 0;  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	// Even if we have analog values ie > 1 we put 0 as it doesn't matter  	// from the board side. They will be ignored anyway  	if (port * 8 + i < Pins.Count)  		values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	// Even if we have analog values ie > 1 we put 0 as it doesn't matter  	// from the board side. They will be ignored anyway  	if (port * 8 + i < Pins.Count)  		values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	// Even if we have analog values ie > 1 we put 0 as it doesn't matter  	// from the board side. They will be ignored anyway  	if (port * 8 + i < Pins.Count)  		values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  }  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: if (port * 8 + i < Pins.Count)  	values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: if (port * 8 + i < Pins.Count)  	values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  
Magic Number,Sharpduino,EasyFirmata,C:\repos\thutch_sharpduino\Sharpduino\EasyFirmata.cs,GetDigitalPortValues,The following statement contains a magic number: values [i] = Pins [port * 8 + i].CurrentValue == 1 ? true : false;  
Magic Number,Sharpduino,Pin,C:\repos\thutch_sharpduino\Sharpduino\Pin.cs,Pin,The following statement contains a magic number: if (HasDigitalCapability ())  	Port = (byte)PinNo / 8;  
Magic Number,Sharpduino,Pin,C:\repos\thutch_sharpduino\Sharpduino\Pin.cs,Pin,The following statement contains a magic number: Port = (byte)PinNo / 8;  
Magic Number,Sharpduino.Base,BitHelper,C:\repos\thutch_sharpduino\Sharpduino\Base\BitHelper.cs,BytesToInt,The following statement contains a magic number: return (MSB & 0x7f) << 7 | (LSB & 0x7f);  
Magic Number,Sharpduino.Base,BitHelper,C:\repos\thutch_sharpduino\Sharpduino\Base\BitHelper.cs,IntToBytes,The following statement contains a magic number: MSB = (byte)((value >> 7) & 0x7f);  
Magic Number,Sharpduino.Base,BitHelper,C:\repos\thutch_sharpduino\Sharpduino\Base\BitHelper.cs,GetBytesFromInt,The following statement contains a magic number: while (true) {  	// There is no need to send another byte (everything will be 0 from now on)  	if (minimumBytes-- <= 0 && value <= 0)  		yield break;  	// Cache the value we want to return  	byte returnValue = (byte)(value & 0x7f);  	// Prepare the value for the next iteration  	value = value >> 7;  	// yield return the current 7-bit value  	yield return returnValue;  }  
Magic Number,Sharpduino.Base,BitHelper,C:\repos\thutch_sharpduino\Sharpduino\Base\BitHelper.cs,GetBytesFromInt,The following statement contains a magic number: value = value >> 7;  
Magic Number,Sharpduino.Base,FirmataEmptyBase,C:\repos\thutch_sharpduino\Sharpduino\Base\FirmataEmptyBase.cs,ReceiveQueueThread,The following statement contains a magic number: while (processQueue) {  	// lock the incoming data so we don't have any race confitions  	lock (IncomingData) {  		// take a peek and dequeue the first byte in the queue  		if (IncomingData.Count > 0) {  			currentByte = IncomingData.Dequeue ();  			foundByteFlag = true;  		}  	}  	// If we found a byte then Handle it  	if (foundByteFlag)  		HandleByte (currentByte);  	else  		Thread.Sleep (10);  	// reset the flag and the byte value  	foundByteFlag = false;  	currentByte = 0x0;  }  
Magic Number,Sharpduino.Base,FirmataEmptyBase,C:\repos\thutch_sharpduino\Sharpduino\Base\FirmataEmptyBase.cs,ReceiveQueueThread,The following statement contains a magic number: if (foundByteFlag)  	HandleByte (currentByte);  else  	Thread.Sleep (10);  
Magic Number,Sharpduino.Base,FirmataEmptyBase,C:\repos\thutch_sharpduino\Sharpduino\Base\FirmataEmptyBase.cs,ReceiveQueueThread,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,Sharpduino.Handlers,AnalogMappingMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\AnalogMappingMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentState) {  case HandlerState.StartEnd:  	currentState = HandlerState.SysexCommand;  	return true;  case HandlerState.SysexCommand:  	currentState = HandlerState.PinMapping;  	return true;  case HandlerState.PinMapping:  	if (messageByte == MessageConstants.SYSEX_END) {  		messageBroker.CreateEvent (message);  		Reset ();  		return false;  	}  	if (messageByte > 127)  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid mapping");  	message.PinMappings.Add (messageByte);  	return true;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,AnalogMappingMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\AnalogMappingMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127)  	throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid mapping");  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentState) {  case HandlerState.StartEnd:  	currentState = HandlerState.SysexCommand;  	return true;  case HandlerState.SysexCommand:  	currentState = HandlerState.Address;  	return true;  case HandlerState.Address:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid address");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.SlaveAddress = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Register;  		firstByte = true;  	}  	return true;  case HandlerState.Register:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid register");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.Register = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Data;  		firstByte = true;  	}  	return true;  case HandlerState.Data:  	if (messageByte > 127 && messageByte != MessageConstants.SYSEX_END) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "These are not valid data");  	}  	if (firstByte) {  		if (message.Data.Count == 0 && messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "There was no data incoming");  		}  		if (messageByte == MessageConstants.SYSEX_END) {  			messageBroker.CreateEvent (message);  			Reset ();  			return false;  		}  		byteCache = messageByte;  		firstByte = false;  		return true;  	}  	else {  		if (messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "The message should not end here");  		}  		message.Data.Add (BitHelper.BytesToInt (byteCache' messageByte));  		firstByte = true;  		return true;  	}  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentState) {  case HandlerState.StartEnd:  	currentState = HandlerState.SysexCommand;  	return true;  case HandlerState.SysexCommand:  	currentState = HandlerState.Address;  	return true;  case HandlerState.Address:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid address");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.SlaveAddress = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Register;  		firstByte = true;  	}  	return true;  case HandlerState.Register:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid register");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.Register = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Data;  		firstByte = true;  	}  	return true;  case HandlerState.Data:  	if (messageByte > 127 && messageByte != MessageConstants.SYSEX_END) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "These are not valid data");  	}  	if (firstByte) {  		if (message.Data.Count == 0 && messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "There was no data incoming");  		}  		if (messageByte == MessageConstants.SYSEX_END) {  			messageBroker.CreateEvent (message);  			Reset ();  			return false;  		}  		byteCache = messageByte;  		firstByte = false;  		return true;  	}  	else {  		if (messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "The message should not end here");  		}  		message.Data.Add (BitHelper.BytesToInt (byteCache' messageByte));  		firstByte = true;  		return true;  	}  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentState) {  case HandlerState.StartEnd:  	currentState = HandlerState.SysexCommand;  	return true;  case HandlerState.SysexCommand:  	currentState = HandlerState.Address;  	return true;  case HandlerState.Address:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid address");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.SlaveAddress = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Register;  		firstByte = true;  	}  	return true;  case HandlerState.Register:  	if (messageByte > 127) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid register");  	}  	if (firstByte) {  		byteCache = messageByte;  		firstByte = false;  	}  	else {  		message.Register = BitHelper.BytesToInt (byteCache' messageByte);  		currentState = HandlerState.Data;  		firstByte = true;  	}  	return true;  case HandlerState.Data:  	if (messageByte > 127 && messageByte != MessageConstants.SYSEX_END) {  		Reset ();  		throw new MessageHandlerException (BaseExceptionMessage + "These are not valid data");  	}  	if (firstByte) {  		if (message.Data.Count == 0 && messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "There was no data incoming");  		}  		if (messageByte == MessageConstants.SYSEX_END) {  			messageBroker.CreateEvent (message);  			Reset ();  			return false;  		}  		byteCache = messageByte;  		firstByte = false;  		return true;  	}  	else {  		if (messageByte == MessageConstants.SYSEX_END) {  			Reset ();  			throw new MessageHandlerException (BaseExceptionMessage + "The message should not end here");  		}  		message.Data.Add (BitHelper.BytesToInt (byteCache' messageByte));  		firstByte = true;  		return true;  	}  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127) {  	Reset ();  	throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid address");  }  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127) {  	Reset ();  	throw new MessageHandlerException (BaseExceptionMessage + "This is not a valid register");  }  
Magic Number,Sharpduino.Handlers,I2CMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\I2CMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127 && messageByte != MessageConstants.SYSEX_END) {  	Reset ();  	throw new MessageHandlerException (BaseExceptionMessage + "These are not valid data");  }  
Magic Number,Sharpduino.Handlers,PinStateMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\PinStateMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentHandlerState) {  case HandlerState.StartEnd:  	currentHandlerState = HandlerState.Command;  	return true;  case HandlerState.Command:  	currentHandlerState = HandlerState.PinNo;  	return true;  case HandlerState.PinNo:  	if (messageByte > MessageConstants.MAX_PINS)  		throw new MessageHandlerException (BaseExceptionMessage + "The pin number is wrong");  	message.PinNo = messageByte;  	currentHandlerState = HandlerState.PinMode;  	return true;  case HandlerState.PinMode:  	if (messageByte >= Enum.GetValues (typeof(PinModes)).Length)  		throw new MessageHandlerException (BaseExceptionMessage + "This is no valid PinMode");  	message.Mode = (PinModes)messageByte;  	currentHandlerState = HandlerState.PinState;  	return true;  case HandlerState.PinState:  	if (messageByte == MessageConstants.SYSEX_END) {  		if (stateBytesReceived == 0)  			throw new MessageHandlerException (BaseExceptionMessage + "There was no state in the message for pin " + message.PinNo);  		messageBroker.CreateEvent (message);  		Reset ();  		return false;  	}  	message.State |= messageByte << (stateBytesReceived * 7);  	stateBytesReceived++;  	return true;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,PinStateMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\PinStateMessageHandler.cs,HandleByte,The following statement contains a magic number: message.State |= messageByte << (stateBytesReceived * 7);  
Magic Number,Sharpduino.Handlers,ProtocolVersionMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\ProtocolVersionMessageHandler.cs,Handle,The following statement contains a magic number: switch (currentHandlerState) {  case HandlerState.StartEnd:  	currentHandlerState = HandlerState.MajorVersion;  	return true;  case HandlerState.MajorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128.");  	}  	message.MajorVersion = messageByte;  	currentHandlerState = HandlerState.MinorVersion;  	return true;  case HandlerState.MinorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128.");  	}  	message.MinorVersion = messageByte;  	messageBroker.CreateEvent (message);  	Reset ();  	return false;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,ProtocolVersionMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\ProtocolVersionMessageHandler.cs,Handle,The following statement contains a magic number: switch (currentHandlerState) {  case HandlerState.StartEnd:  	currentHandlerState = HandlerState.MajorVersion;  	return true;  case HandlerState.MajorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128.");  	}  	message.MajorVersion = messageByte;  	currentHandlerState = HandlerState.MinorVersion;  	return true;  case HandlerState.MinorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128.");  	}  	message.MinorVersion = messageByte;  	messageBroker.CreateEvent (message);  	Reset ();  	return false;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Sharpduino.Handlers,ProtocolVersionMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\ProtocolVersionMessageHandler.cs,Handle,The following statement contains a magic number: if (messageByte > 127) {  	currentHandlerState = HandlerState.StartEnd;  	throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128.");  }  
Magic Number,Sharpduino.Handlers,ProtocolVersionMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\ProtocolVersionMessageHandler.cs,Handle,The following statement contains a magic number: if (messageByte > 127) {  	currentHandlerState = HandlerState.StartEnd;  	throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128.");  }  
Magic Number,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentHandlerState) {  case HandlerState.StartEnd:  	currentHandlerState = HandlerState.StartSysex;  	return true;  case HandlerState.StartSysex:  	// MAX_DATA bytes AFTER the command byte  	currentByteCount = 0;  	currentHandlerState = HandlerState.QueryFirmware;  	return true;  case HandlerState.QueryFirmware:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128");  	}  	currentHandlerState = HandlerState.MajorVersion;  	message.MajorVersion = messageByte;  	return true;  case HandlerState.MajorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128");  	}  	currentHandlerState = HandlerState.MinorVersion;  	message.MinorVersion = messageByte;  	return true;  case HandlerState.MinorVersion:  	currentHandlerState = HandlerState.FirmwareName;  	HandleChar (messageByte);  	return true;  case HandlerState.FirmwareName:  	if (messageByte == MessageConstants.SYSEX_END) {  		// Get the string we have been building all along  		message.FirmwareName = stringBuilder.ToString ();  		messageBroker.CreateEvent (message);  		Reset ();  		return false;  	}  	HandleChar (messageByte);  	return true;  default:  	throw new MessageHandlerException ("Unknown SysexMessage handler state");  }  
Magic Number,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,HandleByte,The following statement contains a magic number: switch (currentHandlerState) {  case HandlerState.StartEnd:  	currentHandlerState = HandlerState.StartSysex;  	return true;  case HandlerState.StartSysex:  	// MAX_DATA bytes AFTER the command byte  	currentByteCount = 0;  	currentHandlerState = HandlerState.QueryFirmware;  	return true;  case HandlerState.QueryFirmware:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128");  	}  	currentHandlerState = HandlerState.MajorVersion;  	message.MajorVersion = messageByte;  	return true;  case HandlerState.MajorVersion:  	if (messageByte > 127) {  		currentHandlerState = HandlerState.StartEnd;  		throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128");  	}  	currentHandlerState = HandlerState.MinorVersion;  	message.MinorVersion = messageByte;  	return true;  case HandlerState.MinorVersion:  	currentHandlerState = HandlerState.FirmwareName;  	HandleChar (messageByte);  	return true;  case HandlerState.FirmwareName:  	if (messageByte == MessageConstants.SYSEX_END) {  		// Get the string we have been building all along  		message.FirmwareName = stringBuilder.ToString ();  		messageBroker.CreateEvent (message);  		Reset ();  		return false;  	}  	HandleChar (messageByte);  	return true;  default:  	throw new MessageHandlerException ("Unknown SysexMessage handler state");  }  
Magic Number,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127) {  	currentHandlerState = HandlerState.StartEnd;  	throw new MessageHandlerException (BaseExceptionMessage + "Major Version should be < 128");  }  
Magic Number,Sharpduino.Handlers,SysexFirmwareMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexFirmwareMessageHandler.cs,HandleByte,The following statement contains a magic number: if (messageByte > 127) {  	currentHandlerState = HandlerState.StartEnd;  	throw new MessageHandlerException (BaseExceptionMessage + "Minor Version should be < 128");  }  
Magic Number,Sharpduino.Handlers,SysexMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexMessageHandler.cs,Reset,The following statement contains a magic number: cacheChar = 255;  
Magic Number,Sharpduino.Handlers,SysexMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexMessageHandler.cs,HandleChar,The following statement contains a magic number: if (cacheChar != 255) {  	stringBuilder.Append ((char)BitHelper.BytesToInt (cacheChar' charByte));  	cacheChar = 255;  }  else  	cacheChar = charByte;  
Magic Number,Sharpduino.Handlers,SysexMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexMessageHandler.cs,HandleChar,The following statement contains a magic number: if (cacheChar != 255) {  	stringBuilder.Append ((char)BitHelper.BytesToInt (cacheChar' charByte));  	cacheChar = 255;  }  else  	cacheChar = charByte;  
Magic Number,Sharpduino.Handlers,SysexMessageHandler,C:\repos\thutch_sharpduino\Sharpduino\Handlers\SysexMessageHandler.cs,HandleChar,The following statement contains a magic number: cacheChar = 255;  
Magic Number,Sharpduino.Messages.Send,ServoConfigMessage,C:\repos\thutch_sharpduino\Sharpduino\Messages\Send\ServoConfigMessage.cs,ServoConfigMessage,The following statement contains a magic number: Angle = 90;  
